//##################################### noise.lib ########################################
// A library of noise generators.
//
// It should be used using the `no` environment:
//
// ```
// no = library("noise.lib");
// process = no.functionCall;
// ```
//
// Another option is to import `stdfaust.lib` which already contains the `no`
// environment:
//
// ```
// import("stdfaust.lib");
// process = no.functionCall;
// ```
//########################################################################################

/************************************************************************
************************************************************************
FAUST library file
Copyright (C) 2003-2016 GRAME, Centre National de Creation Musicale
----------------------------------------------------------------------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

ba = library("basic.lib");
fi = library("filter.lib");

declare name "Faust Noise Generator Library";
declare version "0.0";

//=============================Functions Reference========================================
//========================================================================================

//-------`noise`----------
// White noise generator (outputs random number between -1 and 1).
// 
// #### Usage
//
// ```
// noise : _
// ```
//------------------------
// TODO: add mask for 32 bits
noise = random / RANDMAX
with{
	random = +(12345) ~ *(1103515245); // "linear congruential"
	RANDMAX	= 2147483647.0; // = 2^31-1 = MAX_SIGNED_INT in 32 bits
};

//---------------------`multirandom`--------------------------
// Generates multiple decorrelated random numbers 
// in parallel. 
//
// #### Usage
// ```
// multirandom(n) : _
// ```
//
// Where:
//
// * `n`: the number of decorrelated random numbers in parallel
//-------------------------------------------------------------
multirandom(n) = randomize(n) ~_
with {
	randomize (1) 	= +(12345) : *(1103515245);
	randomize (n) 	= randomize(1) <: randomize(n-1),_;
};

//-----------------------`multinoise`------------------------
// Generates multiple decorrelated noises
// in parallel.
//
// #### Usage
//
// ```
// multinoise(n) : _
// ```
//
// Where:
//
// * `n`: the number of decorrelated random numbers in parallel
//------------------------------------------------------------
multinoise(n) = multirandom(n) : par(i,n,/(RANDMAX)) 
with { 
	RANDMAX = 2147483647.0; 
};


//-----------------------`noises`------------------------
// TODO.
//----------------------------------------------------------
noises(N,i) = multinoise(N) : ba.selector(i,N);


//---------------------------`pink_noise`--------------------------
// Pink noise (1/f noise) generator (third-order approximation)
//
// #### Usage
//
// ```
// pink_noise : _;
// ```
//
// #### Reference:
//
// <https://ccrma.stanford.edu/~jos/sasp/Example_Synthesis_1_F_Noise.html>
//------------------------------------------------------------
// TODO: author JOS, revised by RM

pink_filter = fi.iir((0.049922035, -0.095993537, 0.050612699, -0.004408786),
                    (-2.494956002, 2.017265875, -0.522189400));

pink_noise = noise : pink_filter;

//-------------------------`pink_noise_vm`-------------------
// Multi pink noise generator.
//
// #### Usage
//
// ```
// pink_noise_vm(N) : _;
// ```
//
// Where: 
//
// * `N`: number of latched white-noise processes to sum,
// 	not to exceed sizeof(int) in C++ (typically 32).
//
// #### References
// 
// * <http://www.dsprelated.com/showarticle/908.php>
// * <http://www.firstpr.com.au/dsp/pink-noise/#Voss-McCartney>
//------------------------------------------------------------
// TODO: author JOS, revised by RM
pink_noise_vm(N) = noise <: _,par(i,N,ba.latch(clock(i))) :> _
with {
  clock(i) = (ba.time>>i)&1; // i'th latch clock signal
};

//-----------------------`lfnoise`, `lfnoise0` and `lfnoiseN`---------------------
// Low-frequency noise generators (Butterworth-filtered downsampled white noise)
//
// #### Usage
//
// ```
// lfnoise0(rate) : _;   // new random number every int(SR/rate) samples or so
// lfnoiseN(N,rate) : _; // same as "lfnoise0(rate) : lowpass(N,rate)" [see filter.lib]
// lfnoise(rate) : _;    // same as "lfnoise0(rate) : seq(i,5,lowpass(N,rate))" (no overshoot)
// ```
//
// #### Example 
//
// (view waveforms in faust2octave):
//
// ```
// rate = SR/100.0; // new random value every 100 samples (SR from music.lib)
// process = lfnoise0(rate),   // sampled/held noise (piecewise constant)
//           lfnoiseN(3,rate), // lfnoise0 smoothed by 3rd order Butterworth LPF
//           lfnoise(rate);    // lfnoise0 smoothed with no overshoot
// ```
//------------------------------------------------------------
// TODO: author JOS, revised by RM
lfnoise0(freq) = noise : ba.latch(os.oscrs(freq));
lfnoiseN(N,freq) = lfnoise0(freq) : fi.lowpass(N,freq); // Nth-order Butterworth lowpass
lfnoise(freq) = lfnoise0(freq) : seq(i,5,fi.lowpass(1,freq)); // non-overshooting lowpass
