//#################################### demos.lib ##########################################
// This library contains a set of demo functions based on examples located in the
// `/examples` folder. Its official prefix is `dm`.
//########################################################################################

/************************************************************************
************************************************************************
FAUST library file, GRAME section

Except where noted otherwise, Copyright (C) 2003-2017 by GRAME,
Centre National de Creation Musicale.
----------------------------------------------------------------------
GRAME LICENSE

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

ma = library("maths.lib");
ba = library("basics.lib");
de = library("delays.lib");
si = library("signals.lib");
an = library("analyzers.lib");
fi = library("filters.lib");
os = library("oscillators.lib");
no = library("noises.lib");
ef = library("misceffects.lib");
co = library("compressors.lib");
ve = library("vaeffects.lib");
pf = library("phaflangers.lib");
re = library("reverbs.lib");
en = library("envelopes.lib");

//########################################################################################
/************************************************************************
FAUST library file, jos section

Except where noted otherwise, The Faust functions below in this
section are Copyright (C) 2003-2017 by Julius O. Smith III <jos@ccrma.stanford.edu>
([jos](http://ccrma.stanford.edu/~jos/)), and released under the
(MIT-style) [STK-4.3](#stk-4.3-license) license.

All MarkDown comments in this section are Copyright 2016-2017 by Romain
Michon and Julius O. Smith III, and are released under the
[CCA4I](https://creativecommons.org/licenses/by/4.0/) license (TODO: if/when Romain agrees!)

************************************************************************/

//====================================Analyzers===========================================
//========================================================================================

//----------------------`mth_octave_spectral_level_demo`----------------------
// Demonstrate mth_octave_spectral_level in a standalone GUI.
//
// #### Usage
// ```
// _ : mth_octave_spectral_level_demo(BandsPerOctave);
// _ : spectral_level_demo : _; // 2/3 octave
// ```
//------------------------------------------------------------
// Coauthor: Yann Orlarey
mth_octave_spectral_level_demo(BPO) =  an.mth_octave_spectral_level_default(M,ftop,N,tau,dB_offset)
with{
	M = BPO;
	ftop = 16000;
	Noct = 10; // number of octaves down from ftop
	// Lowest band-edge is at ftop*2^(-Noct+2) = 62.5 Hz when ftop=16 kHz:
	N = int(Noct*M); // without 'int()', segmentation fault observed for M=1.67
	ctl_group(x)  = hgroup("[1] SPECTRUM ANALYZER CONTROLS", x);
	tau = ctl_group(hslider("[0] Level Averaging Time [unit:ms] [scale:log]
		[tooltip: band-level averaging time in milliseconds]",
	100,1,10000,1)) * 0.001;
	dB_offset = ctl_group(hslider("[1] Level dB Offset [unit:dB]
	[tooltip: Level offset in decibels]",
	50,-50,100,1));
};

spectral_level_demo = mth_octave_spectral_level_demo(1.5); // 2/3 octave


//======================================Filters===========================================
//========================================================================================

//--------------------------`parametric_eq_demo`------------------------------
// A parametric equalizer application.
//
// #### Usage:
//
// ```
// _ : parametric_eq_demo : _ ;
// ```
//------------------------------------------------------------
parametric_eq_demo = fi.low_shelf(LL,FL) : fi.peak_eq(LP,FP,BP) : fi.high_shelf(LH,FH)
with{
	eq_group(x) = hgroup("[0] PARAMETRIC EQ SECTIONS [tooltip: See Faust's filters.lib
		for info and pointers]",x);
	ls_group(x) = eq_group(vgroup("[1] Low Shelf",x));

	LL = ls_group(hslider("[0] Low Boost|Cut [unit:dB] [style:knob]
		[tooltip: Amount of low-frequency boost or cut in decibels]",0,-40,40,0.1));
	FL = ls_group(hslider("[1] Transition Frequency [unit:Hz] [style:knob] [scale:log]
		[tooltip: Transition-frequency from boost (cut) to unity gain]",200,1,5000,1));

	pq_group(x) = eq_group(vgroup("[2] Peaking Equalizer[tooltip: Parametric Equalizer
		sections from filters.lib]",x));
	LP = pq_group(hslider("[0] Peak Boost|Cut [unit:dB] [style:knob][tooltip: Amount of
		local boost or cut in decibels]",0,-40,40,0.1));
	FP = pq_group(hslider("[1] Peak Frequency [unit:PK] [style:knob] [tooltip: Peak
		Frequency in Piano Key (PK) units (A440 = 49PK)]",49,1,100,1)) : si.smooth(0.999)
		: ba.pianokey2hz;
	Q = pq_group(hslider("[2] Peak Q [style:knob] [scale:log] [tooltip: Quality factor
		(Q) of the peak = center-frequency/bandwidth]",40,1,1000,0.1));

	BP = FP/Q;

	hs_group(x) = eq_group(vgroup("[3] High Shelf [tooltip: A high shelf provides a boost
		or cut above some frequency]",x));
	LH = hs_group(hslider("[0] High Boost|Cut [unit:dB] [style:knob] [tooltip: Amount of
		high-frequency boost or cut in decibels]",0,-40,40,.1));
	FH = hs_group(hslider("[1] Transition Frequency [unit:Hz] [style:knob] [scale:log]
	[tooltip: Transition-frequency from boost (cut) to unity gain]",8000,20,10000,1));
};


//-------------------`spectral_tilt_demo`-----------------------
// A spectral tilt application.
//
// #### Usage
//
// ```
// _ : spectral_tilt_demo(N) : _ ;
// ```
//
// Where:
//
// * `N`: filter order (integer)
//
// All other parameters interactive
//------------------------------------------------------------
spectral_tilt_demo(N) = fi.spectral_tilt(O,f0,bw,alpha)
with{
	O = N;
	alpha = hslider("[1] Slope of Spectral Tilt across Band",-1/2,-1,1,0.001);
	f0 = hslider("[2] Band Start Frequency [unit:Hz]",100,20,10000,1);
	bw = hslider("[3] Band Width [unit:Hz]",5000,100,10000,1);
};


//---------`mth_octave_filterbank_demo` and `filterbank_demo`-------------
// Graphic Equalizer: Each filter-bank output signal routes through a fader.
//
// #### Usage
//
// ```
// _ : mth_octave_filterbank_demo(M) : _
// _ : filterbank_demo : _
// ```
//
// Where:
//
// * `N`: number of bands per octave
//--------------------------------------------------------------
mth_octave_filterbank_demo(O) = bp1(bp,mthoctavefilterbankdemo)
with{
	M = O;
	bp1 = ba.bypass1;
	mofb_group(x) = vgroup("CONSTANT-Q FILTER BANK (Butterworth dyadic tree)
		[tooltip: See Faust's filters.lib for documentation and references]", x);
	bypass_group(x) = mofb_group(hgroup("[0]", x));
	slider_group(x)	 = mofb_group(hgroup("[1]", x));

	N = 10*M; // total number of bands (highpass band, octave-bands, dc band)
	ftop = 10000;
	mthoctavefilterbankdemo = chan;
	chan = fi.mth_octave_filterbank_default(M,ftop,N) : sum(i,N,(*(ba.db2linear(fader(N-i)))));
	fader(i) = slider_group(vslider("[%2i] [unit:dB] [tooltip: Bandpass filter
		gain in dB]", -10, -70, 10, 0.1)) : si.smoo;
	bp = bypass_group(checkbox("[0] Bypass
		[tooltip: When this is checked, the filter-bank has no effect]"));
};

filterbank_demo = mth_octave_filterbank_demo(1); // octave-bands = default


//======================================Effects===========================================
//========================================================================================

//---------------------------`cubicnl_demo`--------------------------
// Distortion demo application.
//
// #### Usage:
//
// ```
// _ : cubicnl_demo : _;
// ```
//------------------------------------------------------------
cubicnl_demo = ba.bypass1(bp, ef.cubicnl_nodc(drive:si.smoo,offset:si.smoo))
with{
	cnl_group(x)  = vgroup("CUBIC NONLINEARITY cubicnl [tooltip: Reference:
		https://ccrma.stanford.edu/~jos/pasp/Cubic_Soft_Clipper.html]", x);
	bp = cnl_group(checkbox("[0] Bypass [tooltip: When this is checked, the
		nonlinearity has no effect]"));
	drive = cnl_group(hslider("[1] Drive [tooltip: Amount of distortion]",
		0, 0, 1, 0.01));
	offset = cnl_group(hslider("[2] Offset [tooltip: Brings in even harmonics]",
		0, 0, 1, 0.01));
};


//----------------------------`gate_demo`-------------------------
// Gate demo application.
//
// #### Usage
//
// ```
// _,_ : gate_demo : _,_;
// ```
//------------------------------------------------------------
gate_demo = ba.bypass2(gbp,gate_stereo_demo)
with{
	gate_group(x) = vgroup("GATE  [tooltip: Reference:
		http://en.wikipedia.org/wiki/Noise_gate]", x);
	meter_group(x) = gate_group(hgroup("[0]", x));
	knob_group(x) = gate_group(hgroup("[1]", x));

	gbp = meter_group(checkbox("[0] Bypass	[tooltip: When this is checked,
		the gate has no effect]"));

	gateview = ef.gate_gain_mono(gatethr,gateatt,gatehold,gaterel) : ba.linear2db :
	meter_group(hbargraph("[1] Gate Gain [unit:dB] [tooltip: Current gain of the
	gate in dB]", -50,+10)); // [style:led]

	gate_stereo_demo(x,y) = attach(x,gateview(abs(x)+abs(y))),y :
	ef.gate_stereo(gatethr,gateatt,gatehold,gaterel);

	gatethr = knob_group(hslider("[1] Threshold [unit:dB] [style:knob] [tooltip: When
		the signal level falls below the Threshold (expressed in dB), the signal is
		muted]", -30, -120, 0, 0.1));

	gateatt = knob_group(hslider("[2] Attack [unit:us] [style:knob] [scale:log]
	[tooltip: Time constant in MICROseconds (1/e smoothing time) for the gate
	gain to go (exponentially) from 0 (muted) to 1 (unmuted)]",
	10, 10, 10000, 1)) : *(0.000001) : max(1.0/float(ma.SR));

	gatehold = knob_group(hslider("[3] Hold [unit:ms] [style:knob] [scale:log]
	[tooltip: Time in ms to keep the gate open (no muting) after the signal
	level falls below the Threshold]", 200, 1, 1000, 1)) : *(0.001) :
	max(1.0/float(ma.SR));

	gaterel = knob_group(hslider("[4] Release [unit:ms] [style:knob] [scale:log]
	[tooltip: Time constant in ms (1/e smoothing time) for the gain to go
	(exponentially) from 1 (unmuted) to 0 (muted)]",
	100, 1, 1000, 1)) : *(0.001) : max(1.0/float(ma.SR));
};


//----------------------------`compressor_demo`-------------------------
// Compressor demo application.
//
// #### Usage
//
// ```
// _,_ : compressor_demo : _,_;
// ```
//------------------------------------------------------------
compressor_demo = ba.bypass2(cbp,compressor_stereo_demo)
with{
	comp_group(x) = vgroup("COMPRESSOR [tooltip: Reference:
		http://en.wikipedia.org/wiki/Dynamic_range_compression]", x);

	meter_group(x)	= comp_group(hgroup("[0]", x));
	knob_group(x)  = comp_group(hgroup("[1]", x));

	cbp = meter_group(checkbox("[0] Bypass	[tooltip: When this is checked, the compressor
		has no effect]"));
	gainview = co.compression_gain_mono(ratio,threshold,attack,release) : ba.linear2db :
	meter_group(hbargraph("[1] Compressor Gain [unit:dB] [tooltip: Current gain of
	the compressor in dB]",-50,+10));

	displaygain = _,_ <: _,_,(abs,abs:+) : _,_,gainview : _,attach;

	compressor_stereo_demo =
	displaygain(co.compressor_stereo(ratio,threshold,attack,release)) :
	*(makeupgain), *(makeupgain);

	ctl_group(x)  = knob_group(hgroup("[3] Compression Control", x));

	ratio = ctl_group(hslider("[0] Ratio [style:knob]
	[tooltip: A compression Ratio of N means that for each N dB increase in input
	signal level above Threshold, the output level goes up 1 dB]",
	5, 1, 20, 0.1));

	threshold = ctl_group(hslider("[1] Threshold [unit:dB] [style:knob]
	[tooltip: When the signal level exceeds the Threshold (in dB), its level
	is compressed according to the Ratio]",
	-30, -100, 10, 0.1));

	env_group(x)  = knob_group(hgroup("[4] Compression Response", x));

	attack = env_group(hslider("[1] Attack [unit:ms] [style:knob] [scale:log]
	tooltip: Time constant in ms (1/e smoothing time) for the compression gain
	to approach (exponentially) a new lower target level (the compression
	`kicking in')]", 50, 1, 1000, 0.1)) : *(0.001) : max(1/ma.SR);

	release = env_group(hslider("[2] Release [unit:ms] [style: knob] [scale:log]
	[tooltip: Time constant in ms (1/e smoothing time) for the compression gain
	to approach (exponentially) a new higher target level (the compression
	'releasing')]", 500, 1, 1000, 0.1)) : *(0.001) : max(1/ma.SR);

	makeupgain = comp_group(hslider("[5] Makeup Gain [unit:dB]
	[tooltip: The compressed-signal output level is increased by this amount
	(in dB) to make up for the level lost due to compression]",
	40, -96, 96, 0.1)) : ba.db2linear;
};


//-------------------------`moog_vcf_demo`---------------------------
// Illustrate and compare all three Moog VCF implementations above.
//
// #### Usage
//
// ```
// _ : moog_vcf_demo : _;
// ```
//------------------------------------------------------------
moog_vcf_demo = ba.bypass1(bp,vcf)
with{
	mvcf_group(x) = hgroup("MOOG VCF (Voltage Controlled Filter) [tooltip: See Faust's
		vaeffects.lib for info and references]",x);
	cb_group(x) = mvcf_group(hgroup("[0]",x));

	bp = cb_group(checkbox("[0] Bypass  [tooltip: When this is checked, the Moog VCF
		has no effect]"));
	archsw = cb_group(checkbox("[1] Use Biquads [tooltip: Select moog_vcf_2b (two-biquad)
		implementation, instead of the default moog_vcf (analog style) implementation]"));
	bqsw = cb_group(checkbox("[2] Normalized Ladders [tooltip: If using biquads, make
		them normalized ladders (moog_vcf_2bn)]"));

	freq = mvcf_group(hslider("[1] Corner Frequency [unit:PK] [tooltip: The VCF resonates
		at the corner frequency (specified in PianoKey (PK) units, with A440 = 49 PK).
		The VCF response is flat below the corner frequency, and rolls off -24 dB per
		octave above.]",
		25, 1, 88, 0.01) : ba.pianokey2hz) : si.smoo;

	res = mvcf_group(hslider("[2] Corner Resonance [style:knob] [tooltip: Amount of
		resonance near VCF corner frequency (specified between 0 and 1)]", 0.9, 0, 1, 0.01));

	outgain = mvcf_group(hslider("[3] VCF Output Level [unit:dB] [style:knob] [tooltip:
		output level in decibels]", 5, -60, 20, 0.1)) : ba.db2linear : si.smoo;

	vcfbq = _ <: select2(bqsw, ve.moog_vcf_2b(res,freq), ve.moog_vcf_2bn(res,freq));
	vcfarch = _ <: select2(archsw, ve.moog_vcf(res^4,freq), vcfbq);
	vcf = vcfarch : *(outgain);
};


//-------------------------`wah4_demo`---------------------------
// Wah pedal application.
//
// #### Usage
//
// ```
// _ : wah4_demo : _;
// ```
//------------------------------------------------------------
wah4_demo = ba.bypass1(bp, ve.wah4(fr))
with{
	wah4_group(x) = hgroup("WAH4 [tooltip: Fourth-order wah effect made using moog_vcf]", x);
	bp = wah4_group(checkbox("[0] Bypass [tooltip: When this is checked, the wah pedal has
		no effect]"));
	fr = wah4_group(hslider("[1] Resonance Frequency [scale:log] [tooltip: wah resonance
		frequency in Hz]", 200,100,2000,1));
	// Avoid dc with the moog_vcf (amplitude too high when freq comes up from dc)
	// Also, avoid very high resonance frequencies (e.g., 5kHz or above).
};


//-------------------------`crybaby_demo`---------------------------
// Crybaby effect application.
//
// #### Usage
//
// ```
// _ : crybaby_demo : _ ;
// ```
//------------------------------------------------------------
crybaby_demo = ba.bypass1(bp, ve.crybaby(wah))
with{
	crybaby_group(x) = hgroup("CRYBABY [tooltip: Reference:
		https://ccrma.stanford.edu/~jos/pasp/vegf.html]", x);
	bp = crybaby_group(checkbox("[0] Bypass [tooltip: When this is checked, the wah
		pedal has no effect]"));
	wah = crybaby_group(hslider("[1] Wah parameter [tooltip: wah pedal angle between
		0 (rocked back) and 1 (rocked forward)]",0.8,0,1,0.01));
};


//-------------------------`flanger_demo`---------------------------
// Flanger effect application.
//
// #### Usage
//
// ```
// _,_ : flanger_demo : _,_;
// ```
//------------------------------------------------------------
flanger_demo = ba.bypass2(fbp,flanger_stereo_demo)
with{
	flanger_group(x) = vgroup("FLANGER
		[tooltip: Reference: https://ccrma.stanford.edu/~jos/pasp/Flanging.html]", x);
	meter_group(x) = flanger_group(hgroup("[0]", x));
	ctl_group(x)  = flanger_group(hgroup("[1]", x));
	del_group(x)  = flanger_group(hgroup("[2] Delay Controls", x));
	lvl_group(x)  = flanger_group(hgroup("[3]", x));

	fbp = meter_group(checkbox("[0] Bypass	[tooltip: When this is checked, the flanger
		has no effect]"));
	invert = meter_group(checkbox("[1] Invert Flange Sum"));

	// FIXME: This should be an amplitude-response display:
	flangeview = lfor(freq) + lfol(freq) : meter_group(hbargraph("[2] Flange LFO
		[style: led] [tooltip: Display sum of flange delays]", -1.5,+1.5));

	flanger_stereo_demo(x,y) = attach(x,flangeview),y :
		*(level),*(level) : pf.flanger_stereo(dmax,curdel1,curdel2,depth,fb,invert);

	lfol = os.oscrs;
	lfor = os.oscrc;

	dmax = 2048;
	dflange = 0.001 * ma.SR *
		del_group(hslider("[1] Flange Delay [unit:ms] [style:knob]", 10, 0, 20, 0.001));
	odflange = 0.001 * ma.SR *
	del_group(hslider("[2] Delay Offset [unit:ms] [style:knob]", 1, 0, 20, 0.001));
	freq   = ctl_group(hslider("[1] Speed [unit:Hz] [style:knob]", 0.5, 0, 10, 0.01));
	depth  = ctl_group(hslider("[2] Depth [style:knob]", 1, 0, 1, 0.001));
	fb     = ctl_group(hslider("[3] Feedback [style:knob]", 0, -0.999, 0.999, 0.001));
	level  = lvl_group(hslider("Flanger Output Level [unit:dB]", 0, -60, 10, 0.1)) :
		ba.db2linear;
	curdel1 = odflange+dflange*(1 + lfol(freq))/2;
	curdel2 = odflange+dflange*(1 + lfor(freq))/2;
};


//-------------------------`phaser2_demo`---------------------------
// Phaser effect demo application.
//
// #### Usage
//
// ```
// _,_ : phaser2_demo : _,_;
// ```
//------------------------------------------------------------
phaser2_demo = ba.bypass2(pbp,phaser2_stereo_demo)
with{
	phaser2_group(x) = vgroup("PHASER2 [tooltip: Reference:
		https://ccrma.stanford.edu/~jos/pasp/Flanging.html]", x);
	meter_group(x) = phaser2_group(hgroup("[0]", x));
	ctl_group(x)  = phaser2_group(hgroup("[1]", x));
	nch_group(x)  = phaser2_group(hgroup("[2]", x));
	lvl_group(x)  = phaser2_group(hgroup("[3]", x));

	pbp = meter_group(checkbox("[0] Bypass	[tooltip: When this is checked, the phaser
		has no effect]"));
	invert = meter_group(checkbox("[1] Invert Internal Phaser Sum"));
	vibr = meter_group(checkbox("[2] Vibrato Mode")); // In this mode you can hear any "Doppler"

	// FIXME: This should be an amplitude-response display:
	// flangeview = phaser2_amp_resp : meter_group(hspectrumview("[2] Phaser Amplitude Response", 0,1));
	// phaser2_stereo_demo(x,y) = attach(x,flangeview),y : ...

	phaser2_stereo_demo = *(level),*(level) :
		pf.phaser2_stereo(Notches,width,frqmin,fratio,frqmax,speed,mdepth,fb,invert);

	Notches = 4; // Compile-time parameter: 2 is typical for analog phaser stomp-boxes

	// FIXME: Add tooltips
	speed  = ctl_group(hslider("[1] Speed [unit:Hz] [style:knob]", 0.5, 0, 10, 0.001));
	depth  = ctl_group(hslider("[2] Notch Depth (Intensity) [style:knob]", 1, 0, 1, 0.001));
	fb     = ctl_group(hslider("[3] Feedback Gain [style:knob]", 0, -0.999, 0.999, 0.001));

	width  = nch_group(hslider("[1] Notch width [unit:Hz] [style:knob] [scale:log]",
		1000, 10, 5000, 1));
	frqmin = nch_group(hslider("[2] Min Notch1 Freq [unit:Hz] [style:knob] [scale:log]",
		100, 20, 5000, 1));
	frqmax = nch_group(hslider("[3] Max Notch1 Freq [unit:Hz] [style:knob] [scale:log]",
		800, 20, 10000, 1)) : max(frqmin);
	fratio = nch_group(hslider("[4] Notch Freq Ratio: NotchFreq(n+1)/NotchFreq(n) [style:knob]",
		1.5, 1.1, 4, 0.001));

	level  = lvl_group(hslider("Phaser Output Level [unit:dB]", 0, -60, 10, 0.1)) :
		ba.db2linear;

	mdepth = select2(vibr,depth,2); // Improve "ease of use"
};


//---------------------`stereo_reverb_tester`--------------------
// Handy test inputs for reverberator demos below.
//
// #### Usage
//
// ```
// _ : stereo_reverb_tester : _
// ```
//------------------------------------------------------------
stereo_reverb_tester(revin_group,x,y) = reverb_tester(_)
with{
	reverb_tester(revin_group,x,y) = inx,iny with {
		ck_group(x) = revin_group(vgroup("[1] Input Config",x));
		mutegain = 1 - ck_group(checkbox("[1] Mute Ext Inputs
		[tooltip: When this is checked, the stereo external audio inputs are
		disabled (good for hearing the impulse response or pink-noise response alone)]"));
		pinkin = ck_group(checkbox("[2] Pink Noise
		[tooltip: Pink Noise (or 1/f noise) is Constant-Q Noise (useful for adjusting
		the EQ sections)]"));

		imp_group(x) = revin_group(hgroup("[2] Impulse Selection",x));
		pulseL =  imp_group(button("[1] Left
		[tooltip: Send impulse into LEFT channel]")) : ba.impulsify;
		pulseC =  imp_group(button("[2] Center
		[tooltip: Send impulse into LEFT and RIGHT channels]")) : ba.impulsify;
		pulseR = imp_group(button("[3] Right
		[tooltip: Send impulse into RIGHT channel]")) : ba.impulsify;

		inx = x*mutegain + (pulseL+pulseC) + pn;
		iny = y*mutegain + (pulseR+pulseC) + pn;
		pn = 0.1*pinkin*no.pink_noise;
	};
};


//-------------------------`fdnrev0_demo`---------------------------
// A reverb application using `fdnrev0`.
//
// #### Usage
//
// ```
// _,_ : fdnrev0_demo(N,NB,BBSO) : _,_
// ```
//
// Where:
//
// * `n`: Feedback Delay Network (FDN) order / number of delay lines used =
//	order of feedback matrix / 2, 4, 8, or 16 [extend primes array below for
//	32, 64, ...]
// * `nb`: Number of frequency bands / Number of (nearly) independent T60 controls
//	/ Integer 3 or greater
// * `bbso` = Butterworth band-split order / order of lowpass/highpass bandsplit
//	used at each crossover freq / odd positive integer
//------------------------------------------------------------
fdnrev0_demo(N,NB,BBSO) = stereo_reverb_tester(revin_group)
	  <: re.fdnrev0(MAXDELAY,delays,BBSO,freqs,durs,loopgainmax,nonl)
	  :> *(gain),*(gain)
with{
	MAXDELAY = 8192; // sync w delays and prime_power_delays above
	defdurs = (8.4,6.5,5.0,3.8,2.7); // NB default durations (sec)
	deffreqs = (500,1000,2000,4000); // NB-1 default crossover frequencies (Hz)
	deflens = (56.3,63.0); // 2 default min and max path lengths

	fdn_group(x)  = vgroup("FEEDBACK DELAY NETWORK (FDN) REVERBERATOR, ORDER 16
	[tooltip: See Faust's reverbs.lib for documentation and references]", x);

	freq_group(x)  = fdn_group(vgroup("[1] Band Crossover Frequencies", x));
	t60_group(x)  = fdn_group(hgroup("[2] Band Decay Times (T60)", x));
	path_group(x)  = fdn_group(vgroup("[3] Room Dimensions", x));
	revin_group(x)	= fdn_group(hgroup("[4] Input Controls", x));
	nonl_group(x) = revin_group(vgroup("[4] Nonlinearity",x));
	quench_group(x) = revin_group(vgroup("[3] Reverb State",x));

	nonl = nonl_group(hslider("[style:knob] [tooltip: nonlinear mode coupling]",
	    0, -0.999, 0.999, 0.001));
	loopgainmax = 1.0-0.5*quench_group(button("[1] Quench
		[tooltip: Hold down 'Quench' to clear the reverberator]"));

	pathmin = path_group(hslider("[1] min acoustic ray length [unit:m] [scale:log]
	[tooltip: This length (in meters) determines the shortest delay-line used in the FDN
	reverberator. Think of it as the shortest wall-to-wall separation in the room.]",
	46, 0.1, 63, 0.1));
	pathmax = path_group(hslider("[2] max acoustic ray length [unit:m] [scale:log]
		[tooltip: This length (in meters) determines the longest delay-line used in the
		FDN reverberator. Think of it as the largest wall-to-wall separation in the room.]",
	63, 0.1, 63, 0.1));

	durvals(i) = t60_group(vslider("[%i] %i [unit:s] [scale:log][tooltip: T60 is the 60dB
		decay-time in seconds. For concert halls, an overall reverberation time (T60) near
		1.9 seconds is typical [Beranek 2004]. Here we may set T60 independently in each
		frequency band.	 In real rooms, higher frequency bands generally decay faster due
		to absorption and scattering.]",ba.take(i+1,defdurs), 0.1, 100, 0.1));
	durs = par(i,NB,durvals(NB-1-i));

	freqvals(i) = freq_group(hslider("[%i] Band %i upper edge in Hz [unit:Hz] [scale:log]
	[tooltip: Each delay-line signal is split into frequency-bands for separate
	decay-time control in each band]",ba.take(i+1,deffreqs), 100, 10000, 1));
	freqs = par(i,NB-1,freqvals(i));

	delays = de.prime_power_delays(N,pathmin,pathmax);

	gain = hslider("[3] Output Level (dB) [unit:dB][tooltip: Output scale factor]",
		-40, -70, 20, 0.1) : ba.db2linear;
	// (can cause infinite loop:) with { db2linear(x) = pow(10, x/20.0); };
};



//---------------------------`zita_rev_fdn_demo`------------------------------
// Reverb demo application based on `zita_rev_fdn`.
//
// #### Usage
//
// ```
// si.bus(8) : zita_rev_fdn_demo : si.bus(8)
// ```
//------------------------------------------------------------
zita_rev_fdn_demo = re.zita_rev_fdn(f1,f2,t60dc,t60m,fsmax)
with{
	fsmax = 48000.0;
	fdn_group(x) = hgroup("Zita_Rev Internal FDN Reverb [tooltip: ~ Zita_Rev's internal
		8x8 Feedback Delay Network (FDN) & Schroeder allpass-comb reverberator.	 See
		Faust's reverbs.lib for documentation and references]",x);
	t60dc = fdn_group(vslider("[1] Low RT60 [unit:s] [style:knob][style:knob]
	[tooltip: T60 = time (in seconds) to decay 60dB in low-frequency band]",
	3, 1, 8, 0.1));
	f1 = fdn_group(vslider("[2] LF X [unit:Hz] [style:knob] [scale:log]
	[tooltip: Crossover frequency (Hz) separating low and middle frequencies]",
	200, 50, 1000, 1));
	t60m = fdn_group(vslider("[3] Mid RT60 [unit:s] [style:knob] [scale:log]
	[tooltip: T60 = time (in seconds) to decay 60dB in middle band]",
	2, 1, 8, 0.1));
	f2 = fdn_group(vslider("[4] HF Damping [unit:Hz] [style:knob] [scale:log]
	[tooltip: Frequency (Hz) at which the high-frequency T60 is half the middle-band's T60]",
	6000, 1500, 0.49*fsmax, 1));
};

//----------------------------------`zita_rev1`------------------------------
// Example GUI for `zita_rev1_stereo` (mostly following the Linux `zita-rev1` GUI).
//
// Only the dry/wet and output level parameters are "dezippered" here.	If
// parameters are to be varied in real time, use `smooth(0.999)` or the like
// in the same way.
//
// #### Usage
//
// ```
// _,_ : zita_rev1 : _,_
// ```
//
// #### Reference
//
// <http://www.kokkinizita.net/linuxaudio/zita-rev1-doc/quickguide.html>
//------------------------------------------------------------
zita_rev1 = _,_ <: re.zita_rev1_stereo(rdel,f1,f2,t60dc,t60m,fsmax),_,_ : out_eq,_,_ :
	dry_wet : out_level
with{
	fsmax = 48000.0;  // highest sampling rate that will be used

	fdn_group(x) = hgroup(
	"[0] Zita_Rev1 [tooltip: ~ ZITA REV1 FEEDBACK DELAY NETWORK (FDN) & SCHROEDER
	ALLPASS-COMB REVERBERATOR (8x8). See Faust's reverbs.lib for documentation and
	references]", x);

	in_group(x) = fdn_group(hgroup("[1] Input", x));

	rdel = in_group(vslider("[1] In Delay [unit:ms] [style:knob] [tooltip: Delay in ms
		before reverberation begins]",60,20,100,1));

	freq_group(x) = fdn_group(hgroup("[2] Decay Times in Bands (see tooltips)", x));

	f1 = freq_group(vslider("[1] LF X [unit:Hz] [style:knob] [scale:log] [tooltip:
		Crossover frequency (Hz) separating low and middle frequencies]", 200, 50, 1000, 1));

	t60dc = freq_group(vslider("[2] Low RT60 [unit:s] [style:knob] [scale:log]
	[style:knob] [tooltip: T60 = time (in seconds) to decay 60dB in low-frequency band]",
	3, 1, 8, 0.1));

	t60m = freq_group(vslider("[3] Mid RT60 [unit:s] [style:knob] [scale:log] [tooltip:
		T60 = time (in seconds) to decay 60dB in middle band]",2, 1, 8, 0.1));

	f2 = freq_group(vslider("[4] HF Damping [unit:Hz] [style:knob] [scale:log]
	[tooltip: Frequency (Hz) at which the high-frequency T60 is half the middle-band's T60]",
	6000, 1500, 0.49*fsmax, 1));

	out_eq = pareq_stereo(eq1f,eq1l,eq1q) : pareq_stereo(eq2f,eq2l,eq2q);
	// Zolzer style peaking eq (not used in zita-rev1) (filters.lib):
	// pareq_stereo(eqf,eql,Q) = peak_eq(eql,eqf,eqf/Q), peak_eq(eql,eqf,eqf/Q);
	// Regalia-Mitra peaking eq with "Q" hard-wired near sqrt(g)/2 (filters.lib):
	pareq_stereo(eqf,eql,Q) = fi.peak_eq_rm(eql,eqf,tpbt), fi.peak_eq_rm(eql,eqf,tpbt)
	with {
	tpbt = wcT/sqrt(max(0,g)); // tan(PI*B/SR), B bw in Hz (Q^2 ~ g/4)
	wcT = 2*ma.PI*eqf/ma.SR;  // peak frequency in rad/sample
	g = ba.db2linear(eql); // peak gain
	};

	eq1_group(x) = fdn_group(hgroup("[3] RM Peaking Equalizer 1", x));

	eq1f = eq1_group(vslider("[1] Eq1 Freq [unit:Hz] [style:knob] [scale:log] [tooltip:
		Center-frequency of second-order Regalia-Mitra peaking equalizer section 1]",
	315, 40, 2500, 1));

	eq1l = eq1_group(vslider("[2] Eq1 Level [unit:dB] [style:knob] [tooltip: Peak level
		in dB of second-order Regalia-Mitra peaking equalizer section 1]", 0, -15, 15, 0.1));

	eq1q = eq1_group(vslider("[3] Eq1 Q [style:knob] [tooltip: Q = centerFrequency/bandwidth
		of second-order peaking equalizer section 1]", 3, 0.1, 10, 0.1));

	eq2_group(x) = fdn_group(hgroup("[4] RM Peaking Equalizer 2", x));

	eq2f = eq2_group(vslider("[1] Eq2 Freq [unit:Hz] [style:knob] [scale:log] [tooltip:
		Center-frequency of second-order Regalia-Mitra peaking equalizer section 2]",
	1500, 160, 10000, 1));

	eq2l = eq2_group(vslider("[2] Eq2 Level [unit:dB] [style:knob] [tooltip: Peak level
		in dB of second-order Regalia-Mitra peaking equalizer section 2]", 0, -15, 15, 0.1));

	eq2q = eq2_group(vslider("[3] Eq2 Q [style:knob] [tooltip: Q = centerFrequency/bandwidth
		of second-order peaking equalizer section 2]", 3, 0.1, 10, 0.1));

	out_group(x)  = fdn_group(hgroup("[5] Output", x));

	dry_wet(x,y) = *(wet) + dry*x, *(wet) + dry*y with {
		wet = 0.5*(drywet+1.0);
	dry = 1.0-wet;
	};

	drywet = out_group(vslider("[1] Dry/Wet Mix [style:knob] [tooltip: -1 = dry, 1 = wet]",
	0, -1.0, 1.0, 0.01)) : si.smoo;

	out_level = *(gain),*(gain);

	gain = out_group(vslider("[2] Level [unit:dB] [style:knob] [tooltip: Output scale
		factor]", -20, -70, 40, 0.1)) : ba.db2linear : si.smoo;
};


//====================================Generators==========================================
//========================================================================================

//--------------------------`sawtooth_demo`---------------------------
// An application demonstrating the different sawtooth oscillators of Faust.
//
// #### Usage
//
// ```
// sawtooth_demo : _
// ```
//------------------------------------------------------------
sawtooth_demo = signal
with{
	osc_group(x) = vgroup("[0] SAWTOOTH OSCILLATOR [tooltip: See Faust's oscillators.lib
		for documentation and references]",x);
	knob_group(x)  = osc_group(hgroup("[1]", x));
	ampdb  = knob_group(vslider("[1] Amplitude [unit:dB] [style:knob] [tooltip: Sawtooth
		waveform amplitude]",-20,-120,10,0.1));
	amp = ampdb : ba.db2linear : si.smoo;
	freq = knob_group(vslider("[2] Frequency [unit:PK] [style:knob] [tooltip: Sawtooth
		frequency as a Piano Key (PK) number (A440 = key 49)]",49,1,88,0.01) : ba.pianokey2hz);
	detune1 = 1 + 0.01 * knob_group(
	vslider("[3] Detuning 1 [unit:%%] [style:knob] [tooltip: Percentange frequency-shift
	up or down for second oscillator]",-0.1,-10,10,0.01));
	detune2 = 1 + 0.01 * knob_group(vslider("[4] Detuning 2 [unit:%%] [style:knob] [tooltip:
		Percentange frequency-shift up or down for third detuned oscillator]",+0.1,-10,10,0.01));
	portamento = knob_group(vslider("[5] Portamento [unit:sec] [style:knob] [scale:log]
	[tooltip: Portamento (frequency-glide) time-constant in seconds]",0.1,0.001,10,0.001));
	sfreq = freq : si.smooth(ba.tau2pole(portamento));
	saworder = knob_group(nentry("[6] Saw Order [tooltip: Order of sawtootn aliasing
		suppression]",2,1,os.MAX_SAW_ORDER,1));
	sawchoice = _ <: par(i,os.MAX_SAW_ORDER,os.sawN(i+1)) :
		ba.selectn(int(os.MAX_SAW_ORDER), int(saworder-1)); // when max is pwr of 2
	tone = (amp/3) * (sawchoice(sfreq) + sawchoice(sfreq*detune1) + sawchoice(sfreq*detune2));
	signal = amp * select2(ei, select2(ss, tone, white_or_pink_noise), _);
	white_or_pink_noise = select2(wp,no.noise,no.pink_noise);
	checkbox_group(x) = knob_group(vgroup("[7] Alternate Signals",x));
	ss = checkbox_group(checkbox("[0] Noise (White or Pink - uses only Amplitude control on
		the left)"));
	wp = checkbox_group(checkbox("[1] Pink instead of White Noise (also called 1/f Noise)
		[tooltip: Pink Noise (or 1/f noise) is Constant-Q Noise, meaning that it has the
		same total power in every octave]"));
	ei = checkbox_group(checkbox("[2] External Signal Input (overrides Sawtooth/Noise
		selection above)"));
};


//----------------------`virtual_analog_oscillator_demo`----------------------
// Virtual analog oscillator demo application.
//
// #### Usage
//
// ```
// virtual_analog_oscillator_demo : _
// ```
//------------------------------------------------------------
virtual_analog_oscillator_demo = signal
with{
	osc_group(x) = vgroup("[0] VIRTUAL ANALOG OSCILLATORS
		[tooltip: See Faust's oscillators.lib for documentation and references]",x);

	// Signals
	sawchoice = _ <:
	// When MAX_SAW_ORDER is a power of 2:
	par(i,os.MAX_SAW_ORDER,os.sawN(i+1)) : ba.selectn(int(os.MAX_SAW_ORDER), int(saworder-1));
	// When MAX_SAW_ORDER is NOT a power of 2:
	// (par(i,MAX_SAW_ORDER,sawN(i+1)), par(j,MAX_SAW_ORDER_NEXTPOW2-MAX_SAW_ORDER,_))
	//   : selectn(MAX_SAW_ORDER_NEXTPOW2, saworder-1);
	saw = (amp/3) *
		(sawchoice(sfreq) + sawchoice(sfreq*detune1) + sawchoice(sfreq*detune2));
	sq = (amp/3) *
	(os.square(sfreq) + os.square(sfreq*detune1) + os.square(sfreq*detune2));
	tri = (amp/3) *
	(os.triangle(sfreq) + os.triangle(sfreq*detune1) + os.triangle(sfreq*detune2));
	pt = (amp/3) * (os.pulsetrain(sfreq,ptd)
		    + os.pulsetrain(sfreq*detune1,ptd)
			+ os.pulsetrain(sfreq*detune2,ptd));
	ptN = (amp/3) * (os.pulsetrainN(N,sfreq,ptd)
		    + os.pulsetrainN(N,sfreq*detune1,ptd)
			+ os.pulsetrainN(N,sfreq*detune2,ptd)) with {N=3;};
	pn = amp * no.pink_noise;

	signal = ssaw*saw + ssq*sq + stri*tri
	       + spt*((ssptN*ptN)+(1-ssptN)*pt)
		   + spn*pn + sei*_;

	// Signal controls:
	signal_group(x) = osc_group(hgroup("[0] Signal Levels",x));
	ssaw = signal_group(vslider("[0] Sawtooth [style:vslider]",1,0,1,0.01));

	pt_group(x) = signal_group(vgroup("[1] Pulse Train",x));
	ssptN = pt_group(checkbox("[0] Order 3
		[tooltip: When checked, use 3rd-order aliasing suppression (up from 2)
	See if you can hear a difference with the freq high and swept]"));
	spt = pt_group(vslider("[1] [style:vslider]",0,0,1,0.01));
	ptd = pt_group(vslider("[2] Duty Cycle [style:knob]",0.5,0,1,0.01))
	: si.smooth(0.99);

	ssq = signal_group(vslider("[2] Square [style:vslider]",0,0,1,0.01));
	stri = signal_group(vslider("[3] Triangle [style:vslider]",0,0,1,0.01));
	spn = signal_group(vslider(
		"[4] Pink Noise [style:vslider][tooltip: Pink Noise (or 1/f noise) is
		Constant-Q Noise, meaning that it has the same total power in every octave
		(uses only amplitude controls)]",0,0,1,0.01));
	sei = signal_group(vslider("[5] Ext Input [style:vslider]",0,0,1,0.01));

	// Signal Parameters
	knob_group(x) = osc_group(hgroup("[1] Signal Parameters", x));
	af_group(x) = knob_group(vgroup("[0]", x));
	ampdb = af_group(hslider("[1] Mix Amplitude [unit:dB] [style:hslider]
		[tooltip: Sawtooth waveform amplitude]",-20,-120,10,0.1));
	amp = ampdb : ba.db2linear : si.smoo;
	freq = af_group(hslider("[2] Frequency [unit:PK] [style:hslider] [tooltip: Sawtooth
		frequency as a Piano Key (PK) number (A440 = key 49)]",49,1,88,0.01) : ba.pianokey2hz);

	detune1 = 1 - 0.01 * knob_group(
		vslider("[3] Detuning 1 [unit:%%] [style:knob]
	[tooltip: Percentange frequency-shift up or down for second oscillator]",
	-0.1,-10,10,0.01));
	detune2 = 1 + 0.01 * knob_group(
	vslider("[4] Detuning 2 [unit:%%] [style:knob]
	[tooltip: Percentange frequency-shift up or down for third detuned oscillator]",
	+0.1,-10,10,0.01));
	portamento = knob_group(
	vslider("[5] Portamento [unit:sec] [style:knob] [scale:log]
	[tooltip: Portamento (frequency-glide) time-constant in seconds]",
	0.1,0.001,10,0.001));
	saworder = knob_group(nentry("[6] Saw Order [tooltip: Order of sawtooth aliasing
	suppression]",2,1,os.MAX_SAW_ORDER,1));
	sfreq = freq : si.smooth(ba.tau2pole(portamento));
};


//-------------------------- `oscrs_demo` ---------------------------
// Simple application demoing filter based oscillators.
//
// #### Usage
//
// ```
// oscrs_demo : _
// ```
//-------------------------------------------------------------------
oscrs_demo = signal
with{
	osc_group(x) = vgroup("[0] SINE WAVE OSCILLATOR oscrs [tooltip: Sine oscillator based
		on 2D vector rotation]",x);
	ampdb  = osc_group(hslider("[1] Amplitude [unit:dB] [tooltip: Sawtooth waveform
		amplitude]",-20,-120,10,0.1));
	amp = ampdb : ba.db2linear : si.smoo;
	freq = osc_group(
		hslider("[2] Frequency [unit:PK]
	[tooltip: Sine wave frequency as a Piano Key (PK) number (A440 = 49 PK)]",
	49,1,88,0.01) : ba.pianokey2hz);
	portamento = osc_group(
	hslider("[3] Portamento [unit:sec] [scale:log]
	[tooltip: Portamento (frequency-glide) time-constant in seconds]",
	0.1,0.001,10,0.001));
	sfreq = freq : si.smooth(ba.tau2pole(portamento));
	signal = amp * os.oscrs(sfreq);
};

oscr_demo = oscrs_demo; // synonym


//-------------------------- `velvet_noise_demo` ---------------------------
// Listen to velvet_noise!
//
// #### Usage
//
// ```
// velvet_noise_demo : _
// ```
//-------------------------------------------------------------------

velvet_noise_demo = vn
with{
	amp = hslider("Amp [unit:dB]",-10,-70,10,0.1) : ba.db2linear;
	f0 = 10.0, hslider("Freq [unit:log10(Hz)]",3,0,4,0.001) : pow;
	vn = no.velvet_noise(amp,f0);
};


//-------------------------- `latch_demo` ---------------------------
// Illustrate latch operation
//
// #### Usage
//
// ```
// echo 'import("stdfaust.lib");' > latch_demo.dsp
// echo 'process = dm.latch_demo;' >> latch_demo.dsp
// faust2octave latch_demo.dsp
// Octave:1> plot(faustout);
// ```
//-------------------------------------------------------------------
latch_demo = x, c, ba.latch(c,x) // plot(faustout) after faust2octave
with{
	f = float(ma.SR)/1000.0;
	x = os.oscr(f);
	c = 0.5 * os.oscrs(5*f); // sample 5 times per period
};


//-------------------------- `envelopes_demo` ---------------------------
// Illustrate various envelopes overlaid, including their gate * 1.1
//
// #### Usage
//
// ```
// echo 'import("stdfaust.lib");' > envelopes_demo.dsp
// echo 'process = dm.envelopes_demo;' >> envelopes_demo.dsp
// faust2octave envelopes_demo.dsp
// Octave:1> plot(faustout);
// ```
//-------------------------------------------------------------------
envelopes_demo = gate <: _*1.1,envSE,envAR,envARFE,envARE,envASR,envADSR,envADSRE
with{
	gate = (1-(1@500)) + 0.5*(1@750-(1@1700)); // retrigger at 1/2 amp
	envSE    = en.smoothEnvelope(attSec/6.91); // uses time-constant not t60
	envAR    = en.ar(attSec,relT60);
	envARFE  = en.arfe(attSec,relT60,0.25);
	envARE   = en.are(attSec,relT60);
	envASR   = en.asr(attSec,susLvl,relT60);
	envADSR  = en.adsr(attSec,decT60,susLvl,relT60);
	envADSRE = en.adsre(attSec,decT60,susLvl,relT60);
	attSec=0.002; //  2 ms attack time
	decT60=0.010; // 10 ms decay-to-sustain time
	susLvl=80.0;  // Sustain level = 0.8
	relT60=0.010; // 10 ms release (decay-to-zero) time
};

fft_spectral_level_demo(N) =  an.rfft_spectral_level(N,tau,dB_offset)
with{
	ctl_group(x)  = hgroup("[1] FFT SPECTRUM ANALYZER CONTROLS", x);
	tau = ctl_group(hslider("[0] Level Averaging Time [unit:ms] [scale:log]
		[tooltip: band-level averaging time in milliseconds]",
		100,1,10000,1)) * 0.001;
	dB_offset = ctl_group(hslider("[1] Level dB Offset [unit:dB]
		[tooltip: Level offset in decibels]",
		50,-50,100,1));
};

// end jos section
/************************************************************************
************************************************************************
FAUST library file, GRAME section

Except where noted otherwise, Copyright (C) 2003-2017 by GRAME,
Centre National de Creation Musicale.
----------------------------------------------------------------------
GRAME LICENSE

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

// TODO: Add GRAME functions here

//########################################################################################
/************************************************************************
FAUST library file, further contributions section

All contributions below should indicate both the contributor and terms
of license.  If no such indication is found, "git blame" will say who
last edited each line, and that person can be emailed to inquire about
license disposition, if their license choice is not already indicated
elsewhere among the libraries.	It is expected that all software will be
released under LGPL, STK-4.3, MIT, BSD, or a similar FOSS license.
************************************************************************/

//-------------------------------`exciter`-------------------------------
// Psychoacoustic harmonic exciter, with GUI.
//
// #### Usage
//
// ```
// _ : exciter : _
// ```
//
// #### References
//
// * <https://secure.aes.org/forum/pubs/ebriefs/?elib=16939>
// * <https://www.researchgate.net/publication/258333577_Modeling_the_Harmonic_Exciter>
//-------------------------------------------------------------------------------------
// Authors: PPriyanka Shekar and Julius O. Smith III
// License: STK-4.3
// Markdown: Romain Michon
//-------------------------------------------------------------------------------------
exciter = _ <: (fi.highpass(2, fc) : compressor : pregain : harmonicCreator :
	postgain), _ : balance
with{
	// TODO: rewrite to use the standard compressor from compressors.lib
	compressor = ba.bypass1(cbp,compressorMono)
	with{
		comp_group(x) = vgroup("COMPRESSOR  [tooltip: Reference:
			http://en.wikipedia.org/wiki/Dynamic_range_compression]", x);

	meter_group(x)	= comp_group(hgroup("[0]", x));
	knob_group(x)  = comp_group(hgroup("[1]", x));

	    cbp = meter_group(checkbox("[0] Bypass  [tooltip: When this is checked,
		the compressor has no effect]"));

	    gainview = co.compression_gain_mono(ratio,threshold,attack,release) : ba.linear2db
		: meter_group(hbargraph("[1] Compressor Gain [unit:dB] [tooltip: Current gain
		of the compressor in dB]",-50,+10));

	    displaygain = _ <: _,abs : _,gainview : attach;

	    compressorMono = displaygain(co.compressor_mono(ratio,threshold,attack,release));

	    ctl_group(x)  = knob_group(hgroup("[3] Compression Control", x));

	    ratio = ctl_group(hslider("[0] Ratio [style:knob]  [tooltip: A compression Ratio
	of N means that for each N dB increase in input signal level above Threshold, the
	output level goes up 1 dB]", 5, 1, 20, 0.1));

	    threshold = ctl_group(hslider("[1] Threshold [unit:dB] [style:knob] [tooltip:
	When the signal level exceeds the Threshold (in dB), its level is compressed
	according to the Ratio]", -30, -100, 10, 0.1));

	    env_group(x)  = knob_group(hgroup("[4] Compression Response", x));

	attack = env_group(hslider("[1] Attack [unit:ms] [style:knob]  [tooltip:
	Time constant in ms (1/e smoothing time) for the compression gain to approach
	(exponentially) a new lower target level (the compression `kicking in')]",
	50, 0, 500, 0.1)) : *(0.001) : max(1/ma.SR);

	    release = env_group(hslider("[2] Release [unit:ms] [style: knob]  [tooltip:
	Time constant in ms (1/e smoothing time) for the compression gain to approach
	(exponentially) a new higher target level (the compression 'releasing')]",
	500, 0, 1000, 0.1)) : *(0.001) : max(1/ma.SR);
	};

	//Exciter GUI controls
	ex_group(x) = hgroup("EXCITER  [tooltip: Reference: Patent US4150253 A]", x);

	//Highpass - selectable cutoff frequency
	fc = ex_group(hslider("[0] Cutoff Frequency [unit:Hz] [style:knob] [scale:log]
		[tooltip: Cutoff frequency for highpassed components to be excited]",
	5000, 1000, 10000, 100));

	//Pre-distortion gain - selectable percentage of harmonics
	ph = ex_group(hslider("[1] Harmonics [unit:percent] [style:knob] [tooltip:
		Percentage of harmonics generated]", 20, 0, 200, 1)) / 100;
	pregain = * (ph);

	// TODO: same thing: why doesn't this use cubicnl?
	//Asymmetric cubic soft clipper
	harmonicCreator(x) = x <: cubDist1, cubDist2, cubDist3 :> _;
	cubDist1(x) = (x < 0) * x;
	cubDist2(x) = (x >= 0) * (x <= 1) * (x - x ^ 3 / 3);
	cubDist3(x) = (x > 1) * 2/3;

	//Post-distortion gain - undoes effect of pre-gain
	postgain = * (1/ph);

	//Balance - selectable dry/wet mix
	ml = ex_group(hslider("[2] Mix [style:knob] [tooltip: Dry/Wet mix of original signal
		to excited signal]", 0.50, 0.00, 1.00, 0.01));
	balance = (_ * ml), (_ * (1.0 - ml)) :> _;
};


//----------------------------`vocoder_demo`-------------------------
// Use example of the vocoder function where an impulse train is used
// as excitation.
//
// #### Usage
//
// ```
// _ : vocoder_demo : _;
// ```
//------------------------------------------------------------
// Author: Romain Michon
// License: LGPL
vocoder_demo = hgroup("My Vocoder",_,os.lf_imptrain(freq)*gain :
	ve.vocoder(bands,att,rel,BWRatio) <: _,_)
with{
	bands = 32;
	vocoderGroup(x) = vgroup("Vocoder",x);
	att = vocoderGroup(hslider("[0] Attack [style:knob] [tooltip: Attack time in seconds]",
		5,0.1,100,0.1)*0.001);
	rel = vocoderGroup(hslider("[1] Release [style:knob] [tooltip: Release time in seconds]",
		5,0.1,100,0.1)*0.001);
	BWRatio = vocoderGroup(hslider("[2] BW [style:knob] [tooltip: Coefficient to adjust the
		bandwidth of each band]",0.5,0.1,2,0.001));
	excitGroup(x) = vgroup("Excitation",x);
	freq = excitGroup(hslider("[0] Freq [style:knob]",330,50,2000,0.1));
	gain = excitGroup(vslider("[1] Gain",0.5,0,1,0.01) : si.smoo);
};

//----------------------------`freeverb_demo`-------------------------
// Freeverb demo application.
//
// #### Usage
//
// ```
// _,_ : freeverb_demo : _,_;
// ```
//------------------------------------------------------------
// Author: Romain Michon
// License: LGPL
freeverb_demo = _,_ <: (*(g)*fixedgain,*(g)*fixedgain :
	re.stereo_freeverb(combfeed, allpassfeed, damping, spatSpread)),
	*(1-g), *(1-g) :> _,_
with{
	scaleroom   = 0.28;
	offsetroom  = 0.7;
	allpassfeed = 0.5;
	scaledamp   = 0.4;
	fixedgain   = 0.1;
	origSR = 44100;

	parameters(x) = hgroup("Freeverb",x);
	knobGroup(x) = parameters(vgroup("[0]",x));
	damping = knobGroup(vslider("[0] Damp [style: knob] [tooltip: Somehow control the
		density of the reverb.]",0.5, 0, 1, 0.025)*scaledamp*origSR/ma.SR);
	combfeed = knobGroup(vslider("[1] RoomSize [style: knob] [tooltip: The room size
		between 0 and 1 with 1 for the largest room.]", 0.5, 0, 1, 0.025)*scaleroom*
		origSR/ma.SR + offsetroom);
	spatSpread = knobGroup(vslider("[2] Stereo Spread [style: knob] [tooltip: Spatial
		spread between 0 and 1 with 1 for maximum spread.]",0.5,0,1,0.01)*46*ma.SR/origSR
		: int);
	g = parameters(vslider("[1] Wet [tooltip: The amount of reverb applied to the signal
		between 0 and 1 with 1 for the maximum amount of reverb.]", 0.3333, 0, 1, 0.025));
};

// end further contributions section
