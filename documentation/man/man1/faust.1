.\" Automatically generated by Pandoc 3.1.12.3
.\"
.TH "man" "1" "" "Version 2.80.3 (05\-April\-2025)" "Faust man page"
.SH NAME
Faust \- DSP to C/C++, CMajor, Codebox, CSharp, DLang, Interpreter,
Java, LLVM IR, Julia, JSFX, Rust and WebAssembly (wast/wasm)
.SH SYNOPSIS
\f[B]faust\f[R] [options] file1 [file2 \&...]
.SH DESCRIPTION
Faust (Functional Audio Stream) is a functional programming language
specifically designed for real\-time signal processing and synthesis.
Faust targets high\-performance signal processing applications and audio
plug\-ins for a variety of platforms and standards.
.SH OPTIONS
.SS Input options:
\f[B]\-a\f[R] <file> wrapper architecture file.
.PP
\f[B]\-i\f[R] \f[B]\-\-inline\-architecture\-files\f[R] inline
architecture files.
.PP
\f[B]\-A\f[R] <dir> \f[B]\-\-architecture\-dir\f[R] <dir> add the
directory <dir> to the architecture search path.
.PP
\f[B]\-I\f[R] <dir> \f[B]\-\-import\-dir\f[R] <dir> add the directory
<dir> to the libraries search path.
.PP
\f[B]\-L\f[R] <file> \f[B]\-\-library\f[R] <file> link with the LLVM
module <file>.
.SS Output options:
\f[B]\-o\f[R] <file> the output file.
.PP
\f[B]\-e\f[R] \f[B]\-\-export\-dsp\f[R] export expanded DSP (with all
included libraries).
.PP
\f[B]\-uim\f[R] \f[B]\-\-user\-interface\-macros\f[R] add user
interface macro definitions to the output code.
.PP
\f[B]\-xml\f[R] generate an XML description file.
.PP
\f[B]\-json\f[R] generate a JSON description file.
.PP
\f[B]\-O\f[R] <dir> \f[B]\-\-output\-dir\f[R] <dir> specify the
relative directory of the generated output code and of additional
generated files (SVG, XML\&...).
.SS Code generation options:
\f[B]\-lang\f[R] <lang> \f[B]\-\-language\f[R] select output language,
`lang' should be c, cpp (default), cmajor, codebox, csharp, dlang, fir,
interp, java, jax, jsfx, julia, llvm, ocpp, rust, sdf3, vhdl or
wast/wasm.
.PP
\f[B]\-single\f[R] \f[B]\-\-single\-precision\-floats\f[R] use single
precision floats for internal computations (default).
.PP
\f[B]\-double\f[R] \f[B]\-\-double\-precision\-floats\f[R] use double
precision floats for internal computations.
.PP
\f[B]\-quad\f[R] \f[B]\-\-quad\-precision\-floats\f[R] use quad
precision floats for internal computations.
.PP
\f[B]\-fx\f[R] \f[B]\-\-fixed\-point\f[R] use fixed\-point for internal
computations.
.PP
\f[B]\-fx\f[R]\-size \f[B]\-\-fixed\-point\-size\f[R] fixed\-point
number total size in bits (\-1 is used to generate a unique fixpoint_t
type).
.PP
\f[B]\-es\f[R] 1|0 \f[B]\-\-enable\-semantics\f[R] 1|0 use enable
semantics when 1 (default), and simple multiplication otherwise.
.PP
\f[B]\-lcc\f[R] \f[B]\-\-local\-causality\-check\f[R] check causality
also at local level.
.PP
\f[B]\-light\f[R] \f[B]\-\-light\-mode\f[R] do not generate the entire
DSP API.
.PP
\f[B]\-clang\f[R] \f[B]\-\-clang\f[R] when compiled with clang/clang++,
adds specific #pragma for auto\-vectorization.
.PP
\f[B]\-nvi\f[R] \f[B]\-\-no\-virtual\f[R] when compiled with the C++
backend, does not add the `virtual' keyword.
.PP
\f[B]\-fp\f[R] \f[B]\-\-full\-parentheses\f[R] always add parentheses
around binops.
.PP
\f[B]\-cir\f[R] \f[B]\-\-check\-integer\-range\f[R] check float to
integer range conversion.
.PP
\f[B]\-exp10\f[R] \f[B]\-\-generate\-exp10\f[R] pow(10,x) replaced by
possibly faster exp10(x).
.PP
\f[B]\-os\f[R] \f[B]\-\-one\-sample\f[R] generate one sample
computation.
.PP
\f[B]\-ec\f[R] \f[B]\-\-external\-control\f[R] separated `control' and
`compute' functions.
.PP
\f[B]\-it\f[R] \f[B]\-\-inline\-table\f[R] inline rdtable/rwtable code
in the main class.
.PP
\f[B]\-cm\f[R] \f[B]\-\-compute\-mix\f[R] mix in outputs buffers.
.PP
\f[B]\-ct\f[R] \f[B]\-\-check\-table\f[R] check rtable/rwtable index
range and generate safe access code [0/1: 1 by default].
.PP
\f[B]\-cn\f[R] <name> \f[B]\-\-class\-name\f[R] <name> specify the name
of the dsp class to be used instead of mydsp.
.PP
\f[B]\-scn\f[R] <name> \f[B]\-\-super\-class\-name\f[R] <name> specify
the name of the super class to be used instead of dsp.
.PP
\f[B]\-pn\f[R] <name> \f[B]\-\-process\-name\f[R] <name> specify the
name of the dsp entry\-point instead of process.
.PP
\f[B]\-mcd\f[R] <n> \f[B]\-\-max\-copy\-delay\f[R] <n> use a copy delay
up to max delay <n> and a dense delay above (ocpp only) or a ring buffer
(defaut 16 samples).
.PP
\f[B]\-mdd\f[R] <n> \f[B]\-\-max\-dense\-delay\f[R] <n> use a dense
delay up to max delay <n> (if enough density) and a ring buffer delay
above (ocpp only, default 1024).
.PP
\f[B]\-mdy\f[R] <n> \f[B]\-\-min\-density\f[R] <n> minimal density
(100*number of delays/max delay) to use a dense delays (ocpp only,
default 33).
.PP
\f[B]\-dlt\f[R] <n> \f[B]\-\-delay\-line\-threshold\f[R] <n> use a
mask\-based ring buffer delays up to max delay <n> and a select based
ring buffers above (default INT_MAX samples).
.PP
\f[B]\-mem\f[R] \f[B]\-\-memory\-manager\f[R] allocations done using a
custom memory manager.
.PP
\f[B]\-mem1\f[R] \f[B]\-\-memory\-manager1\f[R] allocations done using
a custom memory manager, using the iControl/fControl and iZone/fZone
model.
.PP
\f[B]\-mem2\f[R] \f[B]\-\-memory\-manager2\f[R] use iControl/fControl,
iZone/fZone model and no explicit memory manager.
.PP
\f[B]\-mem3\f[R] \f[B]\-\-memory\-manager3\f[R] use iControl/fControl,
iZone/fZone model and no explicit memory manager with access as function
parameters.
.PP
\f[B]\-ftz\f[R] <n> \f[B]\-\-flush\-to\-zero\f[R] <n> code added to
recursive signals [0:no (default), 1:fabs based, 2:mask based
(fastest)].
.PP
\f[B]\-rui\f[R] \f[B]\-\-range\-ui\f[R] whether to generate code to
constraint vslider/hslider/nentry values in [min..max] range.
.PP
\f[B]\-fui\f[R] \f[B]\-\-freeze\-ui\f[R] whether to freeze
vslider/hslider/nentry to a given value (init value by default).
.PP
\f[B]\-inj\f[R] <f> \f[B]\-\-inject\f[R] <f> inject source file <f>
into architecture file instead of compiling a dsp file.
.PP
\f[B]\-scal\f[R] \f[B]\-\-scalar\f[R] generate non\-vectorized code
(default).
.PP
\f[B]\-inpl\f[R] \f[B]\-\-in\-place\f[R] generates code working when
input and output buffers are the same (scalar mode only).
.PP
\f[B]\-vec\f[R] \f[B]\-\-vectorize\f[R] generate easier to vectorize
code.
.PP
\f[B]\-vs\f[R] <n> \f[B]\-\-vec\-size\f[R] <n> size of the vector
(default 32 samples).
.PP
\f[B]\-lv\f[R] <n> \f[B]\-\-loop\-variant\f[R] <n> [0:fastest, fixed
vector size and a remaining loop (default), 1:simple, variable vector
size, 2:fixed, fixed vector size].
.PP
\f[B]\-omp\f[R] \f[B]\-\-openmp\f[R] generate OpenMP pragmas, activates
\-\-vectorize option.
.PP
\f[B]\-pl\f[R] \f[B]\-\-par\-loop\f[R] generate parallel loops in
\-\-openmp mode.
.PP
\f[B]\-sch\f[R] \f[B]\-\-scheduler\f[R] generate tasks and use a Work
Stealing scheduler, activates \-\-vectorize option.
.PP
\f[B]\-ocl\f[R] \f[B]\-\-opencl\f[R] generate tasks with OpenCL
(experimental).
.PP
\f[B]\-cuda\f[R] \f[B]\-\-cuda\f[R] generate tasks with CUDA
(experimental).
.PP
\f[B]\-dfs\f[R] \f[B]\-\-deep\-first\-scheduling\f[R] schedule vector
loops in deep first order.
.PP
\f[B]\-g\f[R] \f[B]\-\-group\-tasks\f[R] group single\-threaded
sequential tasks together when \-omp or \-sch is used.
.PP
\f[B]\-fun\f[R] \f[B]\-\-fun\-tasks\f[R] separate tasks code as
separated functions (in \-vec, \-sch, or \-omp mode).
.PP
\f[B]\-fm\f[R] <file> \f[B]\-\-fast\-math\f[R] <file> use optimized
versions of mathematical functions implemented in <file>, use
`faust/dsp/fastmath.cpp' when file is `def', assume functions are
defined in the architecture file when file is `arch'.
.PP
\f[B]\-mapp\f[R] \f[B]\-\-math\-approximation\f[R] simpler/faster
versions of `floor/ceil/fmod/remainder' functions.
.PP
\f[B]\-noreprc\f[R] \f[B]\-\-no\-reprc\f[R] (Rust only) Don\[cq]t force
dsp struct layout to follow C ABI.
.PP
\f[B]\-ns\f[R] <name> \f[B]\-\-namespace\f[R] <name> generate C++ or D
code in a namespace <name>.
.PP
\f[B]\-vhdl\f[R]\-trace \f[B]\-\-vhdl\-trace\f[R] activate trace.
.PP
\f[B]\-vhdl\f[R]\-float \f[B]\-\-vhdl\-float\f[R] uses IEEE\-754 format
for samples instead of fixed point.
.PP
\f[B]\-vhdl\f[R]\-components <file> \f[B]\-\-vhdl\-components\f[R]
<file> path to a file describing custom components for the VHDL backend.
.PP
\f[B]\-fpga\f[R]\-mem <n> \f[B]\-\-fpga\-mem\f[R] <n> FPGA block ram
max size, used in \-mem1/\-mem2 mode.
.PP
\f[B]\-wi\f[R] <n> \f[B]\-\-widening\-iterations\f[R] <n> number of
iterations before widening in signal bounding.
.PP
\f[B]\-ni\f[R] <n> \f[B]\-\-narrowing\-iterations\f[R] <n> number of
iterations before stopping narrowing in signal bounding.
.PP
\f[B]\-rnt\f[R] \f[B]\-\-rust\-no\-faustdsp\-trait\f[R] (Rust only)
Don\[cq]t generate FaustDsp trait implmentation.
.PP
\f[B]\-rnlm\f[R] \f[B]\-\-rust\-no\-libm\f[R] (Rust only) Don\[cq]t
generate FFI calls to libm.
.SS Block diagram options:
\f[B]\-ps\f[R] \f[B]\-\-postscript\f[R] print block\-diagram to a
postscript file.
.PP
\f[B]\-svg\f[R] \f[B]\-\-svg\f[R] print block\-diagram to a svg file.
.PP
\f[B]\-sd\f[R] \f[B]\-\-simplify\-diagrams\f[R] try to further simplify
diagrams before drawing.
.PP
\f[B]\-drf\f[R] \f[B]\-\-draw\-route\-frame\f[R] draw route frames
instead of simple cables.
.PP
\f[B]\-f\f[R] <n> \f[B]\-\-fold\f[R] <n> threshold to activate folding
mode during block\-diagram generation (default 25 elements).
.PP
\f[B]\-fc\f[R] <n> \f[B]\-\-fold\-complexity\f[R] <n> complexity
threshold to fold an expression in folding mode (default 2).
.PP
\f[B]\-mns\f[R] <n> \f[B]\-\-max\-name\-size\f[R] <n> threshold during
block\-diagram generation (default 40 char).
.PP
\f[B]\-sn\f[R] \f[B]\-\-simple\-names\f[R] use simple names (without
arguments) during block\-diagram generation.
.PP
\f[B]\-blur\f[R] \f[B]\-\-shadow\-blur\f[R] add a shadow blur to SVG
boxes.
.PP
\f[B]\-sc\f[R] \f[B]\-\-scaled\-svg\f[R] automatic scalable SVG.
.SS Math doc options:
\f[B]\-mdoc\f[R] \f[B]\-\-mathdoc\f[R] print math documentation of the
Faust program in LaTeX format in a \-mdoc folder.
.PP
\f[B]\-mdlang\f[R] <l> \f[B]\-\-mathdoc\-lang\f[R] <l> if translation
file exists (<l> = en, fr, \&...).
.PP
\f[B]\-stripmdoc\f[R] \f[B]\-\-strip\-mdoc\-tags\f[R] strip mdoc tags
when printing Faust \-mdoc listings.
.SS Debug options:
\f[B]\-d\f[R] \f[B]\-\-details\f[R] print compilation details.
.PP
\f[B]\-time\f[R] \f[B]\-\-compilation\-time\f[R] display compilation
phases timing information.
.PP
\f[B]\-flist\f[R] \f[B]\-\-file\-list\f[R] print file list (including
libraries) used to eval process.
.PP
\f[B]\-tg\f[R] \f[B]\-\-task\-graph\f[R] print the internal task graph
in dot format.
.PP
\f[B]\-sg\f[R] \f[B]\-\-signal\-graph\f[R] print the internal signal
graph in dot format.
.PP
\f[B]\-rg\f[R] \f[B]\-\-retiming\-graph\f[R] print the internal signal
graph after retiming in dot format.
.PP
\f[B]\-norm\f[R] \f[B]\-\-normalized\-form\f[R] print signals in
normalized form and exit.
.PP
\f[B]\-norm1\f[R] \f[B]\-\-normalized\-form1\f[R] print signals in
normalized form with IDs for shared sub\-expressions and exit.
.PP
\f[B]\-me\f[R] \f[B]\-\-math\-exceptions\f[R] check / for 0 as
denominator and remainder, fmod, sqrt, log10, log, acos, asin functions
domain.
.PP
\f[B]\-sts\f[R] \f[B]\-\-strict\-select\f[R] generate strict code for
`selectX' even for stateless branches (both are computed).
.PP
\f[B]\-wall\f[R] \f[B]\-\-warning\-all\f[R] print all warnings.
.PP
\f[B]\-t\f[R] <sec> \f[B]\-\-timeout\f[R] <sec> abort compilation after
<sec> seconds (default 120).
.SS Information options:
\f[B]\-h\f[R] \f[B]\-\-help\f[R] print this help message.
.PP
\f[B]\-v\f[R] \f[B]\-\-version\f[R] print version information and
embedded backends list.
.PP
\f[B]\-libdir\f[R] \f[B]\-\-libdir\f[R] print directory containing the
Faust libraries.
.PP
\f[B]\-includedir\f[R] \f[B]\-\-includedir\f[R] print directory
containing the Faust headers.
.PP
\f[B]\-archdir\f[R] \f[B]\-\-archdir\f[R] print directory containing
the Faust architectures.
.PP
\f[B]\-dspdir\f[R] \f[B]\-\-dspdir\f[R] print directory containing the
Faust dsp libraries.
.PP
\f[B]\-pathslist\f[R] \f[B]\-\-pathslist\f[R] print the architectures
and dsp library paths.
.SS Environment variables:
FAUST_DEBUG = FAUST_LLVM1 print LLVM IR before optimisation.
.PP
FAUST_DEBUG = FAUST_LLVM2 print LLVM IR after optimisation.
.PP
FAUST_DEBUG = FIR_PRINTER print FIR after generation.
.PP
FAUST_DEBUG = FAUST_LLVM_NO_FM deactivate fast\f[B]\-math\f[R]
optimisation in LLVM IR.
.PP
FAUST_OPT = FAUST_SIG_NO_NORM deactivate signal normalisation.
.SS Example:
faust \f[B]\-a\f[R] jack\-gtk.cpp \-o myfx.cpp myfx.dsp
.SH SEE ALSO
Grame Faust site at: \f[B]\c
.UR https://faust.grame.fr
.UE \c
\f[R]
.SH BUGS
Please report bugs to: \f[B]\c
.UR https://github.com/grame-cncm/faust/issues
.UE \c
\f[R]
.SH AUTHOR
Copyright (C) 2002\-2025, GRAME \- Centre National de Creation Musicale.
All rights reserved.
