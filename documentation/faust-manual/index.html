<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    
    <link href="css/faust-doc.css" rel="stylesheet">
    <link href="css/faust-widget.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>

    <title>Faust Manual</title>
  </head>
  <body><div class="container-fluid"><div class="row faust-doc"><nav id="TOC" class="col-3 faust-doc-content"><div style="height: 100%;overflow-y: scroll;"><ul class="nav flex-column"><ul>
<li><a href="#introduction">Introduction</a><ul>
<li><a href="#what-is-faust">What is Faust?</a></li>
<li><a href="#what-is-faust-good-for">What is Faust Good For?</a></li>
<li><a href="#what-is-faust-not-so-good-for">What is Faust Not (So) Good For?</a></li>
<li><a href="#design-principles">Design Principles</a></li>
<li><a href="#signal-processor-semantic">Signal Processor Semantic</a></li>
</ul></li>
<li><a href="#quick-start">Quick Start</a></li>
<li><a href="#overview-of-the-faust-universe">Overview of the Faust Universe</a><ul>
<li><a href="#the-faust-distribution">The Faust Distribution</a><ul>
<li><a href="#command-line-compiler">Command-Line Compiler</a></li>
<li><a href="#libfaust"><code>libfaust</code></a></li>
<li><a href="#faust2...-scripts"><code>faust2...</code> Scripts</a></li>
</ul></li>
<li><a href="#web-tools">Web Tools</a><ul>
<li><a href="#the-online-editor">The Online Editor</a></li>
<li><a href="#the-faustplayground">The FaustPlayground</a></li>
<li><a href="#the-faust-online-compiler">The Faust Online Compiler</a></li>
<li><a href="#web-services">Web Services</a></li>
</ul></li>
<li><a href="#development-tools">Development Tools</a><ul>
<li><a href="#faustlive">FaustLive</a></li>
<li><a href="#faustworks">FaustWorks</a></li>
</ul></li>
</ul></li>
<li><a href="#compiling-and-installing-faust">Compiling and Installing Faust</a><ul>
<li><a href="#getting-the-source-code">Getting the Source Code</a></li>
</ul></li>
<li><a href="#faust-syntax">Faust Syntax</a><ul>
<li><a href="#faust-program">Faust Program</a></li>
<li><a href="#statements">Statements</a><ul>
<li><a href="#metadata">Metadata</a></li>
<li><a href="#global-metadata">Global Metadata</a></li>
<li><a href="#function-metadata">Function Metadata</a></li>
<li><a href="#standard-metadata">Standard Metadata</a></li>
<li><a href="#imports">Imports</a></li>
<li><a href="#documentation-tags">Documentation Tags</a></li>
</ul></li>
<li><a href="#definitions">Definitions</a><ul>
<li><a href="#simple-definitions">Simple Definitions</a></li>
</ul></li>
<li><a href="#function-definitions">Function Definitions</a></li>
<li><a href="#definitions-with-pattern-matching">Definitions with pattern matching</a></li>
<li><a href="#expressions">Expressions</a><ul>
<li><a href="#diagram-expressions">Diagram Expressions</a><ul>
<li><a href="#diagram-composition-operations">Diagram Composition Operations</a></li>
<li><a href="#parallel-composition">Parallel Composition</a></li>
<li><a href="#sequential-composition">Sequential Composition</a></li>
<li><a href="#split-composition">Split Composition</a></li>
<li><a href="#merge-composition">Merge Composition</a></li>
<li><a href="#recursive-composition">Recursive Composition</a></li>
<li><a href="#inputs-and-outputs-of-an-expression">Inputs and Outputs of an Expression</a></li>
<li><a href="#iterations">Iterations</a></li>
<li><a href="#par-iteration"><code>par</code> Iteration</a></li>
<li><a href="#seq-iteration"><code>seq</code> Iteration</a></li>
<li><a href="#sum-iteration"><code>sum</code> Iteration</a></li>
<li><a href="#prod-iteration"><code>prod</code> Iteration</a></li>
</ul></li>
<li><a href="#infix-notation-and-other-syntax-extensions">Infix Notation and Other Syntax Extensions</a><ul>
<li><a href="#infix-operators">Infix Operators</a></li>
<li><a href="#prefix-notation">Prefix Notation</a></li>
<li><a href="#partial-application">Partial Application</a></li>
</ul></li>
<li><a href="#time-expression"><code>'</code> Time Expression</a></li>
<li><a href="#time-expression-1"><code>@</code> Time Expression</a></li>
<li><a href="#environment-expressions">Environment Expressions</a><ul>
<li><a href="#with-expression"><code>with</code> Expression</a></li>
<li><a href="#letrec-expression"><code>letrec</code> Expression</a></li>
<li><a href="#environment-expression"><code>environment</code> Expression</a></li>
<li><a href="#access-expression">Access Expression</a></li>
<li><a href="#library-expression"><code>library</code> Expression</a></li>
<li><a href="#component-expression"><code>component</code> Expression</a></li>
<li><a href="#explicit-substitution">Explicit Substitution</a></li>
</ul></li>
<li><a href="#foreign-expressions">Foreign Expressions</a><ul>
<li><a href="#ffunction"><code>ffunction</code></a></li>
<li><a href="#signature">Signature</a></li>
<li><a href="#types">Types</a></li>
<li><a href="#variables-and-constants">Variables and Constants</a></li>
<li><a href="#file-include">File Include</a></li>
<li><a href="#library-file">Library File</a></li>
</ul></li>
<li><a href="#applications-and-abstractions">Applications and Abstractions</a><ul>
<li><a href="#abstractions">Abstractions</a></li>
<li><a href="#applications">Applications</a></li>
<li><a href="#pattern-matching">Pattern Matching</a></li>
</ul></li>
</ul></li>
<li><a href="#primitives">Primitives</a><ul>
<li><a href="#numbers">Numbers</a></li>
<li><a href="#waveform-primitive"><code>waveform</code> Primitive</a></li>
<li><a href="#soundfile-primitive"><code>soundfile</code> Primitive</a></li>
<li><a href="#c-equivalent-primitives">C-Equivalent Primitives</a><ul>
<li><a href="#integer-number">Integer Number</a></li>
<li><a href="#floating-point-number">Floating Point Number</a></li>
<li><a href="#identity-function">Identity Function</a></li>
<li><a href="#cut-primitive">Cut Primitive</a></li>
<li><a href="#int-primitive"><code>int</code> Primitive</a></li>
<li><a href="#float-primitive"><code>float</code> Primitive</a></li>
<li><a href="#add-primitive">Add Primitive</a></li>
<li><a href="#subtract-primitive">Subtract Primitive</a></li>
<li><a href="#multiply-primitive">Multiply Primitive</a></li>
<li><a href="#divide-primitive">Divide Primitive</a></li>
<li><a href="#power-primitive">Power Primitive</a></li>
<li><a href="#modulo-primitive">Modulo Primitive</a></li>
<li><a href="#and-primitive">AND Primitive</a></li>
<li><a href="#or-primitive">OR Primitive</a></li>
<li><a href="#xor-primitive">XOR Primitive</a></li>
<li><a href="#left-shift-primitive">Left Shift Primitive</a></li>
<li><a href="#right-shift-primitive">Right Shift Primitive</a></li>
<li><a href="#smaller-than-primitive">Smaller Than Primitive</a></li>
<li><a href="#smaller-or-equal-than-primitive">Smaller or Equal Than Primitive</a></li>
<li><a href="#greater-than-primitive">Greater Than Primitive</a></li>
<li><a href="#greater-or-equal-than-primitive">Greater or Equal Than Primitive</a></li>
<li><a href="#equal-to-primitive">Equal to Primitive</a></li>
<li><a href="#different-than-primitive">Different Than Primitive</a></li>
</ul></li>
<li><a href="#math.h-equivalent-primitives"><code>math.h</code>-Equivalent Primitives</a><ul>
<li><a href="#acos-primitive"><code>acos</code> Primitive</a></li>
<li><a href="#asin-primitive"><code>asin</code> Primitive</a></li>
<li><a href="#atan-primitive"><code>atan</code> Primitive</a></li>
<li><a href="#atan2-primitive"><code>atan2</code> Primitive</a></li>
<li><a href="#cos-primitive"><code>cos</code> Primitive</a></li>
<li><a href="#sin-primitive"><code>sin</code> Primitive</a></li>
<li><a href="#tan-primitive"><code>tan</code> Primitive</a></li>
<li><a href="#exp-primitive"><code>exp</code> Primitive</a></li>
<li><a href="#log-primitive"><code>log</code> Primitive</a></li>
<li><a href="#log10-primitive"><code>log10</code> Primitive</a></li>
<li><a href="#pow-primitive"><code>pow</code> Primitive</a></li>
<li><a href="#sqrt-primitive"><code>sqrt</code> Primitive</a></li>
<li><a href="#abs-primitive"><code>abs</code> Primitive</a></li>
<li><a href="#min-primitive"><code>min</code> Primitive</a></li>
<li><a href="#max-primitive"><code>max</code> Primitive</a></li>
<li><a href="#fmod-primitive"><code>fmod</code> Primitive</a></li>
<li><a href="#remainder-primitive"><code>remainder</code> Primitive</a></li>
<li><a href="#floor-primitive"><code>floor</code> Primitive</a></li>
<li><a href="#ceil-primitive"><code>ceil</code> Primitive</a></li>
<li><a href="#rint-primitive"><code>rint</code> Primitive</a></li>
</ul></li>
<li><a href="#delay-primitives-and-modifiers">Delay Primitives and Modifiers</a><ul>
<li><a href="#mem-primitive"><code>mem</code> Primitive</a></li>
<li><a href="#modifier"><code>'</code> Modifier</a></li>
<li><a href="#primitive"><code>@</code> Primitive</a></li>
</ul></li>
<li><a href="#table-primitives">Table Primitives</a><ul>
<li><a href="#rtable-primitive"><code>rtable</code> Primitive</a></li>
<li><a href="#rwtable-primitive"><code>rwtable</code> Primitive</a></li>
</ul></li>
<li><a href="#selector-primitives">Selector Primitives</a><ul>
<li><a href="#select2-primitives"><code>select2</code> Primitives</a></li>
<li><a href="#select3-primitives"><code>select3</code> Primitives</a></li>
</ul></li>
<li><a href="#user-interface-primitives-and-configuration">User Interface Primitives and Configuration</a><ul>
<li><a href="#button-primitive"><code>button</code> Primitive</a></li>
<li><a href="#checkbox-primitive"><code>checkbox</code> Primitive</a></li>
<li><a href="#hslider-primitive"><code>hslider</code> Primitive</a></li>
<li><a href="#vslider-primitive"><code>vslider</code> Primitive</a></li>
<li><a href="#nentry-primitive"><code>nentry</code> Primitive</a></li>
<li><a href="#hgroup-primitive"><code>hgroup</code> Primitive</a></li>
<li><a href="#vgroup-primitive"><code>vgroup</code> Primitive</a></li>
<li><a href="#tgroup-primitive"><code>tgroup</code> Primitive</a></li>
<li><a href="#vbargraph-primitive"><code>vbargraph</code> Primitive</a></li>
<li><a href="#hbargraph-primitive"><code>hbargraph</code> Primitive</a></li>
<li><a href="#attach-primitive"><code>attach</code> Primitive</a></li>
<li><a href="#variable-parts-of-a-label">Variable Parts of a Label</a></li>
<li><a href="#labels-as-pathnames">Labels as Pathnames</a></li>
<li><a href="#smoothing">Smoothing</a></li>
<li><a href="#links-to-generated-code">Links to Generated Code</a></li>
</ul></li>
<li><a href="#ui-label-metadata">UI Label Metadata</a><ul>
<li><a href="#ordering-ui-elements">Ordering UI Elements</a></li>
<li><a href="#global-ui-metadata">Global UI Metadata</a></li>
<li><a href="#styleknob-metadata"><code>[style:knob]</code> Metadata</a></li>
<li><a href="#stylemenu-metadata"><code>[style:menu]</code> Metadata</a></li>
<li><a href="#styleradio-metadata"><code>[style:radio]</code> Metadata</a></li>
<li><a href="#styleled-metadata"><code>[style:led]</code> Metadata</a></li>
<li><a href="#unitdb-metadata"><code>[unit:dB]</code> Metadata</a></li>
<li><a href="#unitxx-metadata"><code>[unit:xx]</code> Metadata</a></li>
<li><a href="#scalexx-metadata"><code>[scale:xx]</code> Metadata</a></li>
<li><a href="#tooltipxx-metadata"><code>[tooltip:xx]</code> Metadata</a></li>
<li><a href="#hiddenxx-metadata"><code>[hidden:xx]</code> Metadata</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#using-the-faust-compiler">Using the Faust Compiler</a><ul>
<li><a href="#structure-of-the-generated-code">Structure of the Generated Code</a></li>
<li><a href="#compilation-options">Compilation Options</a></li>
<li><a href="#controlling-code-generation">Controlling Code Generation</a><ul>
<li><a href="#vector-code-generation">Vector Code Generation</a></li>
<li><a href="#parallel-code-generation">Parallel Code Generation</a><ul>
<li><a href="#the-openmp-code-generator">The OpenMP Code Generator</a></li>
<li><a href="#adding-open-mp-directives">Adding Open MP Directives</a></li>
<li><a href="#example-of-parallel-openmp-code">Example of Parallel OpenMP Code</a></li>
<li><a href="#the-scheduler-code-generator">The Scheduler Code Generator</a></li>
<li><a href="#example-of-parallel-scheduler-code">Example of Parallel Scheduler Code</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#embedding-the-faust-compiler-using-libfaust">Embedding the Faust Compiler Using <code>libfaust</code></a><ul>
<li><a href="#dynamic-compilation-chain">Dynamic Compilation Chain</a></li>
<li><a href="#llvm">LLVM</a></li>
<li><a href="#compiling-in-memory">Compiling in Memory</a></li>
<li><a href="#savingrestoring-the-factory">Saving/Restoring the Factory</a></li>
<li><a href="#additional-functions">Additional Functions</a></li>
<li><a href="#using-the-libfaust-library">Using the <code>libfaust</code> Library</a></li>
<li><a href="#use-case-examples">Use Case Examples</a></li>
</ul></li>
<li><a href="#osc-support">OSC Support</a><ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#simple-example">Simple Example</a></li>
<li><a href="#automatic-port-allocation">Automatic Port Allocation</a></li>
<li><a href="#discovering-osc-applications">Discovering OSC Applications</a></li>
<li><a href="#discovering-the-osc-interface-of-an-application">Discovering the OSC Interface of an Application</a></li>
<li><a href="#widgets-osc-address">Widget’s OSC Address</a></li>
<li><a href="#controlling-the-application-via-osc">Controlling the Application Via OSC</a></li>
<li><a href="#turning-transmission-on">Turning Transmission ON</a></li>
<li><a href="#filtering-osc-messages">Filtering OSC Messages</a></li>
<li><a href="#using-osc-aliases">Using OSC Aliases</a></li>
<li><a href="#osc-cheat-sheet">OSC Cheat Sheet</a><ul>
<li><a href="#default-ports">Default Ports</a></li>
<li><a href="#command-line-options">Command Line Options</a></li>
<li><a href="#discovery-messages">Discovery Messages</a></li>
<li><a href="#control-messages">Control Messages</a></li>
<li><a href="#alias">Alias</a></li>
</ul></li>
</ul></li>
<li><a href="#http-support">HTTP Support</a><ul>
<li><a href="#a-simple-example">A Simple Example</a></li>
<li><a href="#json-description-of-the-user-interface">JSON Description of the User Interface</a></li>
<li><a href="#querying-the-state-of-the-application">Querying the State of the Application</a></li>
<li><a href="#changing-the-value-of-a-widget">Changing the Value of a Widget</a></li>
<li><a href="#proxy-control-access-to-the-web-server">Proxy Control Access to the Web Server</a></li>
<li><a href="#http-cheat-sheet">HTTP Cheat Sheet</a><ul>
<li><a href="#default-ports-1">Default Ports</a></li>
<li><a href="#command-line-options-1">Command Line Options</a></li>
<li><a href="#urls">URLs</a></li>
<li><a href="#json">JSON</a></li>
</ul></li>
</ul></li>
<li><a href="#midi-and-polyphony-support">MIDI and Polyphony Support</a><ul>
<li><a href="#configuring-midi-in-faust">Configuring MIDI in Faust</a><ul>
<li><a href="#midictrl-num-metadata"><code>[midi:ctrl num]</code> Metadata</a></li>
<li><a href="#midikeyon-midikey-metadata"><code>[midi:keyon midikey]</code> Metadata</a></li>
<li><a href="#midikeyoff-midikey-metadata"><code>[midi:keyoff midikey]</code> Metadata</a></li>
<li><a href="#midikey-midikey-metadata"><code>[midi:key midikey]</code> Metadata</a></li>
<li><a href="#midikeypress-midikey-metadata"><code>[midi:keypress midikey]</code> Metadata</a></li>
<li><a href="#midipitchwheel-metadata"><code>[midi:pitchwheel]</code> Metadata</a></li>
<li><a href="#midistart-metadata"><code>[midi:start]</code> Metadata</a></li>
<li><a href="#midistop-metadata"><code>[midi:stop]</code> Metadata</a></li>
<li><a href="#midiclock-metadata"><code>[midi:clock]</code> Metadata</a></li>
<li><a href="#midi-sync">MIDI Sync</a></li>
</ul></li>
<li><a href="#midi-polyphony-support">MIDI Polyphony Support</a><ul>
<li><a href="#standard-polyphony-parameters">Standard Polyphony Parameters</a></li>
<li><a href="#configuring-and-activating-polyphony">Configuring and Activating Polyphony</a></li>
<li><a href="#audio-effects-and-polyphonic-synthesizer">Audio Effects and Polyphonic Synthesizer</a></li>
<li><a href="#polyphony-and-continuous-pitch">Polyphony and Continuous Pitch</a></li>
<li><a href="#complete-example-sustain-pedal-and-additional-parameters">Complete Example: Sustain Pedal and Additional Parameters</a></li>
</ul></li>
</ul></li>
<li><a href="#mathematical-documentation">Mathematical Documentation</a><ul>
<li><a href="#goals-of-the-mathdoc">Goals of the Mathdoc</a></li>
<li><a href="#installation-requirements">Installation Requirements</a></li>
<li><a href="#generating-the-mathdoc">Generating the Mathdoc</a><ul>
<li><a href="#invoking-the--mdoc-option">Invoking the <code>-mdoc</code> Option</a></li>
<li><a href="#invoking-faust2mathdoc">Invoking <code>faust2mathdoc</code></a></li>
<li><a href="#online-examples">Online Examples</a></li>
</ul></li>
<li><a href="#automatic-documentation">Automatic Documentation</a></li>
<li><a href="#manual-documentation">Manual Documentation</a><ul>
<li><a href="#six-tags">Six Tags</a></li>
<li><a href="#the-mdoc-top-level-tags">The <code>mdoc</code> Top-Level Tags</a></li>
</ul></li>
<li><a href="#an-example-of-manual-mathdoc">An Example of Manual Mathdoc</a><ul>
<li><a href="#the--stripmdoc-option">The <code>-stripmdoc</code> Option</a></li>
</ul></li>
<li><a href="#localization-of-mathdoc-files">Localization of Mathdoc Files</a></li>
<li><a href="#summary-of-the-mathdoc-generation-steps">Summary of the Mathdoc Generation Steps</a></li>
</ul></li>
<li><a href="#tutorial-adding-faust-dsp-support-to-your-juce-plug-ins">Tutorial: Adding Faust DSP Support to Your JUCE Plug-ins</a><ul>
<li><a href="#the-old-way-brut-force-method">“The Old Way”: Brut-Force Method</a></li>
<li><a href="#simple-synth-plug-in">Simple Synth Plug-In</a><ul>
<li><a href="#generating-the-dsp-engine">Generating the DSP Engine</a></li>
<li><a href="#creating-an-empty-juce-plug-in-project">Creating an Empty JUCE Plug-In Project</a></li>
</ul></li>
<li><a href="#creating-and-using-a-polyphonic-faust-dsp-object">Creating and Using a Polyphonic Faust DSP Object</a></li>
</ul></li>
</ul>
</div>
</nav>
<main role="main" class="col-9 ml-sm-auto px-4 faust-doc-content">
<div data-spy="scroll" data-target="#TOC" data-offset="0" style="height: 100%;overflow-y: scroll;">
<h1 id="introduction">Introduction</h1>
<h2 id="what-is-faust">What is Faust?</h2>
<p>Faust (Functional Audio Stream) is a functional programming language for sound synthesis and audio processing with a strong focus on the design of synthesizers, musical instruments, audio effects, etc. Faust targets high-performance signal processing applications and audio plug-ins for a variety of platforms and standards. It is used on stage for concerts and artistic productions, in education and research, in open source projects as well as in commercial applications.</p>
<p>The core component of Faust is its compiler. It allows to “translate” any Faust digital signal processing (DSP) specification to a wide range of non-domain specific languages such as C++, C, JAVA, JavaScript, LLVM bit code, WebAssembly, etc. In this regard, Faust can be seen as an alternative to C++ but is much simpler and intuitive to learn.</p>
<p>Thanks to a wrapping system called “architectures,” codes generated by Faust can be easily compiled into a wide variety of objects ranging from <a href="TODO-tutorial">audio plug-ins</a> to <a href="TODO-tutorial">standalone applications</a> or <a href="TODO-tutorial">smartphone</a> and <a href="TODO-tutorial">web apps</a>, etc. (check the <a href="#a-quick-tour-of-the-faust-targets">Quick Tour of the Faust Targets</a> section for an exhaustive list.</p>
<p>This manual gives an overview of the Faust programming language and of its features through various interactive examples.</p>
<h2 id="what-is-faust-good-for">What is Faust Good For?</h2>
<p>Faust’s syntax allows to express any DSP algorithm as a block diagram. For example, <code>+</code> is considered as a valid function (and block) taking two arguments (signals) and returning one:</p>
<div class="faust-run"><a href="img/src/exfaust0/exfaust0-svg/process.svg" target="_blank"><img src="img/src/exfaust0/exfaust0-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = +;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust0/exfaust0.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Blocks can be easily connected together using the <code>:</code> “connection” composition:</p>
<div class="faust-run"><a href="img/src/exfaust1/exfaust1-svg/process.svg" target="_blank"><img src="img/src/exfaust1/exfaust1-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = + : *(0.5);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust1/exfaust1.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>In that case, we add two signals together and then scale the result of this operation.</p>
<p>Thus, <strong>Faust is perfect to implement time-domain algorithms that can be easily represented as block diagrams</strong> such as filters, waveguide physical models, virtual analog elements, etc.</p>
<p><strong>Faust is very concise</strong>, for example, here’s the implementation of a one pole filter/integrator equivalent to <span class="math inline">\(y(n) = x(x) + a_{1}y(n-1)\)</span> (where <span class="math inline">\(a_{1}\)</span> is the pole):</p>
<div class="faust-run"><a href="img/src/exfaust2/exfaust2-svg/process.svg" target="_blank"><img src="img/src/exfaust2/exfaust2-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>a1 = 0.9;
process = +~*(a1);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust2/exfaust2.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p><strong>Codes generated by Faust are extremely optimized</strong> and usually more efficient that handwritten codes (at least for C and C++). The Faust compiler tries to optimize each element of an algorithm. For example, you shouldn’t have to worry about using divides instead of multiplies as they get automatically replaced by multiplies by the compiler when possible, etc.</p>
<p><strong>Faust is very generic</strong> and allows to write code that will run on dozens of platforms.</p>
<!-- If we stick to this, we should also talk about the web capabilities: in
other words be a bit more specific here. -->
<h2 id="what-is-faust-not-so-good-for">What is Faust Not (So) Good For?</h2>
<p>Despite all this, Faust does have some limitations. For instance, it doesn’t allow for the efficient implementation of algorithms requiring multi-rates such as the FFT, convolution, etc. While there are tricks to go around this issue, we’re fully aware that it is a big one and we’re working as hard as possible on it.</p>
<p>Faust’s conciseness can sometimes become a problem too, especially for complex algorithms with lots of recursive signals. It is usually crucial in Faust to have the “mental global picture” of the algorithm to be implemented which in some cases can be hard.</p>
<p>While the Faust compiler is relatively bug-free, it does have some limitations and might get stuck in some extreme cases that you will probably never encounter. If you do, <a href="https://sourceforge.net/p/faudiostream/mailman/">shoot us an e-mail</a>!</p>
<p>From here, you can jump to … if you wanna get your hands dirty, etc. TODO.</p>
<h2 id="design-principles">Design Principles</h2>
<p>Since the beginning of its development in 2002, Faust has been guided by various design principles:</p>
<ul>
<li>Faust is a <em>specification language</em>. It aims at providing an adequate notation to describe <em>signal processors</em> from a mathematical point of view. Faust is, as much as possible, free from implementation details.</li>
<li>Faust programs are fully compiled (i.e., not interpreted). The compiler translates Faust programs into equivalent programs in other languages (e.g., JAVA, JavaScript, LLVM bit code, WebAssembly, etc.) taking care of generating the most efficient code. The result can generally compete with, and sometimes even outperform, C++ code written by seasoned programmers.</li>
<li>The generated code works at the sample level. It is therefore suited to implement low-level DSP functions like recursive filters. Moreover the code can be easily embedded. It is self-contained and doesn’t depend of any DSP library or runtime system. It has a very deterministic behavior and a constant memory footprint.</li>
<li>The semantic of Faust is simple and well defined. This is not just of academic interest. It allows the Faust compiler to be <em>semantically driven</em>. Instead of compiling a program literally, it compiles the mathematical function it denotes. This feature is useful for example to promote components reuse while preserving optimal performance.<br />
</li>
<li>Faust is a textual language but nevertheless block-diagram oriented. It actually combines two approaches: <em>functional programming</em> and <em>algebraic block-diagrams</em>. The key idea is to view block-diagram construction as function composition. For that purpose, Faust relies on a <em>block-diagram algebra</em> of five composition operations: <code>: , ~ &lt;: :&gt;</code> (see the section on <a href="#diagram-composition-operations">Diagram Composition Operations</a> for more details).</li>
<li>Thanks to the concept of <em>architecture</em>, Faust programs can be easily deployed on a large variety of audio platforms and plugin formats without any change to the Faust code.</li>
</ul>
<h2 id="signal-processor-semantic">Signal Processor Semantic</h2>
<p>A Faust program describes a <em>signal processor</em>. The role of a <em>signal processor</em> is to transforms a (possibly empty) group of <em>input signals</em> in order to produce a (possibly empty) group of <em>output signals</em>. Most audio equipments can be modeled as <em>signal processors</em>. They have audio inputs, audio outputs as well as control signals interfaced with sliders, knobs, vu-meters, etc.</p>
<p>More precisely :</p>
<ul>
<li>A <em>signal</em> <span class="math inline">\(s\)</span> is a discrete function of time <span class="math inline">\(s:\mathbb{Z}\rightarrow\mathbb{R}\)</span>. The value of a signal <span class="math inline">\(s\)</span> at time <span class="math inline">\(t\)</span> is written <span class="math inline">\(s(t)\)</span>. The values of signals are usually needed starting from time <span class="math inline">\(0\)</span>. But to take into account <em>delay operations</em>, negative times are possible and are always mapped to zeros. Therefore for any Faust signal <span class="math inline">\(s\)</span> we have <span class="math inline">\(\forall t&lt;0, s(t)=0\)</span>. In operational terms this corresponds to assuming that all delay lines are signals initialized with <span class="math inline">\(0\)</span>s.</li>
<li>Faust considers two type of signals: <em>integer signals</em> (<span class="math inline">\(s:\mathbb{Z}\rightarrow\mathbb{Z}\)</span>) and <em>floating point signals</em> (<span class="math inline">\(s:\mathbb{Z}\rightarrow\mathbb{Q}\)</span>). Exchanges with the outside world are, by convention, made using floating point signals. The full range is represented by sample values between <span class="math inline">\(-1.0\)</span> and <span class="math inline">\(+1.0\)</span>.</li>
<li>The set of all possible signals is <span class="math inline">\(\mathbb{S}=\mathbb{Z}\rightarrow\mathbb{R}\)</span>.</li>
<li>A group of <span class="math inline">\(n\)</span> signals (a <em>n</em>-tuple of signals) is written <span class="math inline">\((s_{1},\ldots,s_{n})\in \mathbb{S}^{n}\)</span>. The <em>empty tuple</em>, single element of <span class="math inline">\(\mathbb{S}^{0}\)</span> is notated <span class="math inline">\(()\)</span>.</li>
<li>A <em>signal processors</em> <span class="math inline">\(p\)</span>, is a function from <em>n</em>-tuples of signals to <em>m</em>-tuples of signals <span class="math inline">\(p:\mathbb{S}^{n}\rightarrow\mathbb{S}^{m}\)</span>. The set <span class="math inline">\(\mathbb{P}=\bigcup_{n,m}\mathbb{S}^{n}\rightarrow\mathbb{S}^{m}\)</span> is the set of all possible signal processors.</li>
</ul>
<p>As an example, let’s express the semantic of the Faust primitive <code>+</code>. Like any Faust expression, it is a signal processor. Its signature is <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}\)</span>. It takes two input signals <span class="math inline">\(X_0\)</span> and <span class="math inline">\(X_1\)</span> and produces an output signal <span class="math inline">\(Y\)</span> such that <span class="math inline">\(Y(t) = X_0(t)+X_1(t)\)</span>.</p>
<p>Numbers are signal processors too. For example the number <span class="math inline">\(3\)</span> has signature <span class="math inline">\(\mathbb{S}^{0}\rightarrow\mathbb{S}\)</span>. It takes no input signals and produce an output signal <span class="math inline">\(Y\)</span> such that <span class="math inline">\(Y(t) = 3\)</span>.</p>
<h1 id="quick-start">Quick Start</h1>
<p>TODO Will be all based on the online editor… May be could be a simple copy and paste of the session 1 of the Kadenze course…</p>
<h1 id="overview-of-the-faust-universe">Overview of the Faust Universe</h1>
<p>While in its most <em>primitive</em> form, Faust is distributed as a command-line compiler, a wide range of tools have been developed around it in the course of the past few years. Their variety and their function might be hard to grab at first. This sort chapter provides an overview of their role and will hopefully help you decide which one is better suited for your personal use.</p>
<!-- TODO: it'd be nice to have some kind of figure here summarizing everything -->
<p>TODO: here say a few words about the philosophy behind the disto: the online editor is the way to go for most users, then various pre-compiled packages of the compiler can be found, then source, then git. Finally other external tools for development.</p>
<h2 id="the-faust-distribution">The Faust Distribution</h2>
<p>The Faust distribution hosts the source of the Faust compiler (both in its command line and library version), the source of the Faust <em>architectures</em> (targets), the various Faust compilation scripts, a wide range of Faust-related-tools, the <a href="TODO">Faust DSP Libraries</a> (which in practice are hosted a separate Git submodule), etc.</p>
<p>The latest stable release of the Faust distribution can be found here: <a href="https://github.com/grame-cncm/faust/releases" class="uri">https://github.com/grame-cncm/faust/releases</a>. It is recommended for most Faust users willing to compile the Faust compiler and <code>libfaust</code> from scratch.</p>
<p>To have the latest stable development version, you can use the <code>master</code> branch of the Faust git repository which is hosted on GitHub: <a href="https://github.com/grame-cncm/faust/tree/master" class="uri">https://github.com/grame-cncm/faust/tree/master</a>.</p>
<p>For something even more bleeding edge (to be used at your own risks), you might use the <code>master-dev</code> branch of the Faust git repository: <a href="https://github.com/grame-cncm/faust/tree/master-dev" class="uri">https://github.com/grame-cncm/faust/tree/master-dev</a>. <code>master-dev</code> is the development sub-branch of <code>master</code>. It is used by Faust developers to commit their changes and can be considered as “the main development branch.” The goal is to make sure that <code>master</code> is always functional. Merges between <code>master-dev</code> and <code>master</code> are carried out multiple times a week by the GRAME team.</p>
<blockquote>
<p>Also, note that pre-compiled packages of the Faust compiler and of <code>libfaust</code> for various platforms can be found on the <a href="__FAUST_DOMAIN__/download">Download Page</a> of the Faust website.</p>
</blockquote>
<p>The Faust distribution is organized as follows:</p>
<pre><code>architecture/          : the source of the architecture files
benchmark/             : tools to measure the efficiency of the generated code
build/                 : the various makefiles and build folders
compiler/              : sources of the Faust compiler
COPYING                : license information
debian/                : files for Debian installation
Dockerfile             : docker file
documentation/         : Faust&#39;s documentations
examples/              : Faust programs examples organized by categories
installer/             : various installers for Linux distribution
libraries/             : Faust DSP libraries
Makefile               : makefile used to build and install Faust
README.md              : instructions on how to build and install Faust
syntax-highlighting/   : support for syntax highlighting for several editors
tests/                 : various tests
tools/                 : tools to produce audio applications and plugins
windows/               : Windows related ressources</code></pre>
<p>The following subsections present some of the main components of the Faust distribution.</p>
<h3 id="command-line-compiler">Command-Line Compiler</h3>
<ul>
<li>Link to precompiled version versions (download page)</li>
<li>What is the Faust compiler? (Quickly)</li>
<li>Link to <a href="#using-the-faust-compiler">Using the Faust Compiler</a></li>
</ul>
<h3 id="libfaust"><code>libfaust</code></h3>
<ul>
<li>Link to precompiled version versions (download page)</li>
<li>What is it? (Quickly)</li>
<li>Link to tutorial <a href="__FAUST_DOMAIN__/learn/embedding-faust">Embedding the Faust Compiler Using <code>libfaust</code></a></li>
</ul>
<h3 id="faust2...-scripts"><code>faust2...</code> Scripts</h3>
<h2 id="web-tools">Web Tools</h2>
<h3 id="the-online-editor">The Online Editor</h3>
<h3 id="the-faustplayground">The FaustPlayground</h3>
<h3 id="the-faust-online-compiler">The Faust Online Compiler</h3>
<h3 id="web-services">Web Services</h3>
<h2 id="development-tools">Development Tools</h2>
<h3 id="faustlive">FaustLive</h3>
<h3 id="faustworks">FaustWorks</h3>
<h1 id="compiling-and-installing-faust">Compiling and Installing Faust</h1>
<p>This chapter describes how to get and compile the Faust compiler as well as other tools related to Faust (e.g., <a href="#libfaust"><code>libfaust</code></a>, <code>libosc</code>, <code>libhttpd</code>, etc.).</p>
<h2 id="getting-the-source-code">Getting the Source Code</h2>
<p>An overview of the various places where the Faust source can be downloaded is given <a href="#the-faust-distribution">here</a>.</p>
<p>If you downloaded the latest Faust release, just un-compressed the archive file and open it in a terminal. For instance, something like (this might vary depending on the version of Faust you downloaded):</p>
<pre><code>tar xzf faust-2.5.31.tar.gz
cd faust-2.5.31</code></pre>
<p>If you wish to get the Faust source directly from the git repository, just run:</p>
<pre><code>git clone --recursive https://github.com/grame-cncm/faust.git
cd faust</code></pre>
<p>in a terminal. Note that the <code>--recursive</code> option is necessary here since some elements (e.g., the Faust DSP libraries) are placed in other repositories.</p>
<p>Finally, if you wish to use the development (and potentially unstable) branch, just run:</p>
<pre><code>git checkout master-dev</code></pre>
<p>after the previous 2 commands.</p>
<p>TODO: see with Dominique for whatever comes next here…</p>
<p>Since release 2.5.18, Faust compilation and installation is based on <code>cmake</code>.</p>
<h1 id="faust-syntax">Faust Syntax</h1>
<!-- TODO we should make a new introductory figure here and add some comments
about it. It'd be nice to make it interactive so that when people click on it,
they are brought to the right section. -->
<h2 id="faust-program">Faust Program</h2>
<p>A Faust program is essentially a list of <em>statements</em>. These statements can be <em>metadata declarations</em> (either <a href="#global-metadata">global metadata</a> or <a href="#function-metadata">function metadata</a>), <a href="#imports"><em>imports</em></a>, <a href="#definitions"><em>definitions</em></a>, and <a href="#documentation-tags"><em>documentation tags</em></a>, with optional C++ style (<code>//...</code> and <code>/*...*/</code>) comments.</p>
<p>Here is a short Faust program that implements of a simple noise generator (called from the <code>noises.lib</code> Faust library). It exhibits various kind of statements : two <a href="#global-metadata"><em>global metadata</em></a> declarations, an <a href="#imports"><em>imports</em></a>, a <em>comment</em>, and a <a href="#definitions"><em>definition</em></a>. We will study later how <a href="#documentation-tags"><em>documentation statements</em></a> work:</p>
<div class="faust-run"><a href="img/src/exfaust3/exfaust3-svg/process.svg" target="_blank"><img src="img/src/exfaust3/exfaust3-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;Noise&quot;;
declare copyright &quot;(c)GRAME 2018&quot;;

import(&quot;stdfaust.lib&quot;);

// noise level controlled by a slider
process = no.noise * hslider(&quot;gain&quot;,0,0,1, 0.1);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust3/exfaust3.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>The keyword <code>process</code> is the equivalent of <code>main</code> in C/C++. Any Faust program, to be valid, must at least define <code>process</code>.</p>
<h2 id="statements">Statements</h2>
<p>The <em>statements</em> of a Faust program are of four kinds:</p>
<ul>
<li><em>metadata declarations</em>,</li>
<li><em>file imports</em>,</li>
<li><em>definitions</em>,</li>
<li><em>documentation</em>.</li>
</ul>
<p>All statements but <em>documentation</em> end with a semicolon <code>;</code>.</p>
<h3 id="metadata">Metadata</h3>
<p>Metadata allow us to add elements which are not part of the language to Faust code. These can range to the name of a Faust program, its author, to potential compilation options or user interface element customizations.</p>
<p>There are three different types of metadata in Faust:</p>
<ul>
<li><a href="#global-metadata">Global Metadata</a>: metadata global to a Faust code</li>
<li><a href="#function-metadata">Function Metadata</a>: metadata specific to a function</li>
<li><a href="#ui-label-metadata">UI Metadata</a>: metadata specific to a UI element</li>
</ul>
<p>Note that some <a href="#global-metadata">Global Metadata</a> have standard names and can be used for specific tasks. Their role is described in the <a href="#standard-metadata">Standard Metadata</a> section.</p>
<h3 id="global-metadata">Global Metadata</h3>
<p>All global metadata declaration in Faust start with <code>declare</code>, followed by a key and a string. For example:</p>
<pre><code>declare name &quot;Noise&quot;;</code></pre>
<p>allows us to specify the name of a Faust program in its whole.</p>
<p>Unlike regular comments, metadata declarations will appear in the C++ code generated by the Faust compiler. A good practice is to start a Faust program with some standard declarations:</p>
<pre><code>declare name &quot;MyProgram&quot;;
declare author &quot;MySelf&quot;;
declare copyright &quot;MyCompany&quot;;
declare version &quot;1.00&quot;;
declare license &quot;BSD&quot;; </code></pre>
<h3 id="function-metadata">Function Metadata</h3>
<p>Metadata can be associated to a specific function. In that case, <code>declare</code> is followed by the name of the function, a key, and a string. For example:</p>
<pre><code>declare add author &quot;John Doe&quot;
add = +;</code></pre>
<p>This is very useful when a library has several contributors and that functions potentially have different license terms, etc.</p>
<h3 id="standard-metadata">Standard Metadata</h3>
<p>There exists a series of standard <a href="#global-metadata">global metadata</a> in Faust whose role role is described in the following table:</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Metadata</th>
<th>Role</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>declare options &quot;[key0:value][key1:value]&quot;</code></td>
<td>This metadata can be used to specify various options associated to a Faust code such as the fact its polyphonic, if it should have OSC, MIDI support, etc. Specific <code>keys</code> usable with this metadata are described throughout this documentation.</td>
</tr>
<tr class="even">
<td><code>declare interface &quot;xxx&quot;</code></td>
<td>Specifies an interface replacing the standard Faust UI.</td>
</tr>
</tbody>
</table>
<!-- TODO: some are missing here: incomplete -->
<h3 id="imports">Imports</h3>
<p>File imports allow us to import definitions from other source files.</p>
<p>For example <code>import(&quot;maths.lib&quot;);</code> imports the definitions of the <a href="TODO"><code>maths.lib</code></a> library.</p>
<p>The most common file to be imported is the <code>stdfaust.lib</code> library which gives access to all the standard Faust libraries from a single point:</p>
<div class="faust-run"><a href="img/src/exfaust4/exfaust4-svg/process.svg" target="_blank"><img src="img/src/exfaust4/exfaust4-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
process = os.osc(440); // the &quot;hello world&quot; of computer music</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust4/exfaust4.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h3 id="documentation-tags">Documentation Tags</h3>
<p>Documentation statements are optional and typically used to control the generation of the mathematical documentation of a Faust program. This documentation system is detailed in the <a href="#mathematical-documentation">Mathematical Documentation</a> chapter. In this section we essentially describe the documentation statements syntax.</p>
<p>A documentation statement starts with an opening <code>&lt;mdoc&gt;</code> tag and ends with a closing <code>&lt;/mdoc&gt;</code> tag. Free text content, typically in Latex format, can be placed in between these two tags. <!-- Why not markdown? --></p>
<p><img src="img/documentation.svg" class="mx-auto d-block"></p>
<p>Moreover, optional sub-tags can be inserted in the text content itself to require the generation, at the insertion point, of mathematical <em>equations</em>, graphical <em>block-diagrams</em>, Faust source code <em>listing</em> and explanation <em>notice</em>.</p>
<p><img src="img/equation.svg" class="mx-auto d-block"></p>
<p>The generation of the mathematical equations of a Faust expression can be requested by placing this expression between an opening <code>&lt;equation&gt;</code> and a closing <code>&lt;/equation&gt;</code> tag. The expression is evaluated within the lexical context of the Faust program.</p>
<p><img src="img/diagram.svg" class="mx-auto d-block"></p>
<p>Similarly, the generation of the graphical block-diagram of a Faust expression can be requested by placing this expression between an opening <code>&lt;diagram&gt;</code> and a closing <code>&lt;/diagram&gt;</code> tag. The expression is evaluated within the lexical context of the Faust program.</p>
<p><img src="img/metadata.svg" class="mx-auto d-block"></p>
<p>The <code>&lt;metadata&gt;</code> tags allow to reference Faust <a href="#global-metadata">global metadatas</a>, calling the corresponding keyword.</p>
<p><img src="img/notice.svg" class="mx-auto d-block"></p>
<p>The <code>&lt;notice/&gt;</code> empty-element tag is used to generate the conventions used in the mathematical equations.</p>
<p><img src="img/listing.svg" class="mx-auto d-block"></p>
<p>The <code>&lt;listing/&gt;</code> empty-element tag is used to generate the listing of the Faust program. Its three attributes <code>mdoctags</code>, <code>dependencies</code>, and <code>distributed</code> enable or disable respectively <code>&lt;mdoc&gt;</code> tags, other files dependencies and distribution of interleaved Faust code between <code>&lt;mdoc&gt;</code> sections.</p>
<h2 id="definitions">Definitions</h2>
<p>A <em>definition</em> associates an identifier with an expression. Definitions are essentially a convenient shortcut avoiding to type long expressions. During compilation, more precisely during the evaluation stage, identifiers are replaced by their definitions. It is therefore always equivalent to use an identifier or directly its definition. Please note that multiple definitions of a same identifier are not allowed, unless it is a pattern matching based definition.</p>
<h3 id="simple-definitions">Simple Definitions</h3>
<p>The syntax of a simple definition is:</p>
<pre><code>identifier = expression ;</code></pre>
<p>For example here is the definition of <code>random</code>, a simple pseudo-random number generator:</p>
<pre><code>random = +(12345) ~ *(1103515245);</code></pre>
<h2 id="function-definitions">Function Definitions</h2>
<p>Definitions with formal parameters correspond to functions definitions.</p>
<p><img src="img/listing.svg" class="mx-auto d-block"></p>
<p>For example the definition of <code>linear2db</code>, a function that converts linear values to decibels, is:</p>
<pre><code>linear2db(x) = 20*log10(x);</code></pre>
<p>Please note that this notation is only a convenient alternative to the direct use of <a href="#abstractions"><em>lambda-abstractions</em></a> (also called anonymous functions). The following is an equivalent definition of <code>linear2db</code> using a lambda-abstraction:</p>
<pre><code>linear2db = \(x).(20*log10(x));</code></pre>
<h2 id="definitions-with-pattern-matching">Definitions with pattern matching</h2>
<p>Moreover, formal parameters can also be full expressions representing patterns.</p>
<p><img src="img/listing.svg" class="mx-auto d-block"></p>
<p>This powerful mechanism allows to algorithmically create and manipulate block diagrams expressions. Let’s say that you want to describe a function to duplicate an expression several times in parallel:</p>
<pre><code>duplicate(1,x) = x;
duplicate(n,x) = x, duplicate(n-1,x);</code></pre>
<p>Note that this last definition is a convenient alternative to the more verbose:</p>
<pre><code>duplicate = case { 
  (1,x) =&gt; x; 
  (n,x) =&gt; duplicate(n-1,x); 
};</code></pre>
<p>A use case for <code>duplicate</code> could be to put 5 white noise generators in parallel:</p>
<div class="faust-run"><a href="img/src/exfaust5/exfaust5-svg/process.svg" target="_blank"><img src="img/src/exfaust5/exfaust5-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
duplicate(1,x) = x;
duplicate(n,x) = x, duplicate(n-1,x);
process = duplicate(5,no.noise);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust5/exfaust5.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Here is another example to count the number of elements of a list. Please note that we simulate lists using <a href="#parallel-composition">parallel composition</a>: <code>(1,2,3,5,7,11)</code>. The main limitation of this approach is that there is no empty list. Moreover lists of only one element are represented by this element:</p>
<pre><code>count((x,xs)) = 1+count(xs);
count(x) = 1;</code></pre>
<p>If we now write <code>count(duplicate(10,666))</code>, the expression will be evaluated as <code>10</code>.</p>
<p>Note that the order of pattern matching rules matters. The more specific rules must precede the more general rules. When this order is not respected, as in:</p>
<pre><code>count(x) = 1;
count((x,xs)) = 1+count(xs);</code></pre>
<p>the first rule will always match and the second rule will never be called.</p>
<h2 id="expressions">Expressions</h2>
<p>Despite its textual syntax, Faust is conceptually a block-diagram language. Faust expressions represent DSP block-diagrams and are assembled from primitive ones using various <em>composition</em> operations. More traditional <em>numerical</em> expressions in infix notation are also possible. Additionally Faust provides time based expressions, like delays, expressions related to lexical environments, expressions to interface with foreign function and lambda expressions.</p>
<p><img src="img/expression.svg" class="mx-auto d-block"></p>
<h3 id="diagram-expressions">Diagram Expressions</h3>
<p>Diagram expressions are assembled from primitive ones using either binary composition operations or high level iterative constructions.</p>
<p><img src="img/diagramexp.svg" class="mx-auto d-block"></p>
<h4 id="diagram-composition-operations">Diagram Composition Operations</h4>
<p>Five binary <em>composition operations</em> are available to combine block-diagrams:</p>
<ul>
<li><a href="#recursion-composition"><em>recursion</em></a> (<code>~</code>),</li>
<li><a href="#parallel-composition"><em>parallel</em></a> (<code>,</code>),</li>
<li><a href="#sequential-composition"><em>sequential</em></a> (<code>:</code>),</li>
<li><a href="#split-composition"><em>split</em></a> (<code>&lt;:</code>),</li>
<li><a href="#merge-composition"><em>merge</em></a> (<code>:&gt;</code>).</li>
</ul>
<p>One can think of each of these composition operations as a particular way to connect two block diagrams.</p>
<p><img src="img/diagcomposition.svg" class="mx-auto d-block"></p>
<p>To describe precisely how these connections are done, we have to introduce some notation. The number of inputs and outputs of a block-diagram <span class="math inline">\(A\)</span> are expressed as <span class="math inline">\(\mathrm{inputs}(A)\)</span> and <span class="math inline">\(\mathrm{outputs}(A)\)</span>. The inputs and outputs themselves are respectively expressed as: <span class="math inline">\([0]A\)</span>, <span class="math inline">\([1]A\)</span>, <span class="math inline">\([2]A\)</span>, <span class="math inline">\(\ldots\)</span> and <span class="math inline">\(A[0]\)</span>, <span class="math inline">\(A[1]\)</span>, <span class="math inline">\(A[2]\)</span>, etc.</p>
<p>For each composition operation between two block-diagrams <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> we will describe the connections <span class="math inline">\(A[i]\rightarrow [j]B\)</span> that are created and the constraints on their relative numbers of inputs and outputs.</p>
<p>The priority and associativity of this five operations are:</p>
<table>
<thead>
<tr class="header">
<th>Syntax</th>
<th>Priority</th>
<th>Association</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>expression ~ expression</code></td>
<td>4</td>
<td>left</td>
<td>Recursive Composition</td>
</tr>
<tr class="even">
<td><code>expression , expression</code></td>
<td>3</td>
<td>right</td>
<td>Parallel Composition</td>
</tr>
<tr class="odd">
<td><code>expression : expression</code></td>
<td>2</td>
<td>right</td>
<td>Sequential Composition</td>
</tr>
<tr class="even">
<td><code>expression &lt;: expression</code></td>
<td>1</td>
<td>right</td>
<td>Split Composition</td>
</tr>
<tr class="odd">
<td><code>expression :&gt; expression</code></td>
<td>1</td>
<td>right</td>
<td>Merge Composition</td>
</tr>
</tbody>
</table>
<h4 id="parallel-composition">Parallel Composition</h4>
<p>The <em>parallel composition</em> (e.g., <code>(A,B)</code>) is probably the simplest one. It places the two block-diagrams one on top of the other, without connections. The inputs of the resulting block-diagram are the inputs of <code>A</code> and <code>B</code>. The outputs of the resulting block-diagram are the outputs of <code>A</code> and <code>B</code>.</p>
<p><em>Parallel composition</em> is an associative operation: <code>(A,(B,C))</code> and <code>((A,B),C)</code> are equivalents. When no parenthesis are used (e.g., <code>A,B,C,D</code>), Faust uses right associativity and therefore builds internally the expression <code>(A,(B,(C,D)))</code>. This organization is important to know when using pattern matching techniques on parallel compositions.</p>
<p><strong>Example: Oscillators in Parallel</strong></p>
<p><em>Parallel composition</em> can be used to put 3 oscillators of different kinds and frequencies in parallel, which will result in a Faust program with 3 outputs:</p>
<div class="faust-run"><a href="img/src/exfaust6/exfaust6-svg/process.svg" target="_blank"><img src="img/src/exfaust6/exfaust6-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
process = os.osc(440),os.sawtooth(550),os.triangle(660);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust6/exfaust6.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p><strong>Example: Stereo Effect</strong></p>
<p><em>Parallel composition</em> can be used to easily turn a mono effect into a stereo one which will result in a Faust program with 2 inputs and 2 outputs:</p>
<div class="faust-run"><a href="img/src/exfaust7/exfaust7-svg/process.svg" target="_blank"><img src="img/src/exfaust7/exfaust7-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
level = 1;
process = ve.autowah(level),ve.autowah(level);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust7/exfaust7.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Note that there’s a better to write this last example using the <a href="#par-iteration"><code>par</code> iteration</a>:</p>
<div class="faust-run"><a href="img/src/exfaust8/exfaust8-svg/process.svg" target="_blank"><img src="img/src/exfaust8/exfaust8-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
level = 1;
process = par(i,2,ve.autowah(level));</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust8/exfaust8.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="sequential-composition">Sequential Composition</h4>
<p>The <em>sequential composition</em> (e.g., <code>A:B</code>) expects:</p>
<p><span class="math display">\[\mathrm{outputs}(A)=\mathrm{inputs}(B)\]</span></p>
<p>It connects each output of <span class="math inline">\(A\)</span> to the corresponding input of <span class="math inline">\(B\)</span>:</p>
<p><span class="math display">\[A[i]\rightarrow[i]B\]</span></p>
<p><em>Sequential composition</em> is an associative operation: <code>(A:(B:C))</code> and <code>((A:B):C)</code> are equivalents. When no parenthesis are used, like in <code>A:B:C:D</code>, Faust uses right associativity and therefore builds internally the expression <code>(A:(B:(C:D)))</code>.</p>
<p><strong>Example: Sine Oscillator</strong></p>
<p>Since everything is considered as a signal generator in Faust, <em>sequential composition</em> can be simply used to pass an argument to a function:</p>
<div class="faust-run"><a href="img/src/exfaust9/exfaust9-svg/process.svg" target="_blank"><img src="img/src/exfaust9/exfaust9-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
process = 440 : os.osc;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust9/exfaust9.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p><strong>Example: Effect Chain</strong></p>
<p><em>Sequential composition</em> can be used to create an audio effect chain. Here we’re plugging a guitar distortion to an autowah:</p>
<div class="faust-run"><a href="img/src/exfaust10/exfaust10-svg/process.svg" target="_blank"><img src="img/src/exfaust10/exfaust10-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
drive = 0.6;
offset = 0;
autoWahLevel = 1;
process = ef.cubicnl(drive,offset) : ve.autowah(autoWahLevel);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust10/exfaust10.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="split-composition">Split Composition</h4>
<p>The <em>split composition</em> (e.g., <code>A&lt;:B</code>) operator is used to distribute the outputs of <span class="math inline">\(A\)</span> to the inputs of <span class="math inline">\(B\)</span>.</p>
<p>For the operation to be valid, the number of inputs of <span class="math inline">\(B\)</span> must be a multiple of the number of outputs of <span class="math inline">\(A\)</span>:</p>
<p><span class="math display">\[\mathrm{outputs}(A).k=\mathrm{inputs}(B)\]</span></p>
<p>Each input <span class="math inline">\(i\)</span> of <span class="math inline">\(B\)</span> is connected to the output <span class="math inline">\(i \bmod k\)</span> of <span class="math inline">\(A\)</span>:</p>
<p><span class="math display">\[A[i \bmod k]\rightarrow[i]B\]</span></p>
<p><strong>Example: Duplicating the Output of an Oscillator</strong></p>
<p><em>Split composition</em> can be used to duplicate signals. For example, the output of the following sawtooth oscillator is duplicated 3 times in parallel.</p>
<div class="faust-run"><a href="img/src/exfaust11/exfaust11-svg/process.svg" target="_blank"><img src="img/src/exfaust11/exfaust11-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
process = os.sawtooth(440) &lt;: _,_,_;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust11/exfaust11.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Note that this can be written in a more effective way by replacing <code>_,_,_</code> with <code>par(i,3,_)</code> using the <a href="#par-iteration"><code>par</code> iteration</a>.</p>
<p><strong>Example: Connecting a Mono Effect to a Stereo One</strong></p>
<p>More generally, the <em>split composition</em> can be used to connect a block with a certain number of output to a block with a greater number of inputs:</p>
<div class="faust-run"><a href="img/src/exfaust12/exfaust12-svg/process.svg" target="_blank"><img src="img/src/exfaust12/exfaust12-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
drive = 0.6;
offset = 0;
process = ef.cubicnl(drive,offset) &lt;: dm.zita_light;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust12/exfaust12.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Note that an arbitrary number of signals can be split, for example:</p>
<div class="faust-run"><a href="img/src/exfaust13/exfaust13-svg/process.svg" target="_blank"><img src="img/src/exfaust13/exfaust13-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
drive = 0.6;
offset = 0;
process = par(i,2,ef.cubicnl(drive,offset)) &lt;: par(i,2,dm.zita_light);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust13/exfaust13.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Once again, the only rule with this is that in the expression <code>A&lt;:B</code> the number of inputs of <code>B</code> has to be a multiple of the number of outputs of <code>A</code>.</p>
<!-- TODO: make sure that signal distribution rules are explained somewhere
else in the doc -->
<h4 id="merge-composition">Merge Composition</h4>
<p>The <em>merge composition</em> (e.g., <code>A:&gt;B</code>) is the dual of the <a href="#split-composition"><em>split composition</em></a>. The number of outputs of <span class="math inline">\(A\)</span> must be a multiple of the number of inputs of <span class="math inline">\(B\)</span>:</p>
<p><span class="math display">\[\mathrm{outputs}(A)=k.\mathrm{inputs}(B)\]</span></p>
<p>Each output <span class="math inline">\(i\)</span> of <span class="math inline">\(A\)</span> is connected to the input <span class="math inline">\(i \bmod k\)</span> of <span class="math inline">\(B\)</span> :</p>
<p><span class="math display">\[A[i]\rightarrow\ [i \bmod k]B\]</span></p>
<p>The <span class="math inline">\(k\)</span> incoming signals of an input of <span class="math inline">\(B\)</span> are summed together.</p>
<p><strong>Example: Summing Signals Together - Additive Synthesis</strong></p>
<p><em>Merge composition</em> can be used to sum an arbitrary number of signals together. Here’s an example of a simple additive synthesizer (note that the result of the sum of the signals is divided by 3 to prevent clicking):</p>
<div class="faust-run"><a href="img/src/exfaust14/exfaust14-svg/process.svg" target="_blank"><img src="img/src/exfaust14/exfaust14-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freq = hslider(&quot;freq&quot;,440,50,3000,0.01);
gain = hslider(&quot;gain&quot;,1,0,1,0.01);
gate = button(&quot;gate&quot;);
envelope = gain*gate : si.smoo;
process = os.osc(freq),os.osc(freq*2),os.osc(freq*3) :&gt; /(3)*envelope;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust14/exfaust14.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>While the resulting block diagram will look slightly different, this is mathematically equivalent to:</p>
<div class="faust-run"><a href="img/src/exfaust15/exfaust15-svg/process.svg" target="_blank"><img src="img/src/exfaust15/exfaust15-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freq = hslider(&quot;freq&quot;,440,50,3000,0.01);
gain = hslider(&quot;gain&quot;,1,0,1,0.01);
gate = button(&quot;gate&quot;);
envelope = gain*gate : si.smoo;
process = (os.osc(freq) + os.osc(freq*2) + os.osc(freq*3))/(3)*envelope;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust15/exfaust15.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p><strong>Example: Connecting a Stereo Effect to a Mono One</strong></p>
<p>More generally, the <em>merge composition</em> can be used to connect a block with a certain number of output to a block with a smaller number of inputs:</p>
<div class="faust-run"><a href="img/src/exfaust16/exfaust16-svg/process.svg" target="_blank"><img src="img/src/exfaust16/exfaust16-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
drive = 0.6;
offset = 0;
process = dm.zita_light :&gt; ef.cubicnl(drive,offset);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust16/exfaust16.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Note that an arbitrary number of signals can be split, for example:</p>
<div class="faust-run"><a href="img/src/exfaust17/exfaust17-svg/process.svg" target="_blank"><img src="img/src/exfaust17/exfaust17-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
drive = 0.6;
offset = 0;
process = par(i,2,dm.zita_light) :&gt; par(i,2,ef.cubicnl(drive,offset));</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust17/exfaust17.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Once again, the only rule with this is that in the expression <code>A:&gt;B</code> the number of outputs of <code>A</code> has to be a multiple of the number of inputs of <code>B</code>.</p>
<h4 id="recursive-composition">Recursive Composition</h4>
<p>The <em>recursive composition</em> (e.g., <code>A~B</code>) is used to create cycles in the block-diagram in order to express recursive computations. It is the most complex operation in terms of connections.</p>
<p>To be applicable, it requires that:</p>
<p><span class="math display">\[\mathrm{outputs}(A) \geq \mathrm{inputs}(B) and \mathrm{inputs}(A) \geq \mathrm{outputs}(B)\]</span></p>
<p>Each input of <span class="math inline">\(B\)</span> is connected to the corresponding output of <span class="math inline">\(A\)</span> via an implicit 1-sample delay :</p>
<p><span class="math display">\[A[i]\stackrel{Z^{-1}}{\rightarrow}[i]B\]</span></p>
<p>and each output of <span class="math inline">\(B\)</span> is connected to the corresponding input of <span class="math inline">\(A\)</span>:</p>
<p><span class="math display">\[B[i]\rightarrow [i]A\]</span></p>
<p>The inputs of the resulting block diagram are the remaining unconnected inputs of <span class="math inline">\(A\)</span>. The outputs are all the outputs of <span class="math inline">\(A\)</span>.</p>
<p><strong>Example: Timer</strong></p>
<p><em>Recursive composition</em> can be used to implement a “timer” that will count each sample starting at time <span class="math inline">\(n=0\)</span>:</p>
<div class="faust-run"><a href="img/src/exfaust18/exfaust18-svg/process.svg" target="_blank"><img src="img/src/exfaust18/exfaust18-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = _~+(1);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust18/exfaust18.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>The difference equation corresponding to this program is:</p>
<p><span class="math display">\[y(n) = y(n-1) + 1\]</span></p>
<p>an its output signal will look like: <span class="math inline">\((1,2,3,4,5,6,\dots)\)</span>.</p>
<p><strong>Example: One Pole Filter</strong></p>
<p><em>Recursive composition</em> can be used to implement a one pole filter with one line of code and just a few characters:</p>
<div class="faust-run"><a href="img/src/exfaust19/exfaust19-svg/process.svg" target="_blank"><img src="img/src/exfaust19/exfaust19-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>a1 = 0.999; // the pole
process = +~*(a1);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust19/exfaust19.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>The difference equation corresponding to this program is:</p>
<p><span class="math display">\[y(n) = x(n) + a_{1}y(n-1)\]</span></p>
<p>Note that the one sample delay of the filter is implicit here so it doesn’t have to be declared.</p>
<h4 id="inputs-and-outputs-of-an-expression">Inputs and Outputs of an Expression</h4>
<p>The number of inputs and outputs of a Faust expression can be known at compile time simply by using <code>inputs(expression)</code> and <code>outputs(expression)</code>.</p>
<p>For example, the number of outputs of a sine wave oscillator can be known simply by writing the following program:</p>
<div class="faust-run"><a href="img/src/exfaust20/exfaust20-svg/process.svg" target="_blank"><img src="img/src/exfaust20/exfaust20-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
process = outputs(os.osc(440));</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust20/exfaust20.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Note that Faust automatically simplified the expression by generating a program that just outputs <code>1</code>.</p>
<p>This type of construction is useful to define high order functions and build algorithmically complex block-diagrams. Here is an example to automatically reverse the order of the outputs of an expression.</p>
<pre><code>Xo(expr) = expr &lt;: par(i,n,ba.selector(n-i-1,n)) 
with { 
  n = outputs(expr);
};</code></pre>
<p>And the inputs of an expression :</p>
<pre><code>Xi(expr) = si.bus(n) &lt;: par(i,n,ba.selector(n-i-1,n)) : expr 
with { 
  n = inputs(expr); 
};</code></pre>
<p>For example <code>Xi(-)</code> will reverse the order of the two inputs of the substraction:</p>
<div class="faust-run"><a href="img/src/exfaust21/exfaust21-svg/process.svg" target="_blank"><img src="img/src/exfaust21/exfaust21-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
Xi(expr) = si.bus(n) &lt;: par(i,n,ba.selector(n-i-1,n)) : expr 
with { 
  n = inputs(expr); 
};
toto = os.osc(440),os.sawtooth(440), os.triangle(440);
process = Xi(-);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust21/exfaust21.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="iterations">Iterations</h4>
<p>Iterations are analogous to <code>for(...)</code> loops in other languages and provide a convenient way to automate some complex block-diagram constructions.</p>
<p><img src="img/diagiteration.svg" class="mx-auto d-block"></p>
<p>The use and role of <a href="#par-iteration"><code>par</code></a>, <a href="#seq-iteration"><code>seq</code></a>, <a href="#sum-iteration"><code>sum</code></a>, and <a href="#prod-iteration"><code>prod</code></a> are detailed in the following sections.</p>
<h4 id="par-iteration"><code>par</code> Iteration</h4>
<p>The <code>par</code> iteration can be used to duplicate an expression in parallel. Just like other types of iterations in Faust:</p>
<ul>
<li>its first argument is a variable name containing the number of the current iteration (a bit like the variable that is usually named <code>i</code> in a for loop) starting at 0,</li>
<li>its second argument is the number of iterations,</li>
<li>its third argument is the expression to be duplicated.</li>
</ul>
<p><strong>Example: Simple Additive Synthesizer</strong></p>
<div class="faust-run"><a href="img/src/exfaust22/exfaust22-svg/process.svg" target="_blank"><img src="img/src/exfaust22/exfaust22-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freq = hslider(&quot;freq&quot;,440,50,3000,0.01);
gain = hslider(&quot;gain&quot;,1,0,1,0.01);
gate = button(&quot;gate&quot;);
envelope = gain*gate : si.smoo;
nHarmonics = 4;
process = par(i,nHarmonics,os.osc(freq*(i+1))) :&gt; /(nHarmonics)*envelope;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust22/exfaust22.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p><code>i</code> is used here at each iteration to compute the value of the frequency of the current oscillator. Also, note that this example could be re-wrtitten using <a href="#sum-iteration"><code>sum</code> iteration</a> (see example in the corresponding section).</p>
<h4 id="seq-iteration"><code>seq</code> Iteration</h4>
<p>The <code>seq</code> iteration can be used to duplicate an expression in series. Just like other types of iterations in Faust:</p>
<ul>
<li>its first argument is a variable name containing the number of the current iteration (a bit like the variable that is usually named <code>i</code> in a for loop) starting at 0,</li>
<li>its second argument is the number of iterations,</li>
<li>its third argument is the expression to be duplicated.</li>
</ul>
<p><strong>Example: Peak Equalizer</strong></p>
<p>The <a href="TODO"><code>fi.peak_eq</code></a> function of the Faust libraries implements a second order “peak equalizer” section (gain boost or cut near some frequency). When placed in series, it can be used to implement a full peak equalizer:</p>
<div class="faust-run"><a href="img/src/exfaust23/exfaust23-svg/process.svg" target="_blank"><img src="img/src/exfaust23/exfaust23-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
nBands = 8;
filterBank(N) = hgroup(&quot;Filter Bank&quot;,seq(i,N,oneBand(i)))
with{
    oneBand(j) = vgroup(&quot;[%j]Band %a&quot;,fi.peak_eq(l,f,b))
    with{
        a = j+1; // just so that band numbers don&#39;t start at 0
        l = vslider(&quot;[2]Level[unit:db]&quot;,0,-70,12,0.01) : si.smoo;
        f = nentry(&quot;[1]Freq&quot;,(80+(1000*8/N*(j+1)-80)),20,20000,0.01) : si.smoo;
        b = f/hslider(&quot;[0]Q[style:knob]&quot;,1,1,50,0.01) : si.smoo;
    };
};
process = filterBank(nBands);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust23/exfaust23.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Note that <code>i</code> is used here at each iteration to compute various elements and to format some labels. Having user interface elements with different names is a way to force their differentiation in the generated interface.</p>
<h4 id="sum-iteration"><code>sum</code> Iteration</h4>
<p>The <code>sum</code> iteration can be used to duplicate an expression as a sum. Just like other types of iterations in Faust:</p>
<ul>
<li>its first argument is a variable name containing the number of the current iteration (a bit like the variable that is usually named <code>i</code> in a for loop) starting at 0,</li>
<li>its second argument is the number of iterations,</li>
<li>its third argument is the expression to be duplicated.</li>
</ul>
<p><strong>Example: Simple Additive Synthesizer</strong></p>
<p>The following example is just a slightly different version from the one presented in the <a href="#par-iteration"><code>par</code> iteration</a> section. While their block diagrams look slightly different, the generated code is exactly the same.</p>
<div class="faust-run"><a href="img/src/exfaust24/exfaust24-svg/process.svg" target="_blank"><img src="img/src/exfaust24/exfaust24-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freq = hslider(&quot;freq&quot;,440,50,3000,0.01);
gain = hslider(&quot;gain&quot;,1,0,1,0.01);
gate = button(&quot;gate&quot;);
envelope = gain*gate : si.smoo;
nHarmonics = 4;
process = sum(i,nHarmonics,os.osc(freq*(i+1)))/(nHarmonics)*envelope;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust24/exfaust24.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p><code>i</code> is used here at each iteration to compute the value of the frequency of the current oscillator.</p>
<h4 id="prod-iteration"><code>prod</code> Iteration</h4>
<p>The <code>sum</code> iteration can be used to duplicate an expression as a product. Just like other types of iterations in Faust:</p>
<ul>
<li>its first argument is a variable name containing the number of the current iteration (a bit like the variable that is usually named <code>i</code> in a for loop) starting at 0,</li>
<li>its second argument is the number of iterations,</li>
<li>its third argument is the expression to be duplicated.</li>
</ul>
<p><strong>Example: Amplitude Modulation Synthesizer</strong></p>
<p>The following example implements an amplitude modulation synthesizer using an arbitrary number of oscillators thanks to the <code>prod</code> iteration:</p>
<div class="faust-run"><a href="img/src/exfaust25/exfaust25-svg/process.svg" target="_blank"><img src="img/src/exfaust25/exfaust25-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freq = hslider(&quot;[0]freq&quot;,440,50,3000,0.01);
gain = hslider(&quot;[1]gain&quot;,1,0,1,0.01);
shift = hslider(&quot;[2]shift&quot;,0,0,1,0.01);
gate = button(&quot;[3]gate&quot;);
envelope = gain*gate : si.smoo;
nOscs = 4;
process = prod(i,nOscs,os.osc(freq*(i+1+shift)))*envelope;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust25/exfaust25.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p><code>i</code> is used here at each iteration to compute the value of the frequency of the current oscillator. Note that the <code>shift</code> parameter can be used to tune the frequency drift between each oscillator.</p>
<h3 id="infix-notation-and-other-syntax-extensions">Infix Notation and Other Syntax Extensions</h3>
<blockquote>
<p>Infix notation is commonly used in mathematics. It consists in placing the operand between the arguments as in <span class="math inline">\(2+3\)</span></p>
</blockquote>
<p>Besides its algebra-based core syntax, Faust provides some syntax extensions, in particular the familiar <em>infix notation</em>. For example if you want to multiply two numbers, say <code>2</code> and <code>3</code>, you can write directly <code>2*3</code> instead of the equivalent core-syntax expression <code>2,3 : *</code>.</p>
<p>The <em>infix notation</em> is not limited to numbers or numerical expressions. Arbitrary expressions <code>A</code> and <code>B</code> can be used, provided that <code>A,B</code> has exactly two outputs. For example <code>_/2</code> is equivalent to <code>_,2:/</code> which divides the incoming signal by <code>2</code>.</p>
<p>Here are a few examples of equivalences:</p>
<table>
<thead>
<tr class="header">
<th>Infix Syntax</th>
<th></th>
<th>Core Syntax</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>2-3</code></td>
<td><span class="math inline">\(\equiv\)</span></td>
<td><code>2,3 : -</code></td>
</tr>
<tr class="even">
<td><code>2*3</code></td>
<td><span class="math inline">\(\equiv\)</span></td>
<td><code>2,3 : *</code></td>
</tr>
<tr class="odd">
<td><code>_@7</code></td>
<td><span class="math inline">\(\equiv\)</span></td>
<td><code>_,7 : @</code></td>
</tr>
<tr class="even">
<td><code>_/2</code></td>
<td><span class="math inline">\(\equiv\)</span></td>
<td><code>_,2 : /</code></td>
</tr>
<tr class="odd">
<td><code>A&lt;B</code></td>
<td><span class="math inline">\(\equiv\)</span></td>
<td><code>A,B : &lt;</code></td>
</tr>
</tbody>
</table>
<p>In case of doubts on the meaning of an infix expression, for example <code>_*_</code>, it is useful to translate it to its core syntax equivalent, here <code>_,_:*</code>, which is equivalent to <code>*</code>.</p>
<h4 id="infix-operators">Infix Operators</h4>
<p>Built-in primitives that can be used in infix notation are called <em>infix operators</em> and are listed below. Please note that a more detailed description of these operators is available <a href="#primitives">section on primitives</a>.</p>
<p><img src="img/infixop.svg" class="mx-auto d-block"></p>
<h4 id="prefix-notation">Prefix Notation</h4>
<p>Beside <em>infix notation</em>, it is also possible to use <em>prefix notation</em>. The <em>prefix notation</em> is the usual mathematical notation for functions <span class="math inline">\(f(x,y,z,\ldots)\)</span>, but extended to <em>infix operators</em>.</p>
<p>It consists in first having the operator, for example <code>/</code>, followed by its arguments between parentheses: <code>/(2,3)</code>:</p>
<table>
<thead>
<tr class="header">
<th>Prefix Syntax</th>
<th></th>
<th>Core Syntax</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>*(2,3)</code></td>
<td><span class="math inline">\(\equiv\)</span></td>
<td><code>2,3 : *</code></td>
</tr>
<tr class="even">
<td><code>@(_,7)</code></td>
<td><span class="math inline">\(\equiv\)</span></td>
<td><code>_,7 : @</code></td>
</tr>
<tr class="odd">
<td><code>/(_,2)</code></td>
<td><span class="math inline">\(\equiv\)</span></td>
<td><code>_,2 : /</code></td>
</tr>
<tr class="even">
<td><code>&lt;(A,B)</code></td>
<td><span class="math inline">\(\equiv\)</span></td>
<td><code>A,B : &lt;</code></td>
</tr>
</tbody>
</table>
<h4 id="partial-application">Partial Application</h4>
<p>The <em>partial application</em> notation is a variant of the <em>prefix notation</em> in which not all arguments are given. For instance <code>/(2)</code> (divide by 2), <code>^(3)</code> (rise to the cube), and <code>@(512)</code> (delay by 512 samples) are examples of partial applications where only one argument is given. The result of a partial application is a function that “waits” for the remaining arguments.</p>
<p>When doing partial application with an <em>infix operator</em>, it is important to note that the supplied argument is not the first argument, but always the second one:</p>
<table>
<thead>
<tr class="header">
<th>Prefix Partial Application Syntax</th>
<th></th>
<th>Core Syntax</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>+(C)</code></td>
<td><span class="math inline">\(\equiv\)</span></td>
<td><code>_,C : *</code></td>
</tr>
<tr class="even">
<td><code>-(C)</code></td>
<td><span class="math inline">\(\equiv\)</span></td>
<td><code>_,C : -</code></td>
</tr>
<tr class="odd">
<td><code>&lt;(C)</code></td>
<td><span class="math inline">\(\equiv\)</span></td>
<td><code>_,C : &lt;</code></td>
</tr>
<tr class="even">
<td><code>/(C)</code></td>
<td><span class="math inline">\(\equiv\)</span></td>
<td><code>_,C : /</code></td>
</tr>
</tbody>
</table>
<p>For commutative operations that doesn’t matter. But for non-commutative ones, it is more “natural” to fix the second argument. We use divide by 2 (<code>/(2)</code>) or rise to the cube (<code>^(3)</code>) more often than the other way around.</p>
<p>Please note that this rule only applies to infix operators, not to other primitives or functions. If you partially apply a regular function to a single argument, it will correspond to the first parameter.</p>
<p><strong>Example: Gain Controller</strong></p>
<p>The following example demonstrates the use of partial application in the context of a gain controller:</p>
<div class="faust-run"><a href="img/src/exfaust26/exfaust26-svg/process.svg" target="_blank"><img src="img/src/exfaust26/exfaust26-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>gain = hslider(&quot;gain&quot;,0.5,0,1,0.01);
process = *(gain);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust26/exfaust26.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h3 id="time-expression"><code>'</code> Time Expression</h3>
<p><code>'</code> is used to express a one sample delay. For example:</p>
<div class="faust-run"><a href="img/src/exfaust27/exfaust27-svg/process.svg" target="_blank"><img src="img/src/exfaust27/exfaust27-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = _&#39;;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust27/exfaust27.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>will delay the incoming signal by one sample.</p>
<p><code>'</code> time expressions can be chained, so the output signal of this program:</p>
<div class="faust-run"><a href="img/src/exfaust28/exfaust28-svg/process.svg" target="_blank"><img src="img/src/exfaust28/exfaust28-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 1&#39;&#39;;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust28/exfaust28.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>will look like: <span class="math inline">\((0,0,1,1,1,1,\dots)\)</span>.</p>
<p>The <code>'</code> time expression is useful when designing filters, etc. and is equivalent to <code>@(1)</code> (see the <a href="#time-expression-1"><code>@</code> Time Expression</a>).</p>
<h3 id="time-expression-1"><code>@</code> Time Expression</h3>
<p><code>@</code> is used to express a delay with an arbitrary number of samples. For example:</p>
<div class="faust-run"><a href="img/src/exfaust29/exfaust29-svg/process.svg" target="_blank"><img src="img/src/exfaust29/exfaust29-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = @(10);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust29/exfaust29.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>will delay the incoming signal by 10 samples.</p>
<p>A delay expressed with <code>@</code> doesn’t have to be fixed but it must be positive and bounded. Therefore, the values of a slider are perfectly acceptable:</p>
<div class="faust-run"><a href="img/src/exfaust30/exfaust30-svg/process.svg" target="_blank"><img src="img/src/exfaust30/exfaust30-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = @(hslider(&quot;delay&quot;,0,0,100,1));</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust30/exfaust30.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p><code>@</code> only allows for the implementation of integer delay. Thus, various fractional delay algorithms are implemented in <a href="TODO">the Faust libraries</a>.</p>
<h3 id="environment-expressions">Environment Expressions</h3>
<p>Faust is a lexically scoped language. The meaning of a Faust expression is determined by its context of definition (its lexical environment) and not by its context of use.</p>
<p>To keep their original meaning, Faust expressions are bounded to their lexical environment in structures called <em>closures</em>. The following constructions allow to explicitly create and access such environments. Moreover they provide powerful means to reuse existing code and promote modular design.</p>
<p><img src="img/envexp.svg" class="mx-auto d-block"></p>
<h4 id="with-expression"><code>with</code> Expression</h4>
<p>The <code>with</code> construction allows to specify a <em>local environment</em>: a private list of definition that will be used to evaluate the left hand expression.</p>
<p>In the following example :</p>
<div class="faust-run"><a href="img/src/exfaust31/exfaust31-svg/process.svg" target="_blank"><img src="img/src/exfaust31/exfaust31-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>pink = f : + ~ g 
with {
  f(x) = 0.04957526213389*x - 0.06305581334498*x&#39; + 0.01483220320740*x&#39;&#39;;
    g(x) = 1.80116083982126*x - 0.80257737639225*x&#39;;
};
process = pink;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust31/exfaust31.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>the definitions of <code>f(x)</code> and <code>g(x)</code> are local to <code>f : + ~ g</code>.</p>
<p>Please note that <code>with</code> is left associative and has the lowest priority:</p>
<ul>
<li><code>f : + ~ g with {...}</code> is equivalent to <code>(f : + ~ g)  with {...}</code>.</li>
<li><code>f : + ~ g with {...} with {...}</code> is equivalent to <code>((f : + ~ g)  with {...})  with {...}</code>.</li>
</ul>
<h4 id="letrec-expression"><code>letrec</code> Expression</h4>
<p>The <code>letrec</code> construction is somehow similar to <a href="#with-expression"><code>with</code></a>, but for difference equations instead of regular definitions. It allows us to easily express groups of mutually recursive signals, for example:</p>
<p><span class="math display">\[
x(t) = y(t-1) + 10\\
y(t) = x(t-1) - 1
\]</span></p>
<p>as <code>E letrec { 'x = y+10; 'y = x-1; }</code></p>
<p>The syntax is defined by the following rules:</p>
<p><img src="img/letrec.svg" class="mx-auto d-block"></p>
<p>Note the special notation <code>'x = y + 10</code> instead of <code>x = y' + 10</code>. It makes syntactically impossible to write non-sensical equations like <code>x=x+1</code>.</p>
<p>Here is a more involved example. Let say we want to define an envelope generator with an attack and a release time (as a number of samples), and a gate signal. A possible definition could be:</p>
<div class="faust-run"><a href="img/src/exfaust32/exfaust32-svg/process.svg" target="_blank"><img src="img/src/exfaust32/exfaust32-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
ar(a,r,g) = v
letrec {
  &#39;n = (n+1) * (g&lt;=g&#39;);
  &#39;v = max(0, v + (n&lt;a)/a - (n&gt;=a)/r) * (g&lt;=g&#39;);
};
gate = button(&quot;gate&quot;);
process = os.osc(440)*ar(1000,1000,gate);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust32/exfaust32.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>With the following semantics for <span class="math inline">\(n(t)\)</span> and <span class="math inline">\(v(t)\)</span>:</p>
<p><span class="math display">\[
n(t) = (n(t-1)+1) * (g(t) &lt;= g(t-1))\\
v(t) = max(0, v(t-1) + (n(t-1)&lt;a(t))/a(t) - (n(t-1)&gt;=a(t))/r(t)) * (g(t)&lt;=g(t-1))
\]</span></p>
<h4 id="environment-expression"><code>environment</code> Expression</h4>
<p>The <code>environment</code> construction allows to create an explicit environment. It is like a <a href="#with-expression">`with’</a>, but without the left hand expression. It is a convenient way to group together related definitions, to isolate groups of definitions and to create a name space hierarchy.</p>
<p><img src="img/environment.svg" class="mx-auto d-block"></p>
<p>In the following example an <code>environment</code> construction is used to group together some constant definitions :</p>
<pre><code>constant = environment {
  pi = 3.14159;
  e = 2,718;
    ...
};</code></pre>
<p>The <a href="#access-expression"><code>.</code> construction</a> allows to access the definitions of an environment (see next section).</p>
<h4 id="access-expression">Access Expression</h4>
<p>Definitions inside an environment can be accessed using the <code>.</code> construction.</p>
<p><img src="img/access.svg" class="mx-auto d-block"></p>
<p>For example <code>constant.pi</code> refers to the definition of <code>pi</code> in the <code>constant</code> environment <a href="#environment-expression">defined above</a>.</p>
<p>Note that environments don’t have to be named. We could have written directly:</p>
<pre><code>environment{pi = 3.14159; e = 2,718;....}.pi</code></pre>
<h4 id="library-expression"><code>library</code> Expression</h4>
<p>The <code>library</code> construct allows to create an environment by reading the definitions from a file.</p>
<p><img src="img/library.svg" class="mx-auto d-block"></p>
<p>For example <code>library(&quot;filters.lib&quot;)</code> represents the <a href="#environment-expression">environment</a> obtained by reading the file <code>filters.lib</code>. It works like <a href="TODO"><code>import(&quot;miscfilter.lib&quot;)</code></a> but all the read definitions are stored in a new separate lexical environment. Individual definitions can be accessed as described in the previous paragraph. For example <code>library(&quot;filters.lib&quot;).lowpass</code> denotes the function <code>lowpass</code> as defined in the file <code>miscfilter.lib</code>.</p>
<p>To avoid name conflicts when importing libraries it is recommended to prefer <code>library</code> to <a href="TODO"><code>import</code></a>. So instead of :</p>
<pre><code>import(&quot;filters.lib&quot;);
  ...
...lowpass....
    ...
};</code></pre>
<p>the following will ensure an absence of conflicts :</p>
<pre><code>fl = library(&quot;filters.lib&quot;);
  ...
...fl.lowpass....
    ...
};</code></pre>
<p>In practice, that’s how the <a href="TODO"><code>stdfaust.lib</code></a> library works.</p>
<!-- TODO: import? -->
<!-- TODO: we should also show how this type of construction can be used to
define function with variables with a predefined value, etc. -->
<h4 id="component-expression"><code>component</code> Expression</h4>
<p>The <code>component</code> construction allows us to reuse a full Faust program (e.g., a <code>.dsp</code> file) as a simple expression.</p>
<p><img src="img/component.svg" class="mx-auto d-block"></p>
<p>For example <code>component(&quot;freeverb.dsp&quot;)</code> denotes the signal processor defined in file <code>freeverb.dsp</code>.</p>
<p>Components can be used within expressions like in:</p>
<pre><code>...component(&quot;karplus32.dsp&quot;) : component(&quot;freeverb.dsp&quot;)... </code></pre>
<p>Please note that <code>component(&quot;freeverb.dsp&quot;)</code> is equivalent to <code>library(&quot;freeverb.dsp&quot;).process</code>.</p>
<p><code>component</code> works well in tandem with <a href="#explicit-substitution">explicit substitution</a> (see next section).</p>
<h4 id="explicit-substitution">Explicit Substitution</h4>
<p>Explicit substitution can be used to customize a component or any expression with a lexical environment by replacing some of its internal definitions, without having to modify it.</p>
<p><img src="img/explicitsubst.svg" class="mx-auto d-block"></p>
<p>For example we can create a customized version of <code>component(&quot;freeverb.dsp&quot;)</code>, with a different definition of <code>foo(x)</code>, by writing:</p>
<pre><code>...component(&quot;freeverb.dsp&quot;)[foo(x) = ...;]...
};</code></pre>
<h3 id="foreign-expressions">Foreign Expressions</h3>
<p>Reference to external C <em>functions</em>, <em>variables</em> and <em>constants</em> can be introduced using the <em>foreign function</em> mechanism.</p>
<p><img src="img/foreignexp.svg" class="mx-auto d-block"></p>
<!-- TODO something needs to be said about the fact that this is a C++ thing -->
<h4 id="ffunction"><code>ffunction</code></h4>
<p>An external C function is declared by indicating its name and signature as well as the required include file. The file <code>maths.lib</code> of the Faust distribution contains several foreign function definitions, for example <a href="TODO">the inverse hyperbolic sine function <code>asinh</code></a>:</p>
<pre><code>asinh = ffunction(float asinh (float), &lt;math.h&gt;, &quot;&quot;);</code></pre>
<!-- TODO: what happens for other languages than C? -->
<p>Foreign functions with input parameters are considered pure math functions. They are therefore considered free of side effects and called only when their parameters change (that is at the rate of the fastest parameter).</p>
<p>Exceptions are functions with no input parameters. A typical example is the C <code>rand()</code> function. In this case, the compiler generates code to call the function at sample rate.</p>
<h4 id="signature">Signature</h4>
<p>The signature part (<code>float asinh (float)</code> in the example presented in <a href="#ffunction">the previous section</a>) describes the prototype of the C function: return type, function name, and list of parameter types. Because the name of the foreign function can possibly depend on the floating point precision in use (float, double and quad), it is possible to give a different function name for each floating point precision using a signature with up to three function names.</p>
<p><img src="img/signature.svg" class="mx-auto d-block"></p>
<p>For example in the declaration:</p>
<pre><code>asinh = ffunction(float asinhf|asinh|asinhl (float), &lt;math.h&gt;, &quot;&quot;);</code></pre>
<p>the signature <code>float asinhf|asinh|asinhl (float)</code> indicates to use the function name <code>asinhf</code> in single precision, <code>asinh</code> in double precision and <code>asinhl</code> in long double (quad) precision.</p>
<h4 id="types">Types</h4>
<p>Only numerical functions involving simple <code>int</code> and <code>float</code> parameters are allowed currently in Faust. No vectors, tables or data structures can be passed as parameters or returned.</p>
<h4 id="variables-and-constants">Variables and Constants</h4>
<p>External variables and constants can also be declared with a similar syntax. In the same <code>maths.lib</code> file, the definition of the sampling rate constant <a href="TODO"><code>SR</code></a> and the definition of the block-size variable <a href="TODO"><code>BS</code></a> can be found:</p>
<pre><code>SR = min(192000.0,max(1.0,fconstant(int fSamplingFreq, &lt;math.h&gt;)));
BS = fvariable(int count, &lt;math.h&gt;);</code></pre>
<p>Foreign constants are not supposed to vary. Therefore expressions involving only foreign constants are only computed once, during the initialization period.</p>
<p>Variable are considered to vary at block speed. This means that expressions depending of external variables are computed every block.</p>
<h4 id="file-include">File Include</h4>
<p>In declaring foreign functions one has also to specify the include file. It allows the Faust compiler to add the corresponding <code>#include</code> in the generated code.</p>
<p><img src="img/includefile.svg" class="mx-auto d-block"></p>
<h4 id="library-file">Library File</h4>
<p>In declaring foreign functions one can possibly specify the library where the actual code is located. It allows the Faust compiler to (possibly) automatically link the library. Note that this feature is only used with the <a href="TODO">LLVM backend in ‘libfaust’ dynamic library model</a>.</p>
<!-- TODO I feel like more could be said here -->
<h3 id="applications-and-abstractions">Applications and Abstractions</h3>
<p><em>Abstractions</em> and <em>applications</em> are fundamental programming constructions directly inspired by Lambda-Calculus. These constructions provide powerful ways to describe and transform block-diagrams algorithmically.</p>
<p><img src="img/abstraction.svg" class="mx-auto d-block"></p>
<h4 id="abstractions">Abstractions</h4>
<p>Abstractions correspond to functions definitions and allow to generalize a block-diagram by <code>making variable</code> some of its parts.</p>
<p>Let’s say we want to transform a stereo reverb, <a href="TODO"><code>dm.zita_light</code></a> for instance, into a mono effect. The following expression can be written (see the sections on <a href="#split-composition">Split Composition</a> and <a href="#merge-composition">Merge Composition</a>):</p>
<pre><code>_ &lt;: dm.zita_light :&gt; _ </code></pre>
<p>The incoming mono signal is split to feed the two input channels of the reverb, while the two output channels of the reverb are mixed together to produce the resulting mono output.</p>
<p>Imagine now that we are interested in transforming other stereo effects. We could generalize this principle by making <code>zita_light</code> a variable:</p>
<pre><code>\(zita_light).(_ &lt;: zita_light :&gt; _)</code></pre>
<p>The resulting abstraction can then be applied to transform other effects. Note that if <code>zita_light</code> is a perfectly valid variable name, a more neutral name would probably be easier to read like:</p>
<pre><code>\(fx).(_ &lt;: fx :&gt; _)</code></pre>
<p>A name can be given to the abstraction and in turn use it on <code>dm.zita_light</code>:</p>
<div class="faust-run"><a href="img/src/exfaust33/exfaust33-svg/process.svg" target="_blank"><img src="img/src/exfaust33/exfaust33-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
mono = \(fx).(_ &lt;: fx :&gt; _);
process = mono(dm.zita_light);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust33/exfaust33.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Or even use a more traditional, but equivalent, notation:</p>
<pre><code>mono(fx) = _ &lt;: fx :&gt; _;</code></pre>
<h4 id="applications">Applications</h4>
<p>Applications correspond to function calls and allow to replace the variable parts of an abstraction with the specified arguments.</p>
<p><img src="img/application.svg" class="mx-auto d-block"></p>
<p>For example, the abstraction described in <a href="#abstractions">the previous section</a> can be used to transform a stereo reverb:</p>
<pre><code>mono(dm.zita_light)</code></pre>
<p>The compiler will start by replacing <code>mono</code> by its definition:</p>
<pre><code>\(fx).(_ &lt;: fx :&gt; _)(dm.zita_light)</code></pre>
<blockquote>
<p>Replacing the <em>variable part</em> with the argument is called beta-reduction in Lambda-Calculus</p>
</blockquote>
<p>Whenever the Faust compiler find an application of an abstraction it replaces the <em>variable part</em> with the argument. The resulting expression is as expected:</p>
<pre><code>(_ &lt;: dm.zita_light :&gt; _)</code></pre>
<h4 id="pattern-matching">Pattern Matching</h4>
<p>Pattern matching rules provide an effective way to analyze and transform block-diagrams algorithmically.</p>
<p><img src="img/patternabstraction.svg" class="mx-auto d-block"></p>
<p>For example <code>case{ (x:y) =&gt; y:x; (x) =&gt; x; }</code> contains two rules. The first one will match a sequential expression and invert the two part. The second one will match all remaining expressions and leave it untouched. Therefore the application:</p>
<pre><code>case{(x:y) =&gt; y:x; (x) =&gt; x;}(reverb : harmonizer)</code></pre>
<p>will produce:</p>
<pre><code>harmonizer : freeverb</code></pre>
<p>Please note that patterns are evaluated before the pattern matching operation. Therefore only variables that appear free in the pattern are binding variables during pattern matching.</p>
<!-- TODO: I think we need a better example here: that's a bit weak. We should
wait to see if it appears somewhere else... Also, I think there are some stuff
missing here. -->
<h2 id="primitives">Primitives</h2>
<p>The primitive signal processing operations represent the built-in functionalities of Faust, that is the atomic operations on signals provided by the language. All these primitives denote <em>signal processors</em>, in other words, functions transforming <em>input signals</em> into <em>output signals</em>.</p>
<!-- TODO: Diagram was removed here since everything is listed below: may be
we should put a table summarizing everything. -->
<h3 id="numbers">Numbers</h3>
<p>Faust considers two types of numbers: <em>integers</em> and <em>floats</em>. Integers are implemented as 32-bits integers, and floats are implemented either with a simple, double, or extended precision depending of the compiler options. Floats are available in decimal or scientific notation.</p>
<p><img src="img/numbers.svg" class="mx-auto d-block"></p>
<p>Like any other Faust expression, numbers are signal processors. For example the number 0.95 is a signal processor of type <span class="math inline">\(\mathbb{S}^{0}\rightarrow\mathbb{S}^{1}\)</span> that transforms an empty tuple of signals <span class="math inline">\(()\)</span> into a 1-tuple of signals <span class="math inline">\((y)\)</span> such that <span class="math inline">\(\forall t\in\mathbb{N}, y(t)=0.95\)</span>.</p>
<h3 id="waveform-primitive"><code>waveform</code> Primitive</h3>
<p>The waveform primitive was designed to facilitate the use of <a href="#rdtable"><code>rdtable</code></a> (read table). It allows us to specify a fixed periodic signal as a list of samples.</p>
<p><code>waveform</code> has two outputs:</p>
<ul>
<li>a constant and indicating the size (as a number of samples) of the period,</li>
<li>the periodic signal itself.</li>
</ul>
<p><img src="img/waveform.svg" class="mx-auto d-block"></p>
<p>For example <code>waveform{0,1,2,3}</code> produces two outputs: the constant signal 4 and the periodic signal <span class="math inline">\((0,1,2,3,0,1,2,3,0,1,\dots)\)</span>.</p>
<p>In the following example:</p>
<div class="faust-run"><a href="img/src/exfaust34/exfaust34-svg/process.svg" target="_blank"><img src="img/src/exfaust34/exfaust34-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
triangleWave = waveform{0,0.5,1,0.5,0,-0.5,-1,-.5};
triangleOsc(f) = triangleWave,int(os.phasor(8,f)) : rdtable;
f = hslider(&quot;freq&quot;,440,50,2000,0.01);
process = triangleOsc(f);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust34/exfaust34.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p><code>waveform</code> is used to define a triangle waveform (in its most primitive form), which is then used with a <a href="TODO"><code>rdtable</code></a> controlled by a phasor to implement a triangle wave oscillator. Note that the quality of this oscillator is very low because of the low resolution of the triangle waveform.</p>
<h3 id="soundfile-primitive"><code>soundfile</code> Primitive</h3>
<p>The <code>soundfile(&quot;label[url:path]&quot;, n)</code> primitive allows for the access of externally defined sound file/resource. <code>soundfile</code> has one input (the read index in the sound), three fixed outputs:</p>
<ul>
<li>the audio wave length in frames</li>
<li>the audio wave nominal sample rate</li>
<li>the audio wave number of channels</li>
</ul>
<p>and several more outputs for the audio channels themselves.</p>
<p>If more outputs than the actual number of channels in the sound file are used, the audio channels will be automatically duplicated up to the wanted number of outputs (so for instance, if a stereo file is used with four output channels, the same group of two channels will be duplicated).</p>
<p>If the sound file cannot be loaded for whatever reason, a default sound with one channel, a length of 1024 frames and null outputs (with samples of value 0) will be used. Note also that sound files are entirely loaded in memory by the architecture file.</p>
<p>Architecture files are responsible to load the actual soundfile. The <code>SoundUI</code> C++ class located in the <code>faust/gui/SoundUI.h</code> file in the <a href="https://github.com/grame-cncm/faust">Faust repository</a> implements the <code>void  addSoundfile(label, path, sf_zone)</code> method, which loads the actual soundfiles using the <code>libsndfile</code> library, and set up the <code>sf_zone</code> sound memory pointers. If <em>label</em> is used without any <em>url</em> metadata, it will be considered as the soundfile pathname.</p>
<p>Note that a special architecture file can well decide to access and use sound resources created by another means (that is, not directly loaded from a sound file). For instance a mapping between labels and sound resources defined in memory could be used, with some additional code in charge of actually setting up all sound memory pointers when <code>void  addSoundfile(label, path, sf_zone)</code> is called by the <code>buidUserInterface</code> mechanism.</p>
<!-- TODO: we need some working example here -->
<h3 id="c-equivalent-primitives">C-Equivalent Primitives</h3>
<p>Most Faust primitives are analogous to their C counterpart but adapted to signal processing. For example <code>+</code> is a function of type <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span> that transforms a pair of signals <span class="math inline">\((x_1,x_2)\)</span> into a 1-tuple of signals <span class="math inline">\((y)\)</span> such that <span class="math inline">\(\forall t\in\mathbb{N}, y(t)=x_{1}(t)+x_{2}(t)\)</span>. <code>+</code> can be used to very simply implement a mixer:</p>
<div class="faust-run"><a href="img/src/exfaust35/exfaust35-svg/process.svg" target="_blank"><img src="img/src/exfaust35/exfaust35-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = +;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust35/exfaust35.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Note that this is equivalent to (see <a href="#identity-function">Identity Function</a>):</p>
<div class="faust-run"><a href="img/src/exfaust36/exfaust36-svg/process.svg" target="_blank"><img src="img/src/exfaust36/exfaust36-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = _+_;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust36/exfaust36.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>The function <code>-</code> has type <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span> and transforms a pair of signals <span class="math inline">\((x_1,x_2)\)</span> into a 1-tuple of signals <span class="math inline">\((y)\)</span> such that <span class="math inline">\(\forall t\in\mathbb{N}, y(t)=x_{1}(t)-x_{2}(t)\)</span>.</p>
<p><strong>Be aware that</strong> the unary <code>-</code> only exists in a limited form. It can be used with numbers: <code>-0.5</code> and variables: <code>-myvar</code>, but not with expressions surrounded by parenthesis, because in this case it represents a partial application. For instance, <code>-(a*b)</code> is a partial application. It is syntactic sugar for <code>_,(a*b) : -</code>. If you want to negate a complex term in parenthesis, you’ll have to use <code>0 - (a*b)</code> instead.</p>
<!-- TODO: need to make sure that the identify function and the exclamation
are properly documented/mentioned somewhere and demonstrated -->
<h4 id="integer-number">Integer Number</h4>
<p>Integer numbers are of type <span class="math inline">\(\mathbb{S}^{0}\rightarrow\mathbb{S}^{1}\)</span> in Faust and can be described mathematically as <span class="math inline">\(y(t)=n\)</span>.</p>
<p><strong>Example: DC Offset of 1</strong></p>
<div class="faust-run"><a href="img/src/exfaust37/exfaust37-svg/process.svg" target="_blank"><img src="img/src/exfaust37/exfaust37-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 1;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust37/exfaust37.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="floating-point-number">Floating Point Number</h4>
<p>Floating point numbers are of type <span class="math inline">\(\mathbb{S}^{0}\rightarrow\mathbb{S}^{1}\)</span> in Faust and can be described as <span class="math inline">\(y(t)=n.m\)</span>.</p>
<p><strong>Example: DC Offset of 0.5</strong></p>
<div class="faust-run"><a href="img/src/exfaust38/exfaust38-svg/process.svg" target="_blank"><img src="img/src/exfaust38/exfaust38-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 0.5;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust38/exfaust38.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="identity-function">Identity Function</h4>
<p>The identity function is expressed in Faust with the <code>_</code> primitive.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x(t)\)</span></li>
</ul>
<p><strong>Example: a Signal Passing Through</strong></p>
<p>In the following example, the <code>_</code> primitive is used to connect the single audio input of a Faust program to its output:</p>
<div class="faust-run"><a href="img/src/exfaust39/exfaust39-svg/process.svg" target="_blank"><img src="img/src/exfaust39/exfaust39-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = _;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust39/exfaust39.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="cut-primitive">Cut Primitive</h4>
<p>The cut primitive is expressed in Faust with <code>!</code>. It can be used to “stop”/terminate a signal.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{0}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(\forall x\in\mathbb{S},(x)\rightarrow ()\)</span></li>
</ul>
<p><strong>Example: Stopping a Signal</strong></p>
<p>In the following example, the <code>!</code> primitive is used to stop one of two parallel signals:</p>
<div class="faust-run"><a href="img/src/exfaust40/exfaust40-svg/process.svg" target="_blank"><img src="img/src/exfaust40/exfaust40-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 1,2 : !,_;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust40/exfaust40.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="int-primitive"><code>int</code> Primitive</h4>
<p>The <code>int</code> primitive can be used to force the cast of a signal to int. It is of type <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span> and can be described mathematically as <span class="math inline">\(y(t)=(int)x(t)\)</span>. This primitive is useful when declaring indices to read in a table, etc.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=(int)x(t)\)</span></li>
</ul>
<p><strong>Example: Simple Cast</strong></p>
<div class="faust-run"><a href="img/src/exfaust41/exfaust41-svg/process.svg" target="_blank"><img src="img/src/exfaust41/exfaust41-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 1.5 : int;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust41/exfaust41.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="float-primitive"><code>float</code> Primitive</h4>
<p>The <code>float</code> primitive can be used to force the cast of a signal to float.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=(float)x(t)\)</span></li>
</ul>
<p><strong>Example: Simple Cast</strong></p>
<div class="faust-run"><a href="img/src/exfaust42/exfaust42-svg/process.svg" target="_blank"><img src="img/src/exfaust42/exfaust42-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 1.5 : float;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust42/exfaust42.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="add-primitive">Add Primitive</h4>
<p>The <code>+</code> primitive can be used to add two signals together.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x_{1}(t)+x_{2}(t)\)</span></li>
</ul>
<p><strong>Example: Simple Mixer</strong></p>
<div class="faust-run"><a href="img/src/exfaust43/exfaust43-svg/process.svg" target="_blank"><img src="img/src/exfaust43/exfaust43-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = +;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust43/exfaust43.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="subtract-primitive">Subtract Primitive</h4>
<p>The <code>-</code> primitive can be used to subtract two signals.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x_{1}(t)-x_{2}(t)\)</span></li>
</ul>
<p><strong>Example: Subtracting Two Input Signals</strong></p>
<div class="faust-run"><a href="img/src/exfaust44/exfaust44-svg/process.svg" target="_blank"><img src="img/src/exfaust44/exfaust44-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = -;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust44/exfaust44.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="multiply-primitive">Multiply Primitive</h4>
<p>The <code>*</code> primitive can be used to multiply two signals.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x_{1}(t)*x_{2}(t)\)</span></li>
</ul>
<p><strong>Example: Multiplying a Signal by 0.5</strong></p>
<div class="faust-run"><a href="img/src/exfaust45/exfaust45-svg/process.svg" target="_blank"><img src="img/src/exfaust45/exfaust45-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = *(0.5);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust45/exfaust45.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="divide-primitive">Divide Primitive</h4>
<p>The <code>/</code> primitive can be used to divide two signals.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x_{1}(t)/{x_{2}(t)}\)</span></li>
</ul>
<p><strong>Example: Dividing a Signal by 2</strong></p>
<div class="faust-run"><a href="img/src/exfaust46/exfaust46-svg/process.svg" target="_blank"><img src="img/src/exfaust46/exfaust46-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = ^(2);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust46/exfaust46.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="power-primitive">Power Primitive</h4>
<p>The <code>^</code> primitive can be used to raise to the power of <code>N</code> a signal.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x_{1}(t)^{x_{2}(t)}\)</span></li>
</ul>
<p><strong>Example: Power of Two of a Signal</strong></p>
<div class="faust-run"><a href="img/src/exfaust47/exfaust47-svg/process.svg" target="_blank"><img src="img/src/exfaust47/exfaust47-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = ^(2);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust47/exfaust47.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="modulo-primitive">Modulo Primitive</h4>
<p>The <code>%</code> primitive can be used to take the modulo of a signal.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x_{1}(t)\%{x_{2}(t)}\)</span></li>
</ul>
<p><strong>Example: Phaser</strong></p>
<p>The following example uses a counter and the <code>%</code> primitive to implement a basic phaser:</p>
<div class="faust-run"><a href="img/src/exfaust48/exfaust48-svg/process.svg" target="_blank"><img src="img/src/exfaust48/exfaust48-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = _~+(1) : -(1) : %(10);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust48/exfaust48.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>will output a signal: <code>(0,1,2,3,4,5,6,7,8,9,0,1,2,3,4)</code></p>
<h4 id="and-primitive">AND Primitive</h4>
<p>Logical AND can be expressed in Faust with the <code>&amp;</code> primitive.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x_{1}(t)\&amp;{x_{2}(t)}\)</span></li>
</ul>
<p><strong>Example</strong></p>
<p>TODO</p>
<h4 id="or-primitive">OR Primitive</h4>
<p>Logical OR can be expressed in Faust with the <code>|</code> primitive.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x_{1}(t)|{x_{2}(t)}\)</span></li>
</ul>
<p><strong>Example</strong></p>
<p>The following example will output 1 if the incoming signal is smaller than 0.5 or greater than 0.7 and 0 otherwise. Note that the result of this operation could be multiplied to another signal to create a condition.</p>
<div class="faust-run"><a href="img/src/exfaust49/exfaust49-svg/process.svg" target="_blank"><img src="img/src/exfaust49/exfaust49-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = _ &lt;: &lt;(0.5) | &gt;(0.7);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust49/exfaust49.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="xor-primitive">XOR Primitive</h4>
<p>Logical XOR can be expressed in Faust with the <code>xor</code> primitive.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x_{1}(t)\land {x_{2}(t)}\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust50/exfaust50-svg/process.svg" target="_blank"><img src="img/src/exfaust50/exfaust50-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = _ &lt;: &lt;(0.5) xor &gt;(0.7);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust50/exfaust50.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="left-shift-primitive">Left Shift Primitive</h4>
<p>Left shift can be expressed in Faust with the <code>&lt;&lt;</code> primitive.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x_{1}(t) &lt;&lt; {x_{2}(t)}\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust51/exfaust51-svg/process.svg" target="_blank"><img src="img/src/exfaust51/exfaust51-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 1 &lt;&lt; 2 ;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust51/exfaust51.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="right-shift-primitive">Right Shift Primitive</h4>
<p>Right shift can be expressed in Faust with the <code>&gt;&gt;</code> primitive.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x_{1}(t) &gt;&gt; {x_{2}(t)}\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust52/exfaust52-svg/process.svg" target="_blank"><img src="img/src/exfaust52/exfaust52-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 1 &gt;&gt; 2 ;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust52/exfaust52.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="smaller-than-primitive">Smaller Than Primitive</h4>
<p>The smaller than comparison can be expressed in Faust with the <code>&lt;</code> primitive.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x_{1}(t) &lt; {x_{2}(t)}\)</span></li>
</ul>
<p><strong>Example</strong></p>
<p>The following code will output 1 if the input signal is smaller than 0.5 and 0 otherwise.</p>
<div class="faust-run"><a href="img/src/exfaust53/exfaust53-svg/process.svg" target="_blank"><img src="img/src/exfaust53/exfaust53-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = &lt;(0.5) ;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust53/exfaust53.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="smaller-or-equal-than-primitive">Smaller or Equal Than Primitive</h4>
<p>The smaller or equal than comparison can be expressed in Faust with the <code>&lt;=</code> primitive.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x_{1}(t) &lt;= {x_{2}(t)}\)</span></li>
</ul>
<p><strong>Example</strong></p>
<p>The following code will output 1 if the input signal is smaller or equal than 0.5 and 0 otherwise.</p>
<div class="faust-run"><a href="img/src/exfaust54/exfaust54-svg/process.svg" target="_blank"><img src="img/src/exfaust54/exfaust54-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = &lt;=(0.5) ;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust54/exfaust54.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="greater-than-primitive">Greater Than Primitive</h4>
<p>The greater than comparison can be expressed in Faust with the <code>&gt;</code> primitive.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x_{1}(t) &gt; {x_{2}(t)}\)</span></li>
</ul>
<p><strong>Example</strong></p>
<p>The following code will output 1 if the input signal is greater than 0.5 and 0 otherwise.</p>
<div class="faust-run"><a href="img/src/exfaust55/exfaust55-svg/process.svg" target="_blank"><img src="img/src/exfaust55/exfaust55-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = &gt;(0.5) ;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust55/exfaust55.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="greater-or-equal-than-primitive">Greater or Equal Than Primitive</h4>
<p>The greater or equal than comparison can be expressed in Faust with the <code>&gt;=</code> primitive.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x_{1}(t) &gt;= {x_{2}(t)}\)</span></li>
</ul>
<p><strong>Example</strong></p>
<p>The following code will output 1 if the input signal is greater or equal than 0.5 and 0 otherwise.</p>
<div class="faust-run"><a href="img/src/exfaust56/exfaust56-svg/process.svg" target="_blank"><img src="img/src/exfaust56/exfaust56-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = &gt;=(0.5) ;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust56/exfaust56.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="equal-to-primitive">Equal to Primitive</h4>
<p>The equal to comparison can be expressed in Faust with the <code>==</code> primitive.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x_{1}(t) == {x_{2}(t)}\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust57/exfaust57-svg/process.svg" target="_blank"><img src="img/src/exfaust57/exfaust57-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 0 == 1;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust57/exfaust57.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="different-than-primitive">Different Than Primitive</h4>
<p>The different than comparison can be expressed in Faust with the <code>!=</code> primitive.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x_{1}(t) != {x_{2}(t)}\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust58/exfaust58-svg/process.svg" target="_blank"><img src="img/src/exfaust58/exfaust58-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 0 != 1;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust58/exfaust58.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h3 id="math.h-equivalent-primitives"><code>math.h</code>-Equivalent Primitives</h3>
<p>Most of the C <code>math.h</code> functions are also built-in as primitives (the others are defined as external functions in file <code>math.lib</code>).</p>
<h4 id="acos-primitive"><code>acos</code> Primitive</h4>
<p>Arc cosine can be expressed as <code>acos</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{acosf}(x(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust59/exfaust59-svg/process.svg" target="_blank"><img src="img/src/exfaust59/exfaust59-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 0.1 : acos;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust59/exfaust59.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="asin-primitive"><code>asin</code> Primitive</h4>
<p>Arc sine can be expressed as <code>asin</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{asinf}(x(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust60/exfaust60-svg/process.svg" target="_blank"><img src="img/src/exfaust60/exfaust60-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 0.1 : asin;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust60/exfaust60.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="atan-primitive"><code>atan</code> Primitive</h4>
<p>Arc tangent can be expressed as <code>atan</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{atanf}(x(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust61/exfaust61-svg/process.svg" target="_blank"><img src="img/src/exfaust61/exfaust61-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 0.1 : atan;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust61/exfaust61.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="atan2-primitive"><code>atan2</code> Primitive</h4>
<p>The arc tangent of 2 signals can be expressed as <code>atan2</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{atan2f}(x_{1}(t), x_{2}(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust62/exfaust62-svg/process.svg" target="_blank"><img src="img/src/exfaust62/exfaust62-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 0.1,-0.1 : atan2;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust62/exfaust62.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="cos-primitive"><code>cos</code> Primitive</h4>
<p>Cosine can be expressed as <code>cos</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{cosf}(x(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust63/exfaust63-svg/process.svg" target="_blank"><img src="img/src/exfaust63/exfaust63-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 0.1 : cos;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust63/exfaust63.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="sin-primitive"><code>sin</code> Primitive</h4>
<p>Sine can be expressed as <code>sin</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{sinf}(x(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust64/exfaust64-svg/process.svg" target="_blank"><img src="img/src/exfaust64/exfaust64-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 0.1 : sin;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust64/exfaust64.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="tan-primitive"><code>tan</code> Primitive</h4>
<p>Tangent can be expressed as <code>tan</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{tanf}(x(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust65/exfaust65-svg/process.svg" target="_blank"><img src="img/src/exfaust65/exfaust65-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 0.1 : tan;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust65/exfaust65.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="exp-primitive"><code>exp</code> Primitive</h4>
<p>Base-e exponential can be expressed as <code>exp</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{expf}(x(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust66/exfaust66-svg/process.svg" target="_blank"><img src="img/src/exfaust66/exfaust66-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 0.1 : exp;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust66/exfaust66.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="log-primitive"><code>log</code> Primitive</h4>
<p>Base-e logarithm can be expressed as <code>log</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{logf}(x(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust67/exfaust67-svg/process.svg" target="_blank"><img src="img/src/exfaust67/exfaust67-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 0.1 : log;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust67/exfaust67.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="log10-primitive"><code>log10</code> Primitive</h4>
<p>Base-10 logarithm can be expressed as <code>log10</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{log10}(x(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust68/exfaust68-svg/process.svg" target="_blank"><img src="img/src/exfaust68/exfaust68-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 0.1 : log10;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust68/exfaust68.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="pow-primitive"><code>pow</code> Primitive</h4>
<p>Power can be expressed as <code>pow</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{powf}(x_{1}(t),x_{2}(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust69/exfaust69-svg/process.svg" target="_blank"><img src="img/src/exfaust69/exfaust69-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 2,4 : pow;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust69/exfaust69.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="sqrt-primitive"><code>sqrt</code> Primitive</h4>
<p>Square root can be expressed as <code>sqrt</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{sqrtf}(x(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust70/exfaust70-svg/process.svg" target="_blank"><img src="img/src/exfaust70/exfaust70-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 4 : sqrt;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust70/exfaust70.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="abs-primitive"><code>abs</code> Primitive</h4>
<p>Absolute value can be expressed as <code>abs</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{abs}(x(t))\)</span> (int) or<br />
<span class="math inline">\(y(t)=\mathrm{fabsf}(x(t))\)</span> (float)</li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust71/exfaust71-svg/process.svg" target="_blank"><img src="img/src/exfaust71/exfaust71-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = -0.5 : abs;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust71/exfaust71.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="min-primitive"><code>min</code> Primitive</h4>
<p><em>Minimum</em> can be expressed as <code>min</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{min}(x_{1}(t),x_{2}(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust72/exfaust72-svg/process.svg" target="_blank"><img src="img/src/exfaust72/exfaust72-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = -0.5,0.2 : min;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust72/exfaust72.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="max-primitive"><code>max</code> Primitive</h4>
<p><em>Maximum</em> can be expressed as <code>max</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{max}(x_{1}(t),x_{2}(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust73/exfaust73-svg/process.svg" target="_blank"><img src="img/src/exfaust73/exfaust73-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = -0.5,0.2 : max;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust73/exfaust73.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="fmod-primitive"><code>fmod</code> Primitive</h4>
<p>Float modulo can be expressed as <code>fmod</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{fmodf}(x_{1}(t),x_{2}(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust74/exfaust74-svg/process.svg" target="_blank"><img src="img/src/exfaust74/exfaust74-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 5.3,2 : fmod;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust74/exfaust74.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="remainder-primitive"><code>remainder</code> Primitive</h4>
<p>Float remainder can be expressed as <code>remainder</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{remainderf}(x_{1}(t),x_{2}(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust75/exfaust75-svg/process.svg" target="_blank"><img src="img/src/exfaust75/exfaust75-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 5.3,2 : remainder;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust75/exfaust75.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="floor-primitive"><code>floor</code> Primitive</h4>
<p>Largest int can be expressed as <code>floor</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(\leq\)</span>: <span class="math inline">\(y(t)=\mathrm{floorf}(x(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust76/exfaust76-svg/process.svg" target="_blank"><img src="img/src/exfaust76/exfaust76-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 3.6 : floor;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust76/exfaust76.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="ceil-primitive"><code>ceil</code> Primitive</h4>
<p>Smallest int can be expressed as <code>ceil</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(\geq\)</span>: <span class="math inline">\(y(t)=\mathrm{ceilf}(x(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust77/exfaust77-svg/process.svg" target="_blank"><img src="img/src/exfaust77/exfaust77-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 3.6 : ceil;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust77/exfaust77.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="rint-primitive"><code>rint</code> Primitive</h4>
<p>Closest int can be expressed as <code>rint</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{rintf}(x(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust78/exfaust78-svg/process.svg" target="_blank"><img src="img/src/exfaust78/exfaust78-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 3.6 : rint;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust78/exfaust78.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<!-- TODO: say something about the fact that things are expressed in core
syntax -->
<h3 id="delay-primitives-and-modifiers">Delay Primitives and Modifiers</h3>
<p>Faust hosts various modifiers and primitives to define one sample or integer delay of arbitrary length. They are presented in this section.</p>
<h4 id="mem-primitive"><code>mem</code> Primitive</h4>
<p>A 1 sample delay can be expressed as <code>mem</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t+1)=x(t),y(0)=0\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust79/exfaust79-svg/process.svg" target="_blank"><img src="img/src/exfaust79/exfaust79-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = mem;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust79/exfaust79.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Note that this is equivalent to <code>process = _'</code> (see <a href="#modifier"><code>'</code> Modifier</a>) and <code>process = @(1)</code> (see <a href="TODO"><code>@</code> Primitive</a>)</p>
<h4 id="modifier"><code>'</code> Modifier</h4>
<p><code>'</code> can be used to apply a 1 sample delay to a signal in Faust. It can be seen as syntactic sugar to the <a href="#mem-primitive"><code>mem</code> primitive</a>. <code>'</code> is very convenient when implementing filters and can help significantly decrease the size of the Faust code.</p>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust80/exfaust80-svg/process.svg" target="_blank"><img src="img/src/exfaust80/exfaust80-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = _&#39;;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust80/exfaust80.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="primitive"><code>@</code> Primitive</h4>
<p>An integer delay of <code>N</code> samples can be expressed as <code>@(N)</code> in Faust. Note that <code>N</code> can be dynamic but that its range must be bounded. This can be done by using a UI primitive (see example below) allowing for the definition of a range such as <a href="TODO"><code>hslider</code></a>, <a href="TODO"><code>vslider</code></a>, or <a href="TODO"><code>nentry</code></a>.</p>
<p>Note that floating point delay is also available in Faust by the mean of <a href="TODO">various fractional delay implementations</a> available in the Faust standard libraries.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t+x_{2}(t))=x_{1}(t), y(t&lt;x_{2}(t))=0\)</span></li>
</ul>
<p><strong>Usage</strong></p>
<pre><code>_ : @(N) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>N</code>: the length of the delay as a number of samples</li>
</ul>
<p><strong>Example: Static N Samples Delay</strong></p>
<div class="faust-run"><a href="img/src/exfaust81/exfaust81-svg/process.svg" target="_blank"><img src="img/src/exfaust81/exfaust81-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>N = 10;
process = @(N);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust81/exfaust81.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p><strong>Example: Dynamic N Samples Delay</strong></p>
<div class="faust-run"><a href="img/src/exfaust82/exfaust82-svg/process.svg" target="_blank"><img src="img/src/exfaust82/exfaust82-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>N = hslider(&quot;N&quot;,10,1,10,1);
process = @(N);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust82/exfaust82.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h3 id="table-primitives">Table Primitives</h3>
<p>TODO</p>
<h4 id="rtable-primitive"><code>rtable</code> Primitive</h4>
<p>The <code>rtable</code> primitive can be used to read through a read-only (pre-defined before compilation) table. The table can either be implemented using a function controlled by a timer (such as <a href="TODO"><code>ba.time</code></a>) as demonstrated in the first example, or by using the <code>waveform</code> primitive (as shown in the second example). The idea is that the table is parsed during the initialization step and before audio computation begins.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{3}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=T[r(t)]\)</span></li>
</ul>
<p><strong>Usage</strong></p>
<pre><code>rtable(n,s,r) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: the table size</li>
<li><code>s</code>: the table</li>
<li><code>r</code>: the read index (an <code>int</code> between 0 and <code>n</code>)</li>
</ul>
<p><strong>Example: Basic Triangle Wave Oscillator Using the <code>waveform</code> Primitive</strong></p>
<p>In this example, a basic (and dirty) triangle wave-table is defined using the <a href="#waveform-primitive"><code>waveform</code></a>. It is then used with the <code>rdtable</code> primitive and a phasor to implement a triangle wave oscillator. Note that the output of</p>
<div class="faust-run"><a href="img/src/exfaust83/exfaust83-svg/process.svg" target="_blank"><img src="img/src/exfaust83/exfaust83-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
triangleWave = waveform{0,0.5,1,0.5,0,-0.5,-1,-.5};
triangleOsc(f) = triangleWave,int(os.phasor(8,f)) : rdtable;
f = hslider(&quot;freq&quot;,440,50,2000,0.01);
process = triangleOsc(f);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust83/exfaust83.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p><strong>Example: Basic Triangle Wave Oscillator Using the <code>waveform</code> Primitive</strong></p>
<p>In this example, a sine table is implemented using the <a href="#sin-primitive"><code>sin</code> primitive</a> and a timer (<a href="TODO"><code>ba.time</code></a>). The timer parses the <code>sin</code> function during the initialization step of the Faust program. It is then used with <code>rdtable</code> to implement a sine wave oscillator.</p>
<div class="faust-run"><a href="img/src/exfaust84/exfaust84-svg/process.svg" target="_blank"><img src="img/src/exfaust84/exfaust84-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
sineWave(tablesize) = float(ba.time)*(2.0*ma.PI)/float(tablesize) : sin;
tableSize = 1 &lt;&lt; 16;
triangleOsc(f) = tableSize,sineWave(tableSize),int(os.phasor(tableSize,f)) : rdtable;
f = hslider(&quot;freq&quot;,440,50,2000,0.01);
process = triangleOsc(f);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust84/exfaust84.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="rwtable-primitive"><code>rwtable</code> Primitive</h4>
<p>The <code>rwtable</code> primitive can be used to implement a read/write table. It takes an audio input that can be written in the table using a <em>record index</em> (i.e., <code>w</code> below) and read using a read index (i.e., <code>r</code> below).</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{5}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(T[w(t)]=c(t); y(t)=T[r(t)]\)</span></li>
</ul>
<p><strong>Usage</strong></p>
<pre><code>_ : rwtable(n,s,w,_,r) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: the table size</li>
<li><code>s</code>: the table</li>
<li><code>w</code>: the write index (an <code>int</code> between 0 and <code>n</code>)</li>
<li><code>r</code>: the read index (an <code>int</code> between 0 and <code>n</code>)</li>
</ul>
<p>Note that the fourth argument of <code>rwtable</code> corresponds to the input of the table.</p>
<p><strong>Example: Simple Looper</strong></p>
<p>In this example, an input signal is written in the table when <code>record</code> is true (equal to 1). The read index is constantly updated to loop through the table. The table size is set to 48000, which corresponds to one second if the sampling rate is 48000 KHz.</p>
<div class="faust-run"><a href="img/src/exfaust85/exfaust85-svg/process.svg" target="_blank"><img src="img/src/exfaust85/exfaust85-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
tableSize = 48000;
recIndex = (+(1) : %(tableSize)) ~ *(record);
readIndex = readSpeed/float(ma.SR) : (+ : ma.decimal) ~ _ : *(float(tableSize)) : int;
readSpeed = hslider(&quot;[0]Read Speed&quot;,1,0.001,10,0.01);
record = button(&quot;[1]Record&quot;) : int;
looper = rwtable(tableSize,0.0,recIndex,_,readIndex);
process = looper;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust85/exfaust85.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<!-- TODO: we might want to have a better example here -->
<h3 id="selector-primitives">Selector Primitives</h3>
<p>Selector primitives can be used to create conditions in Faust and to implement switches to choose between several signals. Note that selector primitives optimize the code generated by the Faust compiler by only computing the selected signal.</p>
<h4 id="select2-primitives"><code>select2</code> Primitives</h4>
<p>The <code>select2</code> primitive is a “two-ways selector” that can be used to select between 2 signals.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{3}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(T[]=\{x_{0}(t),x_{1}(t)\}; y(t)=T[s(t)]\)</span></li>
</ul>
<p><strong>Usage</strong></p>
<pre><code>_,_ : select2(s) : _,_</code></pre>
<p>Where:</p>
<ul>
<li><code>s</code>: the selector (<code>0</code> for the first signal, <code>1</code> for the second one)</li>
</ul>
<p><strong>Example: Signal Selector</strong></p>
<p>The following example allows the user to choose between a sine and a sawtooth wave oscillator.</p>
<div class="faust-run"><a href="img/src/exfaust86/exfaust86-svg/process.svg" target="_blank"><img src="img/src/exfaust86/exfaust86-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
s = nentry(&quot;Selector&quot;,0,0,1,1);
sig = os.osc(440),os.sawtooth(440) : select2(s);
process = sig;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust86/exfaust86.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Note that <code>select2</code> could be easily implemented from scratch in Faust using Boolean primitives:</p>
<div class="faust-run"><a href="img/src/exfaust87/exfaust87-svg/process.svg" target="_blank"><img src="img/src/exfaust87/exfaust87-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
s = nentry(&quot;Selector&quot;,0,0,1,1);
mySelect2(s) = *(s==0),*(s==1) :&gt; _;
sig = os.osc(440),os.sawtooth(440) : mySelect2(s);
process = sig;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust87/exfaust87.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>While the behavior of this last solution is identical to the first one, the generated code will be less optimized as the sine and the sawtooth waves will both be computed all the time.</p>
<h4 id="select3-primitives"><code>select3</code> Primitives</h4>
<p>The <code>select3</code> primitive is a “three-ways selector” that can be used to select between 3 signals.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{4}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(T[]=\{x_{0}(t),x_{1}(t),x_{2}(t)\}; y(t)=T[s(t)]\)</span></li>
</ul>
<p><strong>Usage</strong></p>
<pre><code>_,_,_ : select3(s) : _,_,_</code></pre>
<p>Where:</p>
<ul>
<li><code>s</code>: the selector (<code>0</code> for the first signal, <code>1</code> for the second one, <code>2</code> for the third one)</li>
</ul>
<p><strong>Example: Signal Selector</strong></p>
<p>The following example allows the user to choose between a sine, a sawtooth and a triangle wave oscillator.</p>
<div class="faust-run"><a href="img/src/exfaust88/exfaust88-svg/process.svg" target="_blank"><img src="img/src/exfaust88/exfaust88-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
s = nentry(&quot;Selector&quot;,0,0,1,1);
sig = os.osc(440),os.sawtooth(440),os.triangle(440) : select3(s);
process = sig;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust88/exfaust88.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Note that <code>select2</code> could be easily implemented from scratch in Faust using Boolean primitives:</p>
<div class="faust-run"><a href="img/src/exfaust89/exfaust89-svg/process.svg" target="_blank"><img src="img/src/exfaust89/exfaust89-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
s = nentry(&quot;Selector&quot;,0,0,2,1);
mySelect3(s) = *(s==0),*(s==1),*(s==2) :&gt; _;
sig = os.osc(440),os.sawtooth(440),os.triangle(440) : mySelect3(s);
process = sig;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust89/exfaust89.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>While the behavior of this last solution is identical to the first one, the generated code will be less optimized as the sine, the sawtooth and the triangle waves will all be computed all the time.</p>
<h3 id="user-interface-primitives-and-configuration">User Interface Primitives and Configuration</h3>
<p>Faust user interface widgets/primitives allow for an <strong>abstract</strong> description of a user interface from within the Faust code. This description is independent from any GUI toolkits/frameworks and is purely abstract. Widgets can be <strong>discrete</strong> (e.g., <a href="TODO"><code>button</code></a>, <a href="TODO"><code>checkbox</code></a>, etc.), <strong>continuous</strong> (e.g., <a href="TODO"><code>hslider</code></a>, <a href="TODO"><code>vslider</code></a>, <a href="TODO"><code>nentry</code></a>), and <strong>organizational</strong> (e.g., <a href="TODO"><code>vgroup</code></a>, <a href="TODO"><code>hgroup</code></a>).</p>
<p>Discrete and continuous elements are signal generators. For example, a <code>button</code> produces a signal which is 1 when the button is pressed and 0 otherwise:</p>
<p><img src="img/button.svg" class="mx-auto d-block" width="50%"></p>
<p>These signals can be freely combined with other audio signals. In fact, the following code is perfectly valid and will generate sound:</p>
<div class="faust-run"><a href="img/src/exfaust90/exfaust90-svg/process.svg" target="_blank"><img src="img/src/exfaust90/exfaust90-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = button(&quot;DC&quot;);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust90/exfaust90.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Each primitive implements a specific UI element, but their appearance can also be completely modified using <a href="TODO">metadata</a> (a little bit like HTML and CSS in the web). Therefore, <a href="TODO"><code>hslider</code></a>, <a href="TODO"><code>vslider</code></a>, and <a href="TODO"><code>nentry</code></a>) can for example be turned into a knob, a dropdown menu, etc. This concept is further developed in the <a href="TODO">section on UI metadata</a>.</p>
<p>Continuous UI elements (i.e., <a href="TODO"><code>hslider</code></a>, <a href="TODO"><code>vslider</code></a>, and <a href="TODO"><code>nentry</code></a>) must all declare a range for the parameter they’re controlling. In some cases, this range is used during compilation to allocate memory and will impact the generated code. For example, in the case of:</p>
<div class="faust-run"><a href="img/src/exfaust91/exfaust91-svg/process.svg" target="_blank"><img src="img/src/exfaust91/exfaust91-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = @(hslider(&quot;N&quot;,1,1,10,1));</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust91/exfaust91.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>a buffer of 10 samples will be allocated for the delay implemented with the <a href="#primitive"><code>@</code> primitive</a> while 20 samples will be allocated in the following example:</p>
<div class="faust-run"><a href="img/src/exfaust92/exfaust92-svg/process.svg" target="_blank"><img src="img/src/exfaust92/exfaust92-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = @(hslider(&quot;N&quot;,1,1,20,1));</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust92/exfaust92.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="button-primitive"><code>button</code> Primitive</h4>
<p>The <code>button</code> primitive implements a button.</p>
<p><strong>Usage</strong></p>
<pre><code>button(&quot;label&quot;) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>label</code>: the <a href="#ui-labels-configuration">label</a> (expressed as a string) of the element in the interface</li>
</ul>
<p><strong>Example: Trigger</strong></p>
<div class="faust-run"><a href="img/src/exfaust93/exfaust93-svg/process.svg" target="_blank"><img src="img/src/exfaust93/exfaust93-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
process = no.noise*button(&quot;gate&quot;);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust93/exfaust93.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="checkbox-primitive"><code>checkbox</code> Primitive</h4>
<p>The <code>checkbox</code> primitive implements a checkbox/toggle.</p>
<p><strong>Usage</strong></p>
<pre><code>checkbox(&quot;label&quot;) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>label</code>: the <a href="#ui-labels-configuration">label</a> (expressed as a string) of the element in the interface</li>
</ul>
<p><strong>Example: Trigger</strong></p>
<div class="faust-run"><a href="img/src/exfaust94/exfaust94-svg/process.svg" target="_blank"><img src="img/src/exfaust94/exfaust94-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
process = no.noise*checkbox(&quot;gate&quot;);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust94/exfaust94.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="hslider-primitive"><code>hslider</code> Primitive</h4>
<p>The <code>hslider</code> primitive implements a horizontal slider.</p>
<p><strong>Usage</strong></p>
<pre><code>hslider(&quot;label&quot;,init,min,max,step) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>label</code>: the <a href="#ui-labels-configuration">label</a> (expressed as a string) of the element in the interface</li>
<li><code>init</code>: the initial value of the slider</li>
<li><code>min</code>: the minimum value of the slider</li>
<li><code>max</code>: the maximum value of the slider</li>
<li><code>step</code>: the precision (step) of the slider (1 to count 1 by 1, 0.1 to count 0.1 by 0.1, etc.)</li>
</ul>
<p><strong>Example: Gain Control</strong></p>
<div class="faust-run"><a href="img/src/exfaust95/exfaust95-svg/process.svg" target="_blank"><img src="img/src/exfaust95/exfaust95-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>gain = hslider(&quot;gain&quot;,0,0,1,0.01);
process = *(gain);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust95/exfaust95.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="vslider-primitive"><code>vslider</code> Primitive</h4>
<p>The <code>vslider</code> primitive implements a vertical slider.</p>
<p><strong>Usage</strong></p>
<pre><code>vslider(&quot;label&quot;,init,min,max,step) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>label</code>: the <a href="#ui-labels-configuration">label</a> (expressed as a string) of the element in the interface</li>
<li><code>init</code>: the initial value of the slider</li>
<li><code>min</code>: the minimum value of the slider</li>
<li><code>max</code>: the maximum value of the slider</li>
<li><code>step</code>: the precision (step) of the slider (1 to count 1 by 1, 0.1 to count 0.1 by 0.1, etc.)</li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust96/exfaust96-svg/process.svg" target="_blank"><img src="img/src/exfaust96/exfaust96-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>gain = vslider(&quot;gain&quot;,0,0,1,0.01);
process = *(gain);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust96/exfaust96.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="nentry-primitive"><code>nentry</code> Primitive</h4>
<p>The <code>nentry</code> primitive implements a “numerical entry”.</p>
<p><strong>Usage</strong></p>
<pre><code>nentry(&quot;label&quot;,init,min,max,step) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>label</code>: the <a href="#ui-labels-configuration">label</a> (expressed as a string) of the element in the interface</li>
<li><code>init</code>: the initial value of the numerical entry</li>
<li><code>min</code>: the minimum value of the numerical entry</li>
<li><code>max</code>: the maximum value of the numerical entry</li>
<li><code>step</code>: the precision (step) of the numerical entry (1 to count 1 by 1, 0.1 to count 0.1 by 0.1, etc.)</li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust97/exfaust97-svg/process.svg" target="_blank"><img src="img/src/exfaust97/exfaust97-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>gain = nentry(&quot;gain&quot;,0,0,1,0.01);
process = *(gain);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust97/exfaust97.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="hgroup-primitive"><code>hgroup</code> Primitive</h4>
<p>The <code>hgroup</code> primitive implements a horizontal group. A group contains other UI elements that can also be groups. <code>hgroup</code> is not a signal processor per se and is just a way to label/delimitate part of a Faust code.</p>
<p><strong>Usage</strong></p>
<pre><code>hgroup(&quot;label&quot;,x)</code></pre>
<p>Where:</p>
<ul>
<li><code>label</code>: the <a href="#ui-labels-configuration">label</a> (expressed as a string) of the element in the interface</li>
<li><code>x</code>: the encapsulated/labeled Faust code</li>
</ul>
<p><strong>Example</strong></p>
<p>In the following example, the 2 UI elements controlling an oscillator are encapsulated in a group.</p>
<div class="faust-run"><a href="img/src/exfaust98/exfaust98-svg/process.svg" target="_blank"><img src="img/src/exfaust98/exfaust98-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freq = vslider(&quot;freq&quot;,440,50,1000,0.1);
gain = vslider(&quot;gain&quot;,0,0,1,0.01);
process = hgroup(&quot;Oscillator&quot;,os.sawtooth(freq)*gain);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust98/exfaust98.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Note that the <code>Oscillator</code> group can be placed in a function in case we’d like to add elements to it multiple times.</p>
<div class="faust-run"><a href="img/src/exfaust99/exfaust99-svg/process.svg" target="_blank"><img src="img/src/exfaust99/exfaust99-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
oscGroup(x) = hgroup(&quot;Oscillator&quot;,x);
freq = oscGroup(vslider(&quot;freq&quot;,440,50,1000,0.1));
gain = oscGroup(vslider(&quot;gain&quot;,0,0,1,0.01));
process = os.sawtooth(freq)*gain;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust99/exfaust99.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="vgroup-primitive"><code>vgroup</code> Primitive</h4>
<p>The <code>vgroup</code> primitive implements a vertical group. A group contains other UI elements that can also be groups. <code>vgroup</code> is not a signal processor per se and is just a way to label/delimitate part of a Faust code.</p>
<p><strong>Usage</strong></p>
<pre><code>vgroup(&quot;label&quot;,x)</code></pre>
<p>Where:</p>
<ul>
<li><code>label</code>: the <a href="#ui-labels-configuration">label</a> (expressed as a string) of the element in the interface</li>
<li><code>x</code>: the encapsulated/labeled Faust code</li>
</ul>
<p><strong>Example</strong></p>
<p>In the following example, the 2 UI elements controlling an oscillator are encapsulated in a group.</p>
<div class="faust-run"><a href="img/src/exfaust100/exfaust100-svg/process.svg" target="_blank"><img src="img/src/exfaust100/exfaust100-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freq = hslider(&quot;freq&quot;,440,50,1000,0.1);
gain = hslider(&quot;gain&quot;,0,0,1,0.01);
process = vgroup(&quot;Oscillator&quot;,os.sawtooth(freq)*gain);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust100/exfaust100.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Note that the <code>Oscillator</code> group can be placed in a function in case we’d like to add elements to it multiple times.</p>
<div class="faust-run"><a href="img/src/exfaust101/exfaust101-svg/process.svg" target="_blank"><img src="img/src/exfaust101/exfaust101-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
oscGroup(x) = vgroup(&quot;Oscillator&quot;,x);
freq = oscGroup(hslider(&quot;freq&quot;,440,50,1000,0.1));
gain = oscGroup(hslider(&quot;gain&quot;,0,0,1,0.01));
process = os.sawtooth(freq)*gain;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust101/exfaust101.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="tgroup-primitive"><code>tgroup</code> Primitive</h4>
<p>The <code>tgroup</code> primitive implements a “tab group.” Tab groups can be used to group UI elements in tabs in the interface. A group contains other UI elements that can also be groups. <code>tgroup</code> is not a signal processor per se and is just a way to label/delimitate part of a Faust code.</p>
<p><strong>Usage</strong></p>
<pre><code>tgroup(&quot;label&quot;,x)</code></pre>
<p>Where:</p>
<ul>
<li><code>label</code>: the <a href="#ui-labels-configuration">label</a> (expressed as a string) of the element in the interface</li>
<li><code>x</code>: the encapsulated/labeled Faust code</li>
</ul>
<p><strong>Example</strong></p>
<p>In the following example, the 2 UI elements controlling an oscillator are encapsulated in a group.</p>
<div class="faust-run"><a href="img/src/exfaust102/exfaust102-svg/process.svg" target="_blank"><img src="img/src/exfaust102/exfaust102-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freq = hslider(&quot;freq&quot;,440,50,1000,0.1);
gain = hslider(&quot;gain&quot;,0,0,1,0.01);
process = tgroup(&quot;Oscillator&quot;,os.sawtooth(freq)*gain);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust102/exfaust102.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Note that the <code>Oscillator</code> group can be placed in a function in case we’d like to add elements to it multiple times.</p>
<div class="faust-run"><a href="img/src/exfaust103/exfaust103-svg/process.svg" target="_blank"><img src="img/src/exfaust103/exfaust103-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
oscGroup(x) = tgroup(&quot;Oscillator&quot;,x);
freq = oscGroup(hslider(&quot;freq&quot;,440,50,1000,0.1));
gain = oscGroup(hslider(&quot;gain&quot;,0,0,1,0.01));
process = os.sawtooth(freq)*gain;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust103/exfaust103.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="vbargraph-primitive"><code>vbargraph</code> Primitive</h4>
<p>The <code>vbargraph</code> primitive implements a vertical bar-graph (typically a meter displaying the level of a signal).</p>
<p><strong>Usage</strong></p>
<p><code>vbargraph</code> takes an input signal and outputs it while making it available to the UI.</p>
<pre><code>_ : vbargraph(&quot;label&quot;,min,max) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>min</code>: the minimum value of the signal in the interface</li>
<li><code>max</code>: the maximum value of the signal in the interface</li>
</ul>
<p><strong>Example: Simple VU Meter</strong></p>
<p>A simple VU meter can be implemented using the <code>vbargraph</code> primitive:</p>
<div class="faust-run"><a href="img/src/exfaust104/exfaust104-svg/process.svg" target="_blank"><img src="img/src/exfaust104/exfaust104-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
process = _ &lt;: attach(_,abs : ba.linear2db : vbargraph(&quot;Level&quot;,-60,0));</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust104/exfaust104.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Note the use of the <a href="#attach-primitive"><code>attach</code></a> primitive here that forces the compilation of the <code>vbargraph</code> without using its output signal (see section on the <a href="#attach-primitive"><code>attach</code> primitive</a>).</p>
<h4 id="hbargraph-primitive"><code>hbargraph</code> Primitive</h4>
<p>The <code>hbargraph</code> primitive implements a horizontal bar-graph (typically a meter displaying the level of a signal).</p>
<p><strong>Usage</strong></p>
<p><code>hbargraph</code> takes an input signal and outputs it while making it available to the UI.</p>
<pre><code>_ : hbargraph(&quot;label&quot;,min,max) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>min</code>: the minimum value of the signal in the interface</li>
<li><code>max</code>: the maximum value of the signal in the interface</li>
</ul>
<p><strong>Example: Simple VU Meter</strong></p>
<p>A simple VU meter can be implemented using the <code>hbargraph</code> primitive:</p>
<div class="faust-run"><a href="img/src/exfaust105/exfaust105-svg/process.svg" target="_blank"><img src="img/src/exfaust105/exfaust105-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
process = _ &lt;: attach(_,abs : ba.linear2db : hbargraph(&quot;Level&quot;,-60,0));</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust105/exfaust105.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Note the use of the <a href="#attach-primitive"><code>attach</code></a> primitive here that forces the compilation of the <code>hbargraph</code> without using its output signal (see section on the <a href="#attach-primitive"><code>attach</code> primitive</a>).</p>
<h4 id="attach-primitive"><code>attach</code> Primitive</h4>
<p>The <code>attach</code> primitive takes two input signals and produces one output signal which is a copy of the first input. The role of <code>attach</code> is to force its second input signal to be compiled with the first one. From a mathematical standpoint <code>attach(x,y)</code> is equivalent to <code>1*x+0*y</code>, which is in turn equivalent to <code>x</code>, but it tells the compiler not to optimize-out <code>y</code>.</p>
<p>To illustrate this role, let’s say that we want to develop a mixer application with a vumeter for each input signals. Such vumeters can be easily coded in Faust using an envelope detector connected to a bargraph. The problem is that the signal of the envelope generators has no role in the output signals. Using <code>attach(x,vumeter(x))</code> one can tell the compiler that when <code>x</code> is compiled <code>vumeter(x)</code> should also be compiled.</p>
<p>The examples in the <a href="#hbargraph-primitive"><code>hbargraph</code> Primitive</a> and the <a href="#vbargraph-primitive"><code>vbargraph</code> Primitive</a> illustrate well the use of <code>attach</code>.</p>
<h4 id="variable-parts-of-a-label">Variable Parts of a Label</h4>
<p>Labels can contain variable parts. These are indicated with the sign <code>%</code> followed by the name of a variable. During compilation each label is processed in order to replace the variable parts by the value of the variable. For example:</p>
<div class="faust-run"><a href="img/src/exfaust106/exfaust106-svg/process.svg" target="_blank"><img src="img/src/exfaust106/exfaust106-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = par(i,8,hslider(&quot;Voice %i&quot;, 0.9, 0, 1, 0.01));</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust106/exfaust106.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>creates 8 sliders in parallel with different names while <code>par(i,8,hslider(&quot;Voice&quot;, 0.9, 0, 1, 0.01))</code> would have created only one slider and duplicated its output 8 times.</p>
<p>The variable part can have an optional format digit. For example <code>&quot;Voice %2i&quot;</code> would indicate to use two digit when inserting the value of <code>i</code> in the string.</p>
<p>An escape mechanism is provided. If the sign <code>%</code> is followed by itself, it will be included in the resulting string. For example <code>&quot;feedback (%%)&quot;</code> will result in <code>&quot;feedback (%)&quot;</code>.</p>
<h4 id="labels-as-pathnames">Labels as Pathnames</h4>
<p>Thanks to <a href="#hgroup-primitive">horizontal</a>, <a href="#vgroup-primitive">vertical</a>, and <a href="#tgroup-primitive">tabs</a> groups, user interfaces have a hierarchical structure analog to a hierarchical file system. Each widget has an associated <em>path name</em> obtained by concatenating the labels of all its surrounding groups with its own label.</p>
<p>In the following example :</p>
<pre><code>hgroup(&quot;Foo&quot;,
    ...
    vgroup(&quot;Faa&quot;, 
        ...
        hslider(&quot;volume&quot;,...)
        ...
    )
    ...
)</code></pre>
<p>the volume slider has pathname <code>/h:Foo/v:Faa/volume</code>.</p>
<p>In order to give more flexibility to the design of user interfaces, it is possible to explicitly specify the absolute or relative pathname of a widget directly in its label.</p>
<p>Elements of a path are separated using <code>/</code>. Group types are defined with the following identifiers:</p>
<table>
<thead>
<tr class="header">
<th>Group Type</th>
<th>Group Identifier</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>hgroup</code></td>
<td><code>h:</code></td>
</tr>
<tr class="even">
<td><code>vgroup</code></td>
<td><code>v:</code></td>
</tr>
<tr class="odd">
<td><code>tgroup</code></td>
<td><code>t:</code></td>
</tr>
</tbody>
</table>
<p>Hence, the example presented in the <a href="#hgroup-primitive">section on the <code>hgroup</code> primitive</a> can be rewritten as:</p>
<div class="faust-run"><a href="img/src/exfaust107/exfaust107-svg/process.svg" target="_blank"><img src="img/src/exfaust107/exfaust107-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freq = vslider(&quot;h:Oscillator/freq&quot;,440,50,1000,0.1);
gain = vslider(&quot;h:Oscillator/gain&quot;,0,0,1,0.01);
process = os.sawtooth(freq)*gain;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust107/exfaust107.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>which will be reflected in C++ as:</p>
<pre><code>virtual void buildUserInterface(UI* ui_interface) {
  ui_interface-&gt;openHorizontalBox(&quot;Oscillator&quot;);
  ui_interface-&gt;addVerticalSlider(&quot;freq&quot;, &amp;fVslider1, 440.0f, 50.0f, 1000.0f, 0.100000001f);
  ui_interface-&gt;addVerticalSlider(&quot;gain&quot;, &amp;fVslider0, 0.0f, 0.0f, 1.0f, 0.00999999978f);
  ui_interface-&gt;closeBox();
}</code></pre>
<p>Note that path names are inherent to the use of tools gravitating around Faust such as <a href="TODO">OSC control</a> or <a href="TODO"><code>faust2api</code></a>. In the case of <code>faust2api</code>, since no user interface is actually generated, UI elements just become a way to declare parameters of a Faust object. Therefore, there’s no distinction between <code>nentry</code>, <code>hslider</code>, <code>vslider</code>, etc.</p>
<h4 id="smoothing">Smoothing</h4>
<p>Despite the fact that the signal generated by user interface elements can be used in Faust with any other signals, UI elements run at a slower rate than the audio rate. This might be a source of clicking if the value of the corresponding parameter is modified while the program is running. This behavior is also amplified by the low resolution of signals generated by UI elements (as opposed to actual audio signals). For example, changing the value of the <code>freq</code> or <code>gain</code> parameters of the following code will likely create clicks (in the case of <code>gain</code>) or abrupt jumps (in the case of <code>freq</code>) in the signal:</p>
<div class="faust-run"><a href="img/src/exfaust108/exfaust108-svg/process.svg" target="_blank"><img src="img/src/exfaust108/exfaust108-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freq = hslider(&quot;freq&quot;,440,50,1000,0.1);
gain = hslider(&quot;gain&quot;,0,0,1,0.01);
process = os.osc(freq)*gain;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust108/exfaust108.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>This problem can be easily solved in Faust by using the <a href="TODO"><code>si.smoo</code></a> function which implements an exponential smoothing by a unit-dc-gain one-pole lowpass with a pole at 0.999 (<code>si.smoo</code> is just sugar for <code>si.smooth(0.999)</code>). Therefore, the previous example can be rewritten as:</p>
<div class="faust-run"><a href="img/src/exfaust109/exfaust109-svg/process.svg" target="_blank"><img src="img/src/exfaust109/exfaust109-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freq = hslider(&quot;freq&quot;,440,50,1000,0.1) : si.smoo;
gain = hslider(&quot;gain&quot;,0,0,1,0.01) : si.smoo;
process = os.osc(freq)*gain;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust109/exfaust109.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Beware that each <code>si.smoo</code> that you place in your code will add some extra computation so they should be used precociously.</p>
<h4 id="links-to-generated-code">Links to Generated Code</h4>
<p>UI elements provide a convenient entry point to the DSP process in the code generated by the Faust compiler (e.g., C++, etc.). For example, the Faust program:</p>
<pre><code>import(&quot;stdfaust.lib&quot;);
freq = hslider(&quot;freq&quot;,440,50,1000,0.1);
process = os.osc(freq);</code></pre>
<p>will have the corresponding <code>buildUserInterface</code> method in C++:</p>
<pre><code>virtual void buildUserInterface(UI* ui_interface) {
  ui_interface-&gt;openVerticalBox(&quot;osc&quot;);
  ui_interface-&gt;addHorizontalSlider(&quot;freq&quot;, &amp;fHslider0, 440.0f, 50.0f, 1000.0f, 0.100000001f);
  ui_interface-&gt;closeBox();
}</code></pre>
<p>The second argument of the <code>addHorizontalSlider</code> method is a pointer to the variable containing the current value of the <code>freq</code> parameter. The value of this pointer can be updated at any point to change the frequency of the corresponding oscillator.</p>
<h3 id="ui-label-metadata">UI Label Metadata</h3>
<p><a href="#user-interface-primitives-and-configuration">Widget labels</a> can contain metadata enclosed in square brackets. These metadata associate a key with a value and are used to provide additional information to the architecture file. They are typically used to improve the look and feel of the user interface, configure OSC and accelerometer control/mapping, etc. Since the format of the value associated to a key is relatively open, metadata constitute a flexible way for programmers to add features to the language.</p>
<p>The Faust code:</p>
<pre><code>process = *(hslider(&quot;foo[key1: val 1][key2: val 2]&quot;,0,0,1,0.1));</code></pre>
<p>will produce the corresponding C++ code:</p>
<pre><code>class mydsp : public dsp {
  ...
  virtual void buildUserInterface(UI* ui_interface) {
    ui_interface-&gt;openVerticalBox(&quot;tst&quot;);
    ui_interface-&gt;declare(&amp;fHslider0, &quot;key1&quot;, &quot;val 1&quot;);
    ui_interface-&gt;declare(&amp;fHslider0, &quot;key2&quot;, &quot;val 2&quot;);
    ui_interface-&gt;addHorizontalSlider(&quot;foo&quot;, &amp;fHslider0, 0.0f, 0.0f, 1.0f, 0.100000001f);
    ui_interface-&gt;closeBox();
  }
  ...
};</code></pre>
<p>All metadata are removed from the label by the compiler and transformed in calls to the <code>UI::declare()</code> method. All these <code>UI::declare()</code> calls will always take place before the <code>UI::AddSomething()</code> call that creates the User Interface element. This allows the <code>UI::AddSomething()</code> method to make full use of the available metadata.</p>
<p>Metadata are architecture-specific: it is up to the architecture file to decide what to do with it. While some metadata will work with most architectures (e.g., accelerometer and OSC configuration, etc.), others might be more specific. Some of them are presented in the following sections.</p>
<h4 id="ordering-ui-elements">Ordering UI Elements</h4>
<p>The order of UI declarations in a Faust code doesn’t necessarily reflect the actual order of the UI elements in the corresponding interface. Therefore, UI elements can be ordered by placing a metadata before the declaration of the name of the UI element in the label. For example, in the following declaration:</p>
<pre><code>gain = vslider(&quot;h:Oscillator/[1]gain&quot;,0,0,1,0.01);
freq = vslider(&quot;h:Oscillator/[0]freq&quot;,440,50,1000,0.1);</code></pre>
<p>the <code>freq</code> parameter will be placed before <code>gain</code> despite the fact that <code>gain</code> is declared first.</p>
<p>This system can be used to order groups as well. Ordering will be carried out on elements at the same level. For example:</p>
<div class="faust-run"><a href="img/src/exfaust110/exfaust110-svg/process.svg" target="_blank"><img src="img/src/exfaust110/exfaust110-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freqS = vslider(&quot;h:Oscillators/h:[0]Sawtooth/[0]freq&quot;,440,50,1000,0.1);
gainS = vslider(&quot;h:Oscillators/h:[0]Sawtooth/[1]gain&quot;,0,0,1,0.01);
freqT = vslider(&quot;h:Oscillators/h:[1]Triangle/[0]freq&quot;,440,50,1000,0.1);
gainT = vslider(&quot;h:Oscillators/h:[1]Triangle/[1]gain&quot;,0,0,1,0.01);
process = os.sawtooth(freqS)*gainS + os.triangle(freqT)*gainT;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust110/exfaust110.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Note that this could also be written as:</p>
<div class="faust-run"><a href="img/src/exfaust111/exfaust111-svg/process.svg" target="_blank"><img src="img/src/exfaust111/exfaust111-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freqS = vslider(&quot;[0]freq&quot;,440,50,1000,0.1);
gainS = vslider(&quot;[1]gain&quot;,0,0,1,0.01);
freqT = vslider(&quot;[0]freq&quot;,440,50,1000,0.1);
gainT = vslider(&quot;[1]gain&quot;,0,0,1,0.01);
process = hgroup(&quot;Oscillators&quot;,
  hgroup(&quot;[0]Sawtooth&quot;,os.sawtooth(freqS)*gainS) + 
  hgroup(&quot;[1]Triangle&quot;,os.triangle(freqT)*gainT)
);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust111/exfaust111.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="global-ui-metadata">Global UI Metadata</h4>
<p>Note that global user interfaces completely replacing the one defined using the standard Faust UI primitives may be declared using <a href="#global-metadata">global metadata</a>. This is the case of the <a href="TODO">SmartKeyboard</a> interface for example.</p>
<!-- TODO Link to metadata declaration section -->
<p>In the following subsections, the standard Faust UI metadata are documented. Other types of metadata (e.g., accelerometers, OSC, etc.) are documented in the sections related to these topics.</p>
<h4 id="styleknob-metadata"><code>[style:knob]</code> Metadata</h4>
<p>The <code>[style:knob]</code> metadata turns any continuous UI element (i.e., <a href="#hslider-metadata"><code>hslider</code></a>, <a href="#vslider-metadata"><code>vslider</code></a>, <a href="#nentry-metadata"><code>nentry</code></a>) into a knob.</p>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust112/exfaust112-svg/process.svg" target="_blank"><img src="img/src/exfaust112/exfaust112-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freq = vslider(&quot;freq[style:knob]&quot;,440,50,1000,0.1);
process = os.sawtooth(freq);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust112/exfaust112.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="stylemenu-metadata"><code>[style:menu]</code> Metadata</h4>
<p>The <code>[style:menu]</code> metadata turns any continuous UI element (i.e., <a href="#hslider-metadata"><code>hslider</code></a>, <a href="#vslider-metadata"><code>vslider</code></a>, <a href="#nentry-metadata"><code>nentry</code></a>) into a drop-down menu.</p>
<p><strong>Usage</strong></p>
<pre><code>[style:menu{&#39;Name0&#39;:value0;&#39;Name1&#39;:value1}]</code></pre>
<p>Where:</p>
<ul>
<li><code>NameN</code>: the name associated to <code>valueN</code></li>
<li><code>valueN</code>: the value associated to <code>NameN</code></li>
</ul>
<p><strong>Example: Selector</strong></p>
<div class="faust-run"><a href="img/src/exfaust113/exfaust113-svg/process.svg" target="_blank"><img src="img/src/exfaust113/exfaust113-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
s = vslider(&quot;Signal[style:menu{&#39;Noise&#39;:0;&#39;Sawtooth&#39;:1}]&quot;,0,0,1,1);
process = select2(s,no.noise,os.sawtooth(440));</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust113/exfaust113.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="styleradio-metadata"><code>[style:radio]</code> Metadata</h4>
<p>The <code>[style:radio]</code> metadata turns a <a href="#hslider-metadata"><code>hslider</code></a> or a <a href="#vslider-metadata"><code>vslider</code></a> into a radio-button-menu. The orientation of the menu is determined by the type of UI element (i.e., <code>hslider</code> for horizontal and <code>vslider</code> for vertical).</p>
<p><strong>Usage</strong></p>
<pre><code>[style:radio{&#39;Name0&#39;:value0;&#39;Name1&#39;:value1}]</code></pre>
<p>Where:</p>
<ul>
<li><code>NameN</code>: the name associated to <code>valueN</code></li>
<li><code>valueN</code>: the value associated to <code>NameN</code></li>
</ul>
<p><strong>Example: Selector</strong></p>
<div class="faust-run"><a href="img/src/exfaust114/exfaust114-svg/process.svg" target="_blank"><img src="img/src/exfaust114/exfaust114-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
s = vslider(&quot;Signal[style:radio{&#39;Noise&#39;:0;&#39;Sawtooth&#39;:1}]&quot;,0,0,1,1);
process = select2(s,no.noise,os.sawtooth(440));</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust114/exfaust114.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="styleled-metadata"><code>[style:led]</code> Metadata</h4>
<p>The <code>[style:led]</code> metadata turns a <a href="#vbargraph-metadata"><code>vbargraph</code></a> or a <a href="#hbargraph-metadata"><code>hbargraph</code></a> into a blinking LED (with varying intensity).</p>
<p><strong>Example: Level Display</strong></p>
<div class="faust-run"><a href="img/src/exfaust115/exfaust115-svg/process.svg" target="_blank"><img src="img/src/exfaust115/exfaust115-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
process = _ &lt;: attach(_,abs : ba.linear2db : vbargraph(&quot;Level[style:led]&quot;,-60,0));</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust115/exfaust115.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="unitdb-metadata"><code>[unit:dB]</code> Metadata</h4>
<p>The <code>[style:dB]</code> metadata changes the unit of a <a href="#vbargraph-metadata"><code>vbargraph</code></a> or a <a href="#hbargraph-metadata"><code>hbargraph</code></a> to dB. This impacts its overall appearance by applying a rainbow color scheme, etc.</p>
<p><strong>Example: Level Display</strong></p>
<div class="faust-run"><a href="img/src/exfaust116/exfaust116-svg/process.svg" target="_blank"><img src="img/src/exfaust116/exfaust116-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
process = _ &lt;: attach(_,abs : ba.linear2db : vbargraph(&quot;Level[style:dB]&quot;,-60,0));</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust116/exfaust116.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="unitxx-metadata"><code>[unit:xx]</code> Metadata</h4>
<p>The <code>[unit:xx]</code> metadata allows us to specify the unit of a UI element. The unit will be displayed right next to the current value of the parameter in the interface.</p>
<p><strong>Usage</strong></p>
<pre><code>[unit:xx]</code></pre>
<p>Where:</p>
<ul>
<li><code>xx</code>: the unit of the current parameter</li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust117/exfaust117-svg/process.svg" target="_blank"><img src="img/src/exfaust117/exfaust117-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freq = vslider(&quot;freq[unit:Hz]&quot;,440,50,1000,0.1);
process = os.sawtooth(freq);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust117/exfaust117.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="scalexx-metadata"><code>[scale:xx]</code> Metadata</h4>
<p>The <code>[scale:xx]</code> metadata allows for the specification of a scale (different than the default linear one) to the parameter in the UI. <code>[scale:log]</code> can be used to change to scale to logarithmic and <code>[scale:exp]</code> to exponential.</p>
<h4 id="tooltipxx-metadata"><code>[tooltip:xx]</code> Metadata</h4>
<p>The <code>[tooltip:xx]</code> metadata allows for the specification of a “tooltip” when<br />
the mouse hover a parameter in the interface. This is very convenient when implementing complex interfaces.</p>
<p><strong>Usage</strong></p>
<pre><code>[tooltip:xx]</code></pre>
<p>Where:</p>
<ul>
<li><code>xx</code>: a string to be used as a tooltip in the interface</li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust118/exfaust118-svg/process.svg" target="_blank"><img src="img/src/exfaust118/exfaust118-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freq = vslider(&quot;freq[tooltip:The frequency of the oscillator]&quot;,440,50,1000,0.1);
process = os.sawtooth(freq);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust118/exfaust118.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="hiddenxx-metadata"><code>[hidden:xx]</code> Metadata</h4>
<p>The <code>[hidden:xx]</code> metadata can be used to hide a parameter in the interface. This is convenient when controlling a parameter with a <a href="TODO">motion sensor</a> or <a href="TODO">OSC messages</a> and we don’t want it to be visible in the interface. This feature is commonly used when making apps for Android and iOS using <a href="TODO"><code>faust2android</code></a> or <a href="TODO"><code>faust2ios</code></a>.</p>
<p><strong>Compatibility</strong></p>
<ul>
<li>iOS</li>
<li>Android</li>
</ul>
<h1 id="using-the-faust-compiler">Using the Faust Compiler</h1>
<p>While the Faust compiler is available in different forms (e.g., <a href="TODO">Embedded Compiler</a>, etc.), its most “common” one is the command line version, which can be invoked using the <code>faust</code> command. It translates a Faust program into code in a wide range of languages (C, O-C++, C++, Rust, JAVA, JavaScript, ASM JavaScript, LLVM, C-LLVM, FIR, and WebAssembly). The generated code can be wrapped into an optional <em>architecture file</em> allowing to directly produce a fully operational program.</p>
<p>A typical call of the Faust command line compiler is:</p>
<pre><code>faust [OPTIONS] faustFile.dsp</code></pre>
<p>The Faust compiler outputs C++ code by default therefore running</p>
<pre><code>faust noise.dsp </code></pre>
<p>will compile <a href="misc/noise.dsp"><code>noise.dsp</code></a> and output the corresponding C++ code on the standard output. The option <code>-o</code> allows to reroute the standard output to a file:</p>
<pre><code>faust noise.dsp -o noise.cpp</code></pre>
<p>The <code>-a</code> option allows us to wrap the generated code into an architecture file:</p>
<pre><code>faust -a alsa-gtk.cpp noise.dsp </code></pre>
<p>which can either be placed in the same folder as the current Faust file (<code>noise.dsp</code> here) or be one of the standard Faust architectures.</p>
<!-- TODO: we must check if talk about architectures somewhere in greater
details and put a link to that here -->
<p>To compile a Faust program into an ALSA application on Linux, the following commands can be used:</p>
<pre><code>faust -a alsa-gtk.cpp noise.dsp -o noise.cpp
g++ -lpthread -lasound `pkg-config --cflags --libs gtk+-2.0` noise.cpp -o noise</code></pre>
<p>Note that a wide range of <a href="TODO"><code>faust2...</code> compilation scripts</a> can be used to facilitate this operation by taking a Faust file and returning the corresponding binary for your platform.</p>
<h2 id="structure-of-the-generated-code">Structure of the Generated Code</h2>
<p>A Faust DSP C++ class derives from the base <code>dsp</code> class defined as below (a similar structure is used for languages than C++):</p>
<pre><code>class dsp {
  public:
  dsp() {}
  virtual ~dsp() {}
  
  // Returns the number of inputs of the Faust program
  virtual int getNumInputs() = 0;
  
  // Returns the number of outputs of the Faust program
  virtual int getNumOutputs() = 0;
  
  // This method can be called to retrieve the UI description of
  // the Faust program and its associated fields
  virtual void buildUserInterface(UI* ui_interface) = 0;
  
  // Returns the current sampling rate
  virtual int getSampleRate() = 0;
  
  // Init methods
  virtual void init(int samplingRate) = 0;
  virtual void instanceInit(int samplingRate) = 0;
  virtual void instanceConstants(int samplingRate) = 0;
  virtual void instanceResetUserInterface() = 0;
  virtual void instanceClear() = 0;
  
  // Returns a clone of the instance
  virtual dsp* clone() = 0;
  
  // Retrieve the global metadata of the Faust program
  virtual void metadata(Meta* m) = 0;
  
  // Compute one audio frame
  virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) = 0;
  
  // Compute a time-stamped audio frame
  virtual void compute(double /*date_usec*/, int count, FAUSTFLOAT** inputs,
     FAUSTFLOAT** outputs) { compute(count, inputs, outputs); }
};</code></pre>
<p>Methods are filled by the compiler with the actual code. In the case of <code>noise.dsp</code>:</p>
<pre><code>class mydsp : public dsp {
  private:
  int iRec0[2];
  int fSamplingFreq;
  
  public:
  void metadata(Meta* m) { 
    m-&gt;declare(&quot;author&quot;, &quot;GRAME&quot;);
    m-&gt;declare(&quot;filename&quot;, &quot;noise&quot;);
    m-&gt;declare(&quot;name&quot;, &quot;Noise&quot;);
    m-&gt;declare(&quot;noises.lib/name&quot;, &quot;Faust Noise Generator Library&quot;);
    m-&gt;declare(&quot;noises.lib/version&quot;, &quot;0.0&quot;);
  }
  virtual int getNumInputs() {
    return 0;
  }
  virtual int getNumOutputs() {
    return 1;
  }
  virtual int getInputRate(int channel) {
    int rate;
    switch (channel) {
      default: {
        rate = -1;
        break;
      }
    }
    return rate;
  }
  virtual int getOutputRate(int channel) {
    int rate;
    switch (channel) {
      case 0: {
        rate = 1;
        break;
      }
      default: {
        rate = -1;
        break;
      }
    }
    return rate;
  }
  static void classInit(int samplingFreq) {}
  virtual void instanceConstants(int samplingFreq) {
    fSamplingFreq = samplingFreq;
  }
  virtual void instanceResetUserInterface() {}
  virtual void instanceClear() {
    for (int l0 = 0; (l0 &lt; 2); l0 = (l0 + 1)) {
      iRec0[l0] = 0;
    }
  }
  virtual void init(int samplingFreq) {
    classInit(samplingFreq);
    instanceInit(samplingFreq);
  }
  virtual void instanceInit(int samplingFreq) {
    instanceConstants(samplingFreq);
    instanceResetUserInterface();
    instanceClear();
  }
  virtual mydsp* clone() {
    return new mydsp();
  }
  virtual int getSampleRate() {
    return fSamplingFreq;
  }
  virtual void buildUserInterface(UI* ui_interface) {
    ui_interface-&gt;openVerticalBox(&quot;Noise&quot;);
    ui_interface-&gt;closeBox();
  }
  virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) {
    FAUSTFLOAT* output0 = outputs[0];
    for (int i = 0; (i &lt; count); i = (i + 1)) {
      iRec0[0] = ((1103515245 * iRec0[1]) + 12345);
      output0[i] = FAUSTFLOAT((4.65661287e-10f * float(iRec0[0])));
      iRec0[1] = iRec0[0];
    }
  }
};</code></pre>
<p>Several fine-grained initialization methods are available. The <code>instanceInit</code> method calls several additional initialization methods. The <code>instanceConstants</code> method sets the instance constant state. The <code>instanceClear</code> method resets the instance dynamic state (delay lines…). The <code>instanceResetUserInterface</code> method resets all control value to their default state. All of those methods can be used individually on an allocated instance to reset part of its state.</p>
<p>The <code>init</code> method combines class static state and instance initialization.</p>
<p>When using a single instance, calling <code>init</code> is the simplest way to do “what is needed.” When using several instances, all of them can be initialized using <code>instanceInit</code>, with a single call to <code>classInit</code> to initialize the static shared state.</p>
<h2 id="compilation-options">Compilation Options</h2>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>Short</th>
<th>Long</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-h</code></td>
<td><code>--help</code></td>
<td>print the help message</td>
</tr>
<tr class="even">
<td><code>-v</code></td>
<td><code>--version</code></td>
<td>print the compiler version information</td>
</tr>
<tr class="odd">
<td><code>-d</code></td>
<td><code>--details</code></td>
<td>print the compilation details</td>
</tr>
<tr class="even">
<td><code>-tg</code></td>
<td><code>--task-graph</code></td>
<td>Draw a graph of all internal computational loops as <code>.dot</code> (graphviz) file</td>
</tr>
<tr class="odd">
<td><code>-sg</code></td>
<td><code>--signal-graph</code></td>
<td>Draw a graph of all internal computational loops as <code>.dot</code> (graphviz) file</td>
</tr>
<tr class="even">
<td><code>-ps</code></td>
<td><code>--postscript</code></td>
<td>Generate the block-diagram postscript file</td>
</tr>
<tr class="odd">
<td><code>-svg</code></td>
<td><code>--svg</code></td>
<td>Generate the block-diagram svg file</td>
</tr>
<tr class="even">
<td><code>-mdoc</code></td>
<td><code>--mathdoc</code></td>
<td>Generate the full mathematical documentation of a Faust program</td>
</tr>
<tr class="odd">
<td><code>-mdlang &lt;l&gt;</code></td>
<td><code>--mathdoc-lang</code></td>
<td>Choose the language of the mathematical description (<em>l</em> = en, fr, etc.)</td>
</tr>
<tr class="even">
<td><code>-stripmdoc</code></td>
<td><code>--strip-mdoc-tags</code></td>
<td>Remove documentation tags when printing Faust listings</td>
</tr>
<tr class="odd">
<td><code>-sd</code></td>
<td><code>--simplify-diagrams</code></td>
<td>Try to further simplify block diagrams before drawing them</td>
</tr>
<tr class="even">
<td><code>-f &lt;n&gt;</code></td>
<td><code>--fold &lt;n&gt;</code></td>
<td>Max complexity of svg diagrams before splitting into several files (default 25 elements)</td>
</tr>
<tr class="odd">
<td><code>-mns &lt;n&gt;</code></td>
<td><code>--max-name-size &lt;n&gt;</code></td>
<td>Max character size used in svg diagrams labels</td>
</tr>
<tr class="even">
<td><code>-sn</code></td>
<td><code>--simple-names</code></td>
<td>Use simple names (without arguments) for block-diagram generation (default max size: 40 chars)</td>
</tr>
<tr class="odd">
<td><code>-xml</code></td>
<td><code>-xml</code></td>
<td>Generate an XML description file</td>
</tr>
<tr class="even">
<td><code>-exp10</code></td>
<td><code>--generate-exp10</code></td>
<td>Function call instead of pow(10) function</td>
</tr>
<tr class="odd">
<td><code>-json</code></td>
<td><code>-json</code></td>
<td>Generate a JSON description file</td>
</tr>
<tr class="even">
<td><code>-blur</code></td>
<td><code>--shadow-blur</code></td>
<td>Add a blur to boxes shadows in block diagrams</td>
</tr>
<tr class="odd">
<td><code>-lb</code></td>
<td><code>--left-balanced</code></td>
<td>Generate left-balanced expressions in block diagrams</td>
</tr>
<tr class="even">
<td><code>-mb</code></td>
<td><code>--mid-balanced</code></td>
<td>Generate mid-balanced expressions in block diagrams</td>
</tr>
<tr class="odd">
<td><code>-rb</code></td>
<td><code>--right-balanced</code></td>
<td>Generate right-balanced expressions in block diagrams</td>
</tr>
<tr class="even">
<td><code>-lt</code></td>
<td><code>--less-temporaries</code></td>
<td>Generate less temporaries in compiling delays</td>
</tr>
<tr class="odd">
<td><code>-mcd &lt;n&gt;</code></td>
<td><code>--max-copy-delay &lt;n&gt;</code></td>
<td>Threshold between copy and ring buffer delays (default 16 samples)</td>
</tr>
<tr class="even">
<td><code>-mem</code></td>
<td><code>--memory</code></td>
<td>Allocate static in global state using a custom memory manager</td>
</tr>
<tr class="odd">
<td><code>-a &lt;file&gt;</code></td>
<td><code>-a</code></td>
<td>Specifies a wrapper architecture file</td>
</tr>
<tr class="even">
<td><code>-i</code></td>
<td><code>--inline-architecture-files</code></td>
<td>Inline architecture files in the generated code</td>
</tr>
<tr class="odd">
<td><code>-cn &lt;name&gt;</code></td>
<td><code>--class-name &lt;name&gt;</code></td>
<td>Specify the name of the DSP class to be used instead of <code>mydsp</code></td>
</tr>
<tr class="even">
<td><code>-scn &lt;name&gt;</code></td>
<td><code>--super-class-name &lt;name&gt;</code></td>
<td>Specify the name of the super class to be used instead of <code>dsp</code></td>
</tr>
<tr class="odd">
<td><code>-pn &lt;name&gt;</code></td>
<td><code>--process-name &lt;name&gt;</code></td>
<td>Specify the name of the dsp entry-point instead of process</td>
</tr>
<tr class="even">
<td><code>-t &lt;sec&gt;</code></td>
<td><code>--timeout &lt;sec&gt;</code></td>
<td>Abort compilation after <code>&lt;sec&gt;</code> seconds (default 120)</td>
</tr>
<tr class="odd">
<td><code>-time</code></td>
<td><code>--compilation-time</code></td>
<td>Flag to display compilation phases timing information</td>
</tr>
<tr class="even">
<td><code>-o &lt;file&gt;</code></td>
<td><code>-o &lt;file&gt;</code></td>
<td>C, C++, JAVA, JavaScript, ASM JavaScript, WebAssembly, LLVM IR or FVM (interpreter) output file</td>
</tr>
<tr class="odd">
<td><code>-scal</code></td>
<td><code>--scalar</code></td>
<td>Generate non-vectorized code</td>
</tr>
<tr class="even">
<td><code>-vec</code></td>
<td><code>--vectorize</code></td>
<td>Generate easier to vectorize code</td>
</tr>
<tr class="odd">
<td><code>-vs &lt;n&gt;</code></td>
<td><code>--vec-size &lt;n&gt;</code></td>
<td>Size of the vector (default 32 samples)</td>
</tr>
<tr class="even">
<td><code>-lv &lt;n&gt;</code></td>
<td><code>--loop-variant</code></td>
<td>Loop variant when <code>-vec</code> [0:fastest (default), 1:simple]</td>
</tr>
<tr class="odd">
<td><code>-omp</code></td>
<td><code>--openMP</code></td>
<td>Generate OpenMP pragmas, activates the <code>--vectorize</code> option</td>
</tr>
<tr class="even">
<td><code>-pl</code></td>
<td><code>--par-loop</code></td>
<td>Generate parallel loops in <code>--openMP</code> mode</td>
</tr>
<tr class="odd">
<td><code>-sch</code></td>
<td><code>--scheduler</code></td>
<td>Generate tasks and use a Work Stealing scheduler, activates the <code>--vectorize</code> option</td>
</tr>
<tr class="even">
<td><code>-ocl</code></td>
<td><code>--openCL</code></td>
<td>Generate tasks with OpenCL (experimental)</td>
</tr>
<tr class="odd">
<td><code>-cuda</code></td>
<td><code>--cuda</code></td>
<td>Generate tasks with CUDA (experimental)</td>
</tr>
<tr class="even">
<td><code>-dfs</code></td>
<td><code>--deepFirstScheduling</code></td>
<td>Schedule vector loops in deep first order</td>
</tr>
<tr class="odd">
<td><code>-g</code></td>
<td><code>--groupTasks</code></td>
<td>Group single-threaded sequential tasks together when <code>-omp</code> or <code>-sch</code> is used</td>
</tr>
<tr class="even">
<td><code>-fun</code></td>
<td><code>--funTasks</code></td>
<td>Separate tasks code as separated functions (in <code>-vec</code>, <code>-sch</code>, or <code>-omp</code> mode)</td>
</tr>
<tr class="odd">
<td><code>-lang &lt;lang&gt;</code></td>
<td><code>--language</code></td>
<td>Generate various output formats: <code>c</code>, <code>ocpp</code>, <code>cpp</code>, <code>rust</code>, <code>java</code>, <code>js</code>, <code>ajs</code>, <code>llvm</code>, <code>cllvm</code>, <code>fir</code>, <code>wast</code>/<code>wasm</code>, <code>interp</code> (default <code>cpp</code>)</td>
</tr>
<tr class="even">
<td><code>-uim</code></td>
<td><code>--user-interface-macros</code></td>
<td>Add user interface macro definitions in the output code</td>
</tr>
<tr class="odd">
<td><code>-single</code></td>
<td><code>--single-precision-floats</code></td>
<td>Use single precision floats for internal computations (default)</td>
</tr>
<tr class="even">
<td><code>-double</code></td>
<td><code>--double-precision-floats</code></td>
<td>Use <code>--double-precision-floats</code> for internal computations</td>
</tr>
<tr class="odd">
<td><code>-quad</code></td>
<td><code>--quad-precision-floats</code></td>
<td>Use quad precision floats for internal computations</td>
</tr>
<tr class="even">
<td><code>-es 1|0</code></td>
<td><code>--enable-semantics 1|0</code></td>
<td>Use <code>--enable-semantics 1|0</code> when 1, and simple multiplication otherwise</td>
</tr>
<tr class="odd">
<td><code>-flist</code></td>
<td><code>--file-list</code></td>
<td>Use –file-list used to eval process</td>
</tr>
<tr class="even">
<td><code>-norm</code></td>
<td><code>--normalized-form</code></td>
<td>Prints signals in normalized form and exits</td>
</tr>
<tr class="odd">
<td><code>-A &lt;dir&gt;</code></td>
<td><code>--architecture-dir &lt;dir&gt;</code></td>
<td>Add the directory <code>&lt;dir&gt;</code> to the architecture search path</td>
</tr>
<tr class="even">
<td><code>-I &lt;dir&gt;</code></td>
<td><code>--import-dir &lt;dir&gt;</code></td>
<td>Add the directory <code>&lt;dir&gt;</code> to the import search path</td>
</tr>
<tr class="odd">
<td><code>-L &lt;file&gt;</code></td>
<td><code>--library &lt;file&gt;</code></td>
<td>Link with the LLVM module <code>&lt;file&gt;</code></td>
</tr>
<tr class="even">
<td><code>-O &lt;dir&gt;</code></td>
<td><code>--output-dir &lt;dir&gt;</code></td>
<td>Specify the relative directory of the generated output code, and the output directory of additional generated files (SVG, XML, etc.)</td>
</tr>
<tr class="odd">
<td><code>-e</code></td>
<td><code>--export-dsp</code></td>
<td>Export expanded DSP (all included libraries)</td>
</tr>
<tr class="even">
<td><code>-inpl</code></td>
<td><code>--in-place generates</code></td>
<td>Code working when input and output buffers are the same (in scalar mode only)</td>
</tr>
<tr class="odd">
<td><code>-inj &lt;f&gt;</code></td>
<td><code>--inject &lt;f&gt;</code></td>
<td>inject source file <code>&lt;f&gt;</code> into architecture file instead of compile a dsp file</td>
</tr>
<tr class="even">
<td><code>-ftz</code></td>
<td><code>--flush-to-zero</code></td>
<td>Flush to zero the code added to recursive signals [0:no (default), 1:fabs based, 2:mask based (fastest)]</td>
</tr>
<tr class="odd">
<td><code>-fm &lt;file&gt;</code></td>
<td><code>--fast-math &lt;file&gt;</code></td>
<td>Uses optimized versions of mathematical functions implemented in <code>&lt;file&gt;</code>, take the <code>/faust/dsp/fastmath.cpp</code> file if ‘def’ is used</td>
</tr>
</tbody>
</table>
<h2 id="controlling-code-generation">Controlling Code Generation</h2>
<p>Several options of the Faust compiler allow to control the generated C++ code. By default computation is done sample by sample in a single loop. But the compiler can also generate <em>vector</em> and <em>parallel</em> code.</p>
<h3 id="vector-code-generation">Vector Code Generation</h3>
<p>Modern C++ compilers are able to do autovectorization, that is to use SIMD instructions to speedup the code. These instructions can typically operate in parallel on short vectors of 4 simple precision floating point numbers, leading to a theoretical speedup of <span class="math inline">\(\times4\)</span>.</p>
<p>Autovectorization of C/C++ programs is a difficult task. Current compilers are very sensitive to the way the code is arranged. In particular, complex loops can prevent autovectorization. The goal of the vector code generation is to rearrange the C++ code in a way that facilitates the autovectorization job of the C++ compiler. Instead of generating a single sample computation loop, it splits the computation into several simpler loops that communicates by vectors.</p>
<p>The vector code generation is activated by passing the <a href="#compilation-options"><code>--vectorize</code> (or <code>-vec</code>)</a> option to the Faust compiler. Two additional options are available: <code>--vec-size &lt;n&gt;</code> controls the size of the vector (by default 32 samples) and <code>--loop-variant 0/1</code> gives some additional control on the loops.</p>
<p>To illustrate the difference between scalar code and vector code, let’s take the computation of the RMS (Root Mean Square) value of a signal. Here is the Faust code that computes the Root Mean Square of a sliding window of 1000 samples:</p>
<div class="faust-run"><a href="img/src/exfaust119/exfaust119-svg/process.svg" target="_blank"><img src="img/src/exfaust119/exfaust119-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>// Root Mean Square of n consecutive samples
RMS(n) = square : mean(n) : sqrt;

// Square of a signal
square(x) = x * x;

// Mean of n consecutive samples of a signal (uses fixpoint to avoid the 
// accumulation of rounding errors) 
mean(n) = float2fix : integrate(n) : fix2float : /(n); 

// Sliding sum of n consecutive samples
integrate(n,x) = x - x@n : +~_;

// Convertion between float and fix point
float2fix(x) = int(x*(1&lt;&lt;20));      
fix2float(x) = float(x)/(1&lt;&lt;20);    

// Root Mean Square of 1000 consecutive samples
process = RMS(1000);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust119/exfaust119.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>The <a href="#strucutre-of-the-generated-code">corresponding <code>compute()</code> method</a> generated in scalar mode is the following:</p>
<pre><code>virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) {
  FAUSTFLOAT* input0 = inputs[0];
  FAUSTFLOAT* output0 = outputs[0];
  for (int i = 0; (i &lt; count); i = (i + 1)) {
    int iTemp0 = int((1048576.0f * mydsp_faustpower2_f(float(input0[i]))));
    iVec0[(IOTA &amp; 1023)] = iTemp0;
    iRec0[0] = ((iRec0[1] + iTemp0) - iVec0[((IOTA - 1000) &amp; 1023)]);
    output0[i] = FAUSTFLOAT(std::sqrt((9.53674362e-10f * float(iRec0[0]))));
    IOTA = (IOTA + 1);
    iRec0[1] = iRec0[0];
  }
}</code></pre>
<p>The <code>-vec</code> option leads to the following reorganization of the code:</p>
<pre><code>virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) {
  fInput0_ptr = inputs[0];
  FAUSTFLOAT* fInput0 = 0;
  fOutput0_ptr = outputs[0];
  FAUSTFLOAT* fOutput0 = 0;
  int iRec0_tmp[36];
  int* iRec0 = &amp;iRec0_tmp[4];
  int fullcount = count;
  int index = 0;
  /* Main loop */
  for (index = 0; (index &lt;= (fullcount - 32)); index = (index + 32)) {
    fInput0 = &amp;fInput0_ptr[index];
    fOutput0 = &amp;fOutput0_ptr[index];
    int count = 32;
    /* Recursive loop 0 */
    /* Pre code */
    iYec0_idx = ((iYec0_idx + iYec0_idx_save) &amp; 2047);
    /* Compute code */
    for (int i = 0; (i &lt; count); i = (i + 1)) {
      iYec0[((i + iYec0_idx) &amp; 2047)] = 
      int((1048576.0f mydsp_faustpower2_f(float(fInput0[i]))));
    }
    /* Post code */
    iYec0_idx_save = count;
    /* Recursive loop 1 */
    /* Pre code */
    for (int j0 = 0; (j0 &lt; 4); j0 = (j0 + 1)) {
      iRec0_tmp[j0] = iRec0_perm[j0];
    }
    /* Compute code */
    for (int i = 0; (i &lt; count); i = (i + 1)) {
      iRec0[i] = ((iRec0[(i - 1)] + iYec0[((i + iYec0_idx) &amp; 2047)]) - 
      iYec0[(((i + iYec0_idx) - 1000) &amp; 2047)]);
    }
    /* Post code */
    for (int j = 0; (j &lt; 4); j = (j + 1)) {
      iRec0_perm[j] = iRec0_tmp[(count + j)];
    }
    /* Vectorizable loop 2 */
    /* Compute code */
    for (int i = 0; (i &lt; count); i = (i + 1)) {
      fOutput0[i] = FAUSTFLOAT(std::sqrt((9.53674362e-10f * float(iRec0[i]))));
    }
  }
  
  /* Remaining frames */
  if (index &lt; fullcount) {
    fInput0 = &amp;fInput0_ptr[index];
    fOutput0 = &amp;fOutput0_ptr[index];
    int count = (fullcount - index);
    /* Recursive loop 0 */
    /* Pre code */
    iYec0_idx = ((iYec0_idx + iYec0_idx_save) &amp; 2047);
    /* Compute code */
    for (int i = 0; (i &lt; count); i = (i + 1)) {
      iYec0[((i + iYec0_idx) &amp; 2047)] = int((1048576.0f * 
        mydsp_faustpower2_f(float(fInput0[i]))));
    }
    /* Post code */
    iYec0_idx_save = count;
    /* Recursive loop 1 */
    /* Pre code */
    for (int j0 = 0; (j0 &lt; 4); j0 = (j0 + 1)) {
      iRec0_tmp[j0] = iRec0_perm[j0];
    }
    /* Compute code */
    for (int i = 0; (i &lt; count); i = (i + 1)) {
      iRec0[i] = ((iRec0[(i - 1)] + iYec0[((i + iYec0_idx) &amp; 2047)]) - 
      iYec0[(((i + iYec0_idx) - 1000) &amp; 2047)]);
    }
    /* Post code */
    for (int j = 0; (j &lt; 4); j = (j + 1)) {
      iRec0_perm[j] = iRec0_tmp[(count + j)];
    }
    /* Vectorizable loop 2 */
    /* Compute code */
    for (int i = 0; (i &lt; count); i = (i + 1)) {
      fOutput0[i] = FAUSTFLOAT(std::sqrt((9.53674362e-10f * float(iRec0[i]))));
    }
  }
}</code></pre>
<p>While the second version of the code is more complex, it turns out to be much easier to vectorize efficiently by the C++ compiler. With the exact same compilation options: <code>-O3 -xHost -ftz -fno-alias -fp-model fast=2</code>, the scalar version leads to a throughput performance of 129.144 MB/s, while the vector version achieves 359.548 MB/s, a speedup of x2.8 !</p>
<p><img src="img/compilerStack.svg" class="mx-auto d-block" width="30%"></p>
<p>The vector code generation is built on top of the scalar code generation (see previous figure). Every time an expression needs to be compiled, the compiler checks if it requires a separate loop or not. Expressions that are shared (and are complex enough) are good candidates to be compiled in a separate loop, as well as recursive expressions and expressions used in delay lines.</p>
<p>The result is a directed graph in which each node is a computation loop (see figure below). This graph is stored in the class object and a topological sort is applied to it before printing the code.</p>
<p><img src="img/loopgraph2.svg" class="mx-auto d-block" width="30%"></p>
<h3 id="parallel-code-generation">Parallel Code Generation</h3>
<p>Parallel code generation is activated by passing either the <a href="#compilation-options"><code>--openMP</code> (or <code>-omp</code>) option or the <code>--scheduler</code> (or <code>-sch</code>) option</a>. It implies that the <code>-vec</code> option as well as the parallel code generation are built on top of the vector code generation.</p>
<h4 id="the-openmp-code-generator">The OpenMP Code Generator</h4>
<p><img src="img/openmpModel.svg" class="mx-auto d-block" width="100%"></p>
<p>The <a href="#compilation-options"><code>--openMP</code> (or <code>-omp</code>) option</a>, when given to the Faust compiler, will insert appropriate <a href="https://www.openmp.org/">OpenMP</a> directives into the C++ code. OpenMP is a well established API that is used to explicitly define direct multi-threaded, shared memory parallelism. It is based on a fork-join model of parallelism (see figure above). Parallel regions are delimited by <code>#pragma omp parallel</code> constructs. At the entrance of a parallel region, a group of parallel threads is activated. The code within a parallel region is executed by each thread of the parallel group until the end of the region.</p>
<pre><code>#pragma omp parallel
{
  // the code here is executed simultaneously by every thread of the parallel 
  // team
  ...
}</code></pre>
<p>In order not to have every thread doing redundantly the exact same work, OpenMP provides specific <em>work-sharing</em> directives. For example <code>#pragma omp sections</code> allows to break the work into separate, discrete sections, each section being executed by one thread:</p>
<pre><code>#pragma omp parallel
{
  #pragma omp sections
  {
    #pragma omp section
    {
      // job 1
    }
    #pragma omp section
    {
      // job 2
    }
    ...
  }
  ...
}</code></pre>
<h4 id="adding-open-mp-directives">Adding Open MP Directives</h4>
<p>As said before, parallel code generation is built on top of vector code generation. The graph of loops produced by the vector code generator is topologically sorted in order to detect the loops that can be computed in parallel. The first set <span class="math inline">\(S_0\)</span> (loops <span class="math inline">\(L1\)</span>, <span class="math inline">\(L2\)</span> and <span class="math inline">\(L3\)</span>) contains the loops that don’t depend on any other loops, the set <span class="math inline">\(S_1\)</span> contains the loops that only depend on loops of <span class="math inline">\(S_0\)</span>, (that is loops <span class="math inline">\(L4\)</span> and <span class="math inline">\(L5\)</span>), etc..</p>
<p>As all the loops of a given set <span class="math inline">\(S_n\)</span> can be computed in parallel, the compiler will generate a <code>sections</code> construct with a <code>section</code> for each loop.</p>
<pre><code>#pragma omp sections
{
  #pragma omp section
  for (...) {
    // Loop 1
  }
  #pragma omp section
  for (...) {
    // Loop 2
  }
  ...
}</code></pre>
<p>If a given set contains only one loop, then the compiler checks to see if the loop can be parallelized (no recursive dependencies) or not. If it can be parallelized, it generates:</p>
<pre><code>#pragma omp for
for (...) {
 // Loop code
}</code></pre>
<p>otherwise it generates a <code>single</code> construct so that only one thread will execute the loop:</p>
<pre><code>#pragma omp single
for (...) {
 // Loop code
}</code></pre>
<h4 id="example-of-parallel-openmp-code">Example of Parallel OpenMP Code</h4>
<p>To illustrate how Faust uses the OpenMP directives, here is a very simple example, two 1-pole filters in parallel connected to an adder:</p>
<div class="faust-run"><a href="img/src/exfaust120/exfaust120-svg/process.svg" target="_blank"><img src="img/src/exfaust120/exfaust120-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>filter(c) = *(1-c) : + ~ *(c);
process = filter(0.9), filter(0.9) : +;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust120/exfaust120.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>The corresponding <code>compute()</code> method obtained using the <code>-omp</code> option looks like this:</p>
<pre><code>virtual void compute(int fullcount, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) {
  float fRec0_tmp[36];
  float fRec1_tmp[36];
  FAUSTFLOAT* fInput0 = 0;
  FAUSTFLOAT* fInput1 = 0;
  FAUSTFLOAT* fOutput0 = 0;
  float* fRec0 = &amp;fRec0_tmp[4];
  float* fRec1 = &amp;fRec1_tmp[4];
  fInput0_ptr = inputs[0];
  fInput1_ptr = inputs[1];
  fOutput0_ptr = outputs[0];
  #pragma omp parallel\
      firstprivate(fInput0, fInput1, fOutput0, fRec0, fRec1)
  {
    for (int index = 0; (index &lt; fullcount); index = (index + 32)) {
      fInput0 = &amp;fInput0_ptr[index];
      fInput1 = &amp;fInput1_ptr[index];
      fOutput0 = &amp;fOutput0_ptr[index];
      int count = min(32, (fullcount - index));
      #pragma omp sections
      {
        #pragma omp section
        {
          /* Recursive loop 0 */
          /* Pre code */
          for (int j0 = 0; (j0 &lt; 4); j0 = (j0 + 1)) {
            fRec0_tmp[j0] = fRec0_perm[j0];
          }
          /* Compute code */
          for (int i = 0; (i &lt; count); i = (i + 1)) {
            fRec0[i] = ((0.899999976f * fRec0[(i - 1)]) + 
            (0.100000001f * float(fInput0[i])));
          }
          /* Post code */
          for (int j = 0; (j &lt; 4); j = (j + 1)) {
            fRec0_perm[j] = fRec0_tmp[(count + j)];
          }
        }
        #pragma omp section
        {
          /* Recursive loop 1 */
          /* Pre code */
          for (int j1 = 0; (j1 &lt; 4); j1 = (j1 + 1)) {
            fRec1_tmp[j1] = fRec1_perm[j1];
          }
          /* Compute code */
          for (int i = 0; (i &lt; count); i = (i + 1)) {
            fRec1[i] = ((0.899999976f * fRec1[(i - 1)]) + 
            (0.100000001f * float(fInput1[i])));
          }
          /* Post code */
          for (int j = 0; (j &lt; 4); j = (j + 1)) {
            fRec1_perm[j] = fRec1_tmp[(count + j)];
          }
        }
      }
      #pragma omp single
      {
        /* Vectorizable loop 2 */
        /* Compute code */
        for (int i = 0; (i &lt; count); i = (i + 1)) {
          fOutput0[i] = FAUSTFLOAT((fRec0[i] + fRec1[i]));
        }
      }
    }
  }
}</code></pre>
<p>This code requires some comments:</p>
<ul>
<li>The parallel construct <code>#pragma omp parallel</code> is the fundamental construct that starts parallel execution. The number of parallel threads is generally the number of CPU cores but it can be controlled in several ways.</li>
<li>Variables external to the parallel region are shared by default. The pragma <code>firstprivate(fRec0,fRec1)</code> indicates that each thread should have its private copy of <code>fRec0</code> and <code>fRec1</code>. The reason is that accessing shared variables requires an indirection and is quite inefficient compared to private copies.</li>
<li>The top level loop <code>for (int index = 0;...)...</code> is executed by all threads simultaneously. The subsequent work-sharing directives inside the loop will indicate how the work must be shared between threads.</li>
<li>Please note that an implied barrier exists at the end of each work-sharing region. All threads must have executed the barrier before any of them can continue.</li>
<li>The work-sharing directive <code>#pragma omp single</code> indicates that this first section will be executed by only one thread (any of them).</li>
<li>The work-sharing directive <code>#pragma omp sections</code> indicates that each corresponding <code>#pragma omp section</code>, here our two filters, will be executed in parallel.</li>
<li>The loop construct <code>#pragma omp for</code> specifies that the iterations of the associated loop will be executed in parallel. The iterations of the loop are distributed across the parallel threads. For example, if we have two threads, the first one can compute indices between 0 and count/2 and the other one between count/2 and count.</li>
<li>Finally <code>#pragma omp single</code> indicates that this section will be executed by only one thread (any of them).</li>
</ul>
<h4 id="the-scheduler-code-generator">The Scheduler Code Generator</h4>
<p>With the <a href="#compilation-options"><code>--scheduler</code> (or <code>-sch</code>) option</a> given to the Faust compiler, the computation graph is cut into separate computation loops (called “tasks”), and a “Work Stealing Scheduler” is used to activate and execute them following their dependencies. A pool of worked threads is created and each thread uses it’s own local WSQ (Work Stealing Queue) of tasks. A WSQ is a special queue with a Push operation, a “private” LIFO Pop operation and a “public” FIFO Pop operation.</p>
<p>Starting from a ready task, each thread follows the dependencies, possibly pushing ready sub-tasks into it’s own local WSQ. When no more tasks can be activated on a given computation path, the thread pops a task from it’s local WSQ. If the WSQ is empty, then the thread is allowed to “steal” tasks from other threads WSQ.</p>
<p>The local LIFO Pop operation allows better cache locality and the FIFO steal Pop “larger chuck” of work to be done. The reason for this is that many work stealing workloads are divide-and-conquer in nature, stealing one of the oldest task implicitly also steals a (potentially) large sub-tree of computations that will unfold once that piece of work is stolen and run.</p>
<p>Compared to the OpenMP model (<code>-omp</code>) the new model is worse for simple Faust programs and usually starts to behave comparable or sometimes better for “complex enough” Faust programs. In any case, since OpenMP does not behave so well with GCC compilers, and is unusable on OSX in real-time contexts, this new scheduler option has it’s own value. We plan to improve it adding a “pipelining” idea in the future.</p>
<h4 id="example-of-parallel-scheduler-code">Example of Parallel Scheduler Code</h4>
<p>To illustrate how Faust generates the scheduler code, let’s reuse the previous example made of two 1-pole filters in parallel connected to an adder:</p>
<div class="faust-run"><a href="img/src/exfaust121/exfaust121-svg/process.svg" target="_blank"><img src="img/src/exfaust121/exfaust121-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>filter(c) = *(1-c) : + ~ *(c);
process = filter(0.9), filter(0.9) : +; </code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust121/exfaust121.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>When <code>-sch</code> option is used, the content of the additional <code>architecture/scheduler.h</code> file is inserted in the generated code. It contains code to deal with WSQ and thread management. The <code>compute()</code> and <code>computeThread()</code> methods are the following:</p>
<pre><code>virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) {
  fInput0_ptr = inputs[0];
  fInput1_ptr = inputs[1];
  fOutput0_ptr = outputs[0];
  fCount = count;
  fIndex = 0;
  /* End task has only one input, so will be directly activated */
  /* Only initialize tasks with more than one input */
  initTask(fScheduler, 4, 2);
  /* Push ready tasks in each thread WSQ */
  initTaskList(fScheduler, -1);
  signalAll(fScheduler);
  computeThread(0);
  syncAll(fScheduler);
}
void computeThread(int num_thread) {
  int count = fCount;
  FAUSTFLOAT* fInput0 = 0;
  FAUSTFLOAT* fInput1 = 0;
  FAUSTFLOAT* fOutput0 = 0;
  int tasknum = 0;
  while ((fIndex &lt; fCount)) {
    fInput0 = &amp;fInput0_ptr[fIndex];
    fInput1 = &amp;fInput1_ptr[fIndex];
    fOutput0 = &amp;fOutput0_ptr[fIndex];
    count = min(32, (fCount - fIndex));
    switch (tasknum) {
      case 0: {
        /* Work Stealing task */
        tasknum = getNextTask(fScheduler, num_thread);
        break;
      }
      case 1: {
        /* Last task */
        fIndex = (fIndex + 32);
        if (fIndex &lt; fCount) {
          /* End task has only one input, so will be directly activated */
          /* Only initialize tasks with more than one input */
          initTask(fScheduler, 4, 2);
          /* Push ready tasks in &#39;num_thread&#39; WSQ */
          initTaskList(fScheduler, num_thread);
        }
        tasknum = 0;
        break;
      }
      case 2: {
        /* Recursive loop 2 */
        /* Pre code */
        for (int j0 = 0; (j0 &lt; 4); j0 = (j0 + 1)) {
          fRec0_tmp[j0] = fRec0_perm[j0];
        }
        /* Compute code */
        for (int i = 0; (i &lt; count); i = (i + 1)) {
          fRec0[i] = ((0.899999976f * fRec0[(i - 1)]) + 
          (0.100000001f * float(fInput0[i])));
        }
        /* Post code */
        for (int j = 0; (j &lt; 4); j = (j + 1)) {
          fRec0_perm[j] = fRec0_tmp[(count + j)];
        }
        /* One output only */
        activateOneOutputTask(fScheduler, num_thread, 4, &amp;tasknum);
        break;
      }
      case 3: {
        /* Recursive loop 3 */
        /* Pre code */
        for (int j1 = 0; (j1 &lt; 4); j1 = (j1 + 1)) {
          fRec1_tmp[j1] = fRec1_perm[j1];
        }
        /* Compute code */
        for (int i = 0; (i &lt; count); i = (i + 1)) {
          fRec1[i] = ((0.899999976f * fRec1[(i - 1)]) + 
          (0.100000001f * float(fInput1[i])));
        }
        /* Post code */
        for (int j = 0; (j &lt; 4); j = (j + 1)) {
          fRec1_perm[j] = fRec1_tmp[(count + j)];
        }
        /* One output only */
        activateOneOutputTask(fScheduler, num_thread, 4, &amp;tasknum);
        break;
      }
      case 4: {
        /* Vectorizable loop 4 */
        /* Compute code */
        for (int i = 0; (i &lt; count); i = (i + 1)) {
          fOutput0[i] = FAUSTFLOAT((fRec0[i] + fRec1[i]));
        }
        tasknum = 1;
        break;
      }
    }
  }
}</code></pre>
<h1 id="embedding-the-faust-compiler-using-libfaust">Embedding the Faust Compiler Using <code>libfaust</code></h1>
<!-- TODO: this section could be further developed and better documented -->
<p>The combination of the awesome <a href="https://llvm.org/">LLVM technology</a> and <code>libfaust</code> (the library version of the Faust compiler) allows developers to compile and execute Faust DSP programs on the fly at full speed and without making compromises. In this section, we demonstrate how the Faust dynamic compilation chain can be used to embed the Faust compiler technology directly in applications or plugins.</p>
<h2 id="dynamic-compilation-chain">Dynamic Compilation Chain</h2>
<p>The Faust compiler uses an intermediate FIR representation (Faust Imperative Representation), which can be translated to several output languages. The FIR language describes the computation performed on the samples in a generic manner. It contains primitives to read and write variables and arrays, do arithmetic operations, and define the necessary control structures (<code>for</code> and <code>while</code> loops, <code>if</code> structure, etc.).</p>
<p>To generate various output languages, several backends have been developed: for C, C++, Java, JavaScript, asm.js, LLVM IR, webassemble, etc. The native LLVM based compilation chain is particularly interesting: it provides direct compilation of a DSP source into executable code in memory, bypassing the external compiler requirement.</p>
<h2 id="llvm">LLVM</h2>
<p><a href="https://llvm.org/">LLVM (formerly Low Level Virtual Machine)</a> is a compiler infrastructure, designed for compile-time, link-time, and run-time optimization of programs written in arbitrary programming languages. Executable code is produced dynamically using a <em>Just In Time</em> compiler from a specific code representation, called LLVM IR. Clang, the LLVM native C/C++/Objective-C compiler is a front-end for the LLVM Compiler. It can, for instance, convert a C or C++ source file into LLVM IR code. Domain-specific languages like Faust can easily target the LLVM IR. This has been done by developing an LLVM IR backend in the Faust compiler.</p>
<h2 id="compiling-in-memory">Compiling in Memory</h2>
<p>The complete chain goes from the Faust DSP source code, compiled in LLVM IR using the LLVM backend, to finally produce the executable code using the LLVM JIT. All steps take place in memory, getting rid of the classical file-based approaches. Pointers to executable functions can be retrieved from the resulting LLVM module and the code directly called with the appropriate parameters.</p>
<p>The Faust compiler has been packaged as an embeddable library called <code>libfaust</code>, published with an associated API. Given a Faust source code (as a file or a string), calling the <code>createDSPFactoryXXX</code> function runs the compilation chain (Faust + LLVM JIT) and generates the <em>prototype</em> of the class, as a <code>llvm_dsp_factory</code> pointer.</p>
<p>Note that the library keeps an internal cache of all allocated <em>factories</em> so that the compilation of the same DSP code – that is the same source code and the same set of <em>normalized</em> (sorted in a canonical order) compilation options – will return the same (reference counted) factory pointer.</p>
<p><code>deleteDSPFactory</code> has to be explicitly used to properly decrement the reference counter when the factory is not needed anymore. You can get a unique SHA1 key of the created factory using its <code>getSHAKey</code> method.</p>
<p>Next, the <code>createDSPInstance</code> function (corresponding to the <code>new className</code> of C++) instantiates a <code>llvm_dsp</code> pointer to be used through its interface, connected to the audio chain and controller interfaces. When finished, <code>delete</code> can be used to destroy the dsp instance.</p>
<p>Since <code>llvm_dsp</code> is a subclass of the dsp base class, an object of this type can be used with all the available <code>audio</code> and <code>UI</code> classes. In essence, this is like reusing all architecture files already developed for the static C++ class compilation scheme like <code>OSCUI</code>, <code>httpdUI</code> interfaces, etc. (see TODO pointer to arch section).</p>
<!-- TODO: we need an example here -->
<h2 id="savingrestoring-the-factory">Saving/Restoring the Factory</h2>
<p>After the DSP factory has been compiled, the application or the plug-in running it might need to save it and then restore it. To get the internal factory compiled code, several functions are available:</p>
<ul>
<li><code>writeDSPFactoryToIR</code>: get the DSP factory LLVM IR (in textual format) as a string,</li>
<li><code>writeDSPFactoryToIRFile</code>: get the DSP factory LLVM IR (in textual format) and write it to a file,</li>
<li><code>writeDSPFactoryToBitcode</code>: get the DSP factory LLVM IR (in binary format) as a string</li>
<li><code>writeDSPFactoryToBitcodeFile</code>: save the DSP factory LLVM IR (in binary format) in a file,</li>
<li><code>writeDSPFactoryToMachine</code>: get the DSP factory executable machine code as a string,</li>
<li><code>writeDSPFactoryToMachineFile</code>: save the DSP factory executable machine code in a file.</li>
</ul>
<p>To re-create a DSP factory from a previously saved code, several functions are available:</p>
<ul>
<li><code>readDSPFactoryFromIR</code>: create a DSP factory from a string containing the LLVM IR (in textual format),</li>
<li><code>readDSPFactoryFromIRFile</code>: create a DSP factory from a file containing the LLVM IR (in textual format),</li>
<li><code>readDSPFactoryFromBitcode</code>: create a DSP factory from a string containing the LLVM IR (in binary format),</li>
<li><code>readDSPFactoryFromBitcodeFile</code>: create a DSP factory from a file containing the LLVM IR (in binary format),</li>
<li><code>readDSPFactoryFromMachine</code>: create a DSP factory from a string containing the executable machine code,</li>
<li><code>readDSPFactoryFromMachineFile</code>: create a DSP factory from a file containing the executable machine code.</li>
</ul>
<h2 id="additional-functions">Additional Functions</h2>
<p>Some additional functions are available in the <code>libfaust</code> API:</p>
<ul>
<li><code>expandDSPFromString</code>/<code>expandDSPFromFile</code>: creates a self-contained DSP source string where all needed librairies have been included. All compilations options are normalized and included as a comment in the expanded string,</li>
<li><code>generateAuxFilesFromString</code>/<code>generateAuxFilesFromFile</code>: from a DSP source string or file, generates auxiliary files: SVG, XML, ps, etc. depending of the <code>argv</code> parameters.</li>
</ul>
<h2 id="using-the-libfaust-library">Using the <code>libfaust</code> Library</h2>
<p>The <code>libfaust</code> library is fully integrated to the Faust distribution. You’ll have to compile and install it in order to use it. For an exhaustive documentation/description of the API, we advise you to have a look at the code in the <a href="TODO"><code>faust/dsp/llvm-dsp.h</code></a> header file. Note that <code>faust/dsp/llvm-c-dsp.h</code> is a pure C version of the same API. Additional functions are available in <code>faust/dsp/libfaust.h</code> and their C version can be found in <code>faust/dsp/libfaust-c.h</code>.</p>
<p>More generally, a “typical” use of <code>libfaust</code> could look like:</p>
<pre><code>// the Faust code to compile (could be in a file too)
string theCode = &quot;import(&quot;stdfaust.lib&quot;);process = no.noise;&quot;;
// compiling in memory (createDSPFactoryFromFile could be used alternatively)
llvm_dsp_factory *m_factory = createDSPFactoryFromString( 
  &quot;faust&quot;, theCode, argc, argv, &quot;&quot;, m_errorString, optimize );
// creating the DSP instance for interfacing
dsp *m_dsp = m_factory-&gt;createDSPInstance();
// creating a generic UI to interact with the DSP
my_ui m_ui = new MyUI();
// linking the interface to the DSP instance
m_dsp-&gt;buildUserInterface( m_ui );
// initializing the DSP instance
m_dsp-&gt;init( 44100 );
// hypothetical audio callback
while(...){
  m_dsp-&gt;compute( 1, m_input, m_output );
}
// cleaning
delete m_dsp;
deleteDSPFactory( m_factory );
m_factory = NULL;</code></pre>
<p>Thus, very few code is needed to embed Faust to your project!</p>
<h2 id="use-case-examples">Use Case Examples</h2>
<p>The dynamic compilation chain has been used in several projects:</p>
<ul>
<li><a href="TODO">FaustLive</a>: an integrated IDE for Faust development offering on-the-fly compilation and execution features</li>
<li><a href="TODO">Faustgen</a>: a generic Faust <a href="https://cycling74.com/products/max/">Max/MSP</a> object</li>
<li><a href="TODO">Faust for CSOUND</a>: a <a href="https://csound.com/">CSOUND</a> opcode running the Faust compiler internally</li>
<li><a href="TODO">LibAudioStream</a>: a framework to manipulate audio ressources through the concept of streams</li>
<li><a href="TODO">Faust for JUCE</a>: a tool integrating the Faust compiler to <a href="https://juce.com/">JUCE</a> developed by Oliver Larkin and available as part of the <a href="https://github.com/olilarkin/pMix2">pMix2 project</a></li>
<li>An experimental integration of Faust in <a href="http://forumnet.ircam.fr/product/antescofo-en/">Antescofo</a></li>
<li>FaucK: the combination of the <a href="http://chuck.cs.princeton.edu/">ChucK Programming Language</a> and Faust</li>
</ul>
<h1 id="osc-support">OSC Support</h1>
<h2 id="overview">Overview</h2>
<p>Most Faust architectures provide <a href="http://opensoundcontrol.org/">Open Sound Control (OSC)</a> support (the implementation is based internally on the <em>oscpack</em> library by Ross Bencina). This allows applications to be remotely controlled from any OSC-capable application, programming language, or hardware device.</p>
<p>OSC support can be added to any Faust program (as long as the target architecture supports it: see tables below) simply by adding the <code>[osc:on]</code> metadata to the <a href="#standard-metadata">standard <code>option</code> metadata</a>:</p>
<pre><code>declare options &quot;[osc:on]&quot;;</code></pre>
<p>The following tables provides a list of Faust architectures providing OSC support.</p>
<table>
<thead>
<tr class="header">
<th>Audio System</th>
<th>Environment</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Alsa</td>
<td>GTK, Qt, Console</td>
</tr>
<tr class="even">
<td>Jack</td>
<td>GTK, Qt, Console</td>
</tr>
<tr class="odd">
<td>Netjack</td>
<td>GTK, Qt, Console</td>
</tr>
<tr class="even">
<td>PortAudio</td>
<td>GTK, Qt</td>
</tr>
</tbody>
</table>
<div style="text-align: center;">
<p><strong><em>Linux Faust Architectures with OSC Support</em></strong></p>
</div>
<hr />
<table>
<thead>
<tr class="header">
<th>Audio System</th>
<th>Environment</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CoreAudio</td>
<td>Qt</td>
</tr>
<tr class="even">
<td>Jack</td>
<td>Qt, Console</td>
</tr>
<tr class="odd">
<td>Netjack</td>
<td>Qt, Console</td>
</tr>
<tr class="even">
<td>PortAudio</td>
<td>Qt</td>
</tr>
</tbody>
</table>
<div style="text-align: center;">
<p><strong><em>OSX Faust Architectures with OSC Support</em></strong></p>
</div>
<hr />
<table>
<thead>
<tr class="header">
<th>Audio System</th>
<th>Environment</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Jack</td>
<td>Qt, Console</td>
</tr>
<tr class="even">
<td>PortAudio</td>
<td>Qt</td>
</tr>
</tbody>
</table>
<div style="text-align: center;">
<p><strong><em>Windows Faust Architectures with OSC Support</em></strong></p>
</div>
<hr />
<table>
<thead>
<tr class="header">
<th>Environment</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Android</td>
</tr>
<tr class="even">
<td>iOS</td>
</tr>
<tr class="odd">
<td>JUCE</td>
</tr>
<tr class="even">
<td>Bela</td>
</tr>
</tbody>
</table>
<div style="text-align: center;">
<p><strong><em>Other Faust Architectures with OSC Support</em></strong></p>
</div>
<hr />
<h2 id="simple-example">Simple Example</h2>
<!-- TODO: check that we explain that some of these features are built-in in
stuff like the online editor. -->
<p>To illustrate how OSC support works let’s define a very simple noise generator with a level control (we’ll call it <code>noise.dsp</code>):</p>
<div class="faust-run"><a href="img/src/exfaust122/exfaust122-svg/process.svg" target="_blank"><img src="img/src/exfaust122/exfaust122-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
process = no.noise*hslider(&quot;level&quot;,0,0,1,0.01);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust122/exfaust122.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>This example can be compiled as a standalone Jack Qt application with OSC support simply by running the following command:</p>
<pre><code>faust2jaqt -osc noise.dsp</code></pre>
<p>When the generated application is ran from the command line:</p>
<pre><code>./noise </code></pre>
<p>various information is printed in the standard output, including:</p>
<pre><code>Faust OSC version 0.93 application &#39;noise&#39; is running on UDP ports 5510, 5511, 5512</code></pre>
<p>Hence, the OSC module makes use of three different UDP ports:</p>
<ul>
<li><code>5510</code> is the listening port number: control messages should be addressed to this port.</li>
<li><code>5511</code> is the output port number: control messages sent by the application and answers to query messages are sent to this port.</li>
<li><code>5512</code> is the error port number: used for asynchronous error notifications.</li>
</ul>
<p>These OSC parameters can be changed from the command line using one of the following options:</p>
<ul>
<li><code>-port number</code> sets the port number used by the application to receive messages.</li>
<li><code>-outport number</code> sets the port number used by the application to transmit messages.</li>
<li><code>-errport number</code> sets the port number used by the application to transmit error messages.</li>
<li><code>-desthost host</code> sets the destination host for the messages sent by the application.</li>
<li><code>-xmit 0|1|2</code> turns transmission OFF, ALL, or ALIAS (default OFF). When transmission is OFF, input elements can be controlled using their addresses or aliases (if present). When transmission is ALL, input elements can be controlled using their addresses or aliases (if present), user’s actions and output elements (i.e., <code>bargraph</code>, etc.) are transmitted as OSC messages as well as aliases (if present). When transmission is ALIAS, input elements can only be controlled using their aliases, user’s actions and output elements are transmitted as aliases only.</li>
<li><code>-xmitfilter path</code> allows to filter output messages. Note that <code>path</code> can be a regular expression (like <code>/freeverb/Reverb1/*</code>).</li>
</ul>
<p>For example:</p>
<pre><code>./noise -xmit 1 -desthost 192.168.1.104 -outport 6000</code></pre>
<p>will run <code>noise</code> with transmission mode ON, using <code>192.168.1.104</code> on port <code>6000</code> as destination.</p>
<h2 id="automatic-port-allocation">Automatic Port Allocation</h2>
<p>In order to address each application individually, only one application can be listening on a single port at one time. Therefore when the default incoming port 5510 is already opened by some other application, an application will automatically try increasing port numbers until it finds an available port. Let say that we start <code>noise</code> and <code>mixer</code> (two Faust-generated applications with OSC support) on the same machine, we’ll get the following:</p>
<pre><code>$ ./noise &amp;
...
Faust OSC version 0.93 application &#39;noise&#39; is running on UDP ports 5510, 5511, 5512
$ ./mixer
...
Faust OSC version 0.93 application &#39;mixer&#39; is running on UDP ports 5513, 5511, 5512</code></pre>
<p>The <code>mixer</code> application fails to open the default incoming port <code>5510</code> because it is already opened by <code>noise</code>. Therefore it tries to find an available port starting from <code>5513</code> and opens it. Please note that the two outcoming ports <code>5511</code> and <code>5512</code> are shared by all running applications.</p>
<h2 id="discovering-osc-applications">Discovering OSC Applications</h2>
<p>The commands <code>oscsend</code> and <code>oscdump</code> from the liblo package provide a convenient mean to experiment with OSC control and potentially debug applications with OSC support.</p>
<blockquote>
<p><code>oscsend [hostname] [port] [address] [types] [values]</code>: sends OSC messages via UDP. <code>[types]</code> is a string, the letters indicates the type of the following values: <code>i=integer</code>, <code>f=float</code>, <code>s=string</code>, etc.</p>
</blockquote>
<blockquote>
<p><code>oscdump [port]</code>: receives OSC messages via UDP and dump to standard output</p>
</blockquote>
<blockquote>
<p>Note that OSC messages can be sent from any OSC-compatible applications (e.g., PureData, Max/MSP, etc.).</p>
</blockquote>
<p>In the following examples, we’ll use two separate terminal windows. The first one will be used to send OSC messages to the <code>noise</code> application using <code>oscsend</code>. The second terminal will be used to monitor the messages sent by the application using <code>oscdump</code>. Commands executed on terminal 1 will be preceded by <code>T1$</code>. Messages received on terminal 2 will be preceded by <code>T2:</code>. To monitor on terminal T2 the OSC messages received on UDP port 5511, <code>oscdump</code> will be used:</p>
<pre><code>T2$ oscdump 5511</code></pre>
<p>Once set we can use the <code>hello</code> message to scan UDP ports for Faust applications. For example:</p>
<pre><code>T1$ oscsend localhost 5510 &quot;/*&quot; s hello</code></pre>
<p>gives us the root message address, the network and the UDP ports used by the noise application:</p>
<pre><code>T2: /noise siii &quot;192.168.1.102&quot; 5510 5511 5512</code></pre>
<h2 id="discovering-the-osc-interface-of-an-application">Discovering the OSC Interface of an Application</h2>
<p>The OSC interface of an application (the set of OSC messages we can use to control it) can be discovered by sending the <code>get</code> message to the root:</p>
<pre><code>T1$ oscsend localhost 5510 /noise s get </code></pre>
<p>As an answer to this OSC message, a full description is printed in terminal T2:</p>
<pre><code>T2: /noise sF &quot;xmit&quot; #F
T2: /noise ss &quot;desthost&quot; &quot;127.0.0.1&quot;
T2: /noise si &quot;outport&quot; 5511
T2: /noise si &quot;errport&quot; 5512
T2: /noise/level fff 0.000000 0.000000 1.000000</code></pre>
<p>The root of the OSC interface is <code>/noise</code>. Transmission is OFF, <code>xmit</code> is set to false. The destination host for sending messages is <code>127.0.0.1</code>, the output port is <code>5511</code> and the error port is <code>5512</code>. The application has only one user interface element: <code>/noise/level</code> with current value <code>0.0</code>, minimal value <code>0.0</code> and maximal value <code>1.0</code>.</p>
<h2 id="widgets-osc-address">Widget’s OSC Address</h2>
<p>Each widget of an application has a unique OSC address obtained by concatenating the labels of it’s surrounding groups with its own label.</p>
<blockquote>
<p>There are potential conflicts between widget’s labels and the OSC address space. An OSC symbolic name is an ASCII string consisting of a restricted set of printable characters. Therefore to ensure compatibility spaces are replaced by underscores and some other characters (asterisk, comma, forward, question mark, open bracket, close bracket, open curly brace, close curly brace) are replaced by hyphens.</p>
</blockquote>
<p>Here is as an example <a href="misc/mix4.dsp"><code>mix4.dsp</code></a>, a very simplified monophonic audio mixer with 4 inputs and one output. For each input we have a mute button and a level slider:</p>
<div class="faust-run"><a href="img/src/exfaust123/exfaust123-svg/process.svg" target="_blank"><img src="img/src/exfaust123/exfaust123-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>input(v) = vgroup(&quot;input %v&quot;, *(1-checkbox(&quot;mute&quot;)) : *(vslider(&quot;level&quot;, 0, 0, 1, 0.01)));
process = hgroup(&quot;mixer&quot;, par(i, 4, input(i)) :&gt; _);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust123/exfaust123.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>If we query this application:</p>
<pre><code>T1$ oscsend localhost 5510 &quot;/*&quot; s get </code></pre>
<p>We get a full description of its OSC interface on terminal T2:</p>
<pre><code>T2: /mixer sF &quot;xmit&quot; #F
T2: /mixer ss &quot;desthost&quot; &quot;127.0.0.1&quot;
T2: /mixer si &quot;outport&quot; 5511
T2: /mixer si &quot;errport&quot; 5512
T2: /mixer/input_0/level fff 0.0000 0.0000 1.0000
T2: /mixer/input_0/mute  fff 0.0000 0.0000 1.0000
T2: /mixer/input_1/level fff 0.0000 0.0000 1.0000
T2: /mixer/input_1/mute  fff 0.0000 0.0000 1.0000
T2: /mixer/input_2/level fff 0.0000 0.0000 1.0000
T2: /mixer/input_2/mute  fff 0.0000 0.0000 1.0000
T2: /mixer/input_3/level fff 0.0000 0.0000 1.0000
T2: /mixer/input_3/mute  fff 0.0000 0.0000 1.0000</code></pre>
<p>As we can see, each widget has a unique OSC address obtained by concatenating the top level group label “mixer,” with the “input” group label and the widget label (see the <a href="labels-as-pathnames">Labels as Pathnames Section</a>). Please, note that blank spaces are replaced by underscores and metadata are removed during this operation.</p>
<p>All addresses must have a common root. This is the case in our example because there is a unique horizontal group <code>mixer</code> containing all widgets. If a common root is missing as in the following code:</p>
<pre><code>input(v) = vgroup(&quot;input %v&quot;, *(1-checkbox(&quot;mute&quot;)) : *(vslider(&quot;level&quot;, 0, 0, 1, 0.01)));
process = par(i, 4, input(i)) :&gt; _;</code></pre>
<p>then a default vertical group is automatically create by the Faust compiler using the name of the file <code>mix4</code> as label:</p>
<!-- TODO: is this still true? -->
<pre><code>T2: /mix4 sF &quot;xmit&quot; #F
T2: /mix4 ss &quot;desthost&quot; &quot;127.0.0.1&quot;
T2: /mix4 si &quot;outport&quot; 5511
T2: /mix4 si &quot;errport&quot; 5512
T2: /mix4/input_0/level fff 0.0000 0.0000 1.0000
T2: /mix4/input_0/mute  fff 0.0000 0.0000 1.0000
T2: /mix4/input_1/level fff 0.0000 0.0000 1.0000
T2: /mix4/input_1/mute  fff 0.0000 0.0000 1.0000
T2: /mix4/input_2/level fff 0.0000 0.0000 1.0000
T2: /mix4/input_2/mute  fff 0.0000 0.0000 1.0000
T2: /mix4/input_3/level fff 0.0000 0.0000 1.0000
T2: /mix4/input_3/mute  fff 0.0000 0.0000 1.0000</code></pre>
<h2 id="controlling-the-application-via-osc">Controlling the Application Via OSC</h2>
<p>Any user interface element of the application can be controlled by sending one of the previously discovered messages/addresses. For example, to set the noise level of the application to <code>0.2</code> the following message can be sent:</p>
<pre><code>T1$ oscsend localhost 5510 /noise/level f 0.2</code></pre>
<p>If we now query <code>/noise/level</code> we get, as expected, the value <code>0.2</code>:</p>
<pre><code>T1$ oscsend localhost 5510 /noise/level s get
T2: /noise/level fff 0.2000 0.0000 1.0000</code></pre>
<h2 id="turning-transmission-on">Turning Transmission ON</h2>
<p>The <code>xmit</code> message at the root level is used to control the realtime transmission of OSC messages corresponding to user interface’s actions. For example:</p>
<pre><code>T1$ oscsend localhost 5510 /noise si xmit 1</code></pre>
<p>turns transmission in <code>ALL</code> mode. Now if we move the level slider we get a bunch of messages:</p>
<pre><code>T2: /noise/level f 0.024000
T2: /noise/level f 0.032000
T2: /noise/level f 0.105000
T2: /noise/level f 0.250000
T2: /noise/level f 0.258000
T2: /noise/level f 0.185000
T2: /noise/level f 0.145000
T2: /noise/level f 0.121000
T2: /noise/level f 0.105000
T2: /noise/level f 0.008000
T2: /noise/level f 0.000000</code></pre>
<p>This feature can be typically used for automation to record and replay actions on the user interface, or to remote control from one application to another. It can be turned OFF any time using:</p>
<pre><code>T1$ oscsend localhost 5510 /noise si xmit 0</code></pre>
<p>Use the ALIAS (<code>xmit = 2</code>) mode if you need to restrict the access to your program: when the ALIAS mode is used, only aliases of input elements (sliders, buttons…) can be used to control them, and output elements (bargraph) will only emit on their aliases.</p>
<h2 id="filtering-osc-messages">Filtering OSC Messages</h2>
<p>When the transmission of OSC messages is ON, all the user interface elements are sent through the OSC connection.</p>
<pre><code>T2: /harpe/level f 0.024000
T2: /harpe/hand f 0.1
T2: /harpe/level f 0.024000
T2: /harpe/hand f 0.25
T2: /harpe/level f 0.024000
T2: /harpe/hand f 0.44
T2: /noise/level f 0.145000
T2: /harpe/hand f 0.78
T2: /noise/level f 0.145000
T2: /harpe/hand f 0.99</code></pre>
<p>We can choose to filter unwanted parameters (or group of parameters). For example:</p>
<pre><code>T1$ oscsend localhost 5510 /harpe si xmit 1 xmitfilter /harpe/level</code></pre>
<p>As a result, we will receive:</p>
<pre><code>T2: /harpe/hand f 0.1
T2: /harpe/hand f 0.25
T2: /harpe/hand f 0.44
T2: /harpe/hand f 0.78</code></pre>
<p>To reset the filter, send:</p>
<pre><code>T1$ oscsend localhost 5510 /harpe si xmit 1 xmitfilter</code></pre>
<h2 id="using-osc-aliases">Using OSC Aliases</h2>
<p>Aliases are a convenient mechanism to control a Faust application from a preexisting set of OSC messages.</p>
<p>Let’s say we want to control our previous noise example with <a href="https://hexler.net/software/touchosc-android">TouchOSC</a> on Android. The first step is to configure the TouchOSC host to <code>192.168.1.102</code> (the host running our noise application) and outgoing port to <code>5510</code>.</p>
<p>Then we can use <code>oscdump 5510</code> (after quitting the noise application in order to free port <code>5510</code>) to visualize the OSC messages sent by TouchOSC. Let’s use for that the left slider of “simple layout”. Here is what we get:</p>
<!-- TODO: not sure about all this: at least we could add a figure with the 
interface but do we even want to use TouchOSC at all? -->
<pre><code>T2: /1/fader1 f 0.000000
T2: /1/fader1 f 0.004975
T2: /1/fader1 f 0.004975
T2: /1/fader1 f 0.008125
T2: /1/fader1 f 0.017473
T2: /1/fader1 f 0.032499
T2: /1/fader1 f 0.051032
T2: ...
T2: /1/fader1 f 0.993289
T2: /1/fader1 f 1.000000</code></pre>
<p>We can associate this OSC message to the noise level slider by inserting the metadata <code>[osc:/1/fader1 0 1]</code> into the slider’s label:</p>
<blockquote>
<p>Several osc aliases can be inserted into a single label allowing the same widget to be controlled by several OSC messages</p>
</blockquote>
<pre><code>import(&quot;stdfaust.lib&quot;);
process = no.noise*hslider(&quot;level[osc:/1/fader1 0 1]&quot;,0,0,1,0.01);</code></pre>
<p>Because the range of <code>/1/fader1</code> is 0 to 1 (like the level slider), we can remove the range mapping information and write simply :</p>
<pre><code>import(&quot;stdfaust.lib&quot;);
process = no.noise*hslider(&quot;level[osc:/1/fader1]&quot;,0,0,1,0.01);</code></pre>
<p>TouchOSC can also send accelerometer data by enabling <code>Settings/Options/Accelerometer</code>. Using again <code>oscdump 5510</code> we can visualize the messages sent by TouchOSC:</p>
<pre><code>T2: ...
T2: /accxyz fff -0.147842 0.019752 9.694721
T2: /accxyz fff -0.157419 0.016161 9.686341
T2: /accxyz fff -0.167594 0.012570 9.683948
T2: ...</code></pre>
<p>As we can see, TouchOSC sends the x, y and z accelerometers in a single message, as a triplet of values ranging approximately from -9.81 to 9.81. In order to select the appropriate accelerometer, we need to concatenate to <code>/accxyz</code> a suffix <code>/0</code>, <code>/1</code> or <code>/2</code>. For example <code>/accxyz/0</code> will correspond to x, <code>/accxyz/1</code> to y, etc. We also need to define a mapping because the ranges are different:</p>
<pre><code>import(&quot;stdfaust.lib&quot;);
process = no.noise * hslider(&quot;level[osc:/accxyz/0 0 9.81]&quot;,0,0,1,0.01);</code></pre>
<table>
<thead>
<tr class="header">
<th><strong>alias</strong></th>
<th><strong>description</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>[osc:/1/rotary1 0 1]</code></td>
<td>top left rotary knob</td>
</tr>
<tr class="even">
<td><code>[osc:/1/rotary2 0 1]</code></td>
<td>middle left rotary knob</td>
</tr>
<tr class="odd">
<td><code>[osc:/1/rotary3 0 1]</code></td>
<td>bottom left rotary knob</td>
</tr>
<tr class="even">
<td><code>[osc:/1/push1 0 1]</code></td>
<td>bottom left push button</td>
</tr>
<tr class="odd">
<td><code>[osc:/1/push2 0 1]</code></td>
<td>bottom center left push button</td>
</tr>
<tr class="even">
<td><code>[osc:/1/toggle1 0 1]</code></td>
<td>top center left toggle button</td>
</tr>
<tr class="odd">
<td><code>[osc:/1/toggle2 0 1]</code></td>
<td>middle center left toggle button</td>
</tr>
<tr class="even">
<td><code>[osc:/1/fader1 0 1]</code></td>
<td>center left vertical fader</td>
</tr>
<tr class="odd">
<td><code>[osc:/1/toggle3 0 1]</code></td>
<td>top center right toggle button</td>
</tr>
<tr class="even">
<td><code>[osc:/1/toggle4 0 1]</code></td>
<td>middle center right toggle button</td>
</tr>
<tr class="odd">
<td><code>[osc:/1/fader2 0 1]</code></td>
<td>center right vertical toggle button</td>
</tr>
<tr class="even">
<td><code>[osc:/1/rotary4 0 1]</code></td>
<td>top right rotary knob</td>
</tr>
<tr class="odd">
<td><code>[osc:/1/rotary5 0 1]</code></td>
<td>middle right rotary knob</td>
</tr>
<tr class="even">
<td><code>[osc:/1/rotary6 0 1]</code></td>
<td>bottom right rotary knob</td>
</tr>
<tr class="odd">
<td><code>[osc:/1/push3 0 1]</code></td>
<td>bottom center right push button</td>
</tr>
<tr class="even">
<td><code>[osc:/1/push4 0 1]</code></td>
<td>bottom right push button</td>
</tr>
<tr class="odd">
<td><code>[osc:/1/fader3 0 1]</code></td>
<td>bottom horizontal fader</td>
</tr>
<tr class="even">
<td><code>[osc:/accxyz/0 -10 10]</code></td>
<td><span class="math inline">\(x\)</span> accelerometer</td>
</tr>
<tr class="odd">
<td><code>[osc:/accxyz/1 -10 10]</code></td>
<td><span class="math inline">\(y\)</span> accelerometer</td>
</tr>
<tr class="even">
<td><code>[osc:/accxyz/2 -10 10]</code></td>
<td><span class="math inline">\(z\)</span> accelerometer</td>
</tr>
</tbody>
</table>
<div style="text-align: center;">
<p><strong><em>Examples of OSC Message Aliases for TouchOSC (Layout Mix2).</em></strong></p>
</div>
<h2 id="osc-cheat-sheet">OSC Cheat Sheet</h2>
<h3 id="default-ports">Default Ports</h3>
<table>
<thead>
<tr class="header">
<th>Port</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>5510</code></td>
<td>default listening port</td>
</tr>
<tr class="even">
<td><code>5511</code></td>
<td>default transmission port</td>
</tr>
<tr class="odd">
<td><code>5512</code></td>
<td>default error port</td>
</tr>
<tr class="even">
<td><code>5513</code></td>
<td>alternative listening ports</td>
</tr>
</tbody>
</table>
<h3 id="command-line-options">Command Line Options</h3>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-port n</code></td>
<td>set the port number used by the application to receive messages</td>
</tr>
<tr class="even">
<td><code>-outport n</code></td>
<td>set the port number used by the application to transmit messages</td>
</tr>
<tr class="odd">
<td><code>-errport n</code></td>
<td>set the port number used by the application to transmit error messages</td>
</tr>
<tr class="even">
<td><code>-desthost h</code></td>
<td>set the destination host for the messages sent by the application</td>
</tr>
<tr class="odd">
<td><code>-xmit 0|1|2</code></td>
<td>turn transmission OFF, ALL or ALIAS (default OFF)</td>
</tr>
<tr class="even">
<td><code>-xmitfilter s</code></td>
<td>filter the Faust paths at emission time</td>
</tr>
</tbody>
</table>
<h3 id="discovery-messages">Discovery Messages</h3>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Message</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>oscsend host port &quot;/*&quot; s hello</code></td>
<td>discover if any OSC application is listening on port <em>p</em></td>
</tr>
<tr class="even">
<td><code>oscsend host port &quot;/*&quot; s get</code></td>
<td>query OSC interface of application listening on port <em>p</em></td>
</tr>
</tbody>
</table>
<h3 id="control-messages">Control Messages</h3>
<table>
<thead>
<tr class="header">
<th>Message</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>oscsend host port &quot;/*&quot; si xmit 0|1|2</code></td>
<td>set transmission mode</td>
</tr>
<tr class="even">
<td><code>oscsend host port widget s get</code></td>
<td>get widget’s value</td>
</tr>
<tr class="odd">
<td><code>oscsend host port widget f v</code></td>
<td>set widget’s value</td>
</tr>
</tbody>
</table>
<h3 id="alias">Alias</h3>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Alias</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>&quot;...[osc: address lo  hi ]...&quot;</code></td>
<td>alias with <span class="math inline">\(lo \rightarrow min\)</span>, <span class="math inline">\(hi \rightarrow max\)</span> mapping</td>
</tr>
<tr class="even">
<td><code>&quot;...[osc:' address]...&quot;</code></td>
<td>alias with <em>min</em>, <em>max</em> clipping</td>
</tr>
</tbody>
</table>
<h1 id="http-support">HTTP Support</h1>
<p>Similarly to OSC, several Faust architectures also provide HTTP support. This allows Faust applications to be remotely controlled from any Web browser using specific URLs. Moreover OSC and HTTPD can be freely combined.</p>
<p>While OSC support is installed by default when Faust is built, this is not the case for HTTP. That’s because it depends on the GNU <em>libmicrohttpd</em> library which is usually not installed by default on the system. An additional <code>make httpd</code> step is therefore required when compiling and installing Faust:</p>
<pre><code>make httpd
make
sudo make install</code></pre>
<p>Note that <code>make httpd</code> will fail if <em>libmicrohttpd</em> is not available on the system.</p>
<p>HTTP support can be added to any Faust program (as long as the target architecture supports it: see tables below) simply by adding the <code>[http:on]</code> metadata to the <a href="#standard-metadata">standard <code>option</code> metadata</a>:</p>
<pre><code>declare options &quot;[http:on]&quot;;</code></pre>
<p>The following tables lists Faust’s architectures providing HTTP support:</p>
<table>
<thead>
<tr class="header">
<th>Audio System</th>
<th>Environment</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Alsa</td>
<td>GTK, Qt, Console</td>
</tr>
<tr class="even">
<td>Jack</td>
<td>GTK, Qt, Console</td>
</tr>
<tr class="odd">
<td>Netjack</td>
<td>GTK, Qt, Console</td>
</tr>
<tr class="even">
<td>PortAudio</td>
<td>GTK, Qt</td>
</tr>
</tbody>
</table>
<div style="text-align: center;">
<p><strong><em>Linux Faust Architectures with HTTP Support</em></strong></p>
</div>
<hr />
<table>
<thead>
<tr class="header">
<th>Audio System</th>
<th>Environment</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CoreAudio</td>
<td>Qt</td>
</tr>
<tr class="even">
<td>Jack</td>
<td>Qt, Console</td>
</tr>
<tr class="odd">
<td>Netjack</td>
<td>Qt, Console</td>
</tr>
<tr class="even">
<td>PortAudio</td>
<td>Qt</td>
</tr>
</tbody>
</table>
<div style="text-align: center;">
<p><strong><em>OSX Faust Architectures with HTTP Support</em></strong></p>
</div>
<hr />
<table>
<thead>
<tr class="header">
<th>Audio System</th>
<th>Environment</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Jack</td>
<td>Qt, Console</td>
</tr>
<tr class="even">
<td>PortAudio</td>
<td>Qt</td>
</tr>
</tbody>
</table>
<div style="text-align: center;">
<p><strong><em>Windows Faust Architectures with HTTP Support</em></strong></p>
</div>
<hr />
<h2 id="a-simple-example">A Simple Example</h2>
<p>To illustrate how HTTP support works, let’s reuse our previous <a href="misc/mix4.dsp"><code>mix4.dsp</code></a> example, a simple monophonic audio mixer with 4 inputs and one output. For each input we have a mute button and a level slider:</p>
<div class="faust-run"><a href="img/src/exfaust124/exfaust124-svg/process.svg" target="_blank"><img src="img/src/exfaust124/exfaust124-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>input(v) = vgroup(&quot;input %v&quot;, *(1-checkbox(&quot;mute&quot;)) : *(vslider(&quot;level&quot;, 0, 0, 1, 0.01)));
process  = hgroup(&quot;mixer&quot;, par(i, 4, input(i)) :&gt; _);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust124/exfaust124.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>This example can be compiled as a standalone Jack QT application with HTTP support using the command:</p>
<pre><code>faust2jaqt -httpd mix4.dsp</code></pre>
<p>The <code>-httpd</code> option embeds a small Web server into the generated application. Its purpose is to serve an HTML page implementing the interface of the app. This page makes use of JavaScript and SVG, and is quite similar to the native QT interface.</p>
<p>When the application is started from the command line:</p>
<pre><code>./mix4 </code></pre>
<p>various information are printed on the standard output, including:</p>
<pre><code>Faust httpd server version 0.73 is running on TCP port 5510</code></pre>
<p>As we can see, the embedded Web server is running by default on TCP port 5510. The entry point is <a href="http://localhost:5510" class="uri">http://localhost:5510</a>. It can be open from any recent browser and it produces the page presented in the figure below:</p>
<p><img src="img/mix4-http.png" class="mx-auto d-block" width="70%"></p>
<h2 id="json-description-of-the-user-interface">JSON Description of the User Interface</h2>
<p>The communication between the application and the Web browser is based on several underlying URLs. The first one is <a href="http://localhost:5510/JSON" class="uri">http://localhost:5510/JSON</a> that returns a JSON description of the user interface of the application. This JSON description is used internally by the JavaScript code to build the graphical user interface. Here is (part of) the json returned by <code>mix4</code>:</p>
<pre><code>{
  &quot;name&quot;: &quot;mix4&quot;,
  &quot;address&quot;: &quot;YannAir.local&quot;,
  &quot;port&quot;: &quot;5511&quot;,
  &quot;ui&quot;: [
    {
      &quot;type&quot;: &quot;hgroup&quot;,
      &quot;label&quot;: &quot;mixer&quot;,
      &quot;items&quot;: [
        {
          &quot;type&quot;: &quot;vgroup&quot;,
          &quot;label&quot;: &quot;input_0&quot;,
          &quot;items&quot;: [
            {
              &quot;type&quot;: &quot;vslider&quot;,
              &quot;label&quot;: &quot;level&quot;,
              &quot;address&quot;: &quot;/mixer/input_0/level&quot;,
              &quot;init&quot;: &quot;0&quot;, &quot;min&quot;: &quot;0&quot;, &quot;max&quot;: &quot;1&quot;, 
              &quot;step&quot;: &quot;0.01&quot;
            },
            {
              &quot;type&quot;: &quot;checkbox&quot;,
              &quot;label&quot;: &quot;mute&quot;,
              &quot;address&quot;: &quot;/mixer/input_0/mute&quot;,
              &quot;init&quot;: &quot;0&quot;, &quot;min&quot;: &quot;0&quot;, &quot;max&quot;: &quot;0&quot;, 
              &quot;step&quot;: &quot;0&quot;
            }
          ]
        },
        
        ...
        
      ]
    }
  ]
}</code></pre>
<h2 id="querying-the-state-of-the-application">Querying the State of the Application</h2>
<p>Each widget has a unique “address” field that can be used to query its value. In our example here the level of the input 0 has the address <code>/mixer/input_0/level</code>. The address can be used to forge a URL to get the value of the widget: <a href="http://localhost:5510/mixer/input_0/level" class="uri">http://localhost:5510/mixer/input_0/level</a>, resulting in:</p>
<pre><code>/mixer/input_0/level 0.00000  </code></pre>
<p>Multiple widgets can be queried at once by using an address higher in the hierarchy. For example to get the values of the level and the mute state of input 0 we use <a href="http://localhost:5510/mixer/input_0" class="uri">http://localhost:5510/mixer/input_0</a>, resulting in:</p>
<pre><code>/mixer/input_0/level 0.00000 
/mixer/input_0/mute  0.00000 </code></pre>
<p>To get the all the values at once we simply use <a href="http://localhost:5510/mixer" class="uri">http://localhost:5510/mixer</a>, resulting in:</p>
<pre><code>/mixer/input_0/level 0.00000 
/mixer/input_0/mute  0.00000 
/mixer/input_1/level 0.00000 
/mixer/input_1/mute  0.00000 
/mixer/input_2/level 0.00000 
/mixer/input_2/mute  0.00000 
/mixer/input_3/level 0.00000 
/mixer/input_3/mute  0.00000 </code></pre>
<h2 id="changing-the-value-of-a-widget">Changing the Value of a Widget</h2>
<p><img src="img/mix4-http-mute.png" class="mx-auto d-block" width="70%"></p>
<p>Let’s say that we want to mute input 1 of our mixer. For that purpose, we can use the URL <a href="http://localhost:5510/mixer/input_1/mute?value=1" class="uri">http://localhost:5510/mixer/input_1/mute?value=1</a> obtained by concatenating <code>?value=1</code> at the end of the widget URL.</p>
<p>All widgets can be controlled in a similar way. For example <a href="http://localhost:5510/mixer/input_3/level?value=0.7" class="uri">http://localhost:5510/mixer/input_3/level?value=0.7</a> will set the input 3 level to 0.7.</p>
<h2 id="proxy-control-access-to-the-web-server">Proxy Control Access to the Web Server</h2>
<p>A control application may want to access and control the running DSP using its Web server, but without using the delivered HTML page in a browser. Since the complete JSON can be retrieved, control applications can be purely developed in C/C++. A <em>proxy</em> version of the user interface can then be built, and parameters can be “set and get” using HTTP requests.</p>
<p>This mode can be started dynamically using the <code>-server URL</code> parameter. Assuming an application with HTTP support is running remotely at the given URL, the control application will fetch its JSON description, use it to dynamically build the user interface, and allow for the access of the remote parameters.</p>
<h2 id="http-cheat-sheet">HTTP Cheat Sheet</h2>
<p>Here is a summary of the various URLs used to interact with the application’s Web server.</p>
<h3 id="default-ports-1">Default Ports</h3>
<table>
<thead>
<tr class="header">
<th>Port</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>5510</code></td>
<td>default TCP port used by the application’s Web server</td>
</tr>
<tr class="even">
<td><code>5511...</code></td>
<td>alternative TCP ports</td>
</tr>
</tbody>
</table>
<h3 id="command-line-options-1">Command Line Options</h3>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-port n</code></td>
<td>set the TCP port number used by the application’s Web server</td>
</tr>
<tr class="even">
<td><code>-server URL</code></td>
<td>start a proxy control application accessing the remote application running on the given URL</td>
</tr>
</tbody>
</table>
<h3 id="urls">URLs</h3>
<table>
<thead>
<tr class="header">
<th>URL</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>http://host:port</code></td>
<td>the base URL to be used in proxy control access mode</td>
</tr>
<tr class="even">
<td><code>http://host:port/JSON</code></td>
<td>get a json description of the user interface</td>
</tr>
<tr class="odd">
<td><code>http://host:port/address</code></td>
<td>get the value of a widget or a group of widgets</td>
</tr>
<tr class="even">
<td><code>http://host:port/address?value=v</code></td>
<td>set the value of a widget to <code>v</code></td>
</tr>
</tbody>
</table>
<h3 id="json">JSON</h3>
<p><strong>Top Level</strong></p>
<p>The JSON describes the name, host, and port of the application and a hierarchy of user interface items:</p>
<pre><code>{
  &quot;name&quot;: &lt;name&gt;,
  &quot;address&quot;: &lt;host&gt;,
  &quot;port&quot;: &lt;port&gt;,
  &quot;ui&quot;: [ &lt;item&gt; ]
}</code></pre>
<p>An <code>&lt;item&gt;</code> is either a group (of items) or a widget.</p>
<p><strong>Groups</strong></p>
<p>A group is essentially a list of items with a specific layout:</p>
<pre><code>{
    &quot;type&quot;: &lt;type&gt;,
    &quot;label&quot;: &lt;label&gt;,
    &quot;items&quot;: [ &lt;item&gt;, &lt;item&gt;,...]
}</code></pre>
<p>The <code>&lt;type&gt;</code> defines the layout. It can be either <code>&quot;vgroup&quot;</code>, <code>&quot;hgroup&quot;</code> or <code>&quot;tgroup&quot;</code></p>
<p><strong>Widgets</strong></p>
<pre><code>{
    &quot;type&quot;: &lt;type&gt;,
    &quot;label&quot;: &lt;label&gt;,
    &quot;address&quot;: &lt;address&gt;,
    &quot;meta&quot;: [ { &quot;key&quot;: &quot;value&quot;},... ],
    &quot;init&quot;: &lt;num&gt;,
    &quot;min&quot;: &lt;num&gt;,
    &quot;max&quot;: &lt;num&gt;,
    &quot;step&quot;: &lt;num&gt;
},</code></pre>
<p>Widgets are the basic items of the user interface. They can be of different <code>&lt;type&gt;</code>: <code>&quot;button&quot;</code>, <code>&quot;checkbox&quot;</code>, <code>&quot;nentry&quot;</code>, <code>&quot;vslider&quot;</code>, <code>&quot;hslider&quot;</code>, <code>&quot;vbargraph&quot;</code> or <code>&quot;hbargraph&quot;</code>.</p>
<h1 id="midi-and-polyphony-support">MIDI and Polyphony Support</h1>
<!-- TODO: something should be said about MIDI channels -->
<p>Similarly to <a href="#osc-support">OSC</a>, several Faust architectures also provide MIDI support. This allows Faust applications to be controlled from any MIDI device (or to control MIDI devices). MIDI is also the preferable way to control Polyphonic instruments.</p>
<!-- TODO: more about link between MIDI and polyphony in general -->
<h2 id="configuring-midi-in-faust">Configuring MIDI in Faust</h2>
<p>MIDI support can be added to any Faust program (as long as the target architecture supports it: see tables below) simply by adding the <code>[midi:on]</code> metadata to the <a href="#standard-metadata">standard <code>option</code> metadata</a>:</p>
<pre><code>declare options &quot;[midi:on]&quot;;</code></pre>
<!-- TODO: the tables indicating which architectures implement MIDI support
should be placed here. -->
<p>MIDI control is configured in Faust using <a href="#ui-label-metadata">metadata</a> in <a href="#user-interface-primitives-and-configuration">UI elements</a>. They are decoded by a special architecture that parses incoming MIDI messages and updates the appropriate control parameters, or send MIDI messages when the UI elements (i.e., sliders, buttons, etc.) are moved.</p>
<p>All MIDI configuration metadata in Faust follow the following format:</p>
<pre><code>[midi:xxx yyy...]</code></pre>
<p>This section provides a list of the most common metadata that can be used to configure of the MIDI behavior of a Faust program.</p>
<blockquote>
<p>Below, when a 7-bit MIDI parameter is used to drive a <a href="#button-primitive">button</a> or a <a href="#checkbox-primitive">checkbox</a>, its maximum value (127) maps to 1 (“on”) while its minimum value (0) maps to 0 (“off”).</p>
</blockquote>
<h3 id="midictrl-num-metadata"><code>[midi:ctrl num]</code> Metadata</h3>
<p>The <code>[midi:ctrl num]</code> metadata assigns MIDI CC (control) to a specific UI element. When used in a slider or a bargraph, this metadata will map the UI element value to the {0, 127} range. When used with a button or a checkbox, 1 will be mapped to 127, 0 will be mapped to 0.</p>
<p><strong>Usage</strong></p>
<pre><code>toto = hslider(&quot;toto[midi:ctrl num]&quot;,...);</code></pre>
<p>Where:</p>
<ul>
<li><code>num</code>: the MIDI CC number</li>
</ul>
<p><strong>Example</strong></p>
<p>In the following example, the frequency of a sawtooth wave oscillator is controlled by MIDI CC 11. When CC11=0, then the frequency is 200Hz, when CC11=127, then the frequency is 1000Hz.</p>
<div class="faust-run"><a href="img/src/exfaust125/exfaust125-svg/process.svg" target="_blank"><img src="img/src/exfaust125/exfaust125-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freq = hslider(&quot;frequency[midi:ctrl 11]&quot;,200,50,1000,0.01) : si.smoo;
process = os.sawtooth(freq);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust125/exfaust125.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h3 id="midikeyon-midikey-metadata"><code>[midi:keyon midikey]</code> Metadata</h3>
<p>The <code>[midi:keyon midikey]</code> metadata assigns the velocity value of a key-on MIDI message received on a specific <code>midikey</code> to a Faust parameter. When used in a slider or a bargraph, this metadata will map the UI element value to the {0, 127} range. When used with a button or a checkbox, 1 will be mapped to 127, 0 will be mapped to 0.</p>
<p><strong>Usage</strong></p>
<pre><code>toto = hslider(&quot;toto[midi:keyon midikey]&quot;,...);</code></pre>
<p>Where:</p>
<ul>
<li><code>midikey</code>: the MIDI key number</li>
</ul>
<p><strong>Example</strong></p>
<p>In the following example, the frequency of a sawtooth wave oscillator is controlled by the velocity value received on key 62 when a key-on message is sent. Therefore, the frequency will only be updated when MIDI key 62 is pressed.</p>
<div class="faust-run"><a href="img/src/exfaust126/exfaust126-svg/process.svg" target="_blank"><img src="img/src/exfaust126/exfaust126-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freq = hslider(&quot;frequency[midi:keyon 62]&quot;,200,50,1000,0.01) : si.smoo;
process = os.sawtooth(freq);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust126/exfaust126.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h3 id="midikeyoff-midikey-metadata"><code>[midi:keyoff midikey]</code> Metadata</h3>
<p>The <code>[midi:keyoff midikey]</code> metadata assigns the velocity value of a key-off MIDI message received on a specific <code>midikey</code> to a Faust parameter. When used in a slider or a bargraph, this metadata will map the UI element value to the {0, 127} range. When used with a button or a checkbox, 1 will be mapped to 127, 0 will be mapped to 0.</p>
<p><strong>Usage</strong></p>
<pre><code>toto = hslider(&quot;toto[midi:keyoff midikey]&quot;,...);</code></pre>
<p>Where:</p>
<ul>
<li><code>midikey</code>: the MIDI key number</li>
</ul>
<p><strong>Example</strong></p>
<p>In the following example, the frequency of a sawtooth wave oscillator is controlled by the velocity value received on key 62 when a key-off message is sent. Therefore, the frequency will only be updated when MIDI key 62 is released.</p>
<div class="faust-run"><a href="img/src/exfaust127/exfaust127-svg/process.svg" target="_blank"><img src="img/src/exfaust127/exfaust127-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freq = hslider(&quot;frequency[midi:keyon 62]&quot;,200,50,1000,0.01) : si.smoo;
process = os.sawtooth(freq);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust127/exfaust127.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h3 id="midikey-midikey-metadata"><code>[midi:key midikey]</code> Metadata</h3>
<p>The <code>[midi:key midikey]</code> metadata assigns the velocity value of key-on and key-off MIDI messages received on a specific <code>midikey</code> to a Faust parameter. When used in a slider or a bargraph, this metadata will map the UI element value to the {0, 127} range. When used with a button or a checkbox, 1 will be mapped to 127, 0 will be mapped to 0.</p>
<p><strong>Usage</strong></p>
<pre><code>toto = hslider(&quot;toto[midi:key midikey]&quot;,...);</code></pre>
<p>Where:</p>
<ul>
<li><code>midikey</code>: the MIDI key number</li>
</ul>
<p><strong>Example</strong></p>
<p>In the following example, the frequency of a sawtooth wave oscillator is controlled by the velocity value received on key 62 when key-on and key-off messages are sent. Therefore, the frequency will only be updated when MIDI key 62 is pressed and released.</p>
<div class="faust-run"><a href="img/src/exfaust128/exfaust128-svg/process.svg" target="_blank"><img src="img/src/exfaust128/exfaust128-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freq = hslider(&quot;frequency[midi:key 62]&quot;,200,50,1000,0.01) : si.smoo;
process = os.sawtooth(freq);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust128/exfaust128.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h3 id="midikeypress-midikey-metadata"><code>[midi:keypress midikey]</code> Metadata</h3>
<p>The <code>[midi:keypress midikey]</code> metadata assigns the pressure (after-touch) value of a specific <code>midikey</code> to a Faust parameter. When used in a slider or a bargraph, this metadata will map the UI element value to the {0, 127} range. When used with a button or a checkbox, 1 will be mapped to 127, 0 will be mapped to 0.</p>
<p><strong>Usage</strong></p>
<pre><code>toto = hslider(&quot;toto[midi:keypress midikey]&quot;,...);</code></pre>
<p>Where:</p>
<ul>
<li><code>midikey</code>: the MIDI key number</li>
</ul>
<p><strong>Example</strong></p>
<p>In the following example, the frequency of a sawtooth wave oscillator is controlled by the pressure (after-touch) values received on key 62.</p>
<div class="faust-run"><a href="img/src/exfaust129/exfaust129-svg/process.svg" target="_blank"><img src="img/src/exfaust129/exfaust129-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freq = hslider(&quot;frequency[midi:keypress 62]&quot;,200,50,1000,0.01) : si.smoo;
process = os.sawtooth(freq);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust129/exfaust129.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<!-- TODO: don't understand what those means: check with Stéphane  -->
<!-- 
- \lstinline'[midi:pgm num]' in a slider or bargraph will map the UI element value to the progchange value, so \emph{progchange} message with the same \emph{num} value will be sent. When used with a button or checkbox, 1 will send the \emph{progchange} message with \emph{num} value, 0 will send nothing,

- \lstinline'[midi:chanpress num]' in a slider or bargraph will map the UI element value to the chanpress value, so \emph{chanpress} message with the same \emph{num} value will be sent. When used with a button or checkbox, 1 will send the \emph{chanpress} message with \emph{num} value, 0 will send nothing,
-->
<h3 id="midipitchwheel-metadata"><code>[midi:pitchwheel]</code> Metadata</h3>
<p>The <code>[midi:pitchwheel]</code> metadata assigns the pitch-wheel value to a Faust parameter. When used in a slider or a bargraph, this metadata will map the UI element value to the {0, 16383} range. When used with a button or a checkbox, 1 will be mapped to 16383, 0 will be mapped to 0.</p>
<p><strong>Usage</strong></p>
<pre><code>toto = hslider(&quot;toto[midi:pitchwheel]&quot;,...);</code></pre>
<p><strong>Example</strong></p>
<p>In the following example, the frequency of a sawtooth wave oscillator is controlled by the pitch-wheel.</p>
<div class="faust-run"><a href="img/src/exfaust130/exfaust130-svg/process.svg" target="_blank"><img src="img/src/exfaust130/exfaust130-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freq = hslider(&quot;frequency[midi:pitchwheel]&quot;,200,50,1000,0.01) : si.smoo;
process = os.sawtooth(freq);</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust130/exfaust130.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h3 id="midistart-metadata"><code>[midi:start]</code> Metadata</h3>
<p>When used with a button or a checkbox, <code>[midi:start]</code> will trigger a value of 1 when a <code>start</code> MIDI message is received.</p>
<p><strong>Usage</strong></p>
<pre><code>toto = checkbox(&quot;toto[midi:start]&quot;);</code></pre>
<h3 id="midistop-metadata"><code>[midi:stop]</code> Metadata</h3>
<p>When used with a button or a checkbox, <code>[midi:stop]</code> will trigger a value of 0 when a <code>stop</code> MIDI message is received.</p>
<p><strong>Usage</strong></p>
<pre><code>toto = checkbox(&quot;toto[midi:stop]&quot;);</code></pre>
<h3 id="midiclock-metadata"><code>[midi:clock]</code> Metadata</h3>
<p>When used with a button or a checkbox, <code>[midi:clock]</code> will deliver a sequence of successive 1 and 0 values each time a <code>clock</code> MIDI message is received (seen by Faust code as a square command signal, to be used to compute higher level information).</p>
<p><strong>Usage</strong></p>
<pre><code>toto = checkbox(&quot;toto[midi:clock]&quot;);</code></pre>
<h3 id="midi-sync">MIDI Sync</h3>
<p>MIDI clock-based synchronization can be used to slave a given Faust program using the metadata presented in the 3 past sections.</p>
<p>A typical Faust program will then use the MIDI clock stream to possibly compute the BPM information, or for any synchronization need it may have. Here is a simple example of a sinus generated which a frequency controlled by the MIDI clock stream, and starting/stopping when receiving the MIDI start/stop messages:</p>
<div class="faust-run"><a href="img/src/exfaust131/exfaust131-svg/process.svg" target="_blank"><img src="img/src/exfaust131/exfaust131-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);

// square signal (1/0), changing state at each received clock
clocker = checkbox(&quot;MIDI clock[midi:clock]&quot;);    

// ON/OFF button controlled with MIDI start/stop messages
play = checkbox(&quot;ON/OFF [midi:start] [midi:stop]&quot;);    

// detect front
front(x) = (x-x&#39;) != 0.0;      

// count number of peaks during one second
freq(x) = (x-x@ma.SR) : + ~ _;   
   
process = os.osc(8*freq(front(clocker))) * play;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust131/exfaust131.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="midi-polyphony-support">MIDI Polyphony Support</h2>
<p>Polyphony is conveniently handled in Faust directly by <a href="TODO">Faust Architectures</a>. Note that programming polyphonic instrument completely from scratch in Faust and without relying on architectures is also possible. In fact, this feature is indispensable if complex signal interactions between the different voices have to be described (like sympathetic strings resonance in a physical model, etc.). However, since all voices would always be computed, this approach could be too CPU costly for simpler or more limited needs. In this case describing a single voice in a Faust DSP program and externally combining several of them with a special <em>polyphonic instrument aware</em> architecture file is a better solution. Moreover, this special architecture file takes care of dynamic voice allocation and control MIDI messages decoding and mapping.</p>
<p>Polyphony support can be added to any Faust program (as long as the target architecture supports it) simply by adding the <code>[nvoices:n]</code> metadata to the <a href="#standard-metadata">standard <code>option</code> metadata</a> where <code>n</code> is the maximum number of voices of polyphony to be allocated:</p>
<pre><code>declare options &quot;[nvoices:12]&quot;;</code></pre>
<h3 id="standard-polyphony-parameters">Standard Polyphony Parameters</h3>
<p>Most Faust architectures allow for the implementation of polyphonic instruments simply by using a set of “standard user interface names.” Hence, any Faust program declaring the <code>freq</code>, <code>gain</code>, and <code>gate</code> parameter is polyphony-compatible. These 3 parameters are directly associated to key-on and key-off events and have the following behavior:</p>
<ul>
<li>When a key-on event is received, <code>gate</code> will be set to 1. Inversely, when a key-off event is received, <code>gate</code> will be set to 0. Therefore, <code>gate</code> is typically used to trigger an envelope, etc.</li>
<li><code>freq</code> is a frequency in Hz computed automatically in function of the value of the pitch contained in a key-on or a key-off message.</li>
<li><code>gain</code> is a linear gain (value between 0-1) computed in function of the velocity value contained in a key-on or a key-off message.</li>
</ul>
<p><strong>Example: Simple Polyphonic Synthesizer</strong></p>
<p>In the following example, the standard <code>freq</code>, <code>gain</code>, and <code>gate</code> parameters are used to implement a simple polyphonic synth.</p>
<div class="faust-run"><a href="img/src/exfaust132/exfaust132-svg/process.svg" target="_blank"><img src="img/src/exfaust132/exfaust132-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freq = hslider(&quot;freq&quot;,200,50,1000,0.01);
gain = hslider(&quot;gain&quot;,0.5,0,1,0.01);
gate = button(&quot;gate&quot;);
process = os.sawtooth(freq)*gain*gate;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust132/exfaust132.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<blockquote>
<p>Note that if you execute this code in the <a href="https://faust.grame.fr/editor">Faust online editor</a> with polyphony mode activated, you should be able to control this simple synth with any MIDI keyboard connected to your computer. This will only work if you’re using Google Chrome (most other browsers are not MIDI-compatible).</p>
</blockquote>
<p>The previous example can be slightly improved by adding an envelope generator and controlling it with <code>gain</code> and <code>gate</code>:</p>
<div class="faust-run"><a href="img/src/exfaust133/exfaust133-svg/process.svg" target="_blank"><img src="img/src/exfaust133/exfaust133-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freq = hslider(&quot;freq&quot;,200,50,1000,0.01);
gain = hslider(&quot;gain&quot;,0.5,0,1,0.01);
gate = button(&quot;gate&quot;);
envelope = en.adsr(0.01,0.01,0.8,0.1,gate)*gain;
process = os.sawtooth(freq)*envelope;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust133/exfaust133.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p><strong>Warning:</strong> Note that all the active voices of polyphony are added together without scaling! This means that the previous example will likely click if several voices are played at the same time. It is the Faust programmer’s responsibility to take this into account in his code. For example, assuming that the number of active voices will always be smaller or equal to 4, the following safeguard could be added to the previous example:</p>
<pre><code>process = os.sawtooth(freq)*envelope : /(4);</code></pre>
<h3 id="configuring-and-activating-polyphony">Configuring and Activating Polyphony</h3>
<p>Polyphony can be activated “manually” in some Faust architectures using an option/flag during compilation (e.g., typically <code>-poly</code> or <code>-nvoices</code> in the <a href="TODO">faust2…</a> scripts). That’s also how the <a href="https://faust.grame.fr/editor">Faust online editor</a> works where a button can be used to turn polyphony on or off.</p>
<p>However, the most standard way to activate polyphony in Faust is to declare the <code>[nvoices:n]</code> metadata which allows us to specify the maximum number of voices of polyphony (<code>n</code>) that will be allocated in the generated program.</p>
<p>For example, the Faust program from the previous section could be modified such that:</p>
<div class="faust-run"><a href="img/src/exfaust134/exfaust134-svg/process.svg" target="_blank"><img src="img/src/exfaust134/exfaust134-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare options &quot;[midi:on][nvoices:12]&quot;;
import(&quot;stdfaust.lib&quot;);
freq = hslider(&quot;freq&quot;,200,50,1000,0.01);
gain = hslider(&quot;gain&quot;,0.5,0,1,0.01);
gate = button(&quot;gate&quot;);
envelope = en.adsr(0.01,0.01,0.8,0.1,gate)*gain;
process = os.sawtooth(freq)*envelope;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust134/exfaust134.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<blockquote>
<p>Note that the <code>[midi:on]</code> metadata must also be declared in order to be able to control this program with an external MIDI keyboard.</p>
</blockquote>
<p>which when compiled running (for example):</p>
<pre><code>faust2jaqt faustProgram.dsp</code></pre>
<p>will generate a MIDI-controllable polyphonic synthesizer.</p>
<h3 id="audio-effects-and-polyphonic-synthesizer">Audio Effects and Polyphonic Synthesizer</h3>
<p>While audio audio effects can be added directly to the <code>process</code> line of a Faust synthesizer, for example:</p>
<pre><code>process = os.sawtooth(freq)*envelope : reverb;</code></pre>
<p>it is not a good practice since a new instance of that effect will be created for each active voice of polyphony. The main consequence of this would be an increased CPU cost.</p>
<p>Similarly to <code>process</code>, Faust allows for the declaration of an <code>effect</code> line, which identifies an audio effect to be connected to the output of the polyphonic synthesizer. <code>effect</code> is a standard variable in Faust (just like <code>process</code>).</p>
<p>For example, a simple reverb can be added to the previous example simply by writing:</p>
<div class="faust-run"><a href="img/src/exfaust135/exfaust135-svg/process.svg" target="_blank"><img src="img/src/exfaust135/exfaust135-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare options &quot;[midi:on][nvoices:12]&quot;;
import(&quot;stdfaust.lib&quot;);
freq = hslider(&quot;freq&quot;,200,50,1000,0.01);
gain = hslider(&quot;gain&quot;,0.5,0,1,0.01);
gate = button(&quot;gate&quot;);
envelope = en.adsr(0.01,0.01,0.8,0.1,gate)*gain;
process = os.sawtooth(freq)*envelope &lt;: _,_;
effect = dm.zita_light;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust135/exfaust135.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>In this case, the polyphonic part is based on <code>process</code> and a single instance of the effect defined in <code>effect</code> will be created and shared by all voices.</p>
<p>Note that since <a href="TODO"><code>dm.zita_light</code></a> is a stereo effect, the output of <code>process</code> must be split into 2 signals. Also, be aware that this type of construction wont be visible in the corresponding block diagram that will only show what’s implemented in the <code>process</code> line.</p>
<!-- TODO: in poly mode, effect should automatically activated -->
<h3 id="polyphony-and-continuous-pitch">Polyphony and Continuous Pitch</h3>
<p>Key-on and key-off MIDI messages only send the “base pitch” of the instance of a note. Hence, if only the <code>freq</code> standard parameter is used to control the frequency of the synthesizer, its pitch will always be “quantized” to the nearest semitone. In order to be able to do glissandi, vibrato, etc., a variable associated to the pitch-wheel needs to be declared and must interact with the “base frequency” value retrieved from <code>freq</code> as such:</p>
<pre><code>f = hslider(&quot;freq&quot;,300,50,2000,0.01);
bend = hslider(&quot;bend[midi:pitchwheel]&quot;,1,0,10,0.01);
freq = f*bend; // the &quot;final&quot; freq parameter to be used</code></pre>
<p>The <code>bend</code> variable is controlled by the pitch-wheel thanks to <a href="#midipitchwheel-metadata"><code>[midi:pitchwheel]</code> metadata</a>. <code>bend</code> is used as a factor multiplied to the base frequency retrieved from <code>freq</code>. Therefore, the default value of <code>bend</code> should always be 1 which corresponds to the central position of the pitch wheel (MIDI value 64). A value smaller than 1 will decrease the pitch and a value greater than 1 will increase it.</p>
<p>While the above example will have the expected behavior, it is likely that clicking will happen when changing the value of <code>bend</code> since this parameter is not smoothed. Unfortunately, regular smoothing (through the use of <a href="TODO"><code>si.smoo</code></a>, for example) is not a good option here. This is due to the fact that instances of polyphonic voices are frozen when a voice is not being used. Since the value of <code>bend</code> might jump from one value to another when a voice is being reactivated/reused, continuous smoothing would probably create an “ugly sweep” in that case. Hence, <a href="TODO"><code>si.polySmooth</code></a> should be used in this context instead of <a href="TODO"><code>si.smoo</code></a>. This function shuts down smoothing for a given number of samples when a trigger is activated.</p>
<p>Reusing the example from the previous section, we can implement a click-free polyphonic synthesizer with continuous pitch control:</p>
<div class="faust-run"><a href="img/src/exfaust136/exfaust136-svg/process.svg" target="_blank"><img src="img/src/exfaust136/exfaust136-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare options &quot;[midi:on][nvoices:12]&quot;;
import(&quot;stdfaust.lib&quot;);
f = hslider(&quot;freq&quot;,300,50,2000,0.01);
bend = hslider(&quot;bend[midi:pitchwheel]&quot;,1,0,10,0.01) : si.polySmooth(gate,0.999,1);
gain = hslider(&quot;gain&quot;,0.5,0,1,0.01);
gate = button(&quot;gate&quot;);
freq = f*bend; 
envelope = en.adsr(0.01,0.01,0.8,0.1,gate)*gain;
process = os.sawtooth(freq)*envelope &lt;: _,_;
effect = dm.zita_light;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust136/exfaust136.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Observe the usage of <a href="TODO"><code>si.polySmooth</code></a> here: when <code>gate=0</code> the signal is not smoothed, when <code>gate=1</code> the signal is smoothed with a factor of 0.999 after one sample.</p>
<h3 id="complete-example-sustain-pedal-and-additional-parameters">Complete Example: Sustain Pedal and Additional Parameters</h3>
<p>Just for fun ;), we improve in this section the example from the previous one by implementing sustain pedal control as well as some modulation controlled by the modulation wheel of the MIDI keyboard.</p>
<p>Sustain pedal control can be easily added simply by declaring a sustain parameter controlled by MIDI CC 64 (which is directly linked to the sustain pedal) and interacting with the standard <code>gate</code> parameter:</p>
<pre><code>s = hslider(&quot;sustain[midi:ctrl 64]&quot;,0,0,1,1);
t = button(&quot;gate&quot;);
gate = t+s : min(1);</code></pre>
<p>Hence, <code>gate</code> will remain equal to 1 as long as the sustain pedal is pressed.</p>
<p>The simple synthesizer from the previous section (which is literally just a sawtooth oscillator) can be slightly improved by processing it with a dynamically-controlled lowpass filter:</p>
<div class="faust-run"><a href="img/src/exfaust137/exfaust137-svg/process.svg" target="_blank"><img src="img/src/exfaust137/exfaust137-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare options &quot;[midi:on][nvoices:12]&quot;;
import(&quot;stdfaust.lib&quot;);
f = hslider(&quot;freq&quot;,300,50,2000,0.01);
bend = hslider(&quot;bend[midi:pitchwheel]&quot;,1,0,10,0.01) : si.polySmooth(gate,0.999,1);
gain = hslider(&quot;gain&quot;,0.5,0,1,0.01);
s = hslider(&quot;sustain[midi:ctrl 64]&quot;,0,0,1,1);
cutoff = hslider(&quot;cutoff[midi:ctrl 1]&quot;,1000,50,4000,0.01) : si.smoo;
t = button(&quot;gate&quot;);
freq = f*bend; 
gate = t+s : min(1);
envelope = en.adsr(0.01,0.01,0.8,0.1,gate)*gain;
process = os.sawtooth(freq)*envelope : fi.lowpass(3,cutoff) &lt;: _,_;
effect = dm.zita_light;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust137/exfaust137.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>MIDI CC 1 corresponds to the modulation wheel which is used here to control the cut-off frequency of the lowpass filter.</p>
<!-- Note: the original documentation of polyphony support from the quick 
reference hasn't been integrated to this new doc. We believe that it scares
people more than it helps them. We do think that it would be nice to have a
proper description of the C++ implementation of poly-dsp, but this is the
wrong place for it. -->
<h1 id="mathematical-documentation">Mathematical Documentation</h1>
<p>The Faust compiler provides a mechanism to produce a self-describing documentation of the mathematical semantic of a Faust program, essentially as a pdf file. The corresponding options are <a href="#compilation-options"><code>-mdoc</code> (short) or <code>--mathdoc</code></a> (long).</p>
<h2 id="goals-of-the-mathdoc">Goals of the Mathdoc</h2>
<p>There are three main goals, or uses, of the Faust mathematical documentation generator:</p>
<ul>
<li>to preserve signal processors, independently from any computer language but only under a mathematical form;</li>
<li>to bring some help for debugging tasks, by showing the formulas as they are really computed after the compilation stage;</li>
<li>to give a new teaching support, as a bridge between code and formulas for signal processing.</li>
</ul>
<h2 id="installation-requirements">Installation Requirements</h2>
<ul>
<li><code>faust</code>, of course!</li>
<li><code>svg2pdf</code> (from the Cairo 2D graphics library), to convert block-diagrams, as Latex doesn’t embed SVG directly,</li>
<li><code>breqn</code>, a Latex package to handle automatic breaking of long equations,</li>
<li><code>pdflatex</code>, to compile the Latex output file.</li>
</ul>
<h2 id="generating-the-mathdoc">Generating the Mathdoc</h2>
<p>The easiest way to generate the complete mathematical documentation is to call the <code>faust2mathdoc</code> script on a Faust file, as the <code>-mdoc</code> option leaves the process of generating the documentation unfinished (only the source is produced).</p>
<h3 id="invoking-the--mdoc-option">Invoking the <code>-mdoc</code> Option</h3>
<p>Calling directly <code>faust -mdoc</code> does only the first part of the work, generating:</p>
<ul>
<li>a top-level directory, suffixed with <code>-mdoc</code>,</li>
<li>5 subdirectories (<code>cpp/</code>, <code>pdf/</code>, <code>src/</code>, <code>svg/</code>, <code>tex/</code>),</li>
<li>a Latex file containing the formulas,</li>
<li>SVG files for block-diagrams.</li>
</ul>
<p>At this stage:</p>
<ul>
<li><code>cpp/</code> remains empty,</li>
<li><code>pdf/</code> remains empty,</li>
<li><code>src/</code> contains all the used Faust sources (even libraries),</li>
<li><code>svg/</code> contains SVG block-diagram files,</li>
<li><code>tex/</code> contains the generated Latex file.</li>
</ul>
<h3 id="invoking-faust2mathdoc">Invoking <code>faust2mathdoc</code></h3>
<p>The <code>faust2mathdoc</code> script calls <code>faust --mathdoc</code> first, then it finishes the work:</p>
<ul>
<li>moving the output C++ file into <code>cpp/</code>,</li>
<li>converting all SVG files into pdf files (you must have <code>svg2pdf</code> installed, from the Cairo 2D graphics library),</li>
<li>launching <code>pdflatex</code> on the Latex file (you must have both <code>pdflatex</code> and the <code>breqn</code> package installed),</li>
<li>moving the resulting pdf file into <code>pdf/</code>.</li>
</ul>
<h3 id="online-examples">Online Examples</h3>
<p>To get an idea of the results of this mathematical documentation, which captures the mathematical semantic of Faust programs, you can look at two pdf files online:</p>
<ul>
<li><a href="http://faust.grame.fr/pdf/karplus.pdf" class="uri">http://faust.grame.fr/pdf/karplus.pdf</a> (automatic documentation),</li>
<li><a href="http://faust.grame.fr/pdf/noise.pdf" class="uri">http://faust.grame.fr/pdf/noise.pdf</a> (manual documentation).</li>
</ul>
<p>You can also generate all <em>mdoc</em> pdfs at once, simply invoking the <code>make  mathdoc</code> command inside the <code>examples/</code> directory:</p>
<ul>
<li>for each <code>%.dsp</code> file, a complete <code>%-mdoc</code> directory will be generated,</li>
<li>a single <code>allmathpdfs/</code> directory will gather all the generated pdf files.</li>
</ul>
<h2 id="automatic-documentation">Automatic Documentation</h2>
<p>By default, when no <code>&lt;mdoc&gt;</code> tag can be found in the input Faust file, the <code>-mdoc</code> option automatically generates a Latex file with four sections:</p>
<ul>
<li><strong>Equations of process</strong>, gathering all formulas needed for <code>process</code>,</li>
<li><strong>Block-diagram schema of process</strong>, showing the top-level block-diagram of <code>process</code>,</li>
<li><strong>Notice of this documentation</strong>, summing up generation and conventions information,</li>
<li><strong>Complete listing of the input code</strong>, listing all needed input files (including libraries).</li>
</ul>
<h2 id="manual-documentation">Manual Documentation</h2>
<p>You can specify yourself the documentation instead of using the automatic mode, with five xml-like tags. That allows you to modify the presentation and to add your own comments, not only on <code>process</code>, but also about any expression you’d like to. Note that as soon as you declare an <code>&lt;mdoc&gt;</code> tag inside your Faust file, the default structure of the automatic mode is ignored, and all the Latex stuff becomes up to you!</p>
<h3 id="six-tags">Six Tags</h3>
<p>Here are the six specific tags:</p>
<ul>
<li><code>&lt;mdoc&gt;&lt;/mdoc&gt;</code>, to open a documentation field in the Faust code,
<ul>
<li><code>&lt;equation&gt;&lt;/equation&gt;</code>, to get equations of a Faust expression,</li>
<li><code>&lt;diagram&gt;&lt;/diagram&gt;</code>, to get the top-level block-diagram of a Faust expression,</li>
<li><code>&lt;metadata&gt;&lt;/metadata&gt;</code>, to reference Faust metadatas (cf. declarations), calling the corresponding keyword,</li>
<li><code>&lt;notice /&gt;</code>, to insert the “adaptive” notice all formulas actually printed,</li>
<li><code>&lt;listing [attributes] /&gt;</code>, to insert the listing of Faust files called.</li>
</ul></li>
</ul>
<p>The <code>&lt;listing /&gt;</code> tag can have up to three boolean attributes (set to <code>true</code> by default):</p>
<ul>
<li><code>mdoctags</code> for <code>&lt;mdoc&gt;</code> tags;</li>
<li><code>dependencies</code> for other files dependencies;</li>
<li><code>distributed</code> for the distribution of interleaved Faust code between <code>&lt;mdoc&gt;</code> sections.</li>
</ul>
<h3 id="the-mdoc-top-level-tags">The <code>mdoc</code> Top-Level Tags</h3>
<p>The <code>&lt;mdoc&gt;&lt;/mdoc&gt;</code> tags are the top-level delimiters for Faust mathematical documentation sections. This means that the four other documentation tags can’t be used outside these pairs.</p>
<p>In addition of the four inner tags, <code>&lt;mdoc&gt;&lt;/mdoc&gt;</code> tags accept free Latex text, including its standard macros (like <code>\section</code>, <code>\emph</code>, etc.). This allows to manage the presentation of resulting tex file directly from within the input Faust file.</p>
<p>The complete list of the Latex packages included by Faust can be found in the file <code>architecture/latexheader.tex</code>.</p>
<h2 id="an-example-of-manual-mathdoc">An Example of Manual Mathdoc</h2>
<pre><code>&lt;mdoc&gt;
\title{&lt;metadata&gt;name&lt;/metadata&gt;}
\author{&lt;metadata&gt;author&lt;/metadata&gt;}
\date{\today}
\maketitle

\begin{tabular}{ll}
    \hline
    \textbf{name}       &amp; &lt;metadata&gt;name&lt;/metadata&gt; \\
    \textbf{version}    &amp; &lt;metadata&gt;version&lt;/metadata&gt; \\
    \textbf{author}     &amp; &lt;metadata&gt;author&lt;/metadata&gt; \\
    \textbf{license}    &amp; &lt;metadata&gt;license&lt;/metadata&gt; \\
    \textbf{copyright}  &amp; &lt;metadata&gt;copyright&lt;/metadata&gt; \\
    \hline
\end{tabular}
\bigskip
&lt;/mdoc&gt;
//-----------------------------------------------------------------
// Noise generator and demo file for the Faust math documentation
//-----------------------------------------------------------------

declare name        &quot;Noise&quot;;
declare version     &quot;1.1&quot;;
declare author      &quot;Grame&quot;;
declare author      &quot;Yghe&quot;;
declare license     &quot;BSD&quot;;
declare copyright   &quot;(c)GRAME 2009&quot;;

&lt;mdoc&gt;
\section{Presentation of the &quot;noise.dsp&quot; Faust program}
This program describes a white noise generator with an interactive volume, 
using a random function.

\subsection{The random function}
&lt;/mdoc&gt;

random  = +(12345)~*(1103515245);

&lt;mdoc&gt;
The \texttt{random} function describes a generator of random numbers, which 
equation follows. You should notice hereby the use of an integer arithmetic on 
32 bits, relying on integer wrapping for big numbers.
&lt;equation&gt;random&lt;/equation&gt;

\subsection{The noise function}
&lt;/mdoc&gt;

noise   = random/2147483647.0;

&lt;mdoc&gt;
The white noise then corresponds to:
&lt;equation&gt;noise&lt;/equation&gt;

\subsection{Just add a user interface element to play volume!}
&lt;/mdoc&gt;

process = noise * vslider(&quot;Volume[style:knob]&quot;, 0, 0, 1, 0.1);

&lt;mdoc&gt;
Endly, the sound level of this program is controlled by a user slider, which 
gives the following equation: 
&lt;equation&gt;process&lt;/equation&gt;

\section{Block-diagram schema of process}
This process is illustrated on figure 1.
&lt;diagram&gt;process&lt;/diagram&gt;

\section{Notice of this documentation}
You might be careful of certain information and naming conventions used in this 
documentation:
&lt;notice /&gt;

\section{Listing of the input code}
The following listing shows the input Faust code, parsed to compile this
mathematical documentation.
&lt;listing mdoctags=&quot;false&quot; dependencies=&quot;false&quot; distributed=&quot;true&quot; /&gt;
&lt;/mdoc&gt;</code></pre>
<h3 id="the--stripmdoc-option">The <code>-stripmdoc</code> Option</h3>
<p>The listing of the input code contains all the mathdoc text. As it may be useless in certain cases, we provide an option to strip mathdoc contents directly at compilation stage: <code>-stripmdoc</code> (short) or <code>--strip-mdoc-tags</code> (long).</p>
<h2 id="localization-of-mathdoc-files">Localization of Mathdoc Files</h2>
<p>By default, texts used by the documentator are in English, but you can specify another language (French, German and Italian at the moment), using the <code>-mdlang</code> (or <code>--mathdoc-lang</code>) option with a two-letters argument (<code>en</code>, <code>fr</code>, <code>it</code>, etc.).</p>
<p>The <code>faust2mathdoc</code> script also supports this option, plus a third short form with <code>-l</code>:</p>
<pre><code>faust2mathdoc -l fr myfaustfile.dsp</code></pre>
<p>If you would like to contribute to the localization effort, feel free to translate the mathdoc texts from any of the <code>mathdoctexts-*.txt</code> files, that are in the <code>architecture</code> directory (<code>mathdoctexts-fr.txt</code>, <code>mathdoctexts-it.txt</code>, etc.). As these files are dynamically loaded, just adding a new file with an appropriate name should work.</p>
<h2 id="summary-of-the-mathdoc-generation-steps">Summary of the Mathdoc Generation Steps</h2>
<ul>
<li>First, to get the full mathematical documentation done on your Faust file, call <code>faust2mathdoc myfaustfile.dsp</code>.</li>
<li>Then, open the pdf file <code>myfaustfile-mdoc/pdf/myfaustfile.pdf</code>.</li>
<li>That’s all !</li>
</ul>
<h1 id="tutorial-adding-faust-dsp-support-to-your-juce-plug-ins">Tutorial: Adding Faust DSP Support to Your JUCE Plug-ins</h1>
<blockquote>
<p>This tutorial doesn’t belong to the Faust manual. It will eventually live in its own page. It has been placed here for now for convenience and rapid prototyping.</p>
</blockquote>
<p><a href="https://juce.com/">JUCE</a> is a well known framework for creating audio plug-ins (i.e., VST, AU, AAX, etc.) and applications for a wide range of platforms. Faust can be used to generate ready-to-use JUCE applications and plug-ins implementing the standard user interface (UI) described in the Faust code using <a href="TODO">faust2juce</a>. However, it is sooo easy to make professional looking UIs from scratch in JUCE that you might want to use Faust to implement the DSP portion of your plug-in and build your own UI.</p>
<p>In this tutorial, we demonstrate how to use <a href="TODO"><code>faust2api</code></a> to generate a JUCE audio engine from Faust and how to interface it with your JUCE plug-in/UI. We’ll cover basic examples as well as more advanced applications involving polyphony, etc.</p>
<h2 id="the-old-way-brut-force-method">“The Old Way”: Brut-Force Method</h2>
<blockquote>
<p>If you’re not interested by this brief page of history, you can jump directly to the <a href="#simple-synth-plug-in">next section</a>.</p>
</blockquote>
<p>Before <code>faust2api</code> existed, it was already possible to use Faust to implement the DSP portion of a JUCE plug-in. Indeed, the most basic way to use Faust is to generate C++ code with the Faust compiler. Running:</p>
<pre><code>faust someCode.dsp -o someCode.cpp</code></pre>
<p>will output a C++ file (<code>someCode.cpp</code>) containing a class implementing a ready-to-use audio callback (see <a href="TODO">this tutorial</a>). Hence, it was just a matter of using this class in your JUCE project, pass it the input buffers, retrieve the output buffers, and change potential parameters, etc. <a href="https://ccrma.stanford.edu/courses/256a-fall-2016/lectures/faust/">This short (and potentially outdated) tutorial</a> from 2016 demonstrates how this can be done.</p>
<p>Fortunately, things are simpler than ever nowadays and <code>faust2api</code> greatly simplifies this process.</p>
<h2 id="simple-synth-plug-in">Simple Synth Plug-In</h2>
<p><a href="misc/juce/SawtoothSynth.zip">&lt;&lt; Download the source of this tutorial &gt;&gt;</a></p>
<p>In this section, we demonstrate how to use a Faust synth to build a plug-in in JUCE with a custom UI from scratch.</p>
<blockquote>
<p>This tutorial only demonstrates how to make a JUCE plug-in. Making a JUCE standalone application following the same method is perfhttp://faust.grame.fr/manual/ectly possible with some adjustments.</p>
</blockquote>
<h3 id="generating-the-dsp-engine">Generating the DSP Engine</h3>
<p>First, let’s implement a basic subtractive synthesizer in Faust based on a filtered sawtooth wave (<a href="misc/juce/filteredSawtooth.dsp"><code>filteredSawtooth.dsp</code></a>):</p>
<div class="faust-run"><a href="img/src/exfaust138/exfaust138-svg/process.svg" target="_blank"><img src="img/src/exfaust138/exfaust138-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freq = nentry(&quot;freq&quot;,50,200,1000,0.01);
gain = nentry(&quot;gain&quot;,0.5,0,1,0.01) : si.smoo;
gate = button(&quot;gate&quot;) : si.smoo;
cutoff = nentry(&quot;cutoff&quot;,10000,50,10000,0.01) : si.smoo;
process = os.sawtooth(freq)*gain*gate : fi.lowpass(3,cutoff) &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust138/exfaust138.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Feel free to run it in the web editor to see how it sounds!</p>
<blockquote>
<p>The output of the lowpass is split into 2 signals to create a stereo object.</p>
</blockquote>
<p>Note that all the parameters are smoothed to prevent clicking (we want our plug-in to be clean!). Even <code>gate</code> is smoothed, which will apply a gentle exponential envelope when the trigger signal is sent, etc.</p>
<p>Since Faust will not build its own UI here, the type of UI element used in this code doesn’t really matter. They just serve as a point of entry to control the parameters of the audio engine we’re about to generate. So <code>nentry</code>, could be replaced by <code>hslider</code> or <code>vslider</code>, it would not make any difference. However, we encourage you to always write “coherent” interfaces in case someone would like to use your Faust code “as such” at some point.</p>
<p>This Faust program can be turned into an audio engine for JUCE simply by running the following command (assuming that Faust is properly installed on your system):</p>
<pre><code>faust2api -juce filterSawtooth.dsp</code></pre>
<p>Alternatively (i.e., if you’re an unfortunate Windows user), you can use the Faust web editor to carry out the same task by choosing <code>source/juce</code> in the export function.</p>
<p>In both cases, you’ll end up with with a zip file containing a C++ file and its companion header file as well as some automatically generated markdown documentation.</p>
<h3 id="creating-an-empty-juce-plug-in-project">Creating an Empty JUCE Plug-In Project</h3>
<p>In this section, we’ll assume that you’re a bit familiar with <a href="https://juce.com/">JUCE</a>. If that’s not your case, don’t panic and just read their <a href="https://docs.juce.com/master/tutorial_new_projucer_project.html">Getting started with the Projucer</a> tutorial. We also recommend you to have a look a the next few following tutorials to have a sense of how things work. They’re nice and easy to read!</p>
<p>In the Projucer, create a new Audio Plug-In, add the targets that you want, in the settings, make sure that “Plugin is a Synth” is enabled. In our case, we named it “SawtoothSynth” (choose this name wisely as it will impact the class names of your program).</p>
<p><img src="img/juce/newPlugin.jpg" class="mx-auto d-block" width="70%"></p>
<p>Now, place <code>DspFaust.cpp</code> and <code>DspFaust.h</code> generated in the previous step in the <code>Source</code> folder of your JUCE plug-in project. Then select these 2 files in <code>Source</code> and drag them in the Projucer so that they become visible in the <code>Source</code> tab:</p>
<p><img src="img/juce/juceProject.jpg" class="mx-auto d-block" width="70%"></p>
<p>At this point, try to compile your plug-in and see if it runs. Remember that JUCE now generates a “standalone plug-in” by default which is super convenient to test things without having to open the plug-in in a third party application.</p>
<p>Let’s now add our DspFaust object to the <code>PluginProcessor</code>. In <code>PluginProcessor.h</code>, include <code>DspFaust.h</code>:</p>
<pre><code>#include &quot;../JuceLibraryCode/JuceHeader.h&quot;
#include &quot;DspFaust.h&quot;</code></pre>
<p>and implement <code>DspFaust</code> in the private section of the <code>AudioProcessor</code> class:</p>
<pre><code>private:
    DspFaust dspFaust;
    
    //==============================================================================
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (SawtoothSynthAudioProcessor)</code></pre>
<p>In <code>PluginProcessor.cpp</code>, all we have to do is to call <code>dspFaust.start()</code> when we want to start the Faust audio engine and <code>dspFaust.stop()</code> when we want to stop it. No need to set the sampling rate or the buffer length, <code>dspFaust</code> takes care of that for ya.</p>
<blockquote>
<p>Remember that the package generated by <code>faust2api</code> contains a documentation of the generated API. Feel free to have a look at it to get a sense of what methods are available.</p>
</blockquote>
<p><code>dspFaust.start()</code> and <code>dspFaust.stop()</code> can be conveniently placed in the constructor and destructor (respectively) of <code>SawtoothSynthAudioProcessor</code>:</p>
<pre><code>SawtoothSynthAudioProcessor::SawtoothSynthAudioProcessor()
#ifndef JucePlugin_PreferredChannelConfigurations
     : AudioProcessor (BusesProperties()
                     #if ! JucePlugin_IsMidiEffect
                      #if ! JucePlugin_IsSynth
                       .withInput  (&quot;Input&quot;,  AudioChannelSet::stereo(), true)
                      #endif
                       .withOutput (&quot;Output&quot;, AudioChannelSet::stereo(), true)
                     #endif
                       )
#endif
{
  dspFaust.start();
}

SawtoothSynthAudioProcessor::~SawtoothSynthAudioProcessor()
{
  dspFaust.stop();
}</code></pre>
<p>The default JUCE plug-in copies the input buffer in the output buffer. Therefore, make sure that the implementation of the <code>processBlock</code> method looks like:</p>
<pre><code>void SawtoothSynthAudioProcessor::processBlock (AudioBuffer&lt;float&gt;&amp; buffer, MidiBuffer&amp; midiMessages)
{
}</code></pre>
<p>(empty).</p>
<p>We now want to control the parameters of our <code>dspFaust</code> object. For that, the <code>setParamValue</code> method can be used. Since we want to control the parameters of our synth from the <code>PluginEditor</code>, we create a series of public methods in <code>PluginProcessor</code> to control each parameter of our synth. In <code>PluginProcessor.h</code> this will look like:</p>
<pre><code>public:
  void setFreq(float freq);
  void setGain(float gain);
  void setCutoff(float cutoff);
  void setGate(bool gate);</code></pre>
<p>and the corresponding implementation in <code>PluginProcessor.cpp</code> will be:</p>
<pre><code>void SawtoothSynthAudioProcessor::setFreq(float freq)
{
  dspFaust.setParamValue(&quot;/synth/freq&quot;,freq);
}

void SawtoothSynthAudioProcessor::setGain(float gain)
{
  dspFaust.setParamValue(&quot;/synth/gain&quot;,gain);
}

void SawtoothSynthAudioProcessor::setGate(bool gate)
{
  if(gate){
    dspFaust.setParamValue(&quot;/synth/gate&quot;,1);
  }
  else{
    dspFaust.setParamValue(&quot;/synth/gate&quot;,0);
  }
}

void SawtoothSynthAudioProcessor::setCutoff(float cutoff)
{
  dspFaust.setParamValue(&quot;/synth/cutoff&quot;,cutoff);
}</code></pre>
<p>Hence, <code>setParamValue</code> has 2 arguments: the path of the parameter in the Faust code, and its value. Note that a list of all the available parameters of the Faust object of their corresponding path can be found in the markdown documentation of the package generated with <code>faust2api</code>.</p>
<p>That’s it for the <code>PluginProcessor</code>! Easy isn’t it ;)? Now, let’s add a basic interface to control this synth.</p>
<p>We add a series of sliders, button, and labels to the private section of <code>SawtoothSynthAudioProcessorEditor</code> in <code>PluginEditor.h</code>:</p>
<pre><code>private:
  Slider frequencySlider;
  Slider gainSlider;
  Slider cutoffSlider;
  ToggleButton onOffButton;
    
  Label frequencyLabel;
  Label gainLabel;
  Label cutoffLabel;
  Label onOffLabel;</code></pre>
<p>and their corresponding implementation in <code>PluginEditor.cpp</code>:</p>
<pre><code>SawtoothSynthAudioProcessorEditor::SawtoothSynthAudioProcessorEditor (SawtoothSynthAudioProcessor&amp; p)
    : AudioProcessorEditor (&amp;p), processor (p)
{
  setSize (800, 130);
  
  addAndMakeVisible (frequencySlider);
  frequencySlider.setRange (50.0, 5000.0);
  frequencySlider.setSkewFactorFromMidPoint (500.0);
  frequencySlider.setValue(300);
  frequencySlider.onValueChange = [this] {
    processor.setFreq(frequencySlider.getValue());  
  };

  addAndMakeVisible(frequencyLabel);
  frequencyLabel.setText (&quot;Frequency&quot;, dontSendNotification);
  frequencyLabel.attachToComponent (&amp;frequencySlider, true);
    
  addAndMakeVisible (gainSlider);
  gainSlider.setRange (0.0, 1.0);
  gainSlider.setValue(0.5);
  gainSlider.onValueChange = [this] { 
    processor.setGain(gainSlider.getValue()); 
  };
    
  addAndMakeVisible(gainLabel);
  gainLabel.setText (&quot;Gain&quot;, dontSendNotification);
  gainLabel.attachToComponent (&amp;gainSlider, true);
    
  addAndMakeVisible (cutoffSlider);
  cutoffSlider.setRange (50.0, 10000.0);
  cutoffSlider.setValue(5000.0);
  cutoffSlider.onValueChange = [this] { 
    processor.setCutoff(cutoffSlider.getValue()); 
  };
    
  addAndMakeVisible(cutoffLabel);
  cutoffLabel.setText (&quot;Cutoff&quot;, dontSendNotification);
  cutoffLabel.attachToComponent (&amp;cutoffSlider, true);
  
  addAndMakeVisible(onOffButton);
  onOffButton.onClick = [this] { 
    processor.setGate(onOffButton.getToggleState());
  };
    
  addAndMakeVisible(onOffLabel);
  onOffLabel.setText (&quot;On/Off&quot;, dontSendNotification);
  onOffLabel.attachToComponent (&amp;onOffButton, true);
}</code></pre>
<p>The methods that we declared in the previous step are basically called to set the value of the parameters of our DSP engine thanks to the <code>processor</code> object.</p>
<p>The <code>resized</code> method must be implemented so that the various UI elements that we created actually have a size:</p>
<pre><code>void SawtoothSynthAudioProcessorEditor::resized()
{
  const int sliderLeft = 80;
  frequencySlider.setBounds (sliderLeft, 10, getWidth() - sliderLeft - 20, 20);
  gainSlider.setBounds (sliderLeft, 40, getWidth() - sliderLeft - 20, 20);
  cutoffSlider.setBounds (sliderLeft, 70, getWidth() - sliderLeft - 20, 20);
  onOffButton.setBounds (sliderLeft, 100, getWidth() - sliderLeft - 20, 20);
}</code></pre>
<p>Finally, make sure that you clean the implementation of the <code>paint</code> method to get rid of the default ugly “Hello World”:</p>
<pre><code>void SawtoothSynthAudioProcessorEditor::paint (Graphics&amp; g)
{
  g.fillAll (getLookAndFeel().findColour (ResizableWindow::backgroundColourId));
}</code></pre>
<p>Note that the same approach can be used to create an audio effect: <code>DspFaust</code> will take care of instantiating the input buffers, etc. so it should just work right away as for this synth example.</p>
<p>Compile your plug-in and run it, it should look like this:</p>
<p><img src="img/juce/plugin.jpg" class="mx-auto d-block" width="60%"></p>
<p>The goal of this section was just to show you how to integrate a Faust DSP engine into a JUCE plug-in project and how to control it with a simple UI. Once again, JUCE is a powerful tool to implement sophisticated UI in a very simple way. You’ll find all the documentation you need on <a href="https://juce.com/">their website</a> to start making beautiful plug-ins!</p>
<h2 id="creating-and-using-a-polyphonic-faust-dsp-object">Creating and Using a Polyphonic Faust DSP Object</h2>
<p><a href="misc/juce/SawtoothSynthPoly.zip">&lt;&lt; Download the source of this tutorial &gt;&gt;</a></p>
<p>In the second part of this tutorial, we demonstrate how to generate a polyphonic DSP engine with <code>faust2api</code> and how to control it with the “standard” JUCE keyboard.</p>
<p>The following code is almost the same as the one used in the previous section, except that <a href="TODO">we declared a global effect using the <code>effect</code> standard variable</a> (<a href="TODO"><code>filteredSawtoothPoly.dsp</code></a>):</p>
<div class="faust-run"><a href="img/src/exfaust139/exfaust139-svg/process.svg" target="_blank"><img src="img/src/exfaust139/exfaust139-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freq = nentry(&quot;freq&quot;,50,200,1000,0.01) : si.smoo;
gain = nentry(&quot;gain&quot;,0.5,0,1,0.01) : si.smoo;
gate = button(&quot;gate&quot;) : si.smoo;
cutoff = nentry(&quot;cutoff&quot;,10000,50,10000,0.01) : si.smoo;
process = os.sawtooth(freq)*gain*gate : fi.lowpass(3,cutoff) &lt;: _,_ ;
effect = dm.zita_light;</code></pre>
<a href="https://faust.grame.fr/editor?code=https://faust.grame.fr/manual/img/src/exfaust139/exfaust139.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Note that the <code>freq</code>, <code>gain</code>, and <code>gate</code> parameters are declared, which means that this Faust program can be turned into a polyphonic synth (see the <a href="TODO">MIDI polyphonic documentation</a>). Hence, in the current configuration multiple instances (voices) of <code>process</code> will be created and connected to a single instance of <code>effect</code>.</p>
<p>A polyphonic DSP engine for JUCE can be generated from this code by running:</p>
<pre><code>faust2api -juce -nvoices 12 filteredSawtoothPoly.dsp</code></pre>
<p>where 12 is the maximum number of polyphonic voices (which can be changed from the generated C++ code as well by changing the value of the <code>NVOICES</code> macro at the beginning of <code>DspFaust.cpp</code>). The same result can be achieved using the <a href="https://faust.grame.fr/editor">Faust web editor</a> and by choosing <code>source/juce-poly</code> in the export function.</p>
<p>Create a new JUCE audio plug-in project with the same configuration than in the previous section. Import the <code>DspFaust</code> files, create an instance of the <code>DspFaust</code> object and call the <code>dspFaust.start()</code> and <code>dspFaust.stop()</code> methods as we did before.</p>
<p>Our goal is to create a simple plug-in with the following interface:</p>
<p><img src="img/juce/polyPlugin.jpg" class="mx-auto d-block" width="60%"></p>
<p>where the keyboard can be used to play several notes at the same time and the “cutoff” slider can be used to change the cutoff frequency of the lowpass filter of all active voices. This is an extremely primitive implementation where only the messages from the UI keyboard are processed: we’re just doing this for the sake of the example. If you’ve never worked with keyboards and MIDI in JUCE, we strongly recommend you to read <a href="https://docs.juce.com/master/tutorial_handling_midi_events.html">this tutorial</a>.</p>
<p>In <code>PluginEditor.h</code>, let’s first add the following inheritance to the <code>SawtoothSynthAudioProcessorEditor</code> class:</p>
<pre><code>class SawtoothSynthAudioProcessorEditor  : 
  public AudioProcessorEditor, 
  private MidiInputCallback, 
  private MidiKeyboardStateListener
{</code></pre>
<p>This is necessary to implement the MIDI callback and the keyboard (UI) listener. This inheritance requires us to implement the following methods in the private section of <code>PluginEditor.h</code>. We also add an instance of a UI keyboard and its associated state as well as a slider and its label to control the cutoff frequency of the lowpass:</p>
<pre><code>private:
  void handleNoteOn (MidiKeyboardState*, int midiChannel, int midiNoteNumber, float velocity) override;
  void handleNoteOff (MidiKeyboardState*, int midiChannel, int midiNoteNumber, float /*velocity*/) override;
  void handleIncomingMidiMessage (MidiInput* source, const MidiMessage&amp; message) override;
  
  MidiKeyboardState keyboardState;   
  MidiKeyboardComponent keyboardComponent; 
    
  Slider cutoffSlider;
  Label cutoffLabel;</code></pre>
<p>In <code>PluginEditor.cpp</code>, we can add the keyboard and the slider to the constructor:</p>
<pre><code>SawtoothSynthAudioProcessorEditor::SawtoothSynthAudioProcessorEditor (SawtoothSynthAudioProcessor&amp; p)
  : AudioProcessorEditor (&amp;p), processor (p), keyboardComponent (keyboardState, MidiKeyboardComponent::horizontalKeyboard)
{
  setSize (800, 150);
    
  addAndMakeVisible (keyboardComponent);
  keyboardState.addListener (this);
    
  addAndMakeVisible (cutoffSlider);
  cutoffSlider.setRange (50.0, 10000.0);
  cutoffSlider.setValue(5000.0);
  cutoffSlider.onValueChange = [this] { 
    processor.setCutoff(cutoffSlider.getValue()); 
  };
    
  addAndMakeVisible(cutoffLabel);
  cutoffLabel.setText (&quot;Cutoff&quot;, dontSendNotification);
  cutoffLabel.attachToComponent (&amp;cutoffSlider, true);
}</code></pre>
<p>and we must de-allocate the keyboard state listener in the destructor:</p>
<pre><code>SawtoothSynthAudioProcessorEditor::~SawtoothSynthAudioProcessorEditor()
{
  keyboardState.removeListener(this);
}</code></pre>
<p>The implementation of the <code>setCutoff</code> method is detailed later in this tutorial and is very similar to the one described in the previous section.</p>
<p>We also need to define the size of the various elements in the interface (as we did before):</p>
<pre><code>void SawtoothSynthAudioProcessorEditor::resized()
{
  const int sliderLeft = 80;
  keyboardComponent.setBounds (10,10,getWidth()-30,100);
  cutoffSlider.setBounds (sliderLeft, 120, getWidth() - sliderLeft - 20, 20);
}</code></pre>
<p>MIDI messages are retrieved from the keyboard simply by implementing the following inherited methods:</p>
<pre><code>void SawtoothSynthAudioProcessorEditor::handleIncomingMidiMessage (MidiInput* source, const MidiMessage&amp; message) {}

void SawtoothSynthAudioProcessorEditor::handleNoteOn (MidiKeyboardState*, int midiChannel, int midiNoteNumber, float velocity)
{
  processor.keyOn(midiNoteNumber,int(127*velocity));
}

void SawtoothSynthAudioProcessorEditor::handleNoteOff (MidiKeyboardState*, int midiChannel, int midiNoteNumber, float /*velocity*/)
{
  processor.keyOff(midiNoteNumber);
}</code></pre>
<p>The implementation of the <code>keyOn</code> and <code>keyOff</code> methods is detailed below.</p>
<p>On the <code>PluginProcessor</code> side, the following methods must be declared in <code>PluginProcessor.h</code>:</p>
<pre><code>void keyOn(int pitch, int  velocity);
void keyOff(int pitch);
void setCutoff(float cutoff);</code></pre>
<p>They are the ones that were used in the previous steps.</p>
<p>Their corresponding implementation in <code>PluginProcessor.cpp</code> is very straight forward:</p>
<pre><code>void SawtoothSynthAudioProcessor::keyOn(int pitch, int velocity)
{
  dspFaust.keyOn(pitch,velocity);
}

void SawtoothSynthAudioProcessor::keyOff(int pitch)
{
  dspFaust.keyOff(pitch);
}

void SawtoothSynthAudioProcessor::setCutoff(float cutoff)
{
  dspFaust.setParamValue(&quot;/Sequencer/DSP1/Polyphonic/Voices/synth/cutoff&quot;,cutoff);
}</code></pre>
<p><code>keyOn</code> and <code>keyOff</code> are methods from <code>DspFaust</code> that can be used to trigger and stop a note. <code>keyOn</code> will allocate a new voice, convert its <code>pitch</code> parameter into a frequency that will be sent automatically to the Faust <code>freq</code> parameter, <code>velocity</code> is converted to a level that will be sent to the <code>gain</code> parameter, and the <code>gate</code> parameter is set to 1. Inversely, <code>keyOff</code> sets <code>gate</code> to 0 and waits for t60 to be reached to de-allocate the current voice.</p>
<p><code>keyOn</code> returns a voice ID whose type is <code>unsigned long</code>. This ID can then be used to change the parameter of a specific voice. We’re not using this functionality in the example presented in this tutorial but here is how this would work:</p>
<pre><code>unsigned long voiceID = dspFaust.keyOn(60,110);
dspFaust.setVoiceParamValue(&quot;/synth/cutoff&quot;,voiceID,378);</code></pre>
<p>Note that voices can also be allocated directly without using <code>keyOn</code> and <code>keyOff</code> with the <code>newVoice</code> and the <code>deleteVoice</code> methods:</p>
<pre><code>unsigned long voiceID = dspFaust.newVoice();
dspFaust.setVoiceParamValue(&quot;/synth/gate&quot;,voiceID,1);
// do something...
dspFaust.deleteVoice(voiceID);</code></pre>
<p>Using <code>setParamValue</code> as we’re doing in the current example, we can set the value of a parameter for all the voices of the DSP engine. Unlike <code>setVoiceParamValue</code>, the parameter path must be the complete path provided in the README of the DSP package generated with <code>faust2api</code>. So once again, for <code>setVoiceParamValue</code>, the short path is enough but for <code>setParamValue</code>, the complete path is needed.</p>
<p>You might wonder why the path is much more complex with a polyphonic DSP engine than with a regular one. <code>Sequencer</code> is the full object (poly synth + effect), <code>DSP1</code> is the synth (<code>DSP2</code> is the effect), <code>Polyphonic</code> is the polyphonic layer of the object, and finally <code>Voices</code> addresses all the voices at once.</p>
<p>That’s it folks! Try to compile and run your plug-in, it should just work. Of course, things could be significantly improved here but at this point, you should be able to sail on your own.</p></div></div></div></main>
    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
  </body>
</html>