<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    
    <link href="css/faust-website.css" rel="stylesheet">
    <link href="css/faust-widget.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>

    <title>Faust Programming Language</title>
  </head>
  <body>
    
    <header>
      <div class="fixed-top">
        <nav class="navbar navbar-expand-md navbar-dark bg-dark">
          <a class="navbar-brand" href="#">:> Faust</a>
          <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
          </button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav mr-auto">
              <li class="nav-item dropdown">
              <!--<li class="nav-item active">-->
                <a data-toggle="dropdown" class="nav-link dropdown-toggle active" href="#">Learn</a>
                <div class="dropdown-menu">
                  <a class="dropdown-item" href="#">Overview/Index</a>
                  <a class="dropdown-item" href="#">Get Started</a>
                  <a class="dropdown-item active" href="#">Faust Manual</a>
                  <a class="dropdown-item" href="#">Libraries Documentation</a>
                  <a class="dropdown-item" href="#">Cheat Sheet</a>
                  <a class="dropdown-item" href="#">Tutorials</a>
                  <a class="dropdown-item" href="#">Examples</a>
                  <a class="dropdown-item" href="#">Singal Processing Courses</a>
                </div>
              </li>
              <li class="nav-item">
                <a class="nav-link" href="#">Download</a>
              </li>
              <li class="nav-item dropdown">
                <a data-toggle="dropdown" class="nav-link dropdown-toggle" href="#">Online Platforms</a>
                <div class="dropdown-menu">
                  <a class="dropdown-item" href="#">Web Editor</a>
                  <a class="dropdown-item" href="#">Online Compiler</a>
                  <a class="dropdown-item" href="#">Faust Playground</a>
                </div>
              </li>
              <li class="nav-item dropdown">
                <a data-toggle="dropdown" class="nav-link dropdown-toggle" href="#">Tools</a>
                <div class="dropdown-menu">
                  <a class="dropdown-item" href="#">FaustLive</a>
                  <a class="dropdown-item" href="#">FaustWorks</a>
                  <a class="dropdown-item" href="#">FaustGen</a>
                </div>
              </li>
              <li class="nav-item dropdown">
                <a data-toggle="dropdown" class="nav-link dropdown-toggle" href="#">Community</a>
                <div class="dropdown-menu">
                  <a class="dropdown-item" href="#">News</a>
                  <a class="dropdown-item" href="#">Get Help (Mailing Lists)</a>
                  <a class="dropdown-item" href="#">Faust Conference</a>
                  <a class="dropdown-item" href="#">Academic Papers</a>
                  <a class="dropdown-item" href="#">Press</a>
                  <a class="dropdown-item" href="#">Report a Bug</a>
                  <a class="dropdown-item" href="#">Made with Faust</a>
                </div>
              </li>
              <li class="nav-item">
                <a class="nav-link" href="#">Showcase</a>
              </li>
            </ul>
            <form class="form-inline mt-2 mt-md-0">
              <input class="form-control mr-sm-2" type="text" placeholder="Search" aria-label="Search">
              <button class="btn btn-outline-success my-2 my-sm-0" type="submit">Search</button>
            </form>
          </div>
        </nav>        
        <nav aria-label="breadcrumb">
          <ol class="breadcrumb">
            <li class="breadcrumb-item"><a href="#">Home</a></li>
            <li class="breadcrumb-item"><a href="#">Learn</a></li>
            <li class="breadcrumb-item active" aria-current="page">Faust Manual</li>
          </ol>
        </nav>
      </div>      
    </header>
    <div class="container-fluid"><div class="row faust-doc"><nav id="TOC" class="col-3 faust-doc-content"><div style="height: 100%;overflow-y: scroll;"><ul class="nav flex-column"><ul>
<li><a href="#introduction">Introduction</a><ul>
<li><a href="#what-is-faust">What is Faust?</a></li>
<li><a href="#what-is-faust-good-for">What is Faust Good For?</a></li>
<li><a href="#what-is-faust-not-so-good-for">What is Faust Not (So) Good For?</a></li>
<li><a href="#design-principles">Design Principles</a></li>
<li><a href="#signal-processor-semantic">Signal Processor Semantic</a></li>
</ul></li>
<li><a href="#quick-start">Quick Start</a></li>
<li><a href="#overview-of-the-faust-universe">Overview of the Faust Universe</a><ul>
<li><a href="#the-faust-distribution">The Faust Distribution</a><ul>
<li><a href="#command-line-compiler">Command-Line Compiler</a></li>
<li><a href="#libfaust"><code>libfaust</code></a></li>
<li><a href="#faust2...-scripts"><code>faust2...</code> Scripts</a></li>
</ul></li>
<li><a href="#web-tools">Web Tools</a><ul>
<li><a href="#the-online-editor">The Online Editor</a></li>
<li><a href="#the-faustplayground">The FaustPlayground</a></li>
<li><a href="#the-faust-online-compiler">The Faust Online Compiler</a></li>
<li><a href="#web-services">Web Services</a></li>
</ul></li>
<li><a href="#development-tools">Development Tools</a><ul>
<li><a href="#faustlive">FaustLive</a></li>
<li><a href="#faustworks">FaustWorks</a></li>
</ul></li>
</ul></li>
<li><a href="#compiling-and-installing-faust">Compiling and Installing Faust</a><ul>
<li><a href="#getting-the-source-code">Getting the Source Code</a></li>
</ul></li>
<li><a href="#faust-syntax">Faust Syntax</a><ul>
<li><a href="#faust-program">Faust Program</a></li>
<li><a href="#statements">Statements</a><ul>
<li><a href="#metadata-declarations">Metadata Declarations</a></li>
<li><a href="#imports">Imports</a></li>
<li><a href="#documentation-tags">Documentation Tags</a></li>
</ul></li>
<li><a href="#definitions">Definitions</a><ul>
<li><a href="#simple-definitions">Simple Definitions</a></li>
</ul></li>
<li><a href="#function-definitions">Function Definitions</a></li>
<li><a href="#definitions-with-pattern-matching">Definitions with pattern matching</a></li>
<li><a href="#expressions">Expressions</a><ul>
<li><a href="#diagram-expressions">Diagram Expressions</a><ul>
<li><a href="#diagram-composition-operations">Diagram Composition Operations</a></li>
<li><a href="#parallel-composition">Parallel Composition</a></li>
<li><a href="#sequential-composition">Sequential Composition</a></li>
<li><a href="#split-composition">Split Composition</a></li>
<li><a href="#merge-composition">Merge Composition</a></li>
<li><a href="#recursive-composition">Recursive Composition</a></li>
<li><a href="#inputs-and-outputs-of-an-expression">Inputs and Outputs of an Expression</a></li>
<li><a href="#iterations">Iterations</a></li>
<li><a href="#par-iteration"><code>par</code> Iteration</a></li>
<li><a href="#seq-iteration"><code>seq</code> Iteration</a></li>
<li><a href="#sum-iteration"><code>sum</code> Iteration</a></li>
<li><a href="#prod-iteration"><code>prod</code> Iteration</a></li>
</ul></li>
<li><a href="#infix-notation-and-other-syntax-extensions">Infix Notation and Other Syntax Extensions</a><ul>
<li><a href="#infix-operators">Infix Operators</a></li>
<li><a href="#prefix-notation">Prefix Notation</a></li>
<li><a href="#partial-application">Partial Application</a></li>
</ul></li>
<li><a href="#time-expression"><code>'</code> Time Expression</a></li>
<li><a href="#time-expression-1"><code>@</code> Time Expression</a></li>
<li><a href="#environment-expressions">Environment Expressions</a><ul>
<li><a href="#with-expression"><code>with</code> Expression</a></li>
<li><a href="#letrec-expression"><code>letrec</code> Expression</a></li>
<li><a href="#environment-expression"><code>environment</code> Expression</a></li>
<li><a href="#access-expression">Access Expression</a></li>
<li><a href="#library-expression"><code>library</code> Expression</a></li>
<li><a href="#component-expression"><code>component</code> Expression</a></li>
<li><a href="#explicit-substitution">Explicit Substitution</a></li>
</ul></li>
<li><a href="#foreign-expressions">Foreign Expressions</a><ul>
<li><a href="#ffunction"><code>ffunction</code></a></li>
<li><a href="#signature">Signature</a></li>
<li><a href="#types">Types</a></li>
<li><a href="#variables-and-constants">Variables and Constants</a></li>
<li><a href="#file-include">File Include</a></li>
<li><a href="#library-file">Library File</a></li>
</ul></li>
<li><a href="#applications-and-abstractions">Applications and Abstractions</a><ul>
<li><a href="#abstractions">Abstractions</a></li>
<li><a href="#applications">Applications</a></li>
<li><a href="#pattern-matching">Pattern Matching</a></li>
</ul></li>
</ul></li>
<li><a href="#primitives">Primitives</a><ul>
<li><a href="#numbers">Numbers</a></li>
<li><a href="#waveform-primitive"><code>waveform</code> Primitive</a></li>
<li><a href="#soundfile-primitive"><code>soundfile</code> Primitive</a></li>
<li><a href="#c-equivalent-primitives">C-Equivalent Primitives</a><ul>
<li><a href="#integer-number">Integer Number</a></li>
<li><a href="#floating-point-number">Floating Point Number</a></li>
<li><a href="#identity-function">Identity Function</a></li>
<li><a href="#cut-primitive">Cut Primitive</a></li>
<li><a href="#int-primitive"><code>int</code> Primitive</a></li>
<li><a href="#float-primitive"><code>float</code> Primitive</a></li>
<li><a href="#add-primitive">Add Primitive</a></li>
<li><a href="#subtract-primitive">Subtract Primitive</a></li>
<li><a href="#multiply-primitive">Multiply Primitive</a></li>
<li><a href="#divide-primitive">Divide Primitive</a></li>
<li><a href="#power-primitive">Power Primitive</a></li>
<li><a href="#modulo-primitive">Modulo Primitive</a></li>
<li><a href="#and-primitive">AND Primitive</a></li>
<li><a href="#or-primitive">OR Primitive</a></li>
<li><a href="#xor-primitive">XOR Primitive</a></li>
<li><a href="#left-shift-primitive">Left Shift Primitive</a></li>
<li><a href="#right-shift-primitive">Right Shift Primitive</a></li>
<li><a href="#smaller-than-primitive">Smaller Than Primitive</a></li>
<li><a href="#smaller-or-equal-than-primitive">Smaller or Equal Than Primitive</a></li>
<li><a href="#greater-than-primitive">Greater Than Primitive</a></li>
<li><a href="#greater-or-equal-than-primitive">Greater or Equal Than Primitive</a></li>
<li><a href="#equal-to-primitive">Equal to Primitive</a></li>
<li><a href="#different-than-primitive">Different Than Primitive</a></li>
</ul></li>
<li><a href="#math.h-equivalent-primitives"><code>math.h</code>-Equivalent Primitives</a><ul>
<li><a href="#acos-primitive"><code>acos</code> Primitive</a></li>
<li><a href="#asin-primitive"><code>asin</code> Primitive</a></li>
<li><a href="#atan-primitive"><code>atan</code> Primitive</a></li>
<li><a href="#atan2-primitive"><code>atan2</code> Primitive</a></li>
<li><a href="#cos-primitive"><code>cos</code> Primitive</a></li>
<li><a href="#sin-primitive"><code>sin</code> Primitive</a></li>
<li><a href="#tan-primitive"><code>tan</code> Primitive</a></li>
<li><a href="#exp-primitive"><code>exp</code> Primitive</a></li>
<li><a href="#log-primitive"><code>log</code> Primitive</a></li>
<li><a href="#log10-primitive"><code>log10</code> Primitive</a></li>
<li><a href="#pow-primitive"><code>pow</code> Primitive</a></li>
<li><a href="#sqrt-primitive"><code>sqrt</code> Primitive</a></li>
<li><a href="#abs-primitive"><code>abs</code> Primitive</a></li>
<li><a href="#min-primitive"><code>min</code> Primitive</a></li>
<li><a href="#max-primitive"><code>max</code> Primitive</a></li>
<li><a href="#fmod-primitive"><code>fmod</code> Primitive</a></li>
<li><a href="#remainder-primitive"><code>remainder</code> Primitive</a></li>
<li><a href="#floor-primitive"><code>floor</code> Primitive</a></li>
<li><a href="#ceil-primitive"><code>ceil</code> Primitive</a></li>
<li><a href="#rint-primitive"><code>rint</code> Primitive</a></li>
</ul></li>
<li><a href="#delay-primitives-and-modifiers">Delay Primitives and Modifiers</a><ul>
<li><a href="#mem-primitive"><code>mem</code> Primitive</a></li>
<li><a href="#modifier"><code>'</code> Modifier</a></li>
<li><a href="#primitive"><code>@</code> Primitive</a></li>
</ul></li>
<li><a href="#table-primitives">Table Primitives</a><ul>
<li><a href="#rtable-primitive"><code>rtable</code> Primitive</a></li>
<li><a href="#rwtable-primitive"><code>rwtable</code> Primitive</a></li>
</ul></li>
<li><a href="#selector-primitives">Selector Primitives</a><ul>
<li><a href="#select2-primitives"><code>select2</code> Primitives</a></li>
<li><a href="#select3-primitives"><code>select3</code> Primitives</a></li>
</ul></li>
<li><a href="#user-interface-primitives-and-configuration">User Interface Primitives and Configuration</a><ul>
<li><a href="#button-primitive"><code>button</code> Primitive</a></li>
<li><a href="#checkbox-primitive"><code>checkbox</code> Primitive</a></li>
<li><a href="#hslider-primitive"><code>hslider</code> Primitive</a></li>
<li><a href="#vslider-primitive"><code>vslider</code> Primitive</a></li>
<li><a href="#nentry-primitive"><code>nentry</code> Primitive</a></li>
<li><a href="#hgroup-primitive"><code>hgroup</code> Primitive</a></li>
<li><a href="#vgroup-primitive"><code>vgroup</code> Primitive</a></li>
<li><a href="#tgroup-primitive"><code>tgroup</code> Primitive</a></li>
<li><a href="#vbargraph-primitive"><code>vbargraph</code> Primitive</a></li>
<li><a href="#hbargraph-primitive"><code>hbargraph</code> Primitive</a></li>
<li><a href="#attach-primitive"><code>attach</code> Primitive</a></li>
<li><a href="#variable-parts-of-a-label">Variable Parts of a Label</a></li>
<li><a href="#labels-as-pathnames">Labels as Pathnames</a></li>
<li><a href="#links-to-generated-code">Links to Generated Code</a></li>
</ul></li>
<li><a href="#label-metadata">Label Metadata</a><ul>
<li><a href="#ordering-ui-elements">Ordering UI Elements</a></li>
<li><a href="#global-ui-metadata">Global UI Metadata</a></li>
<li><a href="#styleknob-metadata"><code>[style:knob]</code> Metadata</a></li>
<li><a href="#stylemenu-metadata"><code>style:menu</code> Metadata</a></li>
<li><a href="#styleradio-metadata"><code>style:radio</code> Metadata</a></li>
<li><a href="#styleled-metadata"><code>style:led</code> Metadata</a></li>
<li><a href="#unitdb-metadata"><code>unit:dB</code> Metadata</a></li>
<li><a href="#unitxx-metadata"><code>unit:xx</code> Metadata</a></li>
<li><a href="#scalexx-metadata"><code>[scale:xx]</code> Metadata</a></li>
<li><a href="#tooltipxx-metadata"><code>tooltip:xx</code> Metadata</a></li>
<li><a href="#hiddenxx-metadata"><code>[hidden:xx]</code> Metadata</a></li>
<li><a href="#screencolorxx-metadata"><code>[screencolor:xx]</code> Metadata</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#using-the-faust-compiler">Using the Faust Compiler</a></li>
<li><a href="#a-quick-tour-of-the-faust-targets">A Quick Tour of the Faust Targets</a></li>
<li><a href="#mathematical-documentation">Mathematical Documentation</a></li>
</ul>
</div>
</nav>
<main role="main" class="col-9 ml-sm-auto px-4 faust-doc-content">
<div data-spy="scroll" data-target="#TOC" data-offset="0" style="height: 100%;overflow-y: scroll;">
<h1 id="introduction">Introduction</h1>
<h2 id="what-is-faust">What is Faust?</h2>
<p>Faust (Functional Audio Stream) is a functional programming language for sound synthesis and audio processing with a strong focus on the design of synthesizers, musical instruments, audio effects, etc. Faust targets high-performance signal processing applications and audio plug-ins for a variety of platforms and standards. It is used on stage for concerts and artistic productions, in education and research, in open source projects as well as in commercial applications.</p>
<p>The core component of Faust is its compiler. It allows to “translate” any Faust digital signal processing (DSP) specification to a wide range of non-domain specific languages such as C++, C, JAVA, JavaScript, LLVM bit code, WebAssembly, etc. In this regard, Faust can be seen as an alternative to C++ but is much simpler and intuitive to learn.</p>
<p>Thanks to a wrapping system called “architectures,” codes generated by Faust can be easily compiled into a wide variety of objects ranging from <a href="TODO-tutorial">audio plug-ins</a> to <a href="TODO-tutorial">standalone applications</a> or <a href="TODO-tutorial">smartphone</a> and <a href="TODO-tutorial">web apps</a>, etc. (check the <a href="#a-quick-tour-of-the-faust-targets">Quick Tour of the Faust Targets</a> section for an exhaustive list.</p>
<p>This manual gives an overview of the Faust programming language and of its features through various interactive examples.</p>
<h2 id="what-is-faust-good-for">What is Faust Good For?</h2>
<p>Faust’s syntax allows to express any DSP algorithm as a block diagram. For example, <code>+</code> is considered as a valid function (and block) taking two arguments (signals) and returning one:</p>
<div class="faust-run"><a href="img/src/exfaust0/exfaust0-svg/process.svg" target="_blank"><img src="img/src/exfaust0/exfaust0-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = +;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust0/exfaust0.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Blocks can be easily connected together using the <code>:</code> “connection” composition:</p>
<div class="faust-run"><a href="img/src/exfaust1/exfaust1-svg/process.svg" target="_blank"><img src="img/src/exfaust1/exfaust1-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = + : *(0.5);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust1/exfaust1.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>In that case, we add two signals together and then scale the result of this operation.</p>
<p>Thus, <strong>Faust is perfect to implement time-domain algorithms that can be easily represented as block diagrams</strong> such as filters, waveguide physical models, virtual analog elements, etc.</p>
<p><strong>Faust is very concise</strong>, for example, here’s the implementation of a one pole filter/integrator equivalent to <span class="math inline">\(y(n) = x(x) + a_{1}y(n-1)\)</span> (where <span class="math inline">\(a_{1}\)</span> is the pole):</p>
<div class="faust-run"><a href="img/src/exfaust2/exfaust2-svg/process.svg" target="_blank"><img src="img/src/exfaust2/exfaust2-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>a1 = 0.9;
process = +~*(a1);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust2/exfaust2.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p><strong>Codes generated by Faust are extremely optimized</strong> and usually more efficient that handwritten codes (at least for C and C++). The Faust compiler tries to optimize each element of an algorithm. For example, you shouldn’t have to worry about using divides instead of multiplies as they get automatically replaced by multiplies by the compiler when possible, etc.</p>
<p><strong>Faust is very generic</strong> and allows to write code that will run on dozens of platforms.</p>
<!-- If we stick to this, we should also talk about the web capabilities: in
other words be a bit more specific here. -->
<h2 id="what-is-faust-not-so-good-for">What is Faust Not (So) Good For?</h2>
<p>Despite all this, Faust does have some limitations. For instance, it doesn’t allow for the efficient implementation of algorithms requiring multi-rates such as the FFT, convolution, etc. While there are tricks to go around this issue, we’re fully aware that it is a big one and we’re working as hard as possible on it.</p>
<p>Faust’s conciseness can sometimes become a problem too, especially for complex algorithms with lots of recursive signals. It is usually crucial in Faust to have the “mental global picture” of the algorithm to be implemented which in some cases can be hard.</p>
<p>While the Faust compiler is relatively bug-free, it does have some limitations and might get stuck in some extreme cases that you will probably never encounter. If you do, <a href="https://sourceforge.net/p/faudiostream/mailman/">shoot us an e-mail</a>!</p>
<p>From here, you can jump to … if you wanna get your hands dirty, etc. TODO.</p>
<h2 id="design-principles">Design Principles</h2>
<p>Since the beginning of its development in 2002, Faust has been guided by various design principles:</p>
<ul>
<li>Faust is a <em>specification language</em>. It aims at providing an adequate notation to describe <em>signal processors</em> from a mathematical point of view. Faust is, as much as possible, free from implementation details.</li>
<li>Faust programs are fully compiled (i.e., not interpreted). The compiler translates Faust programs into equivalent programs in other languages (e.g., JAVA, JavaScript, LLVM bit code, WebAssembly, etc.) taking care of generating the most efficient code. The result can generally compete with, and sometimes even outperform, C++ code written by seasoned programmers.</li>
<li>The generated code works at the sample level. It is therefore suited to implement low-level DSP functions like recursive filters. Moreover the code can be easily embedded. It is self-contained and doesn’t depend of any DSP library or runtime system. It has a very deterministic behavior and a constant memory footprint.</li>
<li>The semantic of Faust is simple and well defined. This is not just of academic interest. It allows the Faust compiler to be <em>semantically driven</em>. Instead of compiling a program literally, it compiles the mathematical function it denotes. This feature is useful for example to promote components reuse while preserving optimal performance.<br />
</li>
<li>Faust is a textual language but nevertheless block-diagram oriented. It actually combines two approaches: <em>functional programming</em> and <em>algebraic block-diagrams</em>. The key idea is to view block-diagram construction as function composition. For that purpose, Faust relies on a <em>block-diagram algebra</em> of five composition operations: <code>: , ~ &lt;: :&gt;</code> (see the section on <a href="#diagram-composition-operations">Diagram Composition Operations</a> for more details).</li>
<li>Thanks to the concept of <em>architecture</em>, Faust programs can be easily deployed on a large variety of audio platforms and plugin formats without any change to the Faust code.</li>
</ul>
<h2 id="signal-processor-semantic">Signal Processor Semantic</h2>
<p>A Faust program describes a <em>signal processor</em>. The role of a <em>signal processor</em> is to transforms a (possibly empty) group of <em>input signals</em> in order to produce a (possibly empty) group of <em>output signals</em>. Most audio equipments can be modeled as <em>signal processors</em>. They have audio inputs, audio outputs as well as control signals interfaced with sliders, knobs, vu-meters, etc.</p>
<p>More precisely :</p>
<ul>
<li>A <em>signal</em> <span class="math inline">\(s\)</span> is a discrete function of time <span class="math inline">\(s:\mathbb{Z}\rightarrow\mathbb{R}\)</span>. The value of a signal <span class="math inline">\(s\)</span> at time <span class="math inline">\(t\)</span> is written <span class="math inline">\(s(t)\)</span>. The values of signals are usually needed starting from time <span class="math inline">\(0\)</span>. But to take into account <em>delay operations</em>, negative times are possible and are always mapped to zeros. Therefore for any Faust signal <span class="math inline">\(s\)</span> we have <span class="math inline">\(\forall t&lt;0, s(t)=0\)</span>. In operational terms this corresponds to assuming that all delay lines are signals initialized with <span class="math inline">\(0\)</span>s.</li>
<li>Faust considers two type of signals: <em>integer signals</em> (<span class="math inline">\(s:\mathbb{Z}\rightarrow\mathbb{Z}\)</span>) and <em>floating point signals</em> (<span class="math inline">\(s:\mathbb{Z}\rightarrow\mathbb{Q}\)</span>). Exchanges with the outside world are, by convention, made using floating point signals. The full range is represented by sample values between <span class="math inline">\(-1.0\)</span> and <span class="math inline">\(+1.0\)</span>.</li>
<li>The set of all possible signals is <span class="math inline">\(\mathbb{S}=\mathbb{Z}\rightarrow\mathbb{R}\)</span>.</li>
<li>A group of <span class="math inline">\(n\)</span> signals (a <em>n</em>-tuple of signals) is written <span class="math inline">\((s_{1},\ldots,s_{n})\in \mathbb{S}^{n}\)</span>. The <em>empty tuple</em>, single element of <span class="math inline">\(\mathbb{S}^{0}\)</span> is notated <span class="math inline">\(()\)</span>.</li>
<li>A <em>signal processors</em> <span class="math inline">\(p\)</span>, is a function from <em>n</em>-tuples of signals to <em>m</em>-tuples of signals <span class="math inline">\(p:\mathbb{S}^{n}\rightarrow\mathbb{S}^{m}\)</span>. The set <span class="math inline">\(\mathbb{P}=\bigcup_{n,m}\mathbb{S}^{n}\rightarrow\mathbb{S}^{m}\)</span> is the set of all possible signal processors.</li>
</ul>
<p>As an example, let’s express the semantic of the Faust primitive <code>+</code>. Like any Faust expression, it is a signal processor. Its signature is <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}\)</span>. It takes two input signals <span class="math inline">\(X_0\)</span> and <span class="math inline">\(X_1\)</span> and produces an output signal <span class="math inline">\(Y\)</span> such that <span class="math inline">\(Y(t) = X_0(t)+X_1(t)\)</span>.</p>
<p>Numbers are signal processors too. For example the number <span class="math inline">\(3\)</span> has signature <span class="math inline">\(\mathbb{S}^{0}\rightarrow\mathbb{S}\)</span>. It takes no input signals and produce an output signal <span class="math inline">\(Y\)</span> such that <span class="math inline">\(Y(t) = 3\)</span>.</p>
<h1 id="quick-start">Quick Start</h1>
<p>TODO Will be all based on the online editor… May be could be a simple copy and paste of the session 1 of the Kadenze course…</p>
<h1 id="overview-of-the-faust-universe">Overview of the Faust Universe</h1>
<p>While in its most <em>primitive</em> form, Faust is distributed as a command-line compiler, a wide range of tools have been developed around it in the course of the past few years. Their variety and their function might be hard to grab at first. This sort chapter provides an overview of their role and will hopefully help you decide which one is better suited for your personal use.</p>
<!-- TODO: it'd be nice to have some kind of figure here summarizing everything -->
<p>TODO: here say a few words about the philosophy behind the disto: the online editor is the way to go for most users, then various pre-compiled packages of the compiler can be found, then source, then git. Finally other external tools for development.</p>
<h2 id="the-faust-distribution">The Faust Distribution</h2>
<p>The Faust distribution hosts the source of the Faust compiler (both in its command line and library version), the source of the Faust <em>architectures</em> (targets), the various Faust compilation scripts, a wide range of Faust-related-tools, the <a href="TODO">Faust DSP Libraries</a> (which in practice are hosted a separate Git submodule), etc.</p>
<p>The latest stable release of the Faust distribution can be found here: <a href="https://github.com/grame-cncm/faust/releases" class="uri">https://github.com/grame-cncm/faust/releases</a>. It is recommended for most Faust users willing to compile the Faust compiler and <code>libfaust</code> from scratch.</p>
<p>To have the latest stable development version, you can use the <code>master</code> branch of the Faust git repository which is hosted on GitHub: <a href="https://github.com/grame-cncm/faust/tree/master" class="uri">https://github.com/grame-cncm/faust/tree/master</a>.</p>
<p>For something even more bleeding edge (to be used at your own risks), you might use the <code>master-dev</code> branch of the Faust git repository: <a href="https://github.com/grame-cncm/faust/tree/master-dev" class="uri">https://github.com/grame-cncm/faust/tree/master-dev</a>. <code>master-dev</code> is the development sub-branch of <code>master</code>. It is used by Faust developers to commit their changes and can be considered as “the main development branch.” The goal is to make sure that <code>master</code> is always functional. Merges between <code>master-dev</code> and <code>master</code> are carried out multiple times a week by the GRAME team.</p>
<blockquote>
<p>Also, note that pre-compiled packages of the Faust compiler and of <code>libfaust</code> for various platforms can be found on the <a href="__FAUST_DOMAIN__/download">Download Page</a> of the Faust website.</p>
</blockquote>
<p>The Faust distribution is organized as follows:</p>
<pre><code>architecture/          : the source of the architecture files
benchmark/             : tools to measure the efficiency of the generated code
build/                 : the various makefiles and build folders
compiler/              : sources of the Faust compiler
COPYING                : license information
debian/                : files for Debian installation
Dockerfile             : docker file
documentation/         : Faust&#39;s documentations
examples/              : Faust programs examples organized by categories
installer/             : various installers for Linux distribution
libraries/             : Faust DSP libraries
Makefile               : makefile used to build and install Faust
README.md              : instructions on how to build and install Faust
syntax-highlighting/   : support for syntax highlighting for several editors
tests/                 : various tests
tools/                 : tools to produce audio applications and plugins
windows/               : Windows related ressources</code></pre>
<p>The following subsections present some of the main components of the Faust distribution.</p>
<h3 id="command-line-compiler">Command-Line Compiler</h3>
<ul>
<li>Link to precompiled version versions (download page)</li>
<li>What is the Faust compiler? (Quickly)</li>
<li>Link to <a href="#using-the-faust-compiler">Using the Faust Compiler</a></li>
</ul>
<h3 id="libfaust"><code>libfaust</code></h3>
<ul>
<li>Link to precompiled version versions (download page)</li>
<li>What is it? (Quickly)</li>
<li>Link to tutorial <a href="__FAUST_DOMAIN__/learn/embedding-faust">Embedding the Faust Compiler Using <code>libfaust</code></a></li>
</ul>
<h3 id="faust2...-scripts"><code>faust2...</code> Scripts</h3>
<h2 id="web-tools">Web Tools</h2>
<h3 id="the-online-editor">The Online Editor</h3>
<h3 id="the-faustplayground">The FaustPlayground</h3>
<h3 id="the-faust-online-compiler">The Faust Online Compiler</h3>
<h3 id="web-services">Web Services</h3>
<h2 id="development-tools">Development Tools</h2>
<h3 id="faustlive">FaustLive</h3>
<h3 id="faustworks">FaustWorks</h3>
<h1 id="compiling-and-installing-faust">Compiling and Installing Faust</h1>
<p>This chapter describes how to get and compile the Faust compiler as well as other tools related to Faust (e.g., <a href="#libfaust"><code>libfaust</code></a>, <code>libosc</code>, <code>libhttpd</code>, etc.).</p>
<h2 id="getting-the-source-code">Getting the Source Code</h2>
<p>An overview of the various places where the Faust source can be downloaded is given <a href="#the-faust-distribution">here</a>.</p>
<p>If you downloaded the latest Faust release, just un-compressed the archive file and open it in a terminal. For instance, something like (this might vary depending on the version of Faust you downloaded):</p>
<pre><code>tar xzf faust-2.5.31.tar.gz
cd faust-2.5.31</code></pre>
<p>If you wish to get the Faust source directly from the git repository, just run:</p>
<pre><code>git clone --recursive https://github.com/grame-cncm/faust.git
cd faust</code></pre>
<p>in a terminal. Note that the <code>--recursive</code> option is necessary here since some elements (e.g., the Faust DSP libraries) are placed in other repositories.</p>
<p>Finally, if you wish to use the development (and potentially unstable) branch, just run:</p>
<pre><code>git checkout master-dev</code></pre>
<p>after the previous 2 commands.</p>
<p>TODO: see with Dominique for whatever comes next here…</p>
<p>Since release 2.5.18, Faust compilation and installation is based on <code>cmake</code>.</p>
<h1 id="faust-syntax">Faust Syntax</h1>
<!-- TODO we should make a new introductory figure here and add some comments
about it. It'd be nice to make it interactive so that when people click on it,
they are brought to the right section. -->
<h2 id="faust-program">Faust Program</h2>
<p>A Faust program is essentially a list of <em>statements</em>. These statements can be <a href="#metadata-declarations"><em>metadata declarations</em></a>, <a href="#imports"><em>imports</em></a>, <a href="#definitions"><em>definitions</em></a>, and <a href="#documentation-tags"><em>documentation tags</em></a>, with optional C++ style (<code>//...</code> and <code>/*...*/</code>) comments.</p>
<p>Here is a short Faust program that implements of a simple noise generator (called from the <code>noises.lib</code> Faust library). It exhibits various kind of statements : two <a href="#metadata-declarations"><em>metadata declarations</em></a>, an <a href="#imports"><em>imports</em></a>, a <em>comment</em>, and a <a href="#definitions"><em>definition</em></a>. We will study later how <a href="#documentation-tags"><em>documentation statements</em></a> work:</p>
<div class="faust-run"><a href="img/src/exfaust3/exfaust3-svg/process.svg" target="_blank"><img src="img/src/exfaust3/exfaust3-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name  &quot;Noise&quot;;
declare copyright &quot;(c)GRAME 2018&quot;;

import(&quot;stdfaust.lib&quot;);

// noise level controlled by a slider
process = no.noise * hslider(&quot;gain&quot;,0,0,1, 0.1);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust3/exfaust3.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>The keyword <code>process</code> is the equivalent of <code>main</code> in C/C++. Any Faust program, to be valid, must at least define <code>process</code>.</p>
<h2 id="statements">Statements</h2>
<p>The <em>statements</em> of a Faust program are of four kinds:</p>
<ul>
<li><em>metadata declarations</em>,</li>
<li><em>file imports</em>,</li>
<li><em>definitions</em>,</li>
<li><em>documentation</em>.</li>
</ul>
<p>All statements but <em>documentation</em> end with a semicolon <code>;</code>.</p>
<h3 id="metadata-declarations">Metadata Declarations</h3>
<p>All metadata declaration in Faust start with <code>declare</code>.</p>
<p>When used in the context of Faust program (e.g., <code>.dsp</code> file), they are followed by a key and a string. For example:</p>
<pre><code>declare name &quot;Noise&quot;;</code></pre>
<p>allows us to specify the name of a Faust program in its whole.</p>
<p>When used in the context of a library (e.g., <code>.lib</code> file), metadata declarations can either be “global” (as in the previous example), or associated to a specific function. In that case, <code>declare</code> will be followed by the name of the function, a key, and a string. For example:</p>
<pre><code>declare add author &quot;John Doe&quot;
add = +;</code></pre>
<p>This is very useful when a library has several contributors and that functions potentially have different license terms.</p>
<p>Unlike regular comments, metadata declarations will appear in the C++ code generated by the Faust compiler. A good practice is to start a Faust program with some standard declarations:</p>
<pre><code>declare name &quot;MyProgram&quot;;
declare author &quot;MySelf&quot;;
declare copyright &quot;MyCompany&quot;;
declare version &quot;1.00&quot;;
declare license &quot;BSD&quot;; </code></pre>
<!-- TODO link to other metadata -->
<h3 id="imports">Imports</h3>
<p>File imports allow us to import definitions from other source files.</p>
<p>For example <code>import(&quot;maths.lib&quot;);</code> imports the definitions of the <a href="TODO"><code>maths.lib</code></a> library.</p>
<p>The most common file to be imported is the <code>stdfaust.lib</code> library which gives access to all the standard Faust libraries from a single point:</p>
<div class="faust-run"><a href="img/src/exfaust4/exfaust4-svg/process.svg" target="_blank"><img src="img/src/exfaust4/exfaust4-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
process = os.osc(440); // the &quot;hello world&quot; of computer music</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust4/exfaust4.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h3 id="documentation-tags">Documentation Tags</h3>
<p>Documentation statements are optional and typically used to control the generation of the mathematical documentation of a Faust program. This documentation system is detailed in the <a href="#mathematical-documentation">Mathematical Documentation</a> chapter. In this section we essentially describe the documentation statements syntax.</p>
<p>A documentation statement starts with an opening <code>&lt;mdoc&gt;</code> tag and ends with a closing <code>&lt;/mdoc&gt;</code> tag. Free text content, typically in Latex format, can be placed in between these two tags. <!-- Why not markdown? --></p>
<p><img src="img/documentation.svg" class="mx-auto d-block"></p>
<p>Moreover, optional sub-tags can be inserted in the text content itself to require the generation, at the insertion point, of mathematical <em>equations</em>, graphical <em>block-diagrams</em>, Faust source code <em>listing</em> and explanation <em>notice</em>.</p>
<p><img src="img/equation.svg" class="mx-auto d-block"></p>
<p>The generation of the mathematical equations of a Faust expression can be requested by placing this expression between an opening <code>&lt;equation&gt;</code> and a closing <code>&lt;/equation&gt;</code> tag. The expression is evaluated within the lexical context of the Faust program.</p>
<p><img src="img/diagram.svg" class="mx-auto d-block"></p>
<p>Similarly, the generation of the graphical block-diagram of a Faust expression can be requested by placing this expression between an opening <code>&lt;diagram&gt;</code> and a closing <code>&lt;/diagram&gt;</code> tag. The expression is evaluated within the lexical context of the Faust program.</p>
<p><img src="img/metadata.svg" class="mx-auto d-block"></p>
<p>The <code>&lt;metadata&gt;</code> tags allow to reference Faust <a href="#metadata-declarations">metadata declarations</a>, calling the corresponding keyword.</p>
<p><img src="img/notice.svg" class="mx-auto d-block"></p>
<p>The <code>&lt;notice/&gt;</code> empty-element tag is used to generate the conventions used in the mathematical equations.</p>
<p><img src="img/listing.svg" class="mx-auto d-block"></p>
<p>The <code>&lt;listing/&gt;</code> empty-element tag is used to generate the listing of the Faust program. Its three attributes <code>mdoctags</code>, <code>dependencies</code>, and <code>distributed</code> enable or disable respectively <code>&lt;mdoc&gt;</code> tags, other files dependencies and distribution of interleaved Faust code between <code>&lt;mdoc&gt;</code> sections.</p>
<h2 id="definitions">Definitions</h2>
<p>A <em>definition</em> associates an identifier with an expression. Definitions are essentially a convenient shortcut avoiding to type long expressions. During compilation, more precisely during the evaluation stage, identifiers are replaced by their definitions. It is therefore always equivalent to use an identifier or directly its definition. Please note that multiple definitions of a same identifier are not allowed, unless it is a pattern matching based definition.</p>
<h3 id="simple-definitions">Simple Definitions</h3>
<p>The syntax of a simple definition is:</p>
<pre><code>identifier = expression ;</code></pre>
<p>For example here is the definition of <code>random</code>, a simple pseudo-random number generator:</p>
<pre><code>random = +(12345) ~ *(1103515245);</code></pre>
<h2 id="function-definitions">Function Definitions</h2>
<p>Definitions with formal parameters correspond to functions definitions.</p>
<p><img src="img/listing.svg" class="mx-auto d-block"></p>
<p>For example the definition of <code>linear2db</code>, a function that converts linear values to decibels, is:</p>
<pre><code>linear2db(x) = 20*log10(x);</code></pre>
<p>Please note that this notation is only a convenient alternative to the direct use of <a href="#abstractions"><em>lambda-abstractions</em></a> (also called anonymous functions). The following is an equivalent definition of <code>linear2db</code> using a lambda-abstraction:</p>
<pre><code>linear2db = \(x).(20*log10(x));</code></pre>
<h2 id="definitions-with-pattern-matching">Definitions with pattern matching</h2>
<p>Moreover, formal parameters can also be full expressions representing patterns.</p>
<p><img src="img/listing.svg" class="mx-auto d-block"></p>
<p>This powerful mechanism allows to algorithmically create and manipulate block diagrams expressions. Let’s say that you want to describe a function to duplicate an expression several times in parallel:</p>
<pre><code>duplicate(1,x) = x;
duplicate(n,x) = x, duplicate(n-1,x);</code></pre>
<p>Note that this last definition is a convenient alternative to the more verbose:</p>
<pre><code>duplicate = case { 
  (1,x) =&gt; x; 
  (n,x) =&gt; duplicate(n-1,x); 
};</code></pre>
<p>A use case for <code>duplicate</code> could be to put 5 white noise generators in parallel:</p>
<div class="faust-run"><a href="img/src/exfaust5/exfaust5-svg/process.svg" target="_blank"><img src="img/src/exfaust5/exfaust5-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
duplicate(1,x) = x;
duplicate(n,x) = x, duplicate(n-1,x);
process = duplicate(5,no.noise);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust5/exfaust5.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Here is another example to count the number of elements of a list. Please note that we simulate lists using <a href="#parallel-composition">parallel composition</a>: <code>(1,2,3,5,7,11)</code>. The main limitation of this approach is that there is no empty list. Moreover lists of only one element are represented by this element:</p>
<pre><code>count((x,xs)) = 1+count(xs);
count(x) = 1;</code></pre>
<p>If we now write <code>count(duplicate(10,666))</code>, the expression will be evaluated as <code>10</code>.</p>
<p>Note that the order of pattern matching rules matters. The more specific rules must precede the more general rules. When this order is not respected, as in:</p>
<pre><code>count(x) = 1;
count((x,xs)) = 1+count(xs);</code></pre>
<p>the first rule will always match and the second rule will never be called.</p>
<h2 id="expressions">Expressions</h2>
<p>Despite its textual syntax, Faust is conceptually a block-diagram language. Faust expressions represent DSP block-diagrams and are assembled from primitive ones using various <em>composition</em> operations. More traditional <em>numerical</em> expressions in infix notation are also possible. Additionally Faust provides time based expressions, like delays, expressions related to lexical environments, expressions to interface with foreign function and lambda expressions.</p>
<p><img src="img/expression.svg" class="mx-auto d-block"></p>
<h3 id="diagram-expressions">Diagram Expressions</h3>
<p>Diagram expressions are assembled from primitive ones using either binary composition operations or high level iterative constructions.</p>
<p><img src="img/diagramexp.svg" class="mx-auto d-block"></p>
<h4 id="diagram-composition-operations">Diagram Composition Operations</h4>
<p>Five binary <em>composition operations</em> are available to combine block-diagrams:</p>
<ul>
<li><a href="#recursion-composition"><em>recursion</em></a> (<code>~</code>),</li>
<li><a href="#parallel-composition"><em>parallel</em></a> (<code>,</code>),</li>
<li><a href="#sequential-composition"><em>sequential</em></a> (<code>:</code>),</li>
<li><a href="#split-composition"><em>split</em></a> (<code>&lt;:</code>),</li>
<li><a href="#merge-composition"><em>merge</em></a> (<code>:&gt;</code>).</li>
</ul>
<p>One can think of each of these composition operations as a particular way to connect two block diagrams.</p>
<p><img src="img/diagcomposition.svg" class="mx-auto d-block"></p>
<p>To describe precisely how these connections are done, we have to introduce some notation. The number of inputs and outputs of a block-diagram <span class="math inline">\(A\)</span> are expressed as <span class="math inline">\(\mathrm{inputs}(A)\)</span> and <span class="math inline">\(\mathrm{outputs}(A)\)</span>. The inputs and outputs themselves are respectively expressed as: <span class="math inline">\([0]A\)</span>, <span class="math inline">\([1]A\)</span>, <span class="math inline">\([2]A\)</span>, <span class="math inline">\(\ldots\)</span> and <span class="math inline">\(A[0]\)</span>, <span class="math inline">\(A[1]\)</span>, <span class="math inline">\(A[2]\)</span>, etc.</p>
<p>For each composition operation between two block-diagrams <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> we will describe the connections <span class="math inline">\(A[i]\rightarrow [j]B\)</span> that are created and the constraints on their relative numbers of inputs and outputs.</p>
<p>The priority and associativity of this five operations are:</p>
<table>
<thead>
<tr class="header">
<th>Syntax</th>
<th>Priority</th>
<th>Association</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>expression ~ expression</code></td>
<td>4</td>
<td>left</td>
<td>Recursive Composition</td>
</tr>
<tr class="even">
<td><code>expression , expression</code></td>
<td>3</td>
<td>right</td>
<td>Parallel Composition</td>
</tr>
<tr class="odd">
<td><code>expression : expression</code></td>
<td>2</td>
<td>right</td>
<td>Sequential Composition</td>
</tr>
<tr class="even">
<td><code>expression &lt;: expression</code></td>
<td>1</td>
<td>right</td>
<td>Split Composition</td>
</tr>
<tr class="odd">
<td><code>expression :&gt; expression</code></td>
<td>1</td>
<td>right</td>
<td>Merge Composition</td>
</tr>
</tbody>
</table>
<h4 id="parallel-composition">Parallel Composition</h4>
<p>The <em>parallel composition</em> (e.g., <code>(A,B)</code>) is probably the simplest one. It places the two block-diagrams one on top of the other, without connections. The inputs of the resulting block-diagram are the inputs of <code>A</code> and <code>B</code>. The outputs of the resulting block-diagram are the outputs of <code>A</code> and <code>B</code>.</p>
<p><em>Parallel composition</em> is an associative operation: <code>(A,(B,C))</code> and <code>((A,B),C)</code> are equivalents. When no parenthesis are used (e.g., <code>A,B,C,D</code>), Faust uses right associativity and therefore builds internally the expression <code>(A,(B,(C,D)))</code>. This organization is important to know when using pattern matching techniques on parallel compositions.</p>
<p><strong>Example: Oscillators in Parallel</strong></p>
<p><em>Parallel composition</em> can be used to put 3 oscillators of different kinds and frequencies in parallel, which will result in a Faust program with 3 outputs:</p>
<div class="faust-run"><a href="img/src/exfaust6/exfaust6-svg/process.svg" target="_blank"><img src="img/src/exfaust6/exfaust6-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
process = os.osc(440),os.sawtooth(550),os.triangle(660);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust6/exfaust6.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p><strong>Example: Stereo Effect</strong></p>
<p><em>Parallel composition</em> can be used to easily turn a mono effect into a stereo one which will result in a Faust program with 2 inputs and 2 outputs:</p>
<div class="faust-run"><a href="img/src/exfaust7/exfaust7-svg/process.svg" target="_blank"><img src="img/src/exfaust7/exfaust7-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
level = 1;
process = ve.autowah(level),ve.autowah(level);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust7/exfaust7.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Note that there’s a better to write this last example using the <a href="#par-iteration"><code>par</code> iteration</a>:</p>
<div class="faust-run"><a href="img/src/exfaust8/exfaust8-svg/process.svg" target="_blank"><img src="img/src/exfaust8/exfaust8-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
level = 1;
process = par(i,2,ve.autowah(level));</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust8/exfaust8.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="sequential-composition">Sequential Composition</h4>
<p>The <em>sequential composition</em> (e.g., <code>A:B</code>) expects:</p>
<p><span class="math display">\[\mathrm{outputs}(A)=\mathrm{inputs}(B)\]</span></p>
<p>It connects each output of <span class="math inline">\(A\)</span> to the corresponding input of <span class="math inline">\(B\)</span>:</p>
<p><span class="math display">\[A[i]\rightarrow[i]B\]</span></p>
<p><em>Sequential composition</em> is an associative operation: <code>(A:(B:C))</code> and <code>((A:B):C)</code> are equivalents. When no parenthesis are used, like in <code>A:B:C:D</code>, Faust uses right associativity and therefore builds internally the expression <code>(A:(B:(C:D)))</code>.</p>
<p><strong>Example: Sine Oscillator</strong></p>
<p>Since everything is considered as a signal generator in Faust, <em>sequential composition</em> can be simply used to pass an argument to a function:</p>
<div class="faust-run"><a href="img/src/exfaust9/exfaust9-svg/process.svg" target="_blank"><img src="img/src/exfaust9/exfaust9-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
process = 440 : os.osc;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust9/exfaust9.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p><strong>Example: Effect Chain</strong></p>
<p><em>Sequential composition</em> can be used to create an audio effect chain. Here we’re plugging a guitar distortion to an autowah:</p>
<div class="faust-run"><a href="img/src/exfaust10/exfaust10-svg/process.svg" target="_blank"><img src="img/src/exfaust10/exfaust10-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
drive = 0.6;
offset = 0;
autoWahLevel = 1;
process = ef.cubicnl(drive,offset) : ve.autowah(autoWahLevel);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust10/exfaust10.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="split-composition">Split Composition</h4>
<p>The <em>split composition</em> (e.g., <code>A&lt;:B</code>) operator is used to distribute the outputs of <span class="math inline">\(A\)</span> to the inputs of <span class="math inline">\(B\)</span>.</p>
<p>For the operation to be valid, the number of inputs of <span class="math inline">\(B\)</span> must be a multiple of the number of outputs of <span class="math inline">\(A\)</span>:</p>
<p><span class="math display">\[\mathrm{outputs}(A).k=\mathrm{inputs}(B)\]</span></p>
<p>Each input <span class="math inline">\(i\)</span> of <span class="math inline">\(B\)</span> is connected to the output <span class="math inline">\(i \bmod k\)</span> of <span class="math inline">\(A\)</span>:</p>
<p><span class="math display">\[A[i \bmod k]\rightarrow[i]B\]</span></p>
<p><strong>Example: Duplicating the Output of an Oscillator</strong></p>
<p><em>Split composition</em> can be used to duplicate signals. For example, the output of the following sawtooth oscillator is duplicated 3 times in parallel.</p>
<div class="faust-run"><a href="img/src/exfaust11/exfaust11-svg/process.svg" target="_blank"><img src="img/src/exfaust11/exfaust11-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
process = os.sawtooth(440) &lt;: _,_,_;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust11/exfaust11.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Note that this can be written in a more effective way by replacing <code>_,_,_</code> with <code>par(i,3,_)</code> using the <a href="#par-iteration"><code>par</code> iteration</a>.</p>
<p><strong>Example: Connecting a Mono Effect to a Stereo One</strong></p>
<p>More generally, the <em>split composition</em> can be used to connect a block with a certain number of output to a block with a greater number of inputs:</p>
<div class="faust-run"><a href="img/src/exfaust12/exfaust12-svg/process.svg" target="_blank"><img src="img/src/exfaust12/exfaust12-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
drive = 0.6;
offset = 0;
process = ef.cubicnl(drive,offset) &lt;: dm.zita_light;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust12/exfaust12.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Note that an arbitrary number of signals can be split, for example:</p>
<div class="faust-run"><a href="img/src/exfaust13/exfaust13-svg/process.svg" target="_blank"><img src="img/src/exfaust13/exfaust13-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
drive = 0.6;
offset = 0;
process = par(i,2,ef.cubicnl(drive,offset)) &lt;: par(i,2,dm.zita_light);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust13/exfaust13.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Once again, the only rule with this is that in the expression <code>A&lt;:B</code> the number of inputs of <code>B</code> has to be a multiple of the number of outputs of <code>A</code>.</p>
<!-- TODO: make sure that signal distribution rules are explained somewhere
else in the doc -->
<h4 id="merge-composition">Merge Composition</h4>
<p>The <em>merge composition</em> (e.g., <code>A:&gt;B</code>) is the dual of the <a href="#split-composition"><em>split composition</em></a>. The number of outputs of <span class="math inline">\(A\)</span> must be a multiple of the number of inputs of <span class="math inline">\(B\)</span>:</p>
<p><span class="math display">\[\mathrm{outputs}(A)=k.\mathrm{inputs}(B)\]</span></p>
<p>Each output <span class="math inline">\(i\)</span> of <span class="math inline">\(A\)</span> is connected to the input <span class="math inline">\(i \bmod k\)</span> of <span class="math inline">\(B\)</span> :</p>
<p><span class="math display">\[A[i]\rightarrow\ [i \bmod k]B\]</span></p>
<p>The <span class="math inline">\(k\)</span> incoming signals of an input of <span class="math inline">\(B\)</span> are summed together.</p>
<p><strong>Example: Summing Signals Together - Additive Synthesis</strong></p>
<p><em>Merge composition</em> can be used to sum an arbitrary number of signals together. Here’s an example of a simple additive synthesizer (note that the result of the sum of the signals is divided by 3 to prevent clicking):</p>
<div class="faust-run"><a href="img/src/exfaust14/exfaust14-svg/process.svg" target="_blank"><img src="img/src/exfaust14/exfaust14-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freq = hslider(&quot;freq&quot;,440,50,3000,0.01);
gain = hslider(&quot;gain&quot;,1,0,1,0.01);
gate = button(&quot;gate&quot;);
envelope = gain*gate : si.smoo;
process = os.osc(freq),os.osc(freq*2),os.osc(freq*3) :&gt; /(3)*envelope;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust14/exfaust14.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>While the resulting block diagram will look slightly different, this is mathematically equivalent to:</p>
<div class="faust-run"><a href="img/src/exfaust15/exfaust15-svg/process.svg" target="_blank"><img src="img/src/exfaust15/exfaust15-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freq = hslider(&quot;freq&quot;,440,50,3000,0.01);
gain = hslider(&quot;gain&quot;,1,0,1,0.01);
gate = button(&quot;gate&quot;);
envelope = gain*gate : si.smoo;
process = (os.osc(freq) + os.osc(freq*2) + os.osc(freq*3))/(3)*envelope;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust15/exfaust15.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p><strong>Example: Connecting a Stereo Effect to a Mono One</strong></p>
<p>More generally, the <em>merge composition</em> can be used to connect a block with a certain number of output to a block with a smaller number of inputs:</p>
<div class="faust-run"><a href="img/src/exfaust16/exfaust16-svg/process.svg" target="_blank"><img src="img/src/exfaust16/exfaust16-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
drive = 0.6;
offset = 0;
process = dm.zita_light :&gt; ef.cubicnl(drive,offset);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust16/exfaust16.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Note that an arbitrary number of signals can be split, for example:</p>
<div class="faust-run"><a href="img/src/exfaust17/exfaust17-svg/process.svg" target="_blank"><img src="img/src/exfaust17/exfaust17-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
drive = 0.6;
offset = 0;
process = par(i,2,dm.zita_light) :&gt; par(i,2,ef.cubicnl(drive,offset));</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust17/exfaust17.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Once again, the only rule with this is that in the expression <code>A:&gt;B</code> the number of outputs of <code>A</code> has to be a multiple of the number of inputs of <code>B</code>.</p>
<h4 id="recursive-composition">Recursive Composition</h4>
<p>The <em>recursive composition</em> (e.g., <code>A~B</code>) is used to create cycles in the block-diagram in order to express recursive computations. It is the most complex operation in terms of connections.</p>
<p>To be applicable, it requires that:</p>
<p><span class="math display">\[\mathrm{outputs}(A) \geq \mathrm{inputs}(B) and \mathrm{inputs}(A) \geq \mathrm{outputs}(B)\]</span></p>
<p>Each input of <span class="math inline">\(B\)</span> is connected to the corresponding output of <span class="math inline">\(A\)</span> via an implicit 1-sample delay :</p>
<p><span class="math display">\[A[i]\stackrel{Z^{-1}}{\rightarrow}[i]B\]</span></p>
<p>and each output of <span class="math inline">\(B\)</span> is connected to the corresponding input of <span class="math inline">\(A\)</span>:</p>
<p><span class="math display">\[B[i]\rightarrow [i]A\]</span></p>
<p>The inputs of the resulting block diagram are the remaining unconnected inputs of <span class="math inline">\(A\)</span>. The outputs are all the outputs of <span class="math inline">\(A\)</span>.</p>
<p><strong>Example: Timer</strong></p>
<p><em>Recursive composition</em> can be used to implement a “timer” that will count each sample starting at time <span class="math inline">\(n=0\)</span>:</p>
<div class="faust-run"><a href="img/src/exfaust18/exfaust18-svg/process.svg" target="_blank"><img src="img/src/exfaust18/exfaust18-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = _~+(1);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust18/exfaust18.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>The difference equation corresponding to this program is:</p>
<p><span class="math display">\[y(n) = y(n-1) + 1\]</span></p>
<p>an its output signal will look like: <span class="math inline">\((1,2,3,4,5,6,\dots)\)</span>.</p>
<p><strong>Example: One Pole Filter</strong></p>
<p><em>Recursive composition</em> can be used to implement a one pole filter with one line of code and just a few characters:</p>
<div class="faust-run"><a href="img/src/exfaust19/exfaust19-svg/process.svg" target="_blank"><img src="img/src/exfaust19/exfaust19-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>a1 = 0.999; // the pole
process = +~*(a1);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust19/exfaust19.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>The difference equation corresponding to this program is:</p>
<p><span class="math display">\[y(n) = x(n) + a_{1}y(n-1)\]</span></p>
<p>Note that the one sample delay of the filter is implicit here so it doesn’t have to be declared.</p>
<h4 id="inputs-and-outputs-of-an-expression">Inputs and Outputs of an Expression</h4>
<p>The number of inputs and outputs of a Faust expression can be known at compile time simply by using <code>inputs(expression)</code> and <code>outputs(expression)</code>.</p>
<p>For example, the number of outputs of a sine wave oscillator can be known simply by writing the following program:</p>
<div class="faust-run"><a href="img/src/exfaust20/exfaust20-svg/process.svg" target="_blank"><img src="img/src/exfaust20/exfaust20-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
process = outputs(os.osc(440));</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust20/exfaust20.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Note that Faust automatically simplified the expression by generating a program that just outputs <code>1</code>.</p>
<p>This type of construction is useful to define high order functions and build algorithmically complex block-diagrams. Here is an example to automatically reverse the order of the outputs of an expression.</p>
<pre><code>Xo(expr) = expr &lt;: par(i,n,ba.selector(n-i-1,n)) 
with { 
  n = outputs(expr);
};</code></pre>
<p>And the inputs of an expression :</p>
<pre><code>Xi(expr) = si.bus(n) &lt;: par(i,n,ba.selector(n-i-1,n)) : expr 
with { 
  n = inputs(expr); 
};</code></pre>
<p>For example <code>Xi(-)</code> will reverse the order of the two inputs of the substraction:</p>
<div class="faust-run"><a href="img/src/exfaust21/exfaust21-svg/process.svg" target="_blank"><img src="img/src/exfaust21/exfaust21-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
Xi(expr) = si.bus(n) &lt;: par(i,n,ba.selector(n-i-1,n)) : expr 
with { 
  n = inputs(expr); 
};
toto = os.osc(440),os.sawtooth(440), os.triangle(440);
process = Xi(-);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust21/exfaust21.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="iterations">Iterations</h4>
<p>Iterations are analogous to <code>for(...)</code> loops in other languages and provide a convenient way to automate some complex block-diagram constructions.</p>
<p><img src="img/diagiteration.svg" class="mx-auto d-block"></p>
<p>The use and role of <a href="#par-iteration"><code>par</code></a>, <a href="#seq-iteration"><code>seq</code></a>, <a href="#sum-iteration"><code>sum</code></a>, and <a href="#prod-iteration"><code>prod</code></a> are detailed in the following sections.</p>
<h4 id="par-iteration"><code>par</code> Iteration</h4>
<p>The <code>par</code> iteration can be used to duplicate an expression in parallel. Just like other types of iterations in Faust:</p>
<ul>
<li>its first argument is a variable name containing the number of the current iteration (a bit like the variable that is usually named <code>i</code> in a for loop) starting at 0,</li>
<li>its second argument is the number of iterations,</li>
<li>its third argument is the expression to be duplicated.</li>
</ul>
<p><strong>Example: Simple Additive Synthesizer</strong></p>
<div class="faust-run"><a href="img/src/exfaust22/exfaust22-svg/process.svg" target="_blank"><img src="img/src/exfaust22/exfaust22-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freq = hslider(&quot;freq&quot;,440,50,3000,0.01);
gain = hslider(&quot;gain&quot;,1,0,1,0.01);
gate = button(&quot;gate&quot;);
envelope = gain*gate : si.smoo;
nHarmonics = 4;
process = par(i,nHarmonics,os.osc(freq*(i+1))) :&gt; /(nHarmonics)*envelope;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust22/exfaust22.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p><code>i</code> is used here at each iteration to compute the value of the frequency of the current oscillator. Also, note that this example could be re-wrtitten using <a href="#sum-iteration"><code>sum</code> iteration</a> (see example in the corresponding section).</p>
<h4 id="seq-iteration"><code>seq</code> Iteration</h4>
<p>The <code>seq</code> iteration can be used to duplicate an expression in series. Just like other types of iterations in Faust:</p>
<ul>
<li>its first argument is a variable name containing the number of the current iteration (a bit like the variable that is usually named <code>i</code> in a for loop) starting at 0,</li>
<li>its second argument is the number of iterations,</li>
<li>its third argument is the expression to be duplicated.</li>
</ul>
<p><strong>Example: Peak Equalizer</strong></p>
<p>The <a href="TODO"><code>fi.peak_eq</code></a> function of the Faust libraries implements a second order “peak equalizer” section (gain boost or cut near some frequency). When placed in series, it can be used to implement a full peak equalizer:</p>
<div class="faust-run"><a href="img/src/exfaust23/exfaust23-svg/process.svg" target="_blank"><img src="img/src/exfaust23/exfaust23-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
nBands = 8;
filterBank(N) = hgroup(&quot;Filter Bank&quot;,seq(i,N,oneBand(i)))
with{
    oneBand(j) = vgroup(&quot;[%j]Band %a&quot;,fi.peak_eq(l,f,b))
    with{
        a = j+1; // just so that band numbers don&#39;t start at 0
        l = vslider(&quot;[2]Level[unit:db]&quot;,0,-70,12,0.01) : si.smoo;
        f = nentry(&quot;[1]Freq&quot;,(80+(1000*8/N*(j+1)-80)),20,20000,0.01) : si.smoo;
        b = f/hslider(&quot;[0]Q[style:knob]&quot;,1,1,50,0.01) : si.smoo;
    };
};
process = filterBank(nBands);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust23/exfaust23.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Note that <code>i</code> is used here at each iteration to compute various elements and to format some labels. Having user interface elements with different names is a way to force their differentiation in the generated interface.</p>
<h4 id="sum-iteration"><code>sum</code> Iteration</h4>
<p>The <code>sum</code> iteration can be used to duplicate an expression as a sum. Just like other types of iterations in Faust:</p>
<ul>
<li>its first argument is a variable name containing the number of the current iteration (a bit like the variable that is usually named <code>i</code> in a for loop) starting at 0,</li>
<li>its second argument is the number of iterations,</li>
<li>its third argument is the expression to be duplicated.</li>
</ul>
<p><strong>Example: Simple Additive Synthesizer</strong></p>
<p>The following example is just a slightly different version from the one presented in the <a href="#par-iteration"><code>par</code> iteration</a> section. While their block diagrams look slightly different, the generated code is exactly the same.</p>
<div class="faust-run"><a href="img/src/exfaust24/exfaust24-svg/process.svg" target="_blank"><img src="img/src/exfaust24/exfaust24-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freq = hslider(&quot;freq&quot;,440,50,3000,0.01);
gain = hslider(&quot;gain&quot;,1,0,1,0.01);
gate = button(&quot;gate&quot;);
envelope = gain*gate : si.smoo;
nHarmonics = 4;
process = sum(i,nHarmonics,os.osc(freq*(i+1)))/(nHarmonics)*envelope;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust24/exfaust24.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p><code>i</code> is used here at each iteration to compute the value of the frequency of the current oscillator.</p>
<h4 id="prod-iteration"><code>prod</code> Iteration</h4>
<p>The <code>sum</code> iteration can be used to duplicate an expression as a product. Just like other types of iterations in Faust:</p>
<ul>
<li>its first argument is a variable name containing the number of the current iteration (a bit like the variable that is usually named <code>i</code> in a for loop) starting at 0,</li>
<li>its second argument is the number of iterations,</li>
<li>its third argument is the expression to be duplicated.</li>
</ul>
<p><strong>Example: Amplitude Modulation Synthesizer</strong></p>
<p>The following example implements an amplitude modulation synthesizer using an arbitrary number of oscillators thanks to the <code>prod</code> iteration:</p>
<div class="faust-run"><a href="img/src/exfaust25/exfaust25-svg/process.svg" target="_blank"><img src="img/src/exfaust25/exfaust25-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freq = hslider(&quot;[0]freq&quot;,440,50,3000,0.01);
gain = hslider(&quot;[1]gain&quot;,1,0,1,0.01);
shift = hslider(&quot;[2]shift&quot;,0,0,1,0.01);
gate = button(&quot;[3]gate&quot;);
envelope = gain*gate : si.smoo;
nOscs = 4;
process = prod(i,nOscs,os.osc(freq*(i+1+shift)))*envelope;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust25/exfaust25.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p><code>i</code> is used here at each iteration to compute the value of the frequency of the current oscillator. Note that the <code>shift</code> parameter can be used to tune the frequency drift between each oscillator.</p>
<h3 id="infix-notation-and-other-syntax-extensions">Infix Notation and Other Syntax Extensions</h3>
<blockquote>
<p>Infix notation is commonly used in mathematics. It consists in placing the operand between the arguments as in <span class="math inline">\(2+3\)</span></p>
</blockquote>
<p>Besides its algebra-based core syntax, Faust provides some syntax extensions, in particular the familiar <em>infix notation</em>. For example if you want to multiply two numbers, say <code>2</code> and <code>3</code>, you can write directly <code>2*3</code> instead of the equivalent core-syntax expression <code>2,3 : *</code>.</p>
<p>The <em>infix notation</em> is not limited to numbers or numerical expressions. Arbitrary expressions <code>A</code> and <code>B</code> can be used, provided that <code>A,B</code> has exactly two outputs. For example <code>_/2</code> is equivalent to <code>_,2:/</code> which divides the incoming signal by <code>2</code>.</p>
<p>Here are a few examples of equivalences:</p>
<table>
<thead>
<tr class="header">
<th>Infix Syntax</th>
<th></th>
<th>Core Syntax</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>2-3</code></td>
<td><span class="math inline">\(\equiv\)</span></td>
<td><code>2,3 : -</code></td>
</tr>
<tr class="even">
<td><code>2*3</code></td>
<td><span class="math inline">\(\equiv\)</span></td>
<td><code>2,3 : *</code></td>
</tr>
<tr class="odd">
<td><code>_@7</code></td>
<td><span class="math inline">\(\equiv\)</span></td>
<td><code>_,7 : @</code></td>
</tr>
<tr class="even">
<td><code>_/2</code></td>
<td><span class="math inline">\(\equiv\)</span></td>
<td><code>_,2 : /</code></td>
</tr>
<tr class="odd">
<td><code>A&lt;B</code></td>
<td><span class="math inline">\(\equiv\)</span></td>
<td><code>A,B : &lt;</code></td>
</tr>
</tbody>
</table>
<p>In case of doubts on the meaning of an infix expression, for example <code>_*_</code>, it is useful to translate it to its core syntax equivalent, here <code>_,_:*</code>, which is equivalent to <code>*</code>.</p>
<h4 id="infix-operators">Infix Operators</h4>
<p>Built-in primitives that can be used in infix notation are called <em>infix operators</em> and are listed below. Please note that a more detailed description of these operators is available <a href="#primitives">section on primitives</a>.</p>
<p><img src="img/infixop.svg" class="mx-auto d-block"></p>
<h4 id="prefix-notation">Prefix Notation</h4>
<p>Beside <em>infix notation</em>, it is also possible to use <em>prefix notation</em>. The <em>prefix notation</em> is the usual mathematical notation for functions <span class="math inline">\(f(x,y,z,\ldots)\)</span>, but extended to <em>infix operators</em>.</p>
<p>It consists in first having the operator, for example <code>/</code>, followed by its arguments between parentheses: <code>/(2,3)</code>:</p>
<table>
<thead>
<tr class="header">
<th>Prefix Syntax</th>
<th></th>
<th>Core Syntax</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>*(2,3)</code></td>
<td><span class="math inline">\(\equiv\)</span></td>
<td><code>2,3 : *</code></td>
</tr>
<tr class="even">
<td><code>@(_,7)</code></td>
<td><span class="math inline">\(\equiv\)</span></td>
<td><code>_,7 : @</code></td>
</tr>
<tr class="odd">
<td><code>/(_,2)</code></td>
<td><span class="math inline">\(\equiv\)</span></td>
<td><code>_,2 : /</code></td>
</tr>
<tr class="even">
<td><code>&lt;(A,B)</code></td>
<td><span class="math inline">\(\equiv\)</span></td>
<td><code>A,B : &lt;</code></td>
</tr>
</tbody>
</table>
<h4 id="partial-application">Partial Application</h4>
<p>The <em>partial application</em> notation is a variant of the <em>prefix notation</em> in which not all arguments are given. For instance <code>/(2)</code> (divide by 2), <code>^(3)</code> (rise to the cube), and <code>@(512)</code> (delay by 512 samples) are examples of partial applications where only one argument is given. The result of a partial application is a function that “waits” for the remaining arguments.</p>
<p>When doing partial application with an <em>infix operator</em>, it is important to note that the supplied argument is not the first argument, but always the second one:</p>
<table>
<thead>
<tr class="header">
<th>Prefix Partial Application Syntax</th>
<th></th>
<th>Core Syntax</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>+(C)</code></td>
<td><span class="math inline">\(\equiv\)</span></td>
<td><code>_,C : *</code></td>
</tr>
<tr class="even">
<td><code>-(C)</code></td>
<td><span class="math inline">\(\equiv\)</span></td>
<td><code>_,C : -</code></td>
</tr>
<tr class="odd">
<td><code>&lt;(C)</code></td>
<td><span class="math inline">\(\equiv\)</span></td>
<td><code>_,C : &lt;</code></td>
</tr>
<tr class="even">
<td><code>/(C)</code></td>
<td><span class="math inline">\(\equiv\)</span></td>
<td><code>_,C : /</code></td>
</tr>
</tbody>
</table>
<p>For commutative operations that doesn’t matter. But for non-commutative ones, it is more “natural” to fix the second argument. We use divide by 2 (<code>/(2)</code>) or rise to the cube (<code>^(3)</code>) more often than the other way around.</p>
<p>Please note that this rule only applies to infix operators, not to other primitives or functions. If you partially apply a regular function to a single argument, it will correspond to the first parameter.</p>
<p><strong>Example: Gain Controller</strong></p>
<p>The following example demonstrates the use of partial application in the context of a gain controller:</p>
<div class="faust-run"><a href="img/src/exfaust26/exfaust26-svg/process.svg" target="_blank"><img src="img/src/exfaust26/exfaust26-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>gain = hslider(&quot;gain&quot;,0.5,0,1,0.01);
process = *(gain);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust26/exfaust26.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h3 id="time-expression"><code>'</code> Time Expression</h3>
<p><code>'</code> is used to express a one sample delay. For example:</p>
<div class="faust-run"><a href="img/src/exfaust27/exfaust27-svg/process.svg" target="_blank"><img src="img/src/exfaust27/exfaust27-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = _&#39;;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust27/exfaust27.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>will delay the incoming signal by one sample.</p>
<p><code>'</code> time expressions can be chained, so the output signal of this program:</p>
<div class="faust-run"><a href="img/src/exfaust28/exfaust28-svg/process.svg" target="_blank"><img src="img/src/exfaust28/exfaust28-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 1&#39;&#39;;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust28/exfaust28.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>will look like: <span class="math inline">\((0,0,1,1,1,1,\dots)\)</span>.</p>
<p>The <code>'</code> time expression is useful when designing filters, etc. and is equivalent to <code>@(1)</code> (see the <a href="#time-expression-1"><code>@</code> Time Expression</a>).</p>
<h3 id="time-expression-1"><code>@</code> Time Expression</h3>
<p><code>@</code> is used to express a delay with an arbitrary number of samples. For example:</p>
<div class="faust-run"><a href="img/src/exfaust29/exfaust29-svg/process.svg" target="_blank"><img src="img/src/exfaust29/exfaust29-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = @(10);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust29/exfaust29.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>will delay the incoming signal by 10 samples.</p>
<p>A delay expressed with <code>@</code> doesn’t have to be fixed but it must be positive and bounded. Therefore, the values of a slider are perfectly acceptable:</p>
<div class="faust-run"><a href="img/src/exfaust30/exfaust30-svg/process.svg" target="_blank"><img src="img/src/exfaust30/exfaust30-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = @(hslider(&quot;delay&quot;,0,0,100,1));</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust30/exfaust30.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p><code>@</code> only allows for the implementation of integer delay. Thus, various fractional delay algorithms are implemented in <a href="TODO">the Faust libraries</a>.</p>
<h3 id="environment-expressions">Environment Expressions</h3>
<p>Faust is a lexically scoped language. The meaning of a Faust expression is determined by its context of definition (its lexical environment) and not by its context of use.</p>
<p>To keep their original meaning, Faust expressions are bounded to their lexical environment in structures called <em>closures</em>. The following constructions allow to explicitly create and access such environments. Moreover they provide powerful means to reuse existing code and promote modular design.</p>
<p><img src="img/envexp.svg" class="mx-auto d-block"></p>
<h4 id="with-expression"><code>with</code> Expression</h4>
<p>The <code>with</code> construction allows to specify a <em>local environment</em>: a private list of definition that will be used to evaluate the left hand expression.</p>
<p>In the following example :</p>
<div class="faust-run"><a href="img/src/exfaust31/exfaust31-svg/process.svg" target="_blank"><img src="img/src/exfaust31/exfaust31-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>pink = f : + ~ g 
with {
  f(x) = 0.04957526213389*x - 0.06305581334498*x&#39; + 0.01483220320740*x&#39;&#39;;
    g(x) = 1.80116083982126*x - 0.80257737639225*x&#39;;
};
process = pink;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust31/exfaust31.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>the definitions of <code>f(x)</code> and <code>g(x)</code> are local to <code>f : + ~ g</code>.</p>
<p>Please note that <code>with</code> is left associative and has the lowest priority:</p>
<ul>
<li><code>f : + ~ g with {...}</code> is equivalent to <code>(f : + ~ g)  with {...}</code>.</li>
<li><code>f : + ~ g with {...} with {...}</code> is equivalent to <code>((f : + ~ g)  with {...})  with {...}</code>.</li>
</ul>
<h4 id="letrec-expression"><code>letrec</code> Expression</h4>
<p>The <code>letrec</code> construction is somehow similar to <a href="#with-expression"><code>with</code></a>, but for difference equations instead of regular definitions. It allows us to easily express groups of mutually recursive signals, for example:</p>
<p><span class="math display">\[
x(t) = y(t-1) + 10\\
y(t) = x(t-1) - 1
\]</span></p>
<p>as <code>E letrec { 'x = y+10; 'y = x-1; }</code></p>
<p>The syntax is defined by the following rules:</p>
<p><img src="img/letrec.svg" class="mx-auto d-block"></p>
<p>Note the special notation <code>'x = y + 10</code> instead of <code>x = y' + 10</code>. It makes syntactically impossible to write non-sensical equations like <code>x=x+1</code>.</p>
<p>Here is a more involved example. Let say we want to define an envelope generator with an attack and a release time (as a number of samples), and a gate signal. A possible definition could be:</p>
<div class="faust-run"><a href="img/src/exfaust32/exfaust32-svg/process.svg" target="_blank"><img src="img/src/exfaust32/exfaust32-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
ar(a,r,g) = v
letrec {
  &#39;n = (n+1) * (g&lt;=g&#39;);
  &#39;v = max(0, v + (n&lt;a)/a - (n&gt;=a)/r) * (g&lt;=g&#39;);
};
gate = button(&quot;gate&quot;);
process = os.osc(440)*ar(1000,1000,gate);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust32/exfaust32.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>With the following semantics for <span class="math inline">\(n(t)\)</span> and <span class="math inline">\(v(t)\)</span>:</p>
<p><span class="math display">\[
n(t) = (n(t-1)+1) * (g(t) &lt;= g(t-1))\\
v(t) = max(0, v(t-1) + (n(t-1)&lt;a(t))/a(t) - (n(t-1)&gt;=a(t))/r(t)) * (g(t)&lt;=g(t-1))
\]</span></p>
<h4 id="environment-expression"><code>environment</code> Expression</h4>
<p>The <code>environment</code> construction allows to create an explicit environment. It is like a <a href="#with-expression">`with’</a>, but without the left hand expression. It is a convenient way to group together related definitions, to isolate groups of definitions and to create a name space hierarchy.</p>
<p><img src="img/environment.svg" class="mx-auto d-block"></p>
<p>In the following example an <code>environment</code> construction is used to group together some constant definitions :</p>
<pre><code>constant = environment {
  pi = 3.14159;
  e = 2,718;
    ...
};</code></pre>
<p>The <a href="#access-expression"><code>.</code> construction</a> allows to access the definitions of an environment (see next section).</p>
<h4 id="access-expression">Access Expression</h4>
<p>Definitions inside an environment can be accessed using the <code>.</code> construction.</p>
<p><img src="img/access.svg" class="mx-auto d-block"></p>
<p>For example <code>constant.pi</code> refers to the definition of <code>pi</code> in the <code>constant</code> environment <a href="#environment-expression">defined above</a>.</p>
<p>Note that environments don’t have to be named. We could have written directly:</p>
<pre><code>environment{pi = 3.14159; e = 2,718;....}.pi</code></pre>
<h4 id="library-expression"><code>library</code> Expression</h4>
<p>The <code>library</code> construct allows to create an environment by reading the definitions from a file.</p>
<p><img src="img/library.svg" class="mx-auto d-block"></p>
<p>For example <code>library(&quot;filters.lib&quot;)</code> represents the <a href="#environment-expression">environment</a> obtained by reading the file <code>filters.lib</code>. It works like <a href="TODO"><code>import(&quot;miscfilter.lib&quot;)</code></a> but all the read definitions are stored in a new separate lexical environment. Individual definitions can be accessed as described in the previous paragraph. For example <code>library(&quot;filters.lib&quot;).lowpass</code> denotes the function <code>lowpass</code> as defined in the file <code>miscfilter.lib</code>.</p>
<p>To avoid name conflicts when importing libraries it is recommended to prefer <code>library</code> to <a href="TODO"><code>import</code></a>. So instead of :</p>
<pre><code>import(&quot;filters.lib&quot;);
  ...
...lowpass....
    ...
};</code></pre>
<p>the following will ensure an absence of conflicts :</p>
<pre><code>fl = library(&quot;filters.lib&quot;);
  ...
...fl.lowpass....
    ...
};</code></pre>
<p>In practice, that’s how the <a href="TODO"><code>stdfaust.lib</code></a> library works.</p>
<!-- TODO: import? -->
<!-- TODO: we should also show how this type of construction can be used to
define function with variables with a predefined value, etc. -->
<h4 id="component-expression"><code>component</code> Expression</h4>
<p>The <code>component</code> construction allows us to reuse a full Faust program (e.g., a <code>.dsp</code> file) as a simple expression.</p>
<p><img src="img/component.svg" class="mx-auto d-block"></p>
<p>For example <code>component(&quot;freeverb.dsp&quot;)</code> denotes the signal processor defined in file <code>freeverb.dsp</code>.</p>
<p>Components can be used within expressions like in:</p>
<pre><code>...component(&quot;karplus32.dsp&quot;) : component(&quot;freeverb.dsp&quot;)... </code></pre>
<p>Please note that <code>component(&quot;freeverb.dsp&quot;)</code> is equivalent to <code>library(&quot;freeverb.dsp&quot;).process</code>.</p>
<p><code>component</code> works well in tandem with <a href="#explicit-substitution">explicit substitution</a> (see next section).</p>
<h4 id="explicit-substitution">Explicit Substitution</h4>
<p>Explicit substitution can be used to customize a component or any expression with a lexical environment by replacing some of its internal definitions, without having to modify it.</p>
<p><img src="img/explicitsubst.svg" class="mx-auto d-block"></p>
<p>For example we can create a customized version of <code>component(&quot;freeverb.dsp&quot;)</code>, with a different definition of <code>foo(x)</code>, by writing:</p>
<pre><code>...component(&quot;freeverb.dsp&quot;)[foo(x) = ...;]...
};</code></pre>
<h3 id="foreign-expressions">Foreign Expressions</h3>
<p>Reference to external C <em>functions</em>, <em>variables</em> and <em>constants</em> can be introduced using the <em>foreign function</em> mechanism.</p>
<p><img src="img/foreignexp.svg" class="mx-auto d-block"></p>
<!-- TODO something needs to be said about the fact that this is a C++ thing -->
<h4 id="ffunction"><code>ffunction</code></h4>
<p>An external C function is declared by indicating its name and signature as well as the required include file. The file <code>maths.lib</code> of the Faust distribution contains several foreign function definitions, for example <a href="TODO">the inverse hyperbolic sine function <code>asinh</code></a>:</p>
<pre><code>asinh = ffunction(float asinh (float), &lt;math.h&gt;, &quot;&quot;);</code></pre>
<!-- TODO: what happens for other languages than C? -->
<p>Foreign functions with input parameters are considered pure math functions. They are therefore considered free of side effects and called only when their parameters change (that is at the rate of the fastest parameter).</p>
<p>Exceptions are functions with no input parameters. A typical example is the C <code>rand()</code> function. In this case, the compiler generates code to call the function at sample rate.</p>
<h4 id="signature">Signature</h4>
<p>The signature part (<code>float asinh (float)</code> in the example presented in <a href="#ffunction">the previous section</a>) describes the prototype of the C function: return type, function name, and list of parameter types. Because the name of the foreign function can possibly depend on the floating point precision in use (float, double and quad), it is possible to give a different function name for each floating point precision using a signature with up to three function names.</p>
<p><img src="img/signature.svg" class="mx-auto d-block"></p>
<p>For example in the declaration:</p>
<pre><code>asinh = ffunction(float asinhf|asinh|asinhl (float), &lt;math.h&gt;, &quot;&quot;);</code></pre>
<p>the signature <code>float asinhf|asinh|asinhl (float)</code> indicates to use the function name <code>asinhf</code> in single precision, <code>asinh</code> in double precision and <code>asinhl</code> in long double (quad) precision.</p>
<h4 id="types">Types</h4>
<p>Only numerical functions involving simple <code>int</code> and <code>float</code> parameters are allowed currently in Faust. No vectors, tables or data structures can be passed as parameters or returned.</p>
<h4 id="variables-and-constants">Variables and Constants</h4>
<p>External variables and constants can also be declared with a similar syntax. In the same <code>maths.lib</code> file, the definition of the sampling rate constant <a href="TODO"><code>SR</code></a> and the definition of the block-size variable <a href="TODO"><code>BS</code></a> can be found:</p>
<pre><code>SR = min(192000.0,max(1.0,fconstant(int fSamplingFreq, &lt;math.h&gt;)));
BS = fvariable(int count, &lt;math.h&gt;);</code></pre>
<p>Foreign constants are not supposed to vary. Therefore expressions involving only foreign constants are only computed once, during the initialization period.</p>
<p>Variable are considered to vary at block speed. This means that expressions depending of external variables are computed every block.</p>
<h4 id="file-include">File Include</h4>
<p>In declaring foreign functions one has also to specify the include file. It allows the Faust compiler to add the corresponding <code>#include</code> in the generated code.</p>
<p><img src="img/includefile.svg" class="mx-auto d-block"></p>
<h4 id="library-file">Library File</h4>
<p>In declaring foreign functions one can possibly specify the library where the actual code is located. It allows the Faust compiler to (possibly) automatically link the library. Note that this feature is only used with the <a href="TODO">LLVM backend in ‘libfaust’ dynamic library model</a>.</p>
<!-- TODO I feel like more could be said here -->
<h3 id="applications-and-abstractions">Applications and Abstractions</h3>
<p><em>Abstractions</em> and <em>applications</em> are fundamental programming constructions directly inspired by Lambda-Calculus. These constructions provide powerful ways to describe and transform block-diagrams algorithmically.</p>
<p><img src="img/abstraction.svg" class="mx-auto d-block"></p>
<h4 id="abstractions">Abstractions</h4>
<p>Abstractions correspond to functions definitions and allow to generalize a block-diagram by <code>making variable</code> some of its parts.</p>
<p>Let’s say we want to transform a stereo reverb, <a href="TODO"><code>dm.zita_light</code></a> for instance, into a mono effect. The following expression can be written (see the sections on <a href="#split-composition">Split Composition</a> and <a href="#merge-composition">Merge Composition</a>):</p>
<pre><code>_ &lt;: dm.zita_light :&gt; _ </code></pre>
<p>The incoming mono signal is split to feed the two input channels of the reverb, while the two output channels of the reverb are mixed together to produce the resulting mono output.</p>
<p>Imagine now that we are interested in transforming other stereo effects. We could generalize this principle by making <code>zita_light</code> a variable:</p>
<pre><code>\(zita_light).(_ &lt;: zita_light :&gt; _)</code></pre>
<p>The resulting abstraction can then be applied to transform other effects. Note that if <code>zita_light</code> is a perfectly valid variable name, a more neutral name would probably be easier to read like:</p>
<pre><code>\(fx).(_ &lt;: fx :&gt; _)</code></pre>
<p>A name can be given to the abstraction and in turn use it on <code>dm.zita_light</code>:</p>
<div class="faust-run"><a href="img/src/exfaust33/exfaust33-svg/process.svg" target="_blank"><img src="img/src/exfaust33/exfaust33-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
mono = \(fx).(_ &lt;: fx :&gt; _);
process = mono(dm.zita_light);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust33/exfaust33.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Or even use a more traditional, but equivalent, notation:</p>
<pre><code>mono(fx) = _ &lt;: fx :&gt; _;</code></pre>
<h4 id="applications">Applications</h4>
<p>Applications correspond to function calls and allow to replace the variable parts of an abstraction with the specified arguments.</p>
<p><img src="img/application.svg" class="mx-auto d-block"></p>
<p>For example, the abstraction described in <a href="#abstractions">the previous section</a> can be used to transform a stereo reverb:</p>
<pre><code>mono(dm.zita_light)</code></pre>
<p>The compiler will start by replacing <code>mono</code> by its definition:</p>
<pre><code>\(fx).(_ &lt;: fx :&gt; _)(dm.zita_light)</code></pre>
<blockquote>
<p>Replacing the <em>variable part</em> with the argument is called beta-reduction in Lambda-Calculus</p>
</blockquote>
<p>Whenever the Faust compiler find an application of an abstraction it replaces the <em>variable part</em> with the argument. The resulting expression is as expected:</p>
<pre><code>(_ &lt;: dm.zita_light :&gt; _)</code></pre>
<h4 id="pattern-matching">Pattern Matching</h4>
<p>Pattern matching rules provide an effective way to analyze and transform block-diagrams algorithmically.</p>
<p><img src="img/patternabstraction.svg" class="mx-auto d-block"></p>
<p>For example <code>case{ (x:y) =&gt; y:x; (x) =&gt; x; }</code> contains two rules. The first one will match a sequential expression and invert the two part. The second one will match all remaining expressions and leave it untouched. Therefore the application:</p>
<pre><code>case{(x:y) =&gt; y:x; (x) =&gt; x;}(reverb : harmonizer)</code></pre>
<p>will produce:</p>
<pre><code>harmonizer : freeverb</code></pre>
<p>Please note that patterns are evaluated before the pattern matching operation. Therefore only variables that appear free in the pattern are binding variables during pattern matching.</p>
<!-- TODO: I think we need a better example here: that's a bit weak. We should
wait to see if it appears somewhere else... Also, I think there are some stuff
missing here. -->
<h2 id="primitives">Primitives</h2>
<p>The primitive signal processing operations represent the built-in functionalities of Faust, that is the atomic operations on signals provided by the language. All these primitives denote <em>signal processors</em>, in other words, functions transforming <em>input signals</em> into <em>output signals</em>.</p>
<!-- TODO: Diagram was removed here since everything is listed below: may be
we should put a table summarizing everything. -->
<h3 id="numbers">Numbers</h3>
<p>Faust considers two types of numbers: <em>integers</em> and <em>floats</em>. Integers are implemented as 32-bits integers, and floats are implemented either with a simple, double, or extended precision depending of the compiler options. Floats are available in decimal or scientific notation.</p>
<p><img src="img/numbers.svg" class="mx-auto d-block"></p>
<p>Like any other Faust expression, numbers are signal processors. For example the number 0.95 is a signal processor of type <span class="math inline">\(\mathbb{S}^{0}\rightarrow\mathbb{S}^{1}\)</span> that transforms an empty tuple of signals <span class="math inline">\(()\)</span> into a 1-tuple of signals <span class="math inline">\((y)\)</span> such that <span class="math inline">\(\forall t\in\mathbb{N}, y(t)=0.95\)</span>.</p>
<h3 id="waveform-primitive"><code>waveform</code> Primitive</h3>
<p>The waveform primitive was designed to facilitate the use of <a href="#rdtable"><code>rdtable</code></a> (read table). It allows us to specify a fixed periodic signal as a list of samples.</p>
<p><code>waveform</code> has two outputs:</p>
<ul>
<li>a constant and indicating the size (as a number of samples) of the period,</li>
<li>the periodic signal itself.</li>
</ul>
<p><img src="img/waveform.svg" class="mx-auto d-block"></p>
<p>For example <code>waveform{0,1,2,3}</code> produces two outputs: the constant signal 4 and the periodic signal <span class="math inline">\((0,1,2,3,0,1,2,3,0,1,\dots)\)</span>.</p>
<p>In the following example:</p>
<div class="faust-run"><a href="img/src/exfaust34/exfaust34-svg/process.svg" target="_blank"><img src="img/src/exfaust34/exfaust34-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
triangleWave = waveform{0,0.5,1,0.5,0,-0.5,-1,-.5};
triangleOsc(f) = triangleWave,int(os.phasor(8,f)) : rdtable;
f = hslider(&quot;freq&quot;,440,50,2000,0.01);
process = triangleOsc(f);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust34/exfaust34.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p><code>waveform</code> is used to define a triangle waveform (in its most primitive form), which is then used with a <a href="TODO"><code>rdtable</code></a> controlled by a phasor to implement a triangle wave oscillator. Note that the quality of this oscillator is very low because of the low resolution of the triangle waveform.</p>
<h3 id="soundfile-primitive"><code>soundfile</code> Primitive</h3>
<p>The <code>soundfile(&quot;label[url:path]&quot;, n)</code> primitive allows for the access of externally defined sound file/resource. <code>soundfile</code> has one input (the read index in the sound), three fixed outputs:</p>
<ul>
<li>the audio wave length in frames</li>
<li>the audio wave nominal sample rate</li>
<li>the audio wave number of channels</li>
</ul>
<p>and several more outputs for the audio channels themselves.</p>
<p>If more outputs than the actual number of channels in the sound file are used, the audio channels will be automatically duplicated up to the wanted number of outputs (so for instance, if a stereo file is used with four output channels, the same group of two channels will be duplicated).</p>
<p>If the sound file cannot be loaded for whatever reason, a default sound with one channel, a length of 1024 frames and null outputs (with samples of value 0) will be used. Note also that sound files are entirely loaded in memory by the architecture file.</p>
<p>Architecture files are responsible to load the actual soundfile. The <code>SoundUI</code> C++ class located in the <code>faust/gui/SoundUI.h</code> file in the <a href="https://github.com/grame-cncm/faust">Faust repository</a> implements the <code>void  addSoundfile(label, path, sf_zone)</code> method, which loads the actual soundfiles using the <code>libsndfile</code> library, and set up the <code>sf_zone</code> sound memory pointers. If <em>label</em> is used without any <em>url</em> metadata, it will be considered as the soundfile pathname.</p>
<p>Note that a special architecture file can well decide to access and use sound resources created by another means (that is, not directly loaded from a sound file). For instance a mapping between labels and sound resources defined in memory could be used, with some additional code in charge of actually setting up all sound memory pointers when <code>void  addSoundfile(label, path, sf_zone)</code> is called by the <code>buidUserInterface</code> mechanism.</p>
<!-- TODO: we need some working example here -->
<h3 id="c-equivalent-primitives">C-Equivalent Primitives</h3>
<p>Most Faust primitives are analogous to their C counterpart but adapted to signal processing. For example <code>+</code> is a function of type <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span> that transforms a pair of signals <span class="math inline">\((x_1,x_2)\)</span> into a 1-tuple of signals <span class="math inline">\((y)\)</span> such that <span class="math inline">\(\forall t\in\mathbb{N}, y(t)=x_{1}(t)+x_{2}(t)\)</span>. <code>+</code> can be used to very simply implement a mixer:</p>
<div class="faust-run"><a href="img/src/exfaust35/exfaust35-svg/process.svg" target="_blank"><img src="img/src/exfaust35/exfaust35-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = +;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust35/exfaust35.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Note that this is equivalent to (see <a href="#identity-function">Identity Function</a>):</p>
<div class="faust-run"><a href="img/src/exfaust36/exfaust36-svg/process.svg" target="_blank"><img src="img/src/exfaust36/exfaust36-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = _+_;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust36/exfaust36.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>The function <code>-</code> has type <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span> and transforms a pair of signals <span class="math inline">\((x_1,x_2)\)</span> into a 1-tuple of signals <span class="math inline">\((y)\)</span> such that <span class="math inline">\(\forall t\in\mathbb{N}, y(t)=x_{1}(t)-x_{2}(t)\)</span>.</p>
<p><strong>Be aware that</strong> the unary <code>-</code> only exists in a limited form. It can be used with numbers: <code>-0.5</code> and variables: <code>-myvar</code>, but not with expressions surrounded by parenthesis, because in this case it represents a partial application. For instance, <code>-(a*b)</code> is a partial application. It is syntactic sugar for <code>_,(a*b) : -</code>. If you want to negate a complex term in parenthesis, you’ll have to use <code>0 - (a*b)</code> instead.</p>
<!-- TODO: need to make sure that the identify function and the exclamation
are properly documented/mentioned somewhere and demonstrated -->
<h4 id="integer-number">Integer Number</h4>
<p>Integer numbers are of type <span class="math inline">\(\mathbb{S}^{0}\rightarrow\mathbb{S}^{1}\)</span> in Faust and can be described mathematically as <span class="math inline">\(y(t)=n\)</span>.</p>
<p><strong>Example: DC Offset of 1</strong></p>
<div class="faust-run"><a href="img/src/exfaust37/exfaust37-svg/process.svg" target="_blank"><img src="img/src/exfaust37/exfaust37-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 1;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust37/exfaust37.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="floating-point-number">Floating Point Number</h4>
<p>Floating point numbers are of type <span class="math inline">\(\mathbb{S}^{0}\rightarrow\mathbb{S}^{1}\)</span> in Faust and can be described as <span class="math inline">\(y(t)=n.m\)</span>.</p>
<p><strong>Example: DC Offset of 0.5</strong></p>
<div class="faust-run"><a href="img/src/exfaust38/exfaust38-svg/process.svg" target="_blank"><img src="img/src/exfaust38/exfaust38-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 0.5;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust38/exfaust38.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="identity-function">Identity Function</h4>
<p>The identity function is expressed in Faust with the <code>_</code> primitive.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x(t)\)</span></li>
</ul>
<p><strong>Example: a Signal Passing Through</strong></p>
<p>In the following example, the <code>_</code> primitive is used to connect the single audio input of a Faust program to its output:</p>
<div class="faust-run"><a href="img/src/exfaust39/exfaust39-svg/process.svg" target="_blank"><img src="img/src/exfaust39/exfaust39-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = _;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust39/exfaust39.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="cut-primitive">Cut Primitive</h4>
<p>The cut primitive is expressed in Faust with <code>!</code>. It can be used to “stop”/terminate a signal.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{0}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(\forall x\in\mathbb{S},(x)\rightarrow ()\)</span></li>
</ul>
<p><strong>Example: Stopping a Signal</strong></p>
<p>In the following example, the <code>!</code> primitive is used to stop one of two parallel signals:</p>
<div class="faust-run"><a href="img/src/exfaust40/exfaust40-svg/process.svg" target="_blank"><img src="img/src/exfaust40/exfaust40-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 1,2 : !,_;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust40/exfaust40.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="int-primitive"><code>int</code> Primitive</h4>
<p>The <code>int</code> primitive can be used to force the cast of a signal to int. It is of type <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span> and can be described mathematically as <span class="math inline">\(y(t)=(int)x(t)\)</span>. This primitive is useful when declaring indices to read in a table, etc.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=(int)x(t)\)</span></li>
</ul>
<p><strong>Example: Simple Cast</strong></p>
<div class="faust-run"><a href="img/src/exfaust41/exfaust41-svg/process.svg" target="_blank"><img src="img/src/exfaust41/exfaust41-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 1.5 : int;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust41/exfaust41.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="float-primitive"><code>float</code> Primitive</h4>
<p>The <code>float</code> primitive can be used to force the cast of a signal to float.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=(float)x(t)\)</span></li>
</ul>
<p><strong>Example: Simple Cast</strong></p>
<div class="faust-run"><a href="img/src/exfaust42/exfaust42-svg/process.svg" target="_blank"><img src="img/src/exfaust42/exfaust42-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 1.5 : float;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust42/exfaust42.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="add-primitive">Add Primitive</h4>
<p>The <code>+</code> primitive can be used to add two signals together.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x_{1}(t)+x_{2}(t)\)</span></li>
</ul>
<p><strong>Example: Simple Mixer</strong></p>
<div class="faust-run"><a href="img/src/exfaust43/exfaust43-svg/process.svg" target="_blank"><img src="img/src/exfaust43/exfaust43-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = +;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust43/exfaust43.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="subtract-primitive">Subtract Primitive</h4>
<p>The <code>-</code> primitive can be used to subtract two signals.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x_{1}(t)-x_{2}(t)\)</span></li>
</ul>
<p><strong>Example: Subtracting Two Input Signals</strong></p>
<div class="faust-run"><a href="img/src/exfaust44/exfaust44-svg/process.svg" target="_blank"><img src="img/src/exfaust44/exfaust44-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = -;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust44/exfaust44.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="multiply-primitive">Multiply Primitive</h4>
<p>The <code>*</code> primitive can be used to multiply two signals.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x_{1}(t)*x_{2}(t)\)</span></li>
</ul>
<p><strong>Example: Multiplying a Signal by 0.5</strong></p>
<div class="faust-run"><a href="img/src/exfaust45/exfaust45-svg/process.svg" target="_blank"><img src="img/src/exfaust45/exfaust45-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = *(0.5);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust45/exfaust45.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="divide-primitive">Divide Primitive</h4>
<p>The <code>/</code> primitive can be used to divide two signals.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x_{1}(t)/{x_{2}(t)}\)</span></li>
</ul>
<p><strong>Example: Dividing a Signal by 2</strong></p>
<div class="faust-run"><a href="img/src/exfaust46/exfaust46-svg/process.svg" target="_blank"><img src="img/src/exfaust46/exfaust46-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = ^(2);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust46/exfaust46.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="power-primitive">Power Primitive</h4>
<p>The <code>^</code> primitive can be used to raise to the power of <code>N</code> a signal.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x_{1}(t)^{x_{2}(t)}\)</span></li>
</ul>
<p><strong>Example: Power of Two of a Signal</strong></p>
<div class="faust-run"><a href="img/src/exfaust47/exfaust47-svg/process.svg" target="_blank"><img src="img/src/exfaust47/exfaust47-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = ^(2);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust47/exfaust47.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="modulo-primitive">Modulo Primitive</h4>
<p>The <code>%</code> primitive can be used to take the modulo of a signal.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x_{1}(t)\%{x_{2}(t)}\)</span></li>
</ul>
<p><strong>Example: Phaser</strong></p>
<p>The following example uses a counter and the <code>%</code> primitive to implement a basic phaser:</p>
<div class="faust-run"><a href="img/src/exfaust48/exfaust48-svg/process.svg" target="_blank"><img src="img/src/exfaust48/exfaust48-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = _~+(1) : -(1) : %(10);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust48/exfaust48.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>will output a signal: <code>(0,1,2,3,4,5,6,7,8,9,0,1,2,3,4)</code></p>
<h4 id="and-primitive">AND Primitive</h4>
<p>Logical AND can be expressed in Faust with the <code>&amp;</code> primitive.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x_{1}(t)\&amp;{x_{2}(t)}\)</span></li>
</ul>
<p><strong>Example</strong></p>
<p>TODO</p>
<h4 id="or-primitive">OR Primitive</h4>
<p>Logical OR can be expressed in Faust with the <code>|</code> primitive.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x_{1}(t)|{x_{2}(t)}\)</span></li>
</ul>
<p><strong>Example</strong></p>
<p>The following example will output 1 if the incoming signal is smaller than 0.5 or greater than 0.7 and 0 otherwise. Note that the result of this operation could be multiplied to another signal to create a condition.</p>
<div class="faust-run"><a href="img/src/exfaust49/exfaust49-svg/process.svg" target="_blank"><img src="img/src/exfaust49/exfaust49-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = _ &lt;: &lt;(0.5) | &gt;(0.7);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust49/exfaust49.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="xor-primitive">XOR Primitive</h4>
<p>Logical XOR can be expressed in Faust with the <code>xor</code> primitive.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x_{1}(t)\land {x_{2}(t)}\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust50/exfaust50-svg/process.svg" target="_blank"><img src="img/src/exfaust50/exfaust50-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = _ &lt;: &lt;(0.5) xor &gt;(0.7);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust50/exfaust50.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="left-shift-primitive">Left Shift Primitive</h4>
<p>Left shift can be expressed in Faust with the <code>&lt;&lt;</code> primitive.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x_{1}(t) &lt;&lt; {x_{2}(t)}\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust51/exfaust51-svg/process.svg" target="_blank"><img src="img/src/exfaust51/exfaust51-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 1 &lt;&lt; 2 ;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust51/exfaust51.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="right-shift-primitive">Right Shift Primitive</h4>
<p>Right shift can be expressed in Faust with the <code>&gt;&gt;</code> primitive.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x_{1}(t) &gt;&gt; {x_{2}(t)}\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust52/exfaust52-svg/process.svg" target="_blank"><img src="img/src/exfaust52/exfaust52-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 1 &gt;&gt; 2 ;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust52/exfaust52.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="smaller-than-primitive">Smaller Than Primitive</h4>
<p>The smaller than comparison can be expressed in Faust with the <code>&lt;</code> primitive.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x_{1}(t) &lt; {x_{2}(t)}\)</span></li>
</ul>
<p><strong>Example</strong></p>
<p>The following code will output 1 if the input signal is smaller than 0.5 and 0 otherwise.</p>
<div class="faust-run"><a href="img/src/exfaust53/exfaust53-svg/process.svg" target="_blank"><img src="img/src/exfaust53/exfaust53-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = &lt;(0.5) ;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust53/exfaust53.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="smaller-or-equal-than-primitive">Smaller or Equal Than Primitive</h4>
<p>The smaller or equal than comparison can be expressed in Faust with the <code>&lt;=</code> primitive.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x_{1}(t) &lt;= {x_{2}(t)}\)</span></li>
</ul>
<p><strong>Example</strong></p>
<p>The following code will output 1 if the input signal is smaller or equal than 0.5 and 0 otherwise.</p>
<div class="faust-run"><a href="img/src/exfaust54/exfaust54-svg/process.svg" target="_blank"><img src="img/src/exfaust54/exfaust54-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = &lt;=(0.5) ;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust54/exfaust54.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="greater-than-primitive">Greater Than Primitive</h4>
<p>The greater than comparison can be expressed in Faust with the <code>&gt;</code> primitive.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x_{1}(t) &gt; {x_{2}(t)}\)</span></li>
</ul>
<p><strong>Example</strong></p>
<p>The following code will output 1 if the input signal is greater than 0.5 and 0 otherwise.</p>
<div class="faust-run"><a href="img/src/exfaust55/exfaust55-svg/process.svg" target="_blank"><img src="img/src/exfaust55/exfaust55-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = &gt;(0.5) ;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust55/exfaust55.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="greater-or-equal-than-primitive">Greater or Equal Than Primitive</h4>
<p>The greater or equal than comparison can be expressed in Faust with the <code>&gt;=</code> primitive.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x_{1}(t) &gt;= {x_{2}(t)}\)</span></li>
</ul>
<p><strong>Example</strong></p>
<p>The following code will output 1 if the input signal is greater or equal than 0.5 and 0 otherwise.</p>
<div class="faust-run"><a href="img/src/exfaust56/exfaust56-svg/process.svg" target="_blank"><img src="img/src/exfaust56/exfaust56-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = &gt;=(0.5) ;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust56/exfaust56.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="equal-to-primitive">Equal to Primitive</h4>
<p>The equal to comparison can be expressed in Faust with the <code>==</code> primitive.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x_{1}(t) == {x_{2}(t)}\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust57/exfaust57-svg/process.svg" target="_blank"><img src="img/src/exfaust57/exfaust57-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 0 == 1;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust57/exfaust57.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="different-than-primitive">Different Than Primitive</h4>
<p>The different than comparison can be expressed in Faust with the <code>!=</code> primitive.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=x_{1}(t) != {x_{2}(t)}\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust58/exfaust58-svg/process.svg" target="_blank"><img src="img/src/exfaust58/exfaust58-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 0 != 1;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust58/exfaust58.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h3 id="math.h-equivalent-primitives"><code>math.h</code>-Equivalent Primitives</h3>
<p>Most of the C <code>math.h</code> functions are also built-in as primitives (the others are defined as external functions in file <code>math.lib</code>).</p>
<h4 id="acos-primitive"><code>acos</code> Primitive</h4>
<p>Arc cosine can be expressed as <code>acos</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{acosf}(x(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust59/exfaust59-svg/process.svg" target="_blank"><img src="img/src/exfaust59/exfaust59-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 0.1 : acos;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust59/exfaust59.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="asin-primitive"><code>asin</code> Primitive</h4>
<p>Arc sine can be expressed as <code>asin</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{asinf}(x(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust60/exfaust60-svg/process.svg" target="_blank"><img src="img/src/exfaust60/exfaust60-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 0.1 : asin;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust60/exfaust60.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="atan-primitive"><code>atan</code> Primitive</h4>
<p>Arc tangent can be expressed as <code>atan</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{atanf}(x(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust61/exfaust61-svg/process.svg" target="_blank"><img src="img/src/exfaust61/exfaust61-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 0.1 : atan;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust61/exfaust61.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="atan2-primitive"><code>atan2</code> Primitive</h4>
<p>The arc tangent of 2 signals can be expressed as <code>atan2</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{atan2f}(x_{1}(t), x_{2}(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust62/exfaust62-svg/process.svg" target="_blank"><img src="img/src/exfaust62/exfaust62-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 0.1,-0.1 : atan2;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust62/exfaust62.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="cos-primitive"><code>cos</code> Primitive</h4>
<p>Cosine can be expressed as <code>cos</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{cosf}(x(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust63/exfaust63-svg/process.svg" target="_blank"><img src="img/src/exfaust63/exfaust63-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 0.1 : cos;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust63/exfaust63.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="sin-primitive"><code>sin</code> Primitive</h4>
<p>Sine can be expressed as <code>sin</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{sinf}(x(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust64/exfaust64-svg/process.svg" target="_blank"><img src="img/src/exfaust64/exfaust64-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 0.1 : sin;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust64/exfaust64.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="tan-primitive"><code>tan</code> Primitive</h4>
<p>Tangent can be expressed as <code>tan</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{tanf}(x(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust65/exfaust65-svg/process.svg" target="_blank"><img src="img/src/exfaust65/exfaust65-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 0.1 : tan;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust65/exfaust65.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="exp-primitive"><code>exp</code> Primitive</h4>
<p>Base-e exponential can be expressed as <code>exp</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{expf}(x(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust66/exfaust66-svg/process.svg" target="_blank"><img src="img/src/exfaust66/exfaust66-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 0.1 : exp;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust66/exfaust66.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="log-primitive"><code>log</code> Primitive</h4>
<p>Base-e logarithm can be expressed as <code>log</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{logf}(x(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust67/exfaust67-svg/process.svg" target="_blank"><img src="img/src/exfaust67/exfaust67-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 0.1 : log;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust67/exfaust67.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="log10-primitive"><code>log10</code> Primitive</h4>
<p>Base-10 logarithm can be expressed as <code>log10</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{log10}(x(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust68/exfaust68-svg/process.svg" target="_blank"><img src="img/src/exfaust68/exfaust68-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 0.1 : log10;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust68/exfaust68.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="pow-primitive"><code>pow</code> Primitive</h4>
<p>Power can be expressed as <code>pow</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{powf}(x_{1}(t),x_{2}(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust69/exfaust69-svg/process.svg" target="_blank"><img src="img/src/exfaust69/exfaust69-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 2,4 : pow;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust69/exfaust69.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="sqrt-primitive"><code>sqrt</code> Primitive</h4>
<p>Square root can be expressed as <code>sqrt</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{sqrtf}(x(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust70/exfaust70-svg/process.svg" target="_blank"><img src="img/src/exfaust70/exfaust70-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 4 : sqrt;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust70/exfaust70.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="abs-primitive"><code>abs</code> Primitive</h4>
<p>Absolute value can be expressed as <code>abs</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{abs}(x(t))\)</span> (int) or<br />
<span class="math inline">\(y(t)=\mathrm{fabsf}(x(t))\)</span> (float)</li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust71/exfaust71-svg/process.svg" target="_blank"><img src="img/src/exfaust71/exfaust71-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = -0.5 : abs;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust71/exfaust71.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="min-primitive"><code>min</code> Primitive</h4>
<p><em>Minimum</em> can be expressed as <code>min</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{min}(x_{1}(t),x_{2}(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust72/exfaust72-svg/process.svg" target="_blank"><img src="img/src/exfaust72/exfaust72-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = -0.5,0.2 : min;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust72/exfaust72.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="max-primitive"><code>max</code> Primitive</h4>
<p><em>Maximum</em> can be expressed as <code>max</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{max}(x_{1}(t),x_{2}(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust73/exfaust73-svg/process.svg" target="_blank"><img src="img/src/exfaust73/exfaust73-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = -0.5,0.2 : max;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust73/exfaust73.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="fmod-primitive"><code>fmod</code> Primitive</h4>
<p>Float modulo can be expressed as <code>fmod</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{fmodf}(x_{1}(t),x_{2}(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust74/exfaust74-svg/process.svg" target="_blank"><img src="img/src/exfaust74/exfaust74-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 5.3,2 : fmod;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust74/exfaust74.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="remainder-primitive"><code>remainder</code> Primitive</h4>
<p>Float remainder can be expressed as <code>remainder</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{remainderf}(x_{1}(t),x_{2}(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust75/exfaust75-svg/process.svg" target="_blank"><img src="img/src/exfaust75/exfaust75-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 5.3,2 : remainder;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust75/exfaust75.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="floor-primitive"><code>floor</code> Primitive</h4>
<p>Largest int can be expressed as <code>floor</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(\leq\)</span>: <span class="math inline">\(y(t)=\mathrm{floorf}(x(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust76/exfaust76-svg/process.svg" target="_blank"><img src="img/src/exfaust76/exfaust76-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 3.6 : floor;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust76/exfaust76.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="ceil-primitive"><code>ceil</code> Primitive</h4>
<p>Smallest int can be expressed as <code>ceil</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(\geq\)</span>: <span class="math inline">\(y(t)=\mathrm{ceilf}(x(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust77/exfaust77-svg/process.svg" target="_blank"><img src="img/src/exfaust77/exfaust77-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 3.6 : ceil;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust77/exfaust77.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="rint-primitive"><code>rint</code> Primitive</h4>
<p>Closest int can be expressed as <code>rint</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=\mathrm{rintf}(x(t))\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust78/exfaust78-svg/process.svg" target="_blank"><img src="img/src/exfaust78/exfaust78-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = 3.6 : rint;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust78/exfaust78.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<!-- TODO: say something about the fact that things are expressed in core
syntax -->
<h3 id="delay-primitives-and-modifiers">Delay Primitives and Modifiers</h3>
<p>Faust hosts various modifiers and primitives to define one sample or integer delay of arbitrary length. They are presented in this section.</p>
<h4 id="mem-primitive"><code>mem</code> Primitive</h4>
<p>A 1 sample delay can be expressed as <code>mem</code> in Faust.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{1}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t+1)=x(t),y(0)=0\)</span></li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust79/exfaust79-svg/process.svg" target="_blank"><img src="img/src/exfaust79/exfaust79-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = mem;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust79/exfaust79.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Note that this is equivalent to <code>process = _'</code> (see <a href="#modifier"><code>'</code> Modifier</a>) and <code>process = @(1)</code> (see <a href="TODO"><code>@</code> Primitive</a>)</p>
<h4 id="modifier"><code>'</code> Modifier</h4>
<p><code>'</code> can be used to apply a 1 sample delay to a signal in Faust. It can be seen as syntactic sugar to the <a href="#mem-primitive"><code>mem</code> primitive</a>. <code>'</code> is very convenient when implementing filters and can help significantly decrease the size of the Faust code.</p>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust80/exfaust80-svg/process.svg" target="_blank"><img src="img/src/exfaust80/exfaust80-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = _&#39;;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust80/exfaust80.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="primitive"><code>@</code> Primitive</h4>
<p>An integer delay of <code>N</code> samples can be expressed as <code>@(N)</code> in Faust. Note that <code>N</code> can be dynamic but that its range must be bounded. This can be done by using a UI primitive (see example below) allowing for the definition of a range such as <a href="TODO"><code>hslider</code></a>, <a href="TODO"><code>vslider</code></a>, or <a href="TODO"><code>nentry</code></a>.</p>
<p>Note that floating point delay is also available in Faust by the mean of <a href="TODO">various fractional delay implementations</a> available in the Faust standard libraries.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{2}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t+x_{2}(t))=x_{1}(t), y(t&lt;x_{2}(t))=0\)</span></li>
</ul>
<p><strong>Usage</strong></p>
<pre><code>_ : @(N) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>N</code>: the length of the delay as a number of samples</li>
</ul>
<p><strong>Example: Static N Samples Delay</strong></p>
<div class="faust-run"><a href="img/src/exfaust81/exfaust81-svg/process.svg" target="_blank"><img src="img/src/exfaust81/exfaust81-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>N = 10;
process = @(N);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust81/exfaust81.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p><strong>Example: Dynamic N Samples Delay</strong></p>
<div class="faust-run"><a href="img/src/exfaust82/exfaust82-svg/process.svg" target="_blank"><img src="img/src/exfaust82/exfaust82-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>N = hslider(&quot;N&quot;,10,1,10,1);
process = @(N);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust82/exfaust82.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h3 id="table-primitives">Table Primitives</h3>
<p>TODO</p>
<h4 id="rtable-primitive"><code>rtable</code> Primitive</h4>
<p>The <code>rtable</code> primitive can be used to read through a read-only (pre-defined before compilation) table. The table can either be implemented using a function controlled by a timer (such as <a href="TODO"><code>ba.time</code></a>) as demonstrated in the first example, or by using the <code>waveform</code> primitive (as shown in the second example). The idea is that the table is parsed during the initialization step and before audio computation begins.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{3}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(y(t)=T[r(t)]\)</span></li>
</ul>
<p><strong>Usage</strong></p>
<pre><code>rtable(n,s,r) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: the table size</li>
<li><code>s</code>: the table</li>
<li><code>r</code>: the read index (an <code>int</code> between 0 and <code>n</code>)</li>
</ul>
<p><strong>Example: Basic Triangle Wave Oscillator Using the <code>waveform</code> Primitive</strong></p>
<p>In this example, a basic (and dirty) triangle wave-table is defined using the <a href="#waveform-primitive"><code>waveform</code></a>. It is then used with the <code>rdtable</code> primitive and a phasor to implement a triangle wave oscillator. Note that the output of</p>
<div class="faust-run"><a href="img/src/exfaust83/exfaust83-svg/process.svg" target="_blank"><img src="img/src/exfaust83/exfaust83-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
triangleWave = waveform{0,0.5,1,0.5,0,-0.5,-1,-.5};
triangleOsc(f) = triangleWave,int(os.phasor(8,f)) : rdtable;
f = hslider(&quot;freq&quot;,440,50,2000,0.01);
process = triangleOsc(f);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust83/exfaust83.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p><strong>Example: Basic Triangle Wave Oscillator Using the <code>waveform</code> Primitive</strong></p>
<p>In this example, a sine table is implemented using the <a href="#sin-primitive"><code>sin</code> primitive</a> and a timer (<a href="TODO"><code>ba.time</code></a>). The timer parses the <code>sin</code> function during the initialization step of the Faust program. It is then used with <code>rdtable</code> to implement a sine wave oscillator.</p>
<div class="faust-run"><a href="img/src/exfaust84/exfaust84-svg/process.svg" target="_blank"><img src="img/src/exfaust84/exfaust84-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
sineWave(tablesize) = float(ba.time)*(2.0*ma.PI)/float(tablesize) : sin;
tableSize = 1 &lt;&lt; 16;
triangleOsc(f) = tableSize,sineWave(tableSize),int(os.phasor(tableSize,f)) : rdtable;
f = hslider(&quot;freq&quot;,440,50,2000,0.01);
process = triangleOsc(f);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust84/exfaust84.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="rwtable-primitive"><code>rwtable</code> Primitive</h4>
<p>The <code>rwtable</code> primitive can be used to implement a read/write table. It takes an audio input that can be written in the table using a <em>record index</em> (i.e., <code>w</code> below) and read using a read index (i.e., <code>r</code> below).</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{5}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(T[w(t)]=c(t); y(t)=T[r(t)]\)</span></li>
</ul>
<p><strong>Usage</strong></p>
<pre><code>_ : rwtable(n,s,w,_,r) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: the table size</li>
<li><code>s</code>: the table</li>
<li><code>w</code>: the write index (an <code>int</code> between 0 and <code>n</code>)</li>
<li><code>r</code>: the read index (an <code>int</code> between 0 and <code>n</code>)</li>
</ul>
<p>Note that the fourth argument of <code>rwtable</code> corresponds to the input of the table.</p>
<p><strong>Example: Simple Looper</strong></p>
<p>In this example, an input signal is written in the table when <code>record</code> is true (equal to 1). The read index is constantly updated to loop through the table. The table size is set to 48000, which corresponds to one second if the sampling rate is 48000 KHz.</p>
<div class="faust-run"><a href="img/src/exfaust85/exfaust85-svg/process.svg" target="_blank"><img src="img/src/exfaust85/exfaust85-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
tableSize = 48000;
recIndex = (+(1) : %(tableSize)) ~ *(record);
readIndex = readSpeed/float(ma.SR) : (+ : ma.decimal) ~ _ : *(float(tableSize)) : int;
readSpeed = hslider(&quot;[0]Read Speed&quot;,1,0.001,10,0.01);
record = button(&quot;[1]Record&quot;) : int;
looper = rwtable(tableSize,0.0,recIndex,_,readIndex);
process = looper;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust85/exfaust85.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<!-- TODO: we might want to have a better example here -->
<h3 id="selector-primitives">Selector Primitives</h3>
<p>Selector primitives can be used to create conditions in Faust and to implement switches to choose between several signals. Note that selector primitives optimize the code generated by the Faust compiler by only computing the selected signal.</p>
<h4 id="select2-primitives"><code>select2</code> Primitives</h4>
<p>The <code>select2</code> primitive is a “two-ways selector” that can be used to select between 2 signals.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{3}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(T[]=\{x_{0}(t),x_{1}(t)\}; y(t)=T[s(t)]\)</span></li>
</ul>
<p><strong>Usage</strong></p>
<pre><code>_,_ : select2(s) : _,_</code></pre>
<p>Where:</p>
<ul>
<li><code>s</code>: the selector (<code>0</code> for the first signal, <code>1</code> for the second one)</li>
</ul>
<p><strong>Example: Signal Selector</strong></p>
<p>The following example allows the user to choose between a sine and a sawtooth wave oscillator.</p>
<div class="faust-run"><a href="img/src/exfaust86/exfaust86-svg/process.svg" target="_blank"><img src="img/src/exfaust86/exfaust86-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
s = nentry(&quot;Selector&quot;,0,0,1,1);
sig = os.osc(440),os.sawtooth(440) : select2(s);
process = sig;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust86/exfaust86.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Note that <code>select2</code> could be easily implemented from scratch in Faust using Boolean primitives:</p>
<div class="faust-run"><a href="img/src/exfaust87/exfaust87-svg/process.svg" target="_blank"><img src="img/src/exfaust87/exfaust87-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
s = nentry(&quot;Selector&quot;,0,0,1,1);
mySelect2(s) = *(s==0),*(s==1) :&gt; _;
sig = os.osc(440),os.sawtooth(440) : mySelect2(s);
process = sig;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust87/exfaust87.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>While the behavior of this last solution is identical to the first one, the generated code will be less optimized as the sine and the sawtooth waves will both be computed all the time.</p>
<h4 id="select3-primitives"><code>select3</code> Primitives</h4>
<p>The <code>select3</code> primitive is a “three-ways selector” that can be used to select between 3 signals.</p>
<ul>
<li><strong>Type:</strong> <span class="math inline">\(\mathbb{S}^{4}\rightarrow\mathbb{S}^{1}\)</span></li>
<li><strong>Mathematical Description:</strong> <span class="math inline">\(T[]=\{x_{0}(t),x_{1}(t),x_{2}(t)\}; y(t)=T[s(t)]\)</span></li>
</ul>
<p><strong>Usage</strong></p>
<pre><code>_,_,_ : select3(s) : _,_,_</code></pre>
<p>Where:</p>
<ul>
<li><code>s</code>: the selector (<code>0</code> for the first signal, <code>1</code> for the second one, <code>2</code> for the third one)</li>
</ul>
<p><strong>Example: Signal Selector</strong></p>
<p>The following example allows the user to choose between a sine, a sawtooth and a triangle wave oscillator.</p>
<div class="faust-run"><a href="img/src/exfaust88/exfaust88-svg/process.svg" target="_blank"><img src="img/src/exfaust88/exfaust88-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
s = nentry(&quot;Selector&quot;,0,0,1,1);
sig = os.osc(440),os.sawtooth(440),os.triangle(440) : select3(s);
process = sig;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust88/exfaust88.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Note that <code>select2</code> could be easily implemented from scratch in Faust using Boolean primitives:</p>
<div class="faust-run"><a href="img/src/exfaust89/exfaust89-svg/process.svg" target="_blank"><img src="img/src/exfaust89/exfaust89-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
s = nentry(&quot;Selector&quot;,0,0,2,1);
mySelect3(s) = *(s==0),*(s==1),*(s==2) :&gt; _;
sig = os.osc(440),os.sawtooth(440),os.triangle(440) : mySelect3(s);
process = sig;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust89/exfaust89.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>While the behavior of this last solution is identical to the first one, the generated code will be less optimized as the sine, the sawtooth and the triangle waves will all be computed all the time.</p>
<h3 id="user-interface-primitives-and-configuration">User Interface Primitives and Configuration</h3>
<p>Faust user interface widgets/primitives allow for an <strong>abstract</strong> description of a user interface from within the Faust code. This description is independent from any GUI toolkits/frameworks and is purely abstract. Widgets can be <strong>discrete</strong> (e.g., <a href="TODO"><code>button</code></a>, <a href="TODO"><code>checkbox</code></a>, etc.), <strong>continuous</strong> (e.g., <a href="TODO"><code>hslider</code></a>, <a href="TODO"><code>vslider</code></a>, <a href="TODO"><code>nentry</code></a>), and <strong>organizational</strong> (e.g., <a href="TODO"><code>vgroup</code></a>, <a href="TODO"><code>hgroup</code></a>).</p>
<p>Discrete and continuous elements are signal generators. For example, a <code>button</code> produces a signal which is 1 when the button is pressed and 0 otherwise:</p>
<p><img src="img/button.svg" class="mx-auto d-block" width="50%"></p>
<p>These signals can be freely combined with other audio signals. In fact, the following code is perfectly valid and will generate sound:</p>
<div class="faust-run"><a href="img/src/exfaust90/exfaust90-svg/process.svg" target="_blank"><img src="img/src/exfaust90/exfaust90-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = button(&quot;DC&quot;);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust90/exfaust90.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Each primitive implements a specific UI element, but their appearance can also be completely modified using <a href="TODO">metadata</a> (a little bit like HTML and CSS in the web). Therefore, <a href="TODO"><code>hslider</code></a>, <a href="TODO"><code>vslider</code></a>, and <a href="TODO"><code>nentry</code></a>) can for example be turned into a knob, a dropdown menu, etc. This concept is further developed in the <a href="TODO">section on UI metadata</a>.</p>
<p>Continuous UI elements (i.e., <a href="TODO"><code>hslider</code></a>, <a href="TODO"><code>vslider</code></a>, and <a href="TODO"><code>nentry</code></a>) must all declare a range for the parameter they’re controlling. In some cases, this range is used during compilation to allocate memory and will impact the generated code. For example, in the case of:</p>
<div class="faust-run"><a href="img/src/exfaust91/exfaust91-svg/process.svg" target="_blank"><img src="img/src/exfaust91/exfaust91-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = @(hslider(&quot;N&quot;,1,1,10,1));</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust91/exfaust91.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>a buffer of 10 samples will be allocated for the delay implemented with the <a href="#primitive"><code>@</code> primitive</a> while 20 samples will be allocated in the following example:</p>
<div class="faust-run"><a href="img/src/exfaust92/exfaust92-svg/process.svg" target="_blank"><img src="img/src/exfaust92/exfaust92-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = @(hslider(&quot;N&quot;,1,1,20,1));</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust92/exfaust92.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="button-primitive"><code>button</code> Primitive</h4>
<p>The <code>button</code> primitive implements a button.</p>
<p><strong>Usage</strong></p>
<pre><code>button(&quot;label&quot;) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>label</code>: the <a href="#ui-labels-configuration">label</a> (expressed as a string) of the element in the interface</li>
</ul>
<p><strong>Example: Trigger</strong></p>
<div class="faust-run"><a href="img/src/exfaust93/exfaust93-svg/process.svg" target="_blank"><img src="img/src/exfaust93/exfaust93-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
process = no.noise*button(&quot;gate&quot;);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust93/exfaust93.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="checkbox-primitive"><code>checkbox</code> Primitive</h4>
<p>The <code>checkbox</code> primitive implements a checkbox/toggle.</p>
<p><strong>Usage</strong></p>
<pre><code>checkbox(&quot;label&quot;) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>label</code>: the <a href="#ui-labels-configuration">label</a> (expressed as a string) of the element in the interface</li>
</ul>
<p><strong>Example: Trigger</strong></p>
<div class="faust-run"><a href="img/src/exfaust94/exfaust94-svg/process.svg" target="_blank"><img src="img/src/exfaust94/exfaust94-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
process = no.noise*checkbox(&quot;gate&quot;);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust94/exfaust94.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="hslider-primitive"><code>hslider</code> Primitive</h4>
<p>The <code>hslider</code> primitive implements a horizontal slider.</p>
<p><strong>Usage</strong></p>
<pre><code>hslider(&quot;label&quot;,init,min,max,step) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>label</code>: the <a href="#ui-labels-configuration">label</a> (expressed as a string) of the element in the interface</li>
<li><code>init</code>: the initial value of the slider</li>
<li><code>min</code>: the minimum value of the slider</li>
<li><code>max</code>: the maximum value of the slider</li>
<li><code>step</code>: the precision (step) of the slider (1 to count 1 by 1, 0.1 to count 0.1 by 0.1, etc.)</li>
</ul>
<p><strong>Example: Gain Control</strong></p>
<div class="faust-run"><a href="img/src/exfaust95/exfaust95-svg/process.svg" target="_blank"><img src="img/src/exfaust95/exfaust95-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>gain = hslider(&quot;gain&quot;,0,0,1,0.01);
process = *(gain);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust95/exfaust95.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="vslider-primitive"><code>vslider</code> Primitive</h4>
<p>The <code>vslider</code> primitive implements a vertical slider.</p>
<p><strong>Usage</strong></p>
<pre><code>vslider(&quot;label&quot;,init,min,max,step) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>label</code>: the <a href="#ui-labels-configuration">label</a> (expressed as a string) of the element in the interface</li>
<li><code>init</code>: the initial value of the slider</li>
<li><code>min</code>: the minimum value of the slider</li>
<li><code>max</code>: the maximum value of the slider</li>
<li><code>step</code>: the precision (step) of the slider (1 to count 1 by 1, 0.1 to count 0.1 by 0.1, etc.)</li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust96/exfaust96-svg/process.svg" target="_blank"><img src="img/src/exfaust96/exfaust96-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>gain = vslider(&quot;gain&quot;,0,0,1,0.01);
process = *(gain);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust96/exfaust96.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="nentry-primitive"><code>nentry</code> Primitive</h4>
<p>The <code>nentry</code> primitive implements a “numerical entry”.</p>
<p><strong>Usage</strong></p>
<pre><code>nentry(&quot;label&quot;,init,min,max,step) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>label</code>: the <a href="#ui-labels-configuration">label</a> (expressed as a string) of the element in the interface</li>
<li><code>init</code>: the initial value of the numerical entry</li>
<li><code>min</code>: the minimum value of the numerical entry</li>
<li><code>max</code>: the maximum value of the numerical entry</li>
<li><code>step</code>: the precision (step) of the numerical entry (1 to count 1 by 1, 0.1 to count 0.1 by 0.1, etc.)</li>
</ul>
<p><strong>Example</strong></p>
<div class="faust-run"><a href="img/src/exfaust97/exfaust97-svg/process.svg" target="_blank"><img src="img/src/exfaust97/exfaust97-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>gain = nentry(&quot;gain&quot;,0,0,1,0.01);
process = *(gain);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust97/exfaust97.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="hgroup-primitive"><code>hgroup</code> Primitive</h4>
<p>The <code>hgroup</code> primitive implements a horizontal group. A group contains other UI elements that can also be groups. <code>hgroup</code> is not a signal processor per se and is just a way to label/delimitate part of a Faust code.</p>
<p><strong>Usage</strong></p>
<pre><code>hgroup(&quot;label&quot;,x)</code></pre>
<p>Where:</p>
<ul>
<li><code>label</code>: the <a href="#ui-labels-configuration">label</a> (expressed as a string) of the element in the interface</li>
<li><code>x</code>: the encapsulated/labeled Faust code</li>
</ul>
<p><strong>Example</strong></p>
<p>In the following example, the 2 UI elements controlling an oscillator are encapsulated in a group.</p>
<div class="faust-run"><a href="img/src/exfaust98/exfaust98-svg/process.svg" target="_blank"><img src="img/src/exfaust98/exfaust98-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freq = vslider(&quot;freq&quot;,440,50,1000,0.1);
gain = vslider(&quot;gain&quot;,0,0,1,0.01);
process = hgroup(&quot;Oscillator&quot;,os.sawtooth(freq)*gain);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust98/exfaust98.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Note that the <code>Oscillator</code> group can be placed in a function in case we’d like to add elements to it multiple times.</p>
<div class="faust-run"><a href="img/src/exfaust99/exfaust99-svg/process.svg" target="_blank"><img src="img/src/exfaust99/exfaust99-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
oscGroup(x) = hgroup(&quot;Oscillator&quot;,x);
freq = oscGroup(vslider(&quot;freq&quot;,440,50,1000,0.1));
gain = oscGroup(vslider(&quot;gain&quot;,0,0,1,0.01));
process = os.sawtooth(freq)*gain;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust99/exfaust99.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="vgroup-primitive"><code>vgroup</code> Primitive</h4>
<p>The <code>vgroup</code> primitive implements a vertical group. A group contains other UI elements that can also be groups. <code>vgroup</code> is not a signal processor per se and is just a way to label/delimitate part of a Faust code.</p>
<p><strong>Usage</strong></p>
<pre><code>vgroup(&quot;label&quot;,x)</code></pre>
<p>Where:</p>
<ul>
<li><code>label</code>: the <a href="#ui-labels-configuration">label</a> (expressed as a string) of the element in the interface</li>
<li><code>x</code>: the encapsulated/labeled Faust code</li>
</ul>
<p><strong>Example</strong></p>
<p>In the following example, the 2 UI elements controlling an oscillator are encapsulated in a group.</p>
<div class="faust-run"><a href="img/src/exfaust100/exfaust100-svg/process.svg" target="_blank"><img src="img/src/exfaust100/exfaust100-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freq = hslider(&quot;freq&quot;,440,50,1000,0.1);
gain = hslider(&quot;gain&quot;,0,0,1,0.01);
process = vgroup(&quot;Oscillator&quot;,os.sawtooth(freq)*gain);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust100/exfaust100.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Note that the <code>Oscillator</code> group can be placed in a function in case we’d like to add elements to it multiple times.</p>
<div class="faust-run"><a href="img/src/exfaust101/exfaust101-svg/process.svg" target="_blank"><img src="img/src/exfaust101/exfaust101-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
oscGroup(x) = vgroup(&quot;Oscillator&quot;,x);
freq = oscGroup(hslider(&quot;freq&quot;,440,50,1000,0.1));
gain = oscGroup(hslider(&quot;gain&quot;,0,0,1,0.01));
process = os.sawtooth(freq)*gain;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust101/exfaust101.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="tgroup-primitive"><code>tgroup</code> Primitive</h4>
<p>The <code>tgroup</code> primitive implements a “tab group.” Tab groups can be used to group UI elements in tabs in the interface. A group contains other UI elements that can also be groups. <code>tgroup</code> is not a signal processor per se and is just a way to label/delimitate part of a Faust code.</p>
<p><strong>Usage</strong></p>
<pre><code>tgroup(&quot;label&quot;,x)</code></pre>
<p>Where:</p>
<ul>
<li><code>label</code>: the <a href="#ui-labels-configuration">label</a> (expressed as a string) of the element in the interface</li>
<li><code>x</code>: the encapsulated/labeled Faust code</li>
</ul>
<p><strong>Example</strong></p>
<p>In the following example, the 2 UI elements controlling an oscillator are encapsulated in a group.</p>
<div class="faust-run"><a href="img/src/exfaust102/exfaust102-svg/process.svg" target="_blank"><img src="img/src/exfaust102/exfaust102-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freq = hslider(&quot;freq&quot;,440,50,1000,0.1);
gain = hslider(&quot;gain&quot;,0,0,1,0.01);
process = tgroup(&quot;Oscillator&quot;,os.sawtooth(freq)*gain);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust102/exfaust102.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Note that the <code>Oscillator</code> group can be placed in a function in case we’d like to add elements to it multiple times.</p>
<div class="faust-run"><a href="img/src/exfaust103/exfaust103-svg/process.svg" target="_blank"><img src="img/src/exfaust103/exfaust103-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
oscGroup(x) = tgroup(&quot;Oscillator&quot;,x);
freq = oscGroup(hslider(&quot;freq&quot;,440,50,1000,0.1));
gain = oscGroup(hslider(&quot;gain&quot;,0,0,1,0.01));
process = os.sawtooth(freq)*gain;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust103/exfaust103.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="vbargraph-primitive"><code>vbargraph</code> Primitive</h4>
<p>The <code>vbargraph</code> primitive implements a vertical bar-graph (typically a meter displaying the level of a signal).</p>
<p><strong>Usage</strong></p>
<p><code>vbargraph</code> takes an input signal and outputs it while making it available to the UI.</p>
<pre><code>_ : vbargraph(&quot;label&quot;,min,max) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>min</code>: the minimum value of the signal in the interface</li>
<li><code>max</code>: the maximum value of the signal in the interface</li>
</ul>
<p><strong>Example: Simple VU Meter</strong></p>
<p>A simple VU meter can be implemented using the <code>vbargraph</code> primitive:</p>
<div class="faust-run"><a href="img/src/exfaust104/exfaust104-svg/process.svg" target="_blank"><img src="img/src/exfaust104/exfaust104-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
process = _ &lt;: attach(_,abs : ba.linear2db : vbargraph(&quot;Level&quot;,-60,0));</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust104/exfaust104.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Note the use of the <a href="#attach-primitive"><code>attach</code></a> primitive here that forces the compilation of the <code>vbargraph</code> without using its output signal (see section on the <a href="#attach-primitive"><code>attach</code> primitive</a>).</p>
<h4 id="hbargraph-primitive"><code>hbargraph</code> Primitive</h4>
<p>The <code>hbargraph</code> primitive implements a horizontal bar-graph (typically a meter displaying the level of a signal).</p>
<p><strong>Usage</strong></p>
<p><code>hbargraph</code> takes an input signal and outputs it while making it available to the UI.</p>
<pre><code>_ : hbargraph(&quot;label&quot;,min,max) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>min</code>: the minimum value of the signal in the interface</li>
<li><code>max</code>: the maximum value of the signal in the interface</li>
</ul>
<p><strong>Example: Simple VU Meter</strong></p>
<p>A simple VU meter can be implemented using the <code>hbargraph</code> primitive:</p>
<div class="faust-run"><a href="img/src/exfaust105/exfaust105-svg/process.svg" target="_blank"><img src="img/src/exfaust105/exfaust105-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
process = _ &lt;: attach(_,abs : ba.linear2db : hbargraph(&quot;Level&quot;,-60,0));</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust105/exfaust105.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Note the use of the <a href="#attach-primitive"><code>attach</code></a> primitive here that forces the compilation of the <code>hbargraph</code> without using its output signal (see section on the <a href="#attach-primitive"><code>attach</code> primitive</a>).</p>
<h4 id="attach-primitive"><code>attach</code> Primitive</h4>
<p>The <code>attach</code> primitive takes two input signals and produces one output signal which is a copy of the first input. The role of <code>attach</code> is to force its second input signal to be compiled with the first one. From a mathematical standpoint <code>attach(x,y)</code> is equivalent to <code>1*x+0*y</code>, which is in turn equivalent to <code>x</code>, but it tells the compiler not to optimize-out <code>y</code>.</p>
<p>To illustrate this role, let’s say that we want to develop a mixer application with a vumeter for each input signals. Such vumeters can be easily coded in Faust using an envelope detector connected to a bargraph. The problem is that the signal of the envelope generators has no role in the output signals. Using <code>attach(x,vumeter(x))</code> one can tell the compiler that when <code>x</code> is compiled <code>vumeter(x)</code> should also be compiled.</p>
<p>The examples in the <a href="#hbargraph-primitive"><code>hbargraph</code> Primitive</a> and the <a href="#vbargraph-primitive"><code>vbargraph</code> Primitive</a> illustrate well the use of <code>attach</code>.</p>
<h4 id="variable-parts-of-a-label">Variable Parts of a Label</h4>
<p>Labels can contain variable parts. These are indicated with the sign <code>%</code> followed by the name of a variable. During compilation each label is processed in order to replace the variable parts by the value of the variable. For example:</p>
<div class="faust-run"><a href="img/src/exfaust106/exfaust106-svg/process.svg" target="_blank"><img src="img/src/exfaust106/exfaust106-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>process = par(i,8,hslider(&quot;Voice %i&quot;, 0.9, 0, 1, 0.01));</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust106/exfaust106.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>creates 8 sliders in parallel with different names while <code>par(i,8,hslider(&quot;Voice&quot;, 0.9, 0, 1, 0.01))</code> would have created only one slider and duplicated its output 8 times.</p>
<p>The variable part can have an optional format digit. For example <code>&quot;Voice %2i&quot;</code> would indicate to use two digit when inserting the value of <code>i</code> in the string.</p>
<p>An escape mechanism is provided. If the sign <code>%</code> is followed by itself, it will be included in the resulting string. For example <code>&quot;feedback (%%)&quot;</code> will result in <code>&quot;feedback (%)&quot;</code>.</p>
<h4 id="labels-as-pathnames">Labels as Pathnames</h4>
<p>Thanks to <a href="#hgroup-primitive">horizontal</a>, <a href="#vgroup-primitive">vertical</a>, and <a href="#tgroup-primitive">tabs</a> groups, user interfaces have a hierarchical structure analog to a hierarchical file system. Each widget has an associated <em>path name</em> obtained by concatenating the labels of all its surrounding groups with its own label.</p>
<p>In the following example :</p>
<pre><code>hgroup(&quot;Foo&quot;,
    ...
    vgroup(&quot;Faa&quot;, 
        ...
        hslider(&quot;volume&quot;,...)
        ...
    )
    ...
)</code></pre>
<p>the volume slider has pathname <code>/h:Foo/v:Faa/volume</code>.</p>
<p>In order to give more flexibility to the design of user interfaces, it is possible to explicitly specify the absolute or relative pathname of a widget directly in its label.</p>
<p>Elements of a path are separated using <code>/</code>. Group types are defined with the following identifiers:</p>
<table>
<thead>
<tr class="header">
<th>Group Type</th>
<th>Group Identifier</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>hgroup</code></td>
<td><code>h:</code></td>
</tr>
<tr class="even">
<td><code>vgroup</code></td>
<td><code>v:</code></td>
</tr>
<tr class="odd">
<td><code>tgroup</code></td>
<td><code>t:</code></td>
</tr>
</tbody>
</table>
<p>Hence, the example presented in the <a href="#hgroup-primitive">section on the <code>hgroup</code> primitive</a> can be rewritten as:</p>
<div class="faust-run"><a href="img/src/exfaust107/exfaust107-svg/process.svg" target="_blank"><img src="img/src/exfaust107/exfaust107-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freq = vslider(&quot;h:Oscillator/freq&quot;,440,50,1000,0.1);
gain = vslider(&quot;h:Oscillator/gain&quot;,0,0,1,0.01);
process = os.sawtooth(freq)*gain;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust107/exfaust107.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>which will be reflected in C++ as:</p>
<pre><code>virtual void buildUserInterface(UI* ui_interface) {
  ui_interface-&gt;openHorizontalBox(&quot;Oscillator&quot;);
  ui_interface-&gt;addVerticalSlider(&quot;freq&quot;, &amp;fVslider1, 440.0f, 50.0f, 1000.0f, 0.100000001f);
  ui_interface-&gt;addVerticalSlider(&quot;gain&quot;, &amp;fVslider0, 0.0f, 0.0f, 1.0f, 0.00999999978f);
  ui_interface-&gt;closeBox();
}</code></pre>
<p>Note that path names are inherent to the use of tools gravitating around Faust such as <a href="TODO">OSC control</a> or <a href="TODO"><code>faust2api</code></a>. In the case of <code>faust2api</code>, since no user interface is actually generated, UI elements just become a way to declare parameters of a Faust object. Therefore, there’s no distinction between <code>nentry</code>, <code>hslider</code>, <code>vslider</code>, etc.</p>
<h4 id="links-to-generated-code">Links to Generated Code</h4>
<!-- TODO -->
<h3 id="label-metadata">Label Metadata</h3>
<p><a href="#user-interface-primitives-and-configuration">Widget labels</a> can contain metadata enclosed in square brackets. These metadata associate a key with a value and are used to provide additional information to the architecture file. They are typically used to improve the look and feel of the user interface, configure OSC and accelerometer control/mapping, etc. Since the format of the value associated to a key is relatively open, metadata constitute a flexible way for programmers to add features to the language.</p>
<p>The Faust code:</p>
<pre><code>process = *(hslider(&quot;foo[key1: val 1][key2: val 2]&quot;,0,0,1,0.1));</code></pre>
<p>will produce the corresponding C++ code:</p>
<pre><code>class mydsp : public dsp {
  ...
  virtual void buildUserInterface(UI* ui_interface) {
    ui_interface-&gt;openVerticalBox(&quot;tst&quot;);
    ui_interface-&gt;declare(&amp;fHslider0, &quot;key1&quot;, &quot;val 1&quot;);
    ui_interface-&gt;declare(&amp;fHslider0, &quot;key2&quot;, &quot;val 2&quot;);
    ui_interface-&gt;addHorizontalSlider(&quot;foo&quot;, &amp;fHslider0, 0.0f, 0.0f, 1.0f, 0.100000001f);
    ui_interface-&gt;closeBox();
  }
  ...
};</code></pre>
<p>All metadata are removed from the label by the compiler and transformed in calls to the <code>UI::declare()</code> method. All these <code>UI::declare()</code> calls will always take place before the <code>UI::AddSomething()</code> call that creates the User Interface element. This allows the <code>UI::AddSomething()</code> method to make full use of the available metadata.</p>
<p>Metadata are architecture-specific: it is up to the architecture file to decide what to do with it. While some metadata will work with most architectures (e.g., accelerometer and OSC configuration, etc.), others might be more specific. Some of them are presented in the following sections.</p>
<h4 id="ordering-ui-elements">Ordering UI Elements</h4>
<p>The order of UI declarations in a Faust code doesn’t necessarily reflect the actual order of the UI elements in the corresponding interface. Therefore, UI elements can be ordered by placing a metadata before the declaration of the name of the UI element in the label. For example, in the following declaration:</p>
<pre><code>gain = vslider(&quot;h:Oscillator/[1]gain&quot;,0,0,1,0.01);
freq = vslider(&quot;h:Oscillator/[0]freq&quot;,440,50,1000,0.1);</code></pre>
<p>the <code>freq</code> parameter will be placed before <code>gain</code> despite the fact that <code>gain</code> is declared first.</p>
<p>This system can be used to order groups as well. Ordering will be carried out on elements at the same level. For example:</p>
<div class="faust-run"><a href="img/src/exfaust108/exfaust108-svg/process.svg" target="_blank"><img src="img/src/exfaust108/exfaust108-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freqS = vslider(&quot;h:Oscillators/h:[0]Sawtooth/[0]freq&quot;,440,50,1000,0.1);
gainS = vslider(&quot;h:Oscillators/h:[0]Sawtooth/[1]gain&quot;,0,0,1,0.01);
freqT = vslider(&quot;h:Oscillators/h:[1]Triangle/[0]freq&quot;,440,50,1000,0.1);
gainT = vslider(&quot;h:Oscillators/h:[1]Triangle/[1]gain&quot;,0,0,1,0.01);
process = os.sawtooth(freqS)*gainS + os.triangle(freqT)*gainT;</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust108/exfaust108.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<p>Note that this could also be written as:</p>
<div class="faust-run"><a href="img/src/exfaust109/exfaust109-svg/process.svg" target="_blank"><img src="img/src/exfaust109/exfaust109-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
freqS = vslider(&quot;[0]freq&quot;,440,50,1000,0.1);
gainS = vslider(&quot;[1]gain&quot;,0,0,1,0.01);
freqT = vslider(&quot;[0]freq&quot;,440,50,1000,0.1);
gainT = vslider(&quot;[1]gain&quot;,0,0,1,0.01);
process = hgroup(&quot;Oscillators&quot;,
  hgroup(&quot;[0]Sawtooth&quot;,os.sawtooth(freqS)*gainS) + 
  hgroup(&quot;[1]Triangle&quot;,os.triangle(freqT)*gainT)
);</code></pre>
<a href="http://faust.grame.fr/editor?code=img/src/exfaust109/exfaust109.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h4 id="global-ui-metadata">Global UI Metadata</h4>
<p>Note that global user interfaces completely replacing the one defined using the standard Faust UI primitives may be declared using <a href="#metadata-declarations">global metadata declarations</a>. This is the case of the <a href="TODO">SmartKeyboard</a> interface for example.</p>
<!-- TODO Link to metadata declaration section -->
<p>In the following subsections, the standard Faust UI metadata are documented. Other types of metadata (e.g., accelerometers, OSC, etc.) are documented in the sections related to these topics.</p>
<h4 id="styleknob-metadata"><code>[style:knob]</code> Metadata</h4>
<p>The <code>[style:knob]</code> metadata turns any continuous UI element (i.e., )</p>
<h4 id="stylemenu-metadata"><code>style:menu</code> Metadata</h4>
<h4 id="styleradio-metadata"><code>style:radio</code> Metadata</h4>
<h4 id="styleled-metadata"><code>style:led</code> Metadata</h4>
<h4 id="unitdb-metadata"><code>unit:dB</code> Metadata</h4>
<h4 id="unitxx-metadata"><code>unit:xx</code> Metadata</h4>
<h4 id="scalexx-metadata"><code>[scale:xx]</code> Metadata</h4>
<h4 id="tooltipxx-metadata"><code>tooltip:xx</code> Metadata</h4>
<h4 id="hiddenxx-metadata"><code>[hidden:xx]</code> Metadata</h4>
<h4 id="screencolorxx-metadata"><code>[screencolor:xx]</code> Metadata</h4>
<!-- TODO: {#something}. Also we need to specify the usage of functions in
a better way -->
<!-- TODO give use examples after description here -->
<!-- TODO: say something about smoothing -->
<h1 id="using-the-faust-compiler">Using the Faust Compiler</h1>
<h1 id="a-quick-tour-of-the-faust-targets">A Quick Tour of the Faust Targets</h1>
<h1 id="mathematical-documentation">Mathematical Documentation</h1></div></div></div></main>
    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
  </body>
</html>