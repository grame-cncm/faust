//////////////////////////////////////////////////////////////////////////////////////////
// WARNING: Deprecated Library!!
// Read the README file in /libraries for more information
//////////////////////////////////////////////////////////////////////////////////////////

/************************************************************************
 ************************************************************************
    FAUST library file
    Copyright (C) 2003-2012 GRAME, Centre National de Creation Musicale
    ----------------------------------------------------------------------
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as
    published by the Free Software Foundation; either version 2.1 of the
    License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with the GNU C Library; if not, write to the Free
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.

    EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
    larger FAUST program which directly or indirectly imports this library
    file and still distribute the compiled code generated by the FAUST
    compiler, or a modified version of this compiled code, under your own
    copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
    grants you the right to freely choose the license for the resulting
    compiled code. In particular the resulting compiled code has no obligation
    to be LGPL or GPL. For example you are free to choose a commercial or
    closed source license or any other license if you decide so.

 ************************************************************************
 ************************************************************************/

declare name "Math Library";
declare author "GRAME";
declare copyright "GRAME";
declare version "1.0";
declare license "LGPL with exception";
declare deprecated "This library is deprecated and is not maintained anymore. It will be removed in August 2017."; 

//----------------------Mathematic library for Faust----------------------------
//
// Implementation as Faust foreign functions of math.h functions that are not
// part of Faust's primitives. Defines also various constants and several utilities
//
// ### History
// + 07/08/2015	[YO]	documentation comments
// + 20/06/2014	[SL]	added FTZ function
// + 20/06/2014	[SL]	added FTZ function
// + 22/06/2013	[YO]	added float|double|quad variants of some foreign functions
// + 28/06/2005	[YO]	postfixed functions with 'f' to force float version instead of double
// + 28/06/2005	[YO]	removed 'modf' because it requires a pointer as argument
//------------------------------------------------------------------------------


//--------------------------------- SR ---------------------------------------
// Current sampling rate (between 1Hz and 192000Hz). Constant during
// program execution.
//
// ### Usage:
//    `SR:_`
//-----------------------------------------------------------------------------
SR 			= min(192000.0, max(1.0, fconstant(int fSamplingFreq, <math.h>)));


//--------------------------------- BS ---------------------------------------
// Current block-size. Can change during the execution
//
// ### Usage:
//    `BS:_`
//-----------------------------------------------------------------------------
BS          = fvariable(int count, <math.h>);


//--------------------------------- PI ---------------------------------------
// Constant PI in double precision
//
// ### Usage:
//    `PI:_`
//-----------------------------------------------------------------------------
PI          = 3.1415926535897932385;


//--------------------------------- FTZ ---------------------------------------
// Flush to zero : force samples under the "maximum subnormal number"
// to be zero. Usually not needed in C++ because the architecture
// file take care of this, but can be useful in javascript for instance.
//
// ### Usage:
//    `_:ftz:_`
//
// see : <http://docs.oracle.com/cd/E19957-01/806-3568/ncg_math.html>
//-----------------------------------------------------------------------------
FTZ(x)      = x * (abs(x) > 1.17549435e-38);


//--------------------------------- neg ---------------------------------------
// Invert the sign (-x) of a signal.
//
// ### Usage:
//    `_:neg:_`
//
//-----------------------------------------------------------------------------
neg(x)      = -x;


//--------------------------------- inv ---------------------------------------
// Compute the inverse (1/x) of the input signal
//
// ### Usage:
//    `_:inv:_`
//
//-----------------------------------------------------------------------------
inv(x)      = 1/x;


//--------------------------------- cbrt --------------------------------------
// Computes the cube root of of the input signal.
//
// ### Usage:
//    `_:cbrt:_`
//-----------------------------------------------------------------------------
cbrt 		= ffunction(float cbrtf|cbrt|cbrtl (float), <math.h>,"");


//--------------------------------- hypot(x,y) -------------------------------------
// Computes the euclidian distance of the two input signals
// sqrt(x*x+y*y) without undue overflow or underflow.
//
// ### Usage:
//    `hypot(x,y):_`
//    `_,_:hypot:_`
//-----------------------------------------------------------------------------
hypot 		= ffunction(float hypotf|hypot|hypotl (float, float), <math.h>,"");


//--------------------------------- ldexp -------------------------------------
// Takes two input signals: x and n, and multiplies x by 2 to the power n.
//
// ### Usage:
//    `_,_:ldexp:_`
//-----------------------------------------------------------------------------
ldexp 		= ffunction(float ldexpf|ldexp|ldexpl (float, int), <math.h>,"");


//--------------------------------- scalb -------------------------------------
// Takes two input signals: x and n, and multiplies x by 2 to the power n.
//
// ### Usage:
//    `_,_:scalb:_`
//-----------------------------------------------------------------------------
scalb 		= ffunction(float scalbnf|scalbn|scalbnl (float, int), <math.h>,"");


//--------------------------------- log1p(x) ----------------------------------
// Computes log(1 + x) without undue loss of accuracy when x is nearly zero.
//
// ### Usage:
// +  `log1p(x):_`
// +  `_:log1p:_`
//-----------------------------------------------------------------------------
log1p 		= ffunction(float log1pf|log1p|log1pl (float), <math.h>,"");


//--------------------------------- logb ---------------------------------------
// Return exponent of the input signal as a floating-point number
//
// ### Usage:
//    `_:logb:_`
//-----------------------------------------------------------------------------
logb 		= ffunction(float logbf|logb|logbl (float), <math.h>,"");


//--------------------------------- ilogb -------------------------------------
// Return exponent of the input signal as an integer number
//
// ### Usage:
//    `_:ilogb:_`
//-----------------------------------------------------------------------------
ilogb 		= ffunction(int ilogbf|ilogb|ilogbl (float), <math.h>,"");


//--------------------------------- expm1 -------------------------------------
// Return exponent of the input signal minus 1 with better precision.
//
// ### Usage:
//    `_:expm1:_`
//-----------------------------------------------------------------------------
expm1 		= ffunction(float expm1f|expm1|expm1l (float), <math.h>,"");


//--------------------------------- acosh -------------------------------------
// Computes the principle value of the inverse hyperbolic cosine
// of the input signal.
//
// ### Usage:
//    `_:acosh:_`
//-----------------------------------------------------------------------------
acosh		= ffunction(float acoshf|acosh|acoshl (float), <math.h>, "");


//-------------------------------- asinh(x) -----------------------------------
// Computes the inverse hyperbolic sine of the input signal.
//
// ### Usage:
//    `_:asinh:_`
//-----------------------------------------------------------------------------
asinh		= ffunction(float asinhf|asinh|asinhl (float), <math.h>, "");


//-------------------------------- atanh(x) -----------------------------------
// Computes the inverse hyperbolic tangent of the input signal.
//
// ### Usage:
//    `_:atanh:_`
//-----------------------------------------------------------------------------
atanh		= ffunction(float atanhf|atanh|atanhl (float), <math.h>, "");


//--------------------------------- sinh ---------------------------------------
// Computes the hyperbolic sine of the input signal.
//
// ### Usage:
//    `_:sinh:_`
//-----------------------------------------------------------------------------
sinh		= ffunction(float sinhf|sinh|sinhl (float), <math.h>, "");


//--------------------------------- cosh --------------------------------------
// Computes the hyperbolic cosine of the input signal.
//
// ### Usage:
//    `_:cosh:_`
//-----------------------------------------------------------------------------
cosh		= ffunction(float coshf|cosh|coshl (float), <math.h>, "");


//--------------------------------- tanh --------------------------------------
// Computes the hyperbolic tangent of the input signal.
//
// ### Usage:
//    `_:tanh:_`
//-----------------------------------------------------------------------------
tanh		= ffunction(float tanhf|tanh|tanhl (float), <math.h>,"");


//--------------------------------- erf ---------------------------------------
// Computes the error function of the input signal.
//
// ### Usage:
//    `_:erf:_`
//-----------------------------------------------------------------------------
erf			= ffunction(float erff|erf|erfl(float), <math.h>,"");


//--------------------------------- erf ---------------------------------------
// Computes the complementary error function of the input signal.
//
// ### Usage:
//    `_:erfc:_`
//-----------------------------------------------------------------------------
erfc		= ffunction(float erfcf|erfc|erfcl(float), <math.h>,"");


//--------------------------------- gamma -------------------------------------
// Computes the gamma function of the input signal.
//
// ### Usage:
//    `_:gamma:_`
//-----------------------------------------------------------------------------
gamma		= ffunction(float tgammaf|tgamma|tgammal(float), <math.h>,"");


//--------------------------------- lgamma ------------------------------------
// Calculates the natural logorithm of the absolute value of
// the gamma function of the input signal.
//
// ### Usage:
//    `_:lgamma:_`
//-----------------------------------------------------------------------------
lgamma		= ffunction(float lgammaf|lgamma|lgammal(float), <math.h>,"");


//---------------------------------- J0 ---------------------------------------
// Computes the Bessel function of the first kind of order 0
// of the input signal.
//
// ### Usage:
//    `_:J0:_`
//-----------------------------------------------------------------------------
J0			= ffunction(float j0(float), <math.h>,"");

//---------------------------------- J1 ---------------------------------------
// Computes the Bessel function of the first kind of order 1
// of the input signal.
//
// ### Usage:
//    `_:J1:_`
//-----------------------------------------------------------------------------
J1			= ffunction(float j1(float), <math.h>,"");

//---------------------------------- Jn ---------------------------------------
// Computes the Bessel function of the first kind of order n
// (first input signal) of the second input signal.
//
// ### Usage:
//    `_,_:Jn:_`
//-----------------------------------------------------------------------------
Jn			= ffunction(float jn(int, float), <math.h>,"");


//---------------------------------- Y0 ---------------------------------------
// Computes the linearly independent Bessel function of the second kind
// of order 0 of the input signal.
//
// ### Usage:
//    `_:Y0:_`
//-----------------------------------------------------------------------------
Y0			= ffunction(float y0(float), <math.h>,"");

//---------------------------------- Y1 ---------------------------------------
// Computes the linearly independent Bessel function of the second kind
// of order 1 of the input signal.
//
// ### Usage:
//    `_:Y0:_`
//-----------------------------------------------------------------------------
Y1			= ffunction(float y1(float), <math.h>,"");

//---------------------------------- Yn ---------------------------------------
// Computes the linearly independent Bessel function of the second kind
// of order n (first input signal) of the second input signal.
//
// ### Usage:
//    `_,_:Yn:_`
//-----------------------------------------------------------------------------
Yn			= ffunction(float yn(int, float), <math.h>,"");


// -- Miscellaneous Functions

fabs = abs;
fmax = max;
fmin = min;

//--------------- isnan(x) ----------------
// return non-zero if and only if x is a NaN,
//
// ### Usage:
//    `_:isnan:_`
//
// #### Where:
// + x = signal to analyse
//
//------------------------------------------
isnan 		= ffunction(int isnan (float),<math.h>,"");
nextafter	= ffunction(float nextafter(float, float),<math.h>,"");


//--------------------------------- count(l) ---------------------------------
// Count the number of elements of list l
//
// ### Usage:
//    `count ((10,20,30,40)) 	-> 4`
//
// #### Where:
// + l = list of elements
//
//-----------------------------------------------------------------------------
count ((xs, xxs)) = 1 + count(xxs);
count (xx) = 1;


//------------------------------- take(e,l) -----------------------------------
// Take an element from a list
//
// ### Usage:
//    `take  (3,(10,20,30,40)) -> 30`
//
// #### Where:
// + p = position (starting at 1)
// + l = list of elements
//
//-----------------------------------------------------------------------------
take (1, (xs, xxs)) 	= xs;
take (1, xs) 			= xs;
take (nn, (xs, xxs)) 	= take (nn-1, xxs);


//---------------------------- subseq(l, p, n) --------------------------------
// Extract a part of a list
//
// ### Usage:
// +  `subseq((10,20,30,40,50,60), 1, 3) -> (20,30,40)`
// +  `subseq((10,20,30,40,50,60), 4, 1) -> 50`
//
// #### Where:
// + l = list
// + p = start point (0: begin of list)
// + n = number of elements
//
// #### Note:
// Faust doesn't have proper lists. Lists are simulated with parallel
// compositions and there is no empty list
//
//-----------------------------------------------------------------------------
subseq((head, tail), 0, 1)      = head;
subseq((head, tail), 0, n)      = head, subseq(tail, 0, n-1);
subseq((head, tail), p, n)      = subseq(tail, p-1, n);
subseq(head, 0, n)              = head;


//----------------------------- interpolate(i) -------------------------------
// linear interpolation between two signals
//
// ### Usage:
//    `_,_:interpolate(i):_`
//
// #### Where:
// + i = interpolation control between 0 and 1 (0: first input; 1: second input)
//
//-----------------------------------------------------------------------------
interpolate(i) = *(1.0-i),*(i) : +;


//----------------------------- if(c,t,e)) -----------------------------------
// if-then-else implemented with a select2
//
// ### Usage:
// +   `if(c, then, else):_`
// +   `_,_:if(c):_`
//
// #### Where:
// + c = condition
// + t = signal selected while c is true
// + e = signal selected while c is false
//
//-----------------------------------------------------------------------------
if(cond,thn,els) = select2(cond,els,thn);


//---------------------------- countdown(n,trig) ------------------------------
// Starts counting down from n included to 0. While trig is 1 the output is n.
// The countdown starts with the transition of trig from 1 to 0. At the end
// of the countdown the output value will remain at 0 until the next trig.
//
// ### Usage:
// + `countdown(n,trig):_`
// + `_:countdown(n):_`
// + `_,_:countdown:_`
//
// #### Where
// + n : the starting point of the countdown
// + trig : the trigger signal (1: start at n; 0: decrease until 0)
//-----------------------------------------------------------------------------
countdown(count, trig)	= \(c).(if(trig>0, count, max(0, c-1))) ~_;


//---------------------------- countup(n,trig) --------------------------------
// Starts counting up from 0 to n included. While trig is 1 the output is 0.
// The countup starts with the transition of trig from 1 to 0. At the end
// of the countup the output value will remain at n until the next trig.
//
// ### Usage:
// + `countup(n,trig):_`
// + `_:countup(n):_`
// + `_,_:countup:_`
//
// #### Where
// + n : the starting point of the countup
// + trig : the trigger signal (1: start at 0; 0: increase until n)
//-----------------------------------------------------------------------------
countup(count, trig)	= \(c).(if(trig>0, 0, min(count, c+1))) ~_;


//-------------------------------- bus(n) -------------------------------------
// n parallel cables
//
// ### Usage:
//    `bus(4) -> _,_,_,_`
//
// #### Where:
// + n = is an integer known at compile time that indicates the number of parallel cables.
//
//-----------------------------------------------------------------------------
bus(2) = _,_; // avoids a lot of "bus(1)" labels in block diagrams
bus(n) = par(i, n, _);


//----------------------------- selector(i,n) ---------------------------------
// Selects the ith input among n at compile time
//
// ### Usage:
// `_,_,_,_:selector(2,4):_`  selects the 3rd input among 4
//
// #### Where:
// + i = input to select (int, numbered from 0, known at compile time)
// + n = number of inputs (int, known at compile time, n > i)
//
//-----------------------------------------------------------------------------
selector(i,n) = par(j, n, S(i, j))    with { S(i,i) = _; S(i,j) = !; };


//----------------------------- selectn(N,i) ---------------------------------
// Selects the ith input among N at run time
//
// ### Usage:
// `_,_,_,_:selectn(4,2):_`  selects the 3rd input among 4
//
// #### Where:
// + N = number of inputs (int, known at compile time, N > 0)
// + i = input to select (int, numbered from 0)
//
// #### Example test program:
// `N=64; process = par(n,N, (par(i,N,i) : selectn(N,n)));`
//-----------------------------------------------------------------------------
selectn(N,i) = S(N,0)
    with {
       S(1,offset) = _;
       S(n,offset) = S(left, offset), S(right, offset+left) : select2(i >= offset+left)
            with {
                right = int(n/2);
                left  = n-right;
            };
    };

//-------------------------- interleave(row,col) ------------------------------
// interleave row*col cables from column order to row order.
// input : x(0), x(1), x(2) ..., x(row*col-1)
// output: x(0+0*row), x(0+1*row), x(0+2*row), ..., x(1+0*row), x(1+1*row), x(1+2*row), ...
//
// ### Usage:
//    `_,_,_,_,_,_:interleave(3,2):_,_,_,_,_,_`
//
// #### Where:
// + row = the number of row (int, known at compile time)
// + column = the number of column (int, known at compile time)
//
//-----------------------------------------------------------------------------
interleave(row,col) = bus(row*col) <: par(r, row, par(c, col, selector(r+c*row,row*col)));


//------------------------------- butterfly(n) --------------------------------
// Addition (first half) then substraction (second half) of interleaved signals.
//
// ### Usage:
//    `_,_,_,_:butterfly(4):_,_,_,_`
//
// #### Where:
// + n = size of the butterfly (n is int, even and known at compile time)
//
//-----------------------------------------------------------------------------
butterfly(n) = bus(n) <: interleave(n/2,2), interleave(n/2,2) : par(i, n/2, +), par(i, n/2, -);


//------------------------------ hadamard(n) ----------------------------------
// hadamard matrix function of size n = 2^k
//
// ### Usage:
//    `_,_,_,_:hadamard(4):_,_,_,_`
//
// #### Where:
// + n = 2^k, size of the matrix (int, must be known at compile time)
//
// #### Note:
// Implementation contributed by Remy Muller.
//
//-----------------------------------------------------------------------------
hadamard(2) = butterfly(2);
hadamard(n) = butterfly(n) : (hadamard(n/2) , hadamard(n/2));


//------------------------------- dot(n) --------------------------------------
// Dot product for two vectors of size n
//
// ### Usage:
//    `_,_,_,_,_,_:dot(3):_`
//
// #### Where:
// + n = size of the vectors (int, must be known at compile time)
//
//-----------------------------------------------------------------------------
dot(n) = interleave(n,2) : par(i,n,*) :> _;


//-------------------------------- cross(n) -----------------------------------
// cross n signals : (x1,x2,..,xn) -> (xn,..,x2,x1)
//
// ### Usage:
//    `_,_,_:cross(3):_,_,_`
//
// #### Where:
// + n = number of signals (int, must be known at compile time)
//
//-----------------------------------------------------------------------------
// cross n cables : (x1,x2,..,xn) -> (xn,..,x2,x1)
cross(n) = bus(n) <: par(i,n,selector(n-i-1,n));
