//----------------------------------------------------------
// name: "comb_bug"
//
// Code generated with Faust 2.78.4 (https://faust.grame.fr)
// Compiler options: -lang ocpp -ct 1 -es 0 -mcl 4 -mcd 9 -mfs 1024 -huf 0 -irt 4 -fls 4 -udd 1 -mdd 1024 -mdy 90 -mca 8 -ss 0 -single -ftz 0 
//----------------------------------------------------------

/* link with  */
#include <algorithm>
#include <cmath>
#include <math.h>
#ifndef FAUSTFLOAT
#define FAUSTFLOAT float
#endif 


#ifndef FAUSTCLASS 
#define FAUSTCLASS mydsp
#endif

class mydsp : public dsp {
  private:
	FAUSTFLOAT 	fbutton0;
	float 	fVec0BEState; // Single Delay
	FAUSTFLOAT 	fslider0;
	FAUSTFLOAT 	fslider1;
	// Recursion delay iVec2SI is of type kSingleDelay
	// While its definition is of type kZeroDelay
	int 	iVec2SIState; // Single Delay
	FAUSTFLOAT 	fslider2;
	float 	fConst0KI; // step: 34
	// Recursion delay iVec5SE is of type kSingleDelay
	// While its definition is of type kZeroDelay
	int 	iVec5SEState; // Single Delay
	FAUSTFLOAT 	fslider3;
	float 	fConst1KI; // step: 66
	// Recursion delay fVec7SE is of type kSingleDelay
	// While its definition is of type kZeroDelay
	float 	fVec7SEState; // Single Delay
	float 	fConst2KI; // step: 79
	// Recursion delay iVec9SE is of type kSingleDelay
	// While its definition is of type kZeroDelay
	int 	iVec9SEState; // Single Delay
	int 	IOTA0;
	float 	fVec11SE[2048]; // Ring Delay
	FAUSTFLOAT 	fslider4;
	float 	fConst3KI; // step: 105
	float 	fConst4KI; // step: 107
	// Recursion delay fVec12SE is of type kSingleDelay
	// While its definition is of type kZeroDelay
	float 	fVec12SEState; // Single Delay
	float 	fConst5KI; // step: 122
	float 	fConst6KI; // step: 126
	// Recursion delay fVec1SE is of type kSingleDelay
	// While its definition is of type kZeroDelay
	float 	fVec1SEState; // Single Delay
	// Recursion delay fRec6SE is of type kZeroDelay
	// While its definition is of type kZeroDelay
	FAUSTFLOAT 	fslider5;
	// Recursion delay fVec17SE is of type kSingleDelay
	// While its definition is of type kZeroDelay
	float 	fVec17SEState; // Single Delay
	float 	fVec19SEState; // Single Delay
	int fSampleRate;

  public:
	virtual void metadata(Meta* m) { 
		m->declare("basics_lib_name", "Faust Basic Element Library");
		m->declare("basics_lib_version", "0.1");
		m->declare("compilation_options", "-single -scal -e comb_bug.dsp -o comb_bug_exp.dsp");
		m->declare("compile_options", "-lang ocpp -ct 1 -es 0 -mcl 4 -mcd 9 -mfs 1024 -huf 0 -irt 4 -fls 4 -udd 1 -mdd 1024 -mdy 90 -mca 8 -ss 0 -single -ftz 0");
		m->declare("delays_lib_name", "Faust Delay Library");
		m->declare("delays_lib_version", "0.1");
		m->declare("envelopes_lib_adsr_author", "Yann Orlarey");
		m->declare("envelopes_lib_ar_author", "Yann Orlarey, StÃ©phane Letz");
		m->declare("envelopes_lib_author", "GRAME");
		m->declare("envelopes_lib_copyright", "GRAME");
		m->declare("envelopes_lib_license", "LGPL with exception");
		m->declare("envelopes_lib_name", "Faust Envelope Library");
		m->declare("envelopes_lib_version", "0.0");
		m->declare("filename", "comb_bug.dsp");
		m->declare("filters_lib_fb_fcomb_author", "Julius O. Smith III");
		m->declare("filters_lib_fb_fcomb_copyright", "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>");
		m->declare("filters_lib_fb_fcomb_license", "MIT-style STK-4.3 license");
		m->declare("filters_lib_lowpass0_highpass1", "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>");
		m->declare("filters_lib_name", "Faust Filters Library");
		m->declare("library_path", "/usr/local/share/faust/stdfaust.lib");
		m->declare("maths_lib_author", "GRAME");
		m->declare("maths_lib_copyright", "GRAME");
		m->declare("maths_lib_license", "LGPL with exception");
		m->declare("maths_lib_name", "Faust Math Library");
		m->declare("maths_lib_version", "2.1");
		m->declare("name", "comb_bug");
		m->declare("noises_lib_name", "Faust Noise Generator Library");
		m->declare("noises_lib_version", "0.0");
		m->declare("signals_lib_name", "Faust Signal Routing Library");
		m->declare("signals_lib_version", "0.0");
	}

	virtual int getNumInputs() { return 0; }
	virtual int getNumOutputs() { return 2; }
	static void classInit(int sample_rate) {
	}
	virtual void instanceConstants(int sample_rate) {
		fSampleRate = sample_rate;
		fConst0KI = std::min(1.92e+05f, std::max(1.0f, float(fSampleRate))); // step: 34
		fConst1KI = (1.0f / std::max(1.0f, (0.1f * fConst0KI))); // step: 66
		fConst2KI = (1.0f / std::max(1.0f, (0.01f * fConst0KI))); // step: 79
		IOTA0 = 0;
		fConst3KI = expf(-(1e+03f / fConst0KI)); // step: 105
		fConst4KI = (1.0f + -fConst3KI /* Sum */); // step: 107
		fConst5KI = (0.9993265f * fConst0KI); // step: 122
		fConst6KI = (1.0006735f * fConst0KI); // step: 126
	}
	virtual void instanceResetUserInterface() {
		fbutton0 = 0.0;
		fslider0 = 0.999f;
		fslider1 = 127.0f;
		fslider2 = 0.95f;
		fslider3 = 0.95f;
		fslider4 = 2e+02f;
		fslider5 = 0.8f;
	}
	virtual void instanceClear() {
		fVec0BEState = 0;
		iVec2SIState = 0;
		iVec5SEState = 0;
		fVec7SEState = 0;
		iVec9SEState = 0;
		for (int i = 1; i < 2048; i++) { fVec11SE[i] = 0; }
		fVec11SE[0] = -1;  // detect unintialized
		fVec12SEState = 0;
		fVec1SEState = 0;
		fVec17SEState = 0;
		fVec19SEState = 0;
	}
	virtual void init(int sample_rate) {
		classInit(sample_rate);
		instanceInit(sample_rate);
	}
	virtual void instanceInit(int sample_rate) {
		instanceConstants(sample_rate);
		instanceResetUserInterface();
		instanceClear();
	}
	virtual mydsp* clone() {
		return new mydsp();
	}
	virtual int getSampleRate() {
		return fSampleRate;
	}
	virtual void buildUserInterface(UI* ui_interface) {
		ui_interface->openVerticalBox("comb_bug");
		ui_interface->addHorizontalSlider("comb_res", &fslider0, 0.999f, -0.999f, 0.999f, 0.01f);
		ui_interface->addHorizontalSlider("env_a", &fslider2, 0.95f, 0.001f, 1.0f, 0.01f);
		ui_interface->addHorizontalSlider("env_r", &fslider3, 0.95f, 0.001f, 1.0f, 0.01f);
		ui_interface->addHorizontalSlider("freq", &fslider4, 2e+02f, 2e+02f, 8e+02f, 1.0f);
		ui_interface->addHorizontalSlider("gain", &fslider5, 0.8f, 0.0f, 1.0f, 0.01f);
		ui_interface->addButton("gate", &fbutton0);
		ui_interface->addHorizontalSlider("vitesse", &fslider1, 127.0f, 0.0f, 127.0f, 1.0f);
		ui_interface->closeBox();
	}
	virtual void compute (int count, FAUSTFLOAT** input, FAUSTFLOAT** output) {
		float 	fSlow0BE = float(fbutton0); // Zone 2, step: 1
		float 	fVec0BE[2];
		float 	fSlow1BE = float(fslider0); // Zone 2, step: 6
		float 	fSlow2BE = (3.6666243e-12f * float(fslider1)); // Zone 2, step: 16
		int 	iVec2SI[2];
		float 	fSlow3BE = std::max(1.0f, (fConst0KI * float(fslider2))); // Zone 2, step: 36
		float 	fSlow4BE = (1.0f / fSlow3BE); // Zone 2, step: 37
		float 	fTemp0SE; // step: 38
		int 	iTemp1SE; // step: 42
		int 	iVec5SE[2];
		float 	fTemp2SE; // step: 49
		float 	fSlow5BE = (1.0f / std::max(1.0f, (fConst0KI * float(fslider3)))); // Zone 2, step: 54
		float 	fVec7SE[2];
		int 	iSlow6BE = (fSlow0BE == 0.0f); // Zone 2, step: 80
		int 	iVec9SE[2];
		float 	fTemp3SE; // step: 94
		float 	fSlow7BE = (fConst4KI * float(fslider4)); // Zone 2, step: 108
		float 	fVec12SE[2];
		float 	fTemp4SE; // step: 114
		float 	fTemp5SE; // step: 115
		float 	fTemp6SE; // step: 118
		float 	fTemp7SE; // step: 128
		float 	fTemp8SE; // step: 129
		int 	iTemp9SE; // step: 130
		float 	fTemp10SE; // step: 135
		float 	fVec1SE[2];
		float 	fSlow8BE = (0.001f * float(fslider5)); // Zone 2, step: 153
		float 	fVec17SE[2];
		float 	fVec19SE[2];
		float 	fTemp11SE; // step: 164
		FAUSTFLOAT* output0 = output[0]; // Zone 3
		FAUSTFLOAT* output1 = output[1]; // Zone 3
		fVec0BE[1] = fVec0BEState;
		iVec2SI[1] = iVec2SIState;
		iVec5SE[1] = iVec5SEState;
		fVec7SE[1] = fVec7SEState;
		iVec9SE[1] = iVec9SEState;
		fVec12SE[1] = fVec12SEState;
		fVec1SE[1] = fVec1SEState;
		fVec17SE[1] = fVec17SEState;
		fVec19SE[1] = fVec19SEState;
		for (int i=0; i<count; i++) {
			fVec0BE[0] = fSlow0BE;
			iVec2SI[0] = ((1103515245 * iVec2SI[1]) + 12345 /* Sum */);
			fTemp0SE = fVec0BE[1]; // step: 38
			iTemp1SE = iVec5SE[1]; // step: 42
			iVec5SE[0] = (((fSlow0BE <= fTemp0SE) * (iTemp1SE + (iTemp1SE > 0) /* Sum */)) + (fSlow0BE > fTemp0SE) /* Sum */);
			fTemp2SE = float(iVec5SE[0]); // step: 49
			fVec7SE[0] = (fSlow0BE + (fVec7SE[1] * float((fTemp0SE >= fSlow0BE))) /* Sum */);
			iVec9SE[0] = (iSlow6BE * (iVec9SE[1] + 1 /* Sum */));
			fTemp3SE = ((fSlow1BE * fVec1SE[1]) + (fSlow2BE * ((float(iVec2SI[0]) * std::max(0.0f, std::min((fSlow4BE * fTemp2SE), ((fSlow5BE * (fSlow3BE + -fTemp2SE /* Sum */)) + 1.0f /* Sum */)))) * std::max(0.0f, (std::min((fConst1KI * fVec7SE[0]), 1.0f) + -(fConst2KI * float(iVec9SE[0])) /* Sum */)))) /* Sum */); // step: 94
			fVec11SE[IOTA0&2047] = fTemp3SE;
			fVec12SE[0] = (fSlow7BE + (fConst3KI * fVec12SE[1]) /* Sum */);
			fTemp4SE = fVec12SE[0]; // step: 114
			fTemp5SE = (fConst0KI / fTemp4SE); // step: 115
			fTemp6SE = (fTemp5SE + -floorf(fTemp5SE) /* Sum */); // step: 118
			fTemp7SE = (((fTemp6SE <= 0.06f)) ? (fConst6KI / fTemp4SE) : (((fTemp6SE >= 0.95f)) ? (fConst5KI / fTemp4SE) : fTemp5SE)); // step: 128
			fTemp8SE = (fTemp7SE + -1.0f /* Sum */); // step: 129
			iTemp9SE = int(fTemp8SE); // step: 130
			fTemp10SE = floorf(fTemp8SE); // step: 135
			fVec1SE[0] = ((fVec11SE[(IOTA0-std::min(1025, std::max(0, iTemp9SE)))&2047] * (fTemp10SE + 2.0f + -fTemp7SE /* Sum */)) + ((fTemp7SE + -1.0f + -fTemp10SE /* Sum */) * fVec11SE[(IOTA0-std::min(1025, std::max(0, (iTemp9SE + 1 /* Sum */))))&2047]) /* Sum */);
			float 	fRec6SE = fTemp3SE; // Zero delay
			fVec17SE[0] = (fSlow8BE + (0.999f * fVec17SE[1]) /* Sum */);
			fVec19SE[0] = (fRec6SE * fVec17SE[0]);
			fTemp11SE = (0.3f * fVec19SE[1]); // step: 164
			output0[i] = (FAUSTFLOAT)(fTemp11SE);  // Zone Exec Code
			output1[i] = (FAUSTFLOAT)(fTemp11SE);  // Zone Exec Code
			// post processing
			fVec19SE[1] = fVec19SE[0];
			fVec17SE[1] = fVec17SE[0];
			fVec1SE[1] = fVec1SE[0];
			fVec12SE[1] = fVec12SE[0];
			++IOTA0;
			iVec9SE[1] = iVec9SE[0];
			fVec7SE[1] = fVec7SE[0];
			iVec5SE[1] = iVec5SE[0];
			iVec2SI[1] = iVec2SI[0];
			fVec0BE[1] = fVec0BE[0];
		}
		fVec0BEState = fVec0BE[1];
		iVec2SIState = iVec2SI[1];
		iVec5SEState = iVec5SE[1];
		fVec7SEState = fVec7SE[1];
		iVec9SEState = iVec9SE[1];
		fVec12SEState = fVec12SE[1];
		fVec1SEState = fVec1SE[1];
		fVec17SEState = fVec17SE[1];
		fVec19SEState = fVec19SE[1];
	}
};


