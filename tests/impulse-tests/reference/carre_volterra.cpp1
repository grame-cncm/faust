//----------------------------------------------------------
// name: "carre_volterra"
//
// Code generated with Faust 2.79.0 (https://faust.grame.fr)
// Compiler options: -lang ocpp -ct 1 -es 0 -mcl 4 -mcd 9 -mfs 1024 -huf 0 -irt 4 -fls 4 -udd 1 -mdd 1024 -mdy 90 -mca 8 -ss 0 -single -ftz 0 
//----------------------------------------------------------

/* link with  */
#include <algorithm>
#include <cmath>
#include <math.h>
#ifndef FAUSTFLOAT
#define FAUSTFLOAT float
#endif 


#ifndef FAUSTCLASS 
#define FAUSTCLASS mydsp
#endif

class mydsp : public dsp {
  private:
	int 	iVec0KCState; // Single Delay
	FAUSTFLOAT 	fslider0;
	float 	fConst0KI; // step: 19
	float 	fConst1KI; // step: 20
	// Recursion delay fVec1SE is of type kSingleDelay
	// While its definition is of type kZeroDelay
	float 	fVec1SEState; // Single Delay
	float 	fVec3SEState; // Single Delay
	FAUSTFLOAT 	fslider1;
	// Recursion delay fVec4SE is of type kSingleDelay
	// While its definition is of type kZeroDelay
	float 	fVec4SEState; // Single Delay
	float 	fVec6SEState; // Single Delay
	FAUSTFLOAT 	fslider2;
	float 	fConst2KI; // step: 60
	FAUSTFLOAT 	fslider3;
	float 	fConst3KI; // step: 78
	float 	fConst4KI; // step: 95
	int 	IOTA0;
	float 	fVec15SE[4096]; // Ring Delay
	float 	fVec14SE[4096]; // Ring Delay
	// Recursion delay fVec10SE is of type kSingleDelay
	// While its definition is of type kZeroDelay
	float 	fVec10SEState; // Single Delay
	// Recursion delay fVec9SE is of type kSingleDelay
	// While its definition is of type kZeroDelay
	float 	fVec9SEState; // Single Delay
	// Recursion delay fVec8SE is of type kSingleDelay
	// While its definition is of type kZeroDelay
	float 	fVec8SEState; // Single Delay
	// Recursion delay fVec7SE is of type kSingleDelay
	// While its definition is of type kZeroDelay
	float 	fVec7SEState; // Single Delay
	FAUSTFLOAT 	fcheckbox0;
	// Recursion delay fVec27SE is of type kSingleDelay
	// While its definition is of type kZeroDelay
	float 	fVec27SEState; // Single Delay
	// Recursion delay fVec26SE is of type kSingleDelay
	// While its definition is of type kZeroDelay
	float 	fVec26SEState; // Single Delay
	// Recursion delay fVec25SE is of type kSingleDelay
	// While its definition is of type kZeroDelay
	float 	fVec25SEState; // Single Delay
	// Recursion delay fVec24SE is of type kSingleDelay
	// While its definition is of type kZeroDelay
	float 	fVec24SEState; // Single Delay
	int fSampleRate;

  public:
	virtual void metadata(Meta* m) { 
		m->declare("compile_options", "-lang ocpp -ct 1 -es 0 -mcl 4 -mcd 9 -mfs 1024 -huf 0 -irt 4 -fls 4 -udd 1 -mdd 1024 -mdy 90 -mca 8 -ss 0 -single -ftz 0");
		m->declare("effect.lib/name", "Faust Audio Effect Library");
		m->declare("filename", "carre_volterra.dsp");
		m->declare("filter.lib/author", "Julius O. Smith (jos at ccrma.stanford.edu)");
		m->declare("filter.lib/copyright", "Julius O. Smith III");
		m->declare("filter.lib/license", "STK-4.3");
		m->declare("filter.lib/name", "Faust Filter Library");
		m->declare("filter.lib/reference", "https://ccrma.stanford.edu/~jos/filters/");
		m->declare("filter.lib/version", "1.29");
		m->declare("math.lib/author", "GRAME");
		m->declare("math.lib/copyright", "GRAME");
		m->declare("math.lib/deprecated", "This library is deprecated and is not maintained anymore. It will be removed in August 2017.");
		m->declare("math.lib/license", "LGPL with exception");
		m->declare("math.lib/name", "Math Library");
		m->declare("math.lib/version", "1.0");
		m->declare("music.lib/author", "GRAME");
		m->declare("music.lib/copyright", "GRAME");
		m->declare("music.lib/license", "LGPL with exception");
		m->declare("music.lib/name", "Music Library");
		m->declare("music.lib/version", "1.0");
		m->declare("name", "carre_volterra");
		m->declare("oscillator.lib/author", "Julius O. Smith (jos at ccrma.stanford.edu)");
		m->declare("oscillator.lib/copyright", "Julius O. Smith III");
		m->declare("oscillator.lib/license", "STK-4.3");
		m->declare("oscillator.lib/name", "Faust Oscillator Library");
		m->declare("oscillator.lib/version", "1.11");
	}

	virtual int getNumInputs() { return 0; }
	virtual int getNumOutputs() { return 1; }
	static void classInit(int sample_rate) {
	}
	virtual void instanceConstants(int sample_rate) {
		fSampleRate = sample_rate;
		fConst0KI = std::min(1.92e+05f, std::max(1.0f, float(fSampleRate))); // step: 19
		fConst1KI = (1.0f / fConst0KI); // step: 20
		fConst2KI = (6.2831855f / fConst0KI); // step: 60
		fConst3KI = (0.25f * fConst0KI); // step: 78
		fConst4KI = (0.5f * fConst0KI); // step: 95
		IOTA0 = 0;
	}
	virtual void instanceResetUserInterface() {
		fslider0 = 4.4e+02f;
		fslider1 = 2.0f;
		fslider2 = 7e+02f;
		fslider3 = 0.5f;
		fcheckbox0 = 0.0;
	}
	virtual void instanceClear() {
		iVec0KCState = 0;
		fVec1SEState = 0;
		fVec3SEState = 0;
		fVec4SEState = 0;
		fVec6SEState = 0;
		for (int i = 1; i < 4096; i++) { fVec15SE[i] = 0; }
		fVec15SE[0] = -1;  // detect unintialized
		for (int i = 1; i < 4096; i++) { fVec14SE[i] = 0; }
		fVec14SE[0] = -1;  // detect unintialized
		fVec10SEState = 0;
		fVec9SEState = 0;
		fVec8SEState = 0;
		fVec7SEState = 0;
		fVec27SEState = 0;
		fVec26SEState = 0;
		fVec25SEState = 0;
		fVec24SEState = 0;
	}
	virtual void init(int sample_rate) {
		classInit(sample_rate);
		instanceInit(sample_rate);
	}
	virtual void instanceInit(int sample_rate) {
		instanceConstants(sample_rate);
		instanceResetUserInterface();
		instanceClear();
	}
	virtual mydsp* clone() {
		return new mydsp();
	}
	virtual int getSampleRate() {
		return fSampleRate;
	}
	virtual void buildUserInterface(UI* ui_interface) {
		ui_interface->openVerticalBox("carre_volterra");
		ui_interface->addCheckButton("NL", &fcheckbox0);
		ui_interface->addHorizontalSlider("delta", &fslider1, 2.0f, 0.0f, 6.0f, 0.1f);
		ui_interface->addHorizontalSlider("freq carre", &fslider0, 4.4e+02f, 2e+01f, 8e+03f, 1.0f);
		ui_interface->declare(&fslider2, "unit", "Hz");
		ui_interface->addHorizontalSlider("freq", &fslider2, 7e+02f, 1.0f, 2e+04f, 1.0f);
		ui_interface->addHorizontalSlider("level", &fslider3, 0.5f, 0.0f, 1.0f, 0.01f);
		ui_interface->closeBox();
	}
	virtual void compute (int count, FAUSTFLOAT** input, FAUSTFLOAT** output) {
		int 	iVec0KC[2];
		float 	fSlow0BE = float(fslider0); // Zone 2, step: 10
		float 	fSlow1BE = std::max(fSlow0BE, 23.44895f); // Zone 2, step: 12
		float 	fSlow2BE = std::max(2e+01f, fabsf(fSlow1BE)); // Zone 2, step: 14
		float 	fSlow3BE = (fConst1KI * fSlow2BE); // Zone 2, step: 21
		float 	fTemp0SE; // step: 23
		float 	fVec1SE[2];
		float 	fTemp1SE; // step: 33
		float 	fVec3SE[2];
		float 	fSlow4BE = std::max((fSlow0BE + float(fslider1) /* Sum */), 23.44895f); // Zone 2, step: 40
		float 	fSlow5BE = std::max(2e+01f, fabsf(fSlow4BE)); // Zone 2, step: 42
		float 	fSlow6BE = (fConst1KI * fSlow5BE); // Zone 2, step: 43
		float 	fTemp2SE; // step: 45
		float 	fVec4SE[2];
		float 	fTemp3SE; // step: 54
		float 	fVec6SE[2];
		float 	fSlow7BE = float(fslider2); // Zone 2, step: 58
		float 	fSlow8BE = (fConst2KI * fSlow7BE); // Zone 2, step: 61
		float 	fSlow9BE = (1.0f / (fSlow8BE + 1.0f /* Sum */)); // Zone 2, step: 63
		float 	fSlow10BE = float(fslider3); // Zone 2, step: 74
		float 	fSlow11BE = (fConst2KI * (fSlow10BE * fSlow7BE)); // Zone 2, step: 76
		float 	fTemp4SC; // step: 80
		float 	fSlow12BE = (1.0f / fSlow2BE); // Zone 2, step: 81
		float 	fTemp5SE; // step: 84
		float 	fSlow13BE = (1.0f / fSlow5BE); // Zone 2, step: 86
		float 	fTemp6SE; // step: 89
		float 	fSlow14BE = std::max(0.0f, std::min(2047.0f, (fConst4KI / fSlow4BE))); // Zone 2, step: 98
		int 	iSlow15BE = int(fSlow14BE); // Zone 2, step: 99
		float 	fSlow16BE = float(iSlow15BE); // Zone 2, step: 100
		float 	fSlow17BE = (fSlow14BE + -fSlow16BE /* Sum */); // Zone 2, step: 102
		int 	iSlow18BE = (iSlow15BE + 1 /* Sum */); // Zone 2, step: 103
		float 	fSlow19BE = std::max(0.0f, std::min(2047.0f, (fConst4KI / fSlow1BE))); // Zone 2, step: 109
		int 	iSlow20BE = int(fSlow19BE); // Zone 2, step: 110
		float 	fSlow21BE = float(iSlow20BE); // Zone 2, step: 111
		float 	fSlow22BE = (fSlow21BE + 1.0f + -fSlow19BE /* Sum */); // Zone 2, step: 113
		float 	fSlow23BE = (fConst3KI / fSlow2BE); // Zone 2, step: 114
		float 	fTemp7SE; // step: 117
		float 	fSlow24BE = (fSlow19BE + -fSlow21BE /* Sum */); // Zone 2, step: 122
		int 	iSlow25BE = (iSlow20BE + 1 /* Sum */); // Zone 2, step: 123
		float 	fSlow26BE = (fSlow16BE + 1.0f + -fSlow14BE /* Sum */); // Zone 2, step: 128
		float 	fSlow27BE = (fConst3KI / fSlow5BE); // Zone 2, step: 129
		float 	fTemp8SE; // step: 132
		float 	fTemp9SE; // step: 136
		float 	fVec10SE[2];
		float 	fTemp10SE; // step: 141
		float 	fVec9SE[2];
		float 	fTemp11SE; // step: 146
		float 	fVec8SE[2];
		float 	fTemp12SE; // step: 151
		float 	fVec7SE[2];
		float 	fTemp13SE; // step: 156
		float 	fSlow28BE = (0.33333334f * float(fcheckbox0)); // Zone 2, step: 159
		float 	fTemp14SE; // step: 163
		float 	fTemp15SE; // step: 166
		float 	fTemp16SE; // step: 169
		float 	fVec27SE[2];
		float 	fVec26SE[2];
		float 	fVec25SE[2];
		float 	fVec24SE[2];
		FAUSTFLOAT* output0 = output[0]; // Zone 3
		iVec0KC[1] = iVec0KCState;
		fVec1SE[1] = fVec1SEState;
		fVec3SE[1] = fVec3SEState;
		fVec4SE[1] = fVec4SEState;
		fVec6SE[1] = fVec6SEState;
		fVec10SE[1] = fVec10SEState;
		fVec9SE[1] = fVec9SEState;
		fVec8SE[1] = fVec8SEState;
		fVec7SE[1] = fVec7SEState;
		fVec27SE[1] = fVec27SEState;
		fVec26SE[1] = fVec26SEState;
		fVec25SE[1] = fVec25SEState;
		fVec24SE[1] = fVec24SEState;
		for (int i=0; i<count; i++) {
			iVec0KC[0] = 1;
			fTemp0SE = fVec1SE[1]; // step: 23
			fVec1SE[0] = (fSlow3BE + fTemp0SE + -floorf((fSlow3BE + fTemp0SE /* Sum */)) /* Sum */);
			fTemp1SE = powf(((2.0f * fVec1SE[0]) + -1.0f /* Sum */),2.0f); // step: 33
			fVec3SE[0] = fTemp1SE;
			fTemp2SE = fVec4SE[1]; // step: 45
			fVec4SE[0] = (fSlow6BE + fTemp2SE + -floorf((fSlow6BE + fTemp2SE /* Sum */)) /* Sum */);
			fTemp3SE = powf(((2.0f * fVec4SE[0]) + -1.0f /* Sum */),2.0f); // step: 54
			fVec6SE[0] = fTemp3SE;
			fTemp4SC = float(iVec0KC[1]); // step: 80
			fTemp5SE = (fTemp1SE + -fVec3SE[1] /* Sum */); // step: 84
			fTemp6SE = (fTemp3SE + -fVec6SE[1] /* Sum */); // step: 89
			fTemp7SE = (fSlow23BE * (fTemp4SC * fTemp5SE)); // step: 117
			fVec15SE[IOTA0&4095] = fTemp7SE;
			fTemp8SE = (fSlow27BE * (fTemp4SC * fTemp6SE)); // step: 132
			fVec14SE[IOTA0&4095] = fTemp8SE;
			fTemp9SE = ((fConst3KI * (fTemp4SC * ((fSlow12BE * fTemp5SE) + (fSlow13BE * fTemp6SE) /* Sum */))) + -(fSlow17BE * fVec14SE[(IOTA0-iSlow18BE)&4095]) + -(fSlow22BE * fVec15SE[(IOTA0-iSlow20BE)&4095]) + -(fSlow24BE * fVec15SE[(IOTA0-iSlow25BE)&4095]) + -(fSlow26BE * fVec14SE[(IOTA0-iSlow15BE)&4095]) /* Sum */); // step: 136
			fVec10SE[0] = (fSlow9BE * (fVec10SE[1] + (fSlow11BE * fTemp9SE) /* Sum */));
			fTemp10SE = fVec10SE[0]; // step: 141
			fVec9SE[0] = (fSlow9BE * (fVec9SE[1] + (fSlow8BE * fTemp10SE) /* Sum */));
			fTemp11SE = fVec9SE[0]; // step: 146
			fVec8SE[0] = (fSlow9BE * (fVec8SE[1] + (fSlow8BE * fTemp11SE) /* Sum */));
			fTemp12SE = fVec8SE[0]; // step: 151
			fVec7SE[0] = (fSlow9BE * (fVec7SE[1] + (fSlow8BE * fTemp12SE) /* Sum */));
			fTemp13SE = fVec7SE[0]; // step: 156
			fTemp14SE = powf(fTemp12SE,3.0f); // step: 163
			fTemp15SE = powf(fTemp11SE,3.0f); // step: 166
			fTemp16SE = powf(fTemp10SE,3.0f); // step: 169
			fVec27SE[0] = (fSlow9BE * (fVec27SE[1] + (fSlow8BE * (powf((fSlow10BE * fTemp9SE),3.0f) + -fTemp16SE /* Sum */)) /* Sum */));
			fVec26SE[0] = (fSlow9BE * (fVec26SE[1] + (fSlow8BE * (fVec27SE[0] + fTemp16SE + -fTemp15SE /* Sum */)) /* Sum */));
			fVec25SE[0] = (fSlow9BE * (fVec25SE[1] + (fSlow8BE * (fVec26SE[0] + fTemp15SE + -fTemp14SE /* Sum */)) /* Sum */));
			fVec24SE[0] = (fSlow9BE * (fVec24SE[1] + (fSlow8BE * (fVec25SE[0] + fTemp14SE + -(powf(fTemp13SE,3.0f)) /* Sum */)) /* Sum */));
			output0[i] = (FAUSTFLOAT)((fTemp13SE + -(fSlow28BE * fVec24SE[0]) /* Sum */));  // Zone Exec Code
			// post processing
			fVec24SE[1] = fVec24SE[0];
			fVec25SE[1] = fVec25SE[0];
			fVec26SE[1] = fVec26SE[0];
			fVec27SE[1] = fVec27SE[0];
			fVec7SE[1] = fVec7SE[0];
			fVec8SE[1] = fVec8SE[0];
			fVec9SE[1] = fVec9SE[0];
			fVec10SE[1] = fVec10SE[0];
			++IOTA0;
			fVec6SE[1] = fVec6SE[0];
			fVec4SE[1] = fVec4SE[0];
			fVec3SE[1] = fVec3SE[0];
			fVec1SE[1] = fVec1SE[0];
			iVec0KC[1] = iVec0KC[0];
		}
		iVec0KCState = iVec0KC[1];
		fVec1SEState = fVec1SE[1];
		fVec3SEState = fVec3SE[1];
		fVec4SEState = fVec4SE[1];
		fVec6SEState = fVec6SE[1];
		fVec10SEState = fVec10SE[1];
		fVec9SEState = fVec9SE[1];
		fVec8SEState = fVec8SE[1];
		fVec7SEState = fVec7SE[1];
		fVec27SEState = fVec27SE[1];
		fVec26SEState = fVec26SE[1];
		fVec25SEState = fVec25SE[1];
		fVec24SEState = fVec24SE[1];
	}
};


