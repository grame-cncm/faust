
pub fn mydsp_faustpower2_f(value: f32) -> f32 {
	(value * value)
}
pub fn mydsp_faustpower3_f(value: f32) -> f32 {
	((value * value) * value)
}


pub struct mydsp {
	
	fDummy: f32,
	fVslider0: f32,
	fHslider0: f32,
	iVec0: [i32;4],
	fRec0: [f32;2],
	fVslider1: f32,
	fEntry0: f32,
	fSamplingFreq: i32,
	fConst0: f32,
	fConst1: f32,
	fHslider1: f32,
	fVslider2: f32,
	fRec2: [f32;2],
	fVec1: [f32;2],
	fRec1: [f32;2],
	fConst2: f32,
	fVec2: [f32;2],
	fConst3: f32,
	fVec3: [f32;2],
	fVec4: [f32;2],
	fConst4: f32,
	fVec5: [f32;2],
	fVec6: [f32;2],
	fVec7: [f32;2],
	fVslider3: f32,
	fVec8: [f32;2],
	fRec3: [f32;2],
	fVec9: [f32;2],
	fVec10: [f32;2],
	fVec11: [f32;2],
	fVec12: [f32;2],
	fVec13: [f32;2],
	fVec14: [f32;2],
	fVslider4: f32,
	fVec15: [f32;2],
	fRec4: [f32;2],
	fVec16: [f32;2],
	fVec17: [f32;2],
	fVec18: [f32;2],
	fVec19: [f32;2],
	fVec20: [f32;2],
	fVec21: [f32;2],
	fConst5: f32,
	fVslider5: f32,
	fVec22: [f32;2],
	fRec5: [f32;2],
	fVec23: [f32;2],
	IOTA: i32,
	fVec24: [f32;4096],
	fConst6: f32,
	fVec25: [f32;2],
	fRec6: [f32;2],
	fVec26: [f32;2],
	fVec27: [f32;4096],
	fVec28: [f32;2],
	fRec7: [f32;2],
	fVec29: [f32;2],
	fVec30: [f32;4096],
	fConst7: f32,
	fVslider6: f32,
	fRec8: [f32;2],
	fRec9: [f32;2],
	fRec10: [f32;2],
	fVslider7: f32,
	fCheckbox0: f32,
	fVslider8: f32,
	fRec11: [f32;2],
	fConst8: f32,
	fVec31: [f32;2],
	fVec32: [f32;2],
	fVec33: [f32;4096],
	fVec34: [f32;2],
	fVec35: [f32;2],
	fVec36: [f32;4096],
	fVec37: [f32;2],
	fVec38: [f32;2],
	fVec39: [f32;4096],
	fVslider9: f32,
	iRec13: [i32;2],
	fRec12: [f32;4],
	
}

impl mydsp {
		
	pub fn new() -> mydsp { 
		mydsp {
			fDummy: 0 as f32,
			fVslider0: 0.0,
			fHslider0: 0.0,
			iVec0: [0;4],
			fRec0: [0.0;2],
			fVslider1: 0.0,
			fEntry0: 0.0,
			fSamplingFreq: 0,
			fConst0: 0.0,
			fConst1: 0.0,
			fHslider1: 0.0,
			fVslider2: 0.0,
			fRec2: [0.0;2],
			fVec1: [0.0;2],
			fRec1: [0.0;2],
			fConst2: 0.0,
			fVec2: [0.0;2],
			fConst3: 0.0,
			fVec3: [0.0;2],
			fVec4: [0.0;2],
			fConst4: 0.0,
			fVec5: [0.0;2],
			fVec6: [0.0;2],
			fVec7: [0.0;2],
			fVslider3: 0.0,
			fVec8: [0.0;2],
			fRec3: [0.0;2],
			fVec9: [0.0;2],
			fVec10: [0.0;2],
			fVec11: [0.0;2],
			fVec12: [0.0;2],
			fVec13: [0.0;2],
			fVec14: [0.0;2],
			fVslider4: 0.0,
			fVec15: [0.0;2],
			fRec4: [0.0;2],
			fVec16: [0.0;2],
			fVec17: [0.0;2],
			fVec18: [0.0;2],
			fVec19: [0.0;2],
			fVec20: [0.0;2],
			fVec21: [0.0;2],
			fConst5: 0.0,
			fVslider5: 0.0,
			fVec22: [0.0;2],
			fRec5: [0.0;2],
			fVec23: [0.0;2],
			IOTA: 0,
			fVec24: [0.0;4096],
			fConst6: 0.0,
			fVec25: [0.0;2],
			fRec6: [0.0;2],
			fVec26: [0.0;2],
			fVec27: [0.0;4096],
			fVec28: [0.0;2],
			fRec7: [0.0;2],
			fVec29: [0.0;2],
			fVec30: [0.0;4096],
			fConst7: 0.0,
			fVslider6: 0.0,
			fRec8: [0.0;2],
			fRec9: [0.0;2],
			fRec10: [0.0;2],
			fVslider7: 0.0,
			fCheckbox0: 0.0,
			fVslider8: 0.0,
			fRec11: [0.0;2],
			fConst8: 0.0,
			fVec31: [0.0;2],
			fVec32: [0.0;2],
			fVec33: [0.0;4096],
			fVec34: [0.0;2],
			fVec35: [0.0;2],
			fVec36: [0.0;4096],
			fVec37: [0.0;2],
			fVec38: [0.0;2],
			fVec39: [0.0;4096],
			fVslider9: 0.0,
			iRec13: [0;2],
			fRec12: [0.0;4],
		}
	}
	
	pub fn metadata(&mut self, m: &mut Meta) { 
		m.declare("author", "JOS, revised by RM");
		m.declare("basics.lib/name", "Faust Basic Element Library");
		m.declare("basics.lib/version", "0.0");
		m.declare("description", "Virtual analog oscillator demo application.");
		m.declare("filters.lib/name", "Faust Filters Library");
		m.declare("filters.lib/version", "0.0");
		m.declare("maths.lib/author", "GRAME");
		m.declare("maths.lib/copyright", "GRAME");
		m.declare("maths.lib/license", "LGPL with exception");
		m.declare("maths.lib/name", "Faust Math Library");
		m.declare("maths.lib/version", "2.1");
		m.declare("name", "VirtualAnalog");
		m.declare("noises.lib/name", "Faust Noise Generator Library");
		m.declare("noises.lib/version", "0.0");
		m.declare("oscillators.lib/name", "Faust Oscillator Library");
		m.declare("oscillators.lib/version", "0.0");
		m.declare("signals.lib/name", "Faust Signal Routing Library");
		m.declare("signals.lib/version", "0.0");
		m.declare("version", "0.0");
	}

	pub fn getSampleRate(&mut self) -> i32 {
		self.fSamplingFreq
	}
	pub fn getNumInputs(&mut self) -> i32 {
		1
	}
	pub fn getNumOutputs(&mut self) -> i32 {
		1
	}
	pub fn getInputRate(&mut self, channel: i32) -> i32 {
		let mut rate: i32;
		match (channel) {
			0 => {
				rate = 1;
				
			},
			_ => {
				rate = -1;
				
			},
			
		} 
		rate
	}
	pub fn getOutputRate(&mut self, channel: i32) -> i32 {
		let mut rate: i32;
		match (channel) {
			0 => {
				rate = 1;
				
			},
			_ => {
				rate = -1;
				
			},
			
		} 
		rate
	}
	
	pub fn classInit(samplingFreq: i32) {
		
	}
	
	pub fn instanceResetUserInterface(&mut self) {
		self.fVslider0 = 0.0;
		self.fHslider0 = -20.0;
		self.fVslider1 = 1.0;
		self.fEntry0 = 2.0;
		self.fHslider1 = 49.0;
		self.fVslider2 = 0.100000001;
		self.fVslider3 = -0.100000001;
		self.fVslider4 = 0.100000001;
		self.fVslider5 = 0.0;
		self.fVslider6 = 0.0;
		self.fVslider7 = 0.0;
		self.fCheckbox0 = 0.0;
		self.fVslider8 = 0.5;
		self.fVslider9 = 0.0;
		
	}
	
	pub fn instanceClear(&mut self) {
		let mut l0: i32 = 0;
		loop {
			self.iVec0[l0 as usize] = 0;
			l0 = (l0 + 1);
			if (l0 < 4) { continue; } else { break; }
		}
		let mut l1: i32 = 0;
		loop {
			self.fRec0[l1 as usize] = 0.0;
			l1 = (l1 + 1);
			if (l1 < 2) { continue; } else { break; }
		}
		let mut l2: i32 = 0;
		loop {
			self.fRec2[l2 as usize] = 0.0;
			l2 = (l2 + 1);
			if (l2 < 2) { continue; } else { break; }
		}
		let mut l3: i32 = 0;
		loop {
			self.fVec1[l3 as usize] = 0.0;
			l3 = (l3 + 1);
			if (l3 < 2) { continue; } else { break; }
		}
		let mut l4: i32 = 0;
		loop {
			self.fRec1[l4 as usize] = 0.0;
			l4 = (l4 + 1);
			if (l4 < 2) { continue; } else { break; }
		}
		let mut l5: i32 = 0;
		loop {
			self.fVec2[l5 as usize] = 0.0;
			l5 = (l5 + 1);
			if (l5 < 2) { continue; } else { break; }
		}
		let mut l6: i32 = 0;
		loop {
			self.fVec3[l6 as usize] = 0.0;
			l6 = (l6 + 1);
			if (l6 < 2) { continue; } else { break; }
		}
		let mut l7: i32 = 0;
		loop {
			self.fVec4[l7 as usize] = 0.0;
			l7 = (l7 + 1);
			if (l7 < 2) { continue; } else { break; }
		}
		let mut l8: i32 = 0;
		loop {
			self.fVec5[l8 as usize] = 0.0;
			l8 = (l8 + 1);
			if (l8 < 2) { continue; } else { break; }
		}
		let mut l9: i32 = 0;
		loop {
			self.fVec6[l9 as usize] = 0.0;
			l9 = (l9 + 1);
			if (l9 < 2) { continue; } else { break; }
		}
		let mut l10: i32 = 0;
		loop {
			self.fVec7[l10 as usize] = 0.0;
			l10 = (l10 + 1);
			if (l10 < 2) { continue; } else { break; }
		}
		let mut l11: i32 = 0;
		loop {
			self.fVec8[l11 as usize] = 0.0;
			l11 = (l11 + 1);
			if (l11 < 2) { continue; } else { break; }
		}
		let mut l12: i32 = 0;
		loop {
			self.fRec3[l12 as usize] = 0.0;
			l12 = (l12 + 1);
			if (l12 < 2) { continue; } else { break; }
		}
		let mut l13: i32 = 0;
		loop {
			self.fVec9[l13 as usize] = 0.0;
			l13 = (l13 + 1);
			if (l13 < 2) { continue; } else { break; }
		}
		let mut l14: i32 = 0;
		loop {
			self.fVec10[l14 as usize] = 0.0;
			l14 = (l14 + 1);
			if (l14 < 2) { continue; } else { break; }
		}
		let mut l15: i32 = 0;
		loop {
			self.fVec11[l15 as usize] = 0.0;
			l15 = (l15 + 1);
			if (l15 < 2) { continue; } else { break; }
		}
		let mut l16: i32 = 0;
		loop {
			self.fVec12[l16 as usize] = 0.0;
			l16 = (l16 + 1);
			if (l16 < 2) { continue; } else { break; }
		}
		let mut l17: i32 = 0;
		loop {
			self.fVec13[l17 as usize] = 0.0;
			l17 = (l17 + 1);
			if (l17 < 2) { continue; } else { break; }
		}
		let mut l18: i32 = 0;
		loop {
			self.fVec14[l18 as usize] = 0.0;
			l18 = (l18 + 1);
			if (l18 < 2) { continue; } else { break; }
		}
		let mut l19: i32 = 0;
		loop {
			self.fVec15[l19 as usize] = 0.0;
			l19 = (l19 + 1);
			if (l19 < 2) { continue; } else { break; }
		}
		let mut l20: i32 = 0;
		loop {
			self.fRec4[l20 as usize] = 0.0;
			l20 = (l20 + 1);
			if (l20 < 2) { continue; } else { break; }
		}
		let mut l21: i32 = 0;
		loop {
			self.fVec16[l21 as usize] = 0.0;
			l21 = (l21 + 1);
			if (l21 < 2) { continue; } else { break; }
		}
		let mut l22: i32 = 0;
		loop {
			self.fVec17[l22 as usize] = 0.0;
			l22 = (l22 + 1);
			if (l22 < 2) { continue; } else { break; }
		}
		let mut l23: i32 = 0;
		loop {
			self.fVec18[l23 as usize] = 0.0;
			l23 = (l23 + 1);
			if (l23 < 2) { continue; } else { break; }
		}
		let mut l24: i32 = 0;
		loop {
			self.fVec19[l24 as usize] = 0.0;
			l24 = (l24 + 1);
			if (l24 < 2) { continue; } else { break; }
		}
		let mut l25: i32 = 0;
		loop {
			self.fVec20[l25 as usize] = 0.0;
			l25 = (l25 + 1);
			if (l25 < 2) { continue; } else { break; }
		}
		let mut l26: i32 = 0;
		loop {
			self.fVec21[l26 as usize] = 0.0;
			l26 = (l26 + 1);
			if (l26 < 2) { continue; } else { break; }
		}
		let mut l27: i32 = 0;
		loop {
			self.fVec22[l27 as usize] = 0.0;
			l27 = (l27 + 1);
			if (l27 < 2) { continue; } else { break; }
		}
		let mut l28: i32 = 0;
		loop {
			self.fRec5[l28 as usize] = 0.0;
			l28 = (l28 + 1);
			if (l28 < 2) { continue; } else { break; }
		}
		let mut l29: i32 = 0;
		loop {
			self.fVec23[l29 as usize] = 0.0;
			l29 = (l29 + 1);
			if (l29 < 2) { continue; } else { break; }
		}
		self.IOTA = 0;
		let mut l30: i32 = 0;
		loop {
			self.fVec24[l30 as usize] = 0.0;
			l30 = (l30 + 1);
			if (l30 < 4096) { continue; } else { break; }
		}
		let mut l31: i32 = 0;
		loop {
			self.fVec25[l31 as usize] = 0.0;
			l31 = (l31 + 1);
			if (l31 < 2) { continue; } else { break; }
		}
		let mut l32: i32 = 0;
		loop {
			self.fRec6[l32 as usize] = 0.0;
			l32 = (l32 + 1);
			if (l32 < 2) { continue; } else { break; }
		}
		let mut l33: i32 = 0;
		loop {
			self.fVec26[l33 as usize] = 0.0;
			l33 = (l33 + 1);
			if (l33 < 2) { continue; } else { break; }
		}
		let mut l34: i32 = 0;
		loop {
			self.fVec27[l34 as usize] = 0.0;
			l34 = (l34 + 1);
			if (l34 < 4096) { continue; } else { break; }
		}
		let mut l35: i32 = 0;
		loop {
			self.fVec28[l35 as usize] = 0.0;
			l35 = (l35 + 1);
			if (l35 < 2) { continue; } else { break; }
		}
		let mut l36: i32 = 0;
		loop {
			self.fRec7[l36 as usize] = 0.0;
			l36 = (l36 + 1);
			if (l36 < 2) { continue; } else { break; }
		}
		let mut l37: i32 = 0;
		loop {
			self.fVec29[l37 as usize] = 0.0;
			l37 = (l37 + 1);
			if (l37 < 2) { continue; } else { break; }
		}
		let mut l38: i32 = 0;
		loop {
			self.fVec30[l38 as usize] = 0.0;
			l38 = (l38 + 1);
			if (l38 < 4096) { continue; } else { break; }
		}
		let mut l39: i32 = 0;
		loop {
			self.fRec8[l39 as usize] = 0.0;
			l39 = (l39 + 1);
			if (l39 < 2) { continue; } else { break; }
		}
		let mut l40: i32 = 0;
		loop {
			self.fRec9[l40 as usize] = 0.0;
			l40 = (l40 + 1);
			if (l40 < 2) { continue; } else { break; }
		}
		let mut l41: i32 = 0;
		loop {
			self.fRec10[l41 as usize] = 0.0;
			l41 = (l41 + 1);
			if (l41 < 2) { continue; } else { break; }
		}
		let mut l42: i32 = 0;
		loop {
			self.fRec11[l42 as usize] = 0.0;
			l42 = (l42 + 1);
			if (l42 < 2) { continue; } else { break; }
		}
		let mut l43: i32 = 0;
		loop {
			self.fVec31[l43 as usize] = 0.0;
			l43 = (l43 + 1);
			if (l43 < 2) { continue; } else { break; }
		}
		let mut l44: i32 = 0;
		loop {
			self.fVec32[l44 as usize] = 0.0;
			l44 = (l44 + 1);
			if (l44 < 2) { continue; } else { break; }
		}
		let mut l45: i32 = 0;
		loop {
			self.fVec33[l45 as usize] = 0.0;
			l45 = (l45 + 1);
			if (l45 < 4096) { continue; } else { break; }
		}
		let mut l46: i32 = 0;
		loop {
			self.fVec34[l46 as usize] = 0.0;
			l46 = (l46 + 1);
			if (l46 < 2) { continue; } else { break; }
		}
		let mut l47: i32 = 0;
		loop {
			self.fVec35[l47 as usize] = 0.0;
			l47 = (l47 + 1);
			if (l47 < 2) { continue; } else { break; }
		}
		let mut l48: i32 = 0;
		loop {
			self.fVec36[l48 as usize] = 0.0;
			l48 = (l48 + 1);
			if (l48 < 4096) { continue; } else { break; }
		}
		let mut l49: i32 = 0;
		loop {
			self.fVec37[l49 as usize] = 0.0;
			l49 = (l49 + 1);
			if (l49 < 2) { continue; } else { break; }
		}
		let mut l50: i32 = 0;
		loop {
			self.fVec38[l50 as usize] = 0.0;
			l50 = (l50 + 1);
			if (l50 < 2) { continue; } else { break; }
		}
		let mut l51: i32 = 0;
		loop {
			self.fVec39[l51 as usize] = 0.0;
			l51 = (l51 + 1);
			if (l51 < 4096) { continue; } else { break; }
		}
		let mut l52: i32 = 0;
		loop {
			self.iRec13[l52 as usize] = 0;
			l52 = (l52 + 1);
			if (l52 < 2) { continue; } else { break; }
		}
		let mut l53: i32 = 0;
		loop {
			self.fRec12[l53 as usize] = 0.0;
			l53 = (l53 + 1);
			if (l53 < 4) { continue; } else { break; }
		}
		
	}
	
	pub fn instanceConstants(&mut self, samplingFreq: i32) {
		self.fSamplingFreq = samplingFreq;
		self.fConst0 = f32::min(192000.0, f32::max(1.0, (self.fSamplingFreq as f32)));
		self.fConst1 = (1.0 / self.fConst0);
		self.fConst2 = (0.25 * self.fConst0);
		self.fConst3 = (0.0416666679 * mydsp_faustpower2_f(self.fConst0));
		self.fConst4 = (0.00520833349 * mydsp_faustpower3_f(self.fConst0));
		self.fConst5 = (0.0833333358 * self.fConst0);
		self.fConst6 = (0.5 * self.fConst0);
		self.fConst7 = (1.33333337 / self.fConst0);
		self.fConst8 = (0.013888889 * self.fConst0);
		
	}
	
	pub fn instanceInit(&mut self, samplingFreq: i32) {
		self.instanceConstants(samplingFreq);
		self.instanceResetUserInterface();
		self.instanceClear();
	}
	
	pub fn init(&mut self, samplingFreq: i32) {
		mydsp::classInit(samplingFreq);
		self.instanceInit(samplingFreq);
	}
	
	pub fn buildUserInterface(&mut self, ui_interface: &mut UI<f32>) {
		ui_interface.declare(&mut self.fDummy, "0", "");
		ui_interface.declare(&mut self.fDummy, "tooltip", "See Faust's oscillators.lib for documentation and references");
		ui_interface.openVerticalBox("VIRTUAL ANALOG OSCILLATORS");
		ui_interface.declare(&mut self.fDummy, "0", "");
		ui_interface.openHorizontalBox("Signal Levels");
		ui_interface.declare(&mut self.fVslider1, "0", "");
		ui_interface.declare(&mut self.fVslider1, "style", "vslider");
		ui_interface.addVerticalSlider("Sawtooth", &mut self.fVslider1, 1.0, 0.0, 1.0, 0.01);
		ui_interface.declare(&mut self.fDummy, "1", "");
		ui_interface.openVerticalBox("Pulse Train");
		ui_interface.declare(&mut self.fCheckbox0, "0", "");
		ui_interface.declare(&mut self.fCheckbox0, "tooltip", "When checked, use 3rd-order aliasing suppression (up from 2)  See if you can hear a difference with the freq high and swept");
		ui_interface.addCheckButton("Order 3", &mut self.fCheckbox0);
		ui_interface.declare(&mut self.fVslider7, "1", "");
		ui_interface.declare(&mut self.fVslider7, "style", "vslider");
		ui_interface.addVerticalSlider("0x00", &mut self.fVslider7, 0.0, 0.0, 1.0, 0.01);
		ui_interface.declare(&mut self.fVslider8, "2", "");
		ui_interface.declare(&mut self.fVslider8, "style", "knob");
		ui_interface.addVerticalSlider("Duty Cycle", &mut self.fVslider8, 0.5, 0.0, 1.0, 0.01);
		ui_interface.closeBox();
		ui_interface.declare(&mut self.fVslider5, "2", "");
		ui_interface.declare(&mut self.fVslider5, "style", "vslider");
		ui_interface.addVerticalSlider("Square", &mut self.fVslider5, 0.0, 0.0, 1.0, 0.01);
		ui_interface.declare(&mut self.fVslider6, "3", "");
		ui_interface.declare(&mut self.fVslider6, "style", "vslider");
		ui_interface.addVerticalSlider("Triangle", &mut self.fVslider6, 0.0, 0.0, 1.0, 0.01);
		ui_interface.declare(&mut self.fVslider9, "4", "");
		ui_interface.declare(&mut self.fVslider9, "style", "vslider");
		ui_interface.declare(&mut self.fVslider9, "tooltip", "Pink Noise (or 1/f noise) is   Constant-Q Noise, meaning that it has the same total power in every octave   (uses only amplitude controls)");
		ui_interface.addVerticalSlider("Pink Noise", &mut self.fVslider9, 0.0, 0.0, 1.0, 0.01);
		ui_interface.declare(&mut self.fVslider0, "5", "");
		ui_interface.declare(&mut self.fVslider0, "style", "vslider");
		ui_interface.addVerticalSlider("Ext Input", &mut self.fVslider0, 0.0, 0.0, 1.0, 0.01);
		ui_interface.closeBox();
		ui_interface.declare(&mut self.fDummy, "1", "");
		ui_interface.openHorizontalBox("Signal Parameters");
		ui_interface.declare(&mut self.fDummy, "0", "");
		ui_interface.openVerticalBox("0x00");
		ui_interface.declare(&mut self.fHslider0, "1", "");
		ui_interface.declare(&mut self.fHslider0, "style", "hslider");
		ui_interface.declare(&mut self.fHslider0, "tooltip", "Sawtooth waveform amplitude");
		ui_interface.declare(&mut self.fHslider0, "unit", "dB");
		ui_interface.addHorizontalSlider("Mix Amplitude", &mut self.fHslider0, -20.0, -120.0, 10.0, 0.10000000000000001);
		ui_interface.declare(&mut self.fHslider1, "2", "");
		ui_interface.declare(&mut self.fHslider1, "style", "hslider");
		ui_interface.declare(&mut self.fHslider1, "tooltip", "Sawtooth   frequency as a Piano Key (PK) number (A440 = key 49)");
		ui_interface.declare(&mut self.fHslider1, "unit", "PK");
		ui_interface.addHorizontalSlider("Frequency", &mut self.fHslider1, 49.0, 1.0, 88.0, 0.01);
		ui_interface.closeBox();
		ui_interface.declare(&mut self.fVslider3, "3", "");
		ui_interface.declare(&mut self.fVslider3, "style", "knob");
		ui_interface.declare(&mut self.fVslider3, "tooltip", "Percentange frequency-shift up or down for second oscillator");
		ui_interface.declare(&mut self.fVslider3, "unit", "%%");
		ui_interface.addVerticalSlider("Detuning 1", &mut self.fVslider3, -0.10000000000000001, -10.0, 10.0, 0.01);
		ui_interface.declare(&mut self.fVslider4, "4", "");
		ui_interface.declare(&mut self.fVslider4, "style", "knob");
		ui_interface.declare(&mut self.fVslider4, "tooltip", "Percentange frequency-shift up or down for third detuned oscillator");
		ui_interface.declare(&mut self.fVslider4, "unit", "%%");
		ui_interface.addVerticalSlider("Detuning 2", &mut self.fVslider4, 0.10000000000000001, -10.0, 10.0, 0.01);
		ui_interface.declare(&mut self.fVslider2, "5", "");
		ui_interface.declare(&mut self.fVslider2, "scale", "log");
		ui_interface.declare(&mut self.fVslider2, "style", "knob");
		ui_interface.declare(&mut self.fVslider2, "tooltip", "Portamento (frequency-glide) time-constant in seconds");
		ui_interface.declare(&mut self.fVslider2, "unit", "sec");
		ui_interface.addVerticalSlider("Portamento", &mut self.fVslider2, 0.10000000000000001, 0.001, 10.0, 0.001);
		ui_interface.declare(&mut self.fEntry0, "6", "");
		ui_interface.declare(&mut self.fEntry0, "tooltip", "Order of sawtooth aliasing  suppression");
		ui_interface.addNumEntry("Saw Order", &mut self.fEntry0, 2.0, 1.0, 4.0, 1.0);
		ui_interface.closeBox();
		ui_interface.closeBox();
		
	}
	
	pub fn compute(&mut self, count: i32, inputs: &[&[f32]], outputs: &mut[&mut[f32]]) {
		let mut fSlow0: f32 = (self.fVslider0 as f32);
		let mut fSlow1: f32 = (0.00100000005 * f32::powf(10.0, (0.0500000007 * (self.fHslider0 as f32))));
		let mut fSlow2: f32 = (0.333333343 * (self.fVslider1 as f32));
		let mut iSlow3: i32 = (((self.fEntry0 as f32) + -1.0) as i32);
		let mut iSlow4: i32 = ((iSlow3 >= 2) as i32);
		let mut iSlow5: i32 = ((iSlow3 >= 1) as i32);
		let mut fSlow6: f32 = f32::exp((0.0 - (self.fConst1 / (self.fVslider2 as f32))));
		let mut fSlow7: f32 = (440.0 * (f32::powf(2.0, (0.0833333358 * ((self.fHslider1 as f32) + -49.0))) * (1.0 - fSlow6)));
		let mut iSlow8: i32 = ((iSlow3 >= 3) as i32);
		let mut fSlow9: f32 = (1.0 - (0.00999999978 * (self.fVslider3 as f32)));
		let mut fSlow10: f32 = ((0.00999999978 * (self.fVslider4 as f32)) + 1.0);
		let mut fSlow11: f32 = (self.fConst5 * (self.fVslider5 as f32));
		let mut fSlow12: f32 = (self.fConst7 * (self.fVslider6 as f32));
		let mut fSlow13: f32 = (self.fConst0 * (self.fVslider7 as f32));
		let mut fSlow14: f32 = (self.fCheckbox0 as f32);
		let mut fSlow15: f32 = (0.0833333358 * (1.0 - fSlow14));
		let mut fSlow16: f32 = (0.00999999978 * (self.fVslider8 as f32));
		let mut fSlow17: f32 = (self.fConst8 * fSlow14);
		let mut fSlow18: f32 = (self.fVslider9 as f32);
		let mut i: i32 = 0;
		loop {
			self.iVec0[0] = 1;
			self.fRec0[0] = (fSlow1 + (0.999000013 * self.fRec0[1]));
			self.fRec2[0] = (fSlow7 + (fSlow6 * self.fRec2[1]));
			let mut fTemp0: f32 = f32::max(20.0, f32::abs(self.fRec2[0]));
			self.fVec1[0] = fTemp0;
			let mut fTemp1: f32 = (self.fRec1[1] + (self.fConst1 * self.fVec1[1]));
			self.fRec1[0] = (fTemp1 - f32::floor(fTemp1));
			let mut fTemp2: f32 = (2.0 * self.fRec1[0]);
			let mut fTemp3: f32 = (fTemp2 + -1.0);
			let mut fTemp4: f32 = mydsp_faustpower2_f(fTemp3);
			self.fVec2[0] = fTemp4;
			let mut fTemp5: f32 = mydsp_faustpower3_f(fTemp3);
			self.fVec3[0] = (fTemp5 + (1.0 - fTemp2));
			let mut fTemp6: f32 = ((fTemp5 + (1.0 - (fTemp2 + self.fVec3[1]))) / fTemp0);
			self.fVec4[0] = fTemp6;
			let mut fTemp7: f32 = (fTemp4 * (fTemp4 + -2.0));
			self.fVec5[0] = fTemp7;
			let mut fTemp8: f32 = ((fTemp7 - self.fVec5[1]) / fTemp0);
			self.fVec6[0] = fTemp8;
			let mut fTemp9: f32 = ((fTemp8 - self.fVec6[1]) / fTemp0);
			self.fVec7[0] = fTemp9;
			let mut fTemp10: f32 = (fSlow9 * self.fRec2[0]);
			let mut fTemp11: f32 = f32::max(20.0, f32::abs(fTemp10));
			self.fVec8[0] = fTemp11;
			let mut fTemp12: f32 = (self.fRec3[1] + (self.fConst1 * self.fVec8[1]));
			self.fRec3[0] = (fTemp12 - f32::floor(fTemp12));
			let mut fTemp13: f32 = (2.0 * self.fRec3[0]);
			let mut fTemp14: f32 = (fTemp13 + -1.0);
			let mut fTemp15: f32 = mydsp_faustpower2_f(fTemp14);
			self.fVec9[0] = fTemp15;
			let mut fTemp16: f32 = mydsp_faustpower3_f(fTemp14);
			self.fVec10[0] = (fTemp16 + (1.0 - fTemp13));
			let mut fTemp17: f32 = ((fTemp16 + (1.0 - (fTemp13 + self.fVec10[1]))) / fTemp11);
			self.fVec11[0] = fTemp17;
			let mut fTemp18: f32 = (fTemp15 * (fTemp15 + -2.0));
			self.fVec12[0] = fTemp18;
			let mut fTemp19: f32 = ((fTemp18 - self.fVec12[1]) / fTemp11);
			self.fVec13[0] = fTemp19;
			let mut fTemp20: f32 = ((fTemp19 - self.fVec13[1]) / fTemp11);
			self.fVec14[0] = fTemp20;
			let mut fTemp21: f32 = (fSlow10 * self.fRec2[0]);
			let mut fTemp22: f32 = f32::max(20.0, f32::abs(fTemp21));
			self.fVec15[0] = fTemp22;
			let mut fTemp23: f32 = (self.fRec4[1] + (self.fConst1 * self.fVec15[1]));
			self.fRec4[0] = (fTemp23 - f32::floor(fTemp23));
			let mut fTemp24: f32 = (2.0 * self.fRec4[0]);
			let mut fTemp25: f32 = (fTemp24 + -1.0);
			let mut fTemp26: f32 = mydsp_faustpower2_f(fTemp25);
			self.fVec16[0] = fTemp26;
			let mut fTemp27: f32 = mydsp_faustpower3_f(fTemp25);
			self.fVec17[0] = (fTemp27 + (1.0 - fTemp24));
			let mut fTemp28: f32 = ((fTemp27 + (1.0 - (fTemp24 + self.fVec17[1]))) / fTemp22);
			self.fVec18[0] = fTemp28;
			let mut fTemp29: f32 = (fTemp26 * (fTemp26 + -2.0));
			self.fVec19[0] = fTemp29;
			let mut fTemp30: f32 = ((fTemp29 - self.fVec19[1]) / fTemp22);
			self.fVec20[0] = fTemp30;
			let mut fTemp31: f32 = ((fTemp30 - self.fVec20[1]) / fTemp22);
			self.fVec21[0] = fTemp31;
			let mut fTemp32: f32 = f32::max(self.fRec2[0], 23.4489498);
			let mut fTemp33: f32 = f32::max(20.0, f32::abs(fTemp32));
			self.fVec22[0] = fTemp33;
			let mut fTemp34: f32 = (self.fRec5[1] + (self.fConst1 * self.fVec22[1]));
			self.fRec5[0] = (fTemp34 - f32::floor(fTemp34));
			let mut fTemp35: f32 = (2.0 * self.fRec5[0]);
			let mut fTemp36: f32 = (fTemp35 + -1.0);
			let mut fTemp37: f32 = mydsp_faustpower2_f(fTemp36);
			self.fVec23[0] = fTemp37;
			let mut fTemp38: f32 = (((self.iVec0[1] as f32) * (fTemp37 - self.fVec23[1])) / fTemp33);
			self.fVec24[(self.IOTA & 4095) as usize] = fTemp38;
			let mut fTemp39: f32 = f32::max(0.0, f32::min(2047.0, (self.fConst6 / fTemp32)));
			let mut iTemp40: i32 = (fTemp39 as i32);
			let mut fTemp41: f32 = f32::floor(fTemp39);
			let mut fTemp42: f32 = ((fTemp38 - (self.fVec24[((self.IOTA - iTemp40) & 4095) as usize] * (fTemp41 + (1.0 - fTemp39)))) - ((fTemp39 - fTemp41) * self.fVec24[((self.IOTA - (iTemp40 + 1)) & 4095) as usize]));
			let mut fTemp43: f32 = f32::max(fTemp10, 23.4489498);
			let mut fTemp44: f32 = f32::max(20.0, f32::abs(fTemp43));
			self.fVec25[0] = fTemp44;
			let mut fTemp45: f32 = (self.fRec6[1] + (self.fConst1 * self.fVec25[1]));
			self.fRec6[0] = (fTemp45 - f32::floor(fTemp45));
			let mut fTemp46: f32 = (2.0 * self.fRec6[0]);
			let mut fTemp47: f32 = (fTemp46 + -1.0);
			let mut fTemp48: f32 = mydsp_faustpower2_f(fTemp47);
			self.fVec26[0] = fTemp48;
			let mut fTemp49: f32 = (((self.iVec0[1] as f32) * (fTemp48 - self.fVec26[1])) / fTemp44);
			self.fVec27[(self.IOTA & 4095) as usize] = fTemp49;
			let mut fTemp50: f32 = f32::max(0.0, f32::min(2047.0, (self.fConst6 / fTemp43)));
			let mut iTemp51: i32 = (fTemp50 as i32);
			let mut fTemp52: f32 = f32::floor(fTemp50);
			let mut fTemp53: f32 = ((fTemp49 - (self.fVec27[((self.IOTA - iTemp51) & 4095) as usize] * (fTemp52 + (1.0 - fTemp50)))) - ((fTemp50 - fTemp52) * self.fVec27[((self.IOTA - (iTemp51 + 1)) & 4095) as usize]));
			let mut fTemp54: f32 = f32::max(fTemp21, 23.4489498);
			let mut fTemp55: f32 = f32::max(20.0, f32::abs(fTemp54));
			self.fVec28[0] = fTemp55;
			let mut fTemp56: f32 = (self.fRec7[1] + (self.fConst1 * self.fVec28[1]));
			self.fRec7[0] = (fTemp56 - f32::floor(fTemp56));
			let mut fTemp57: f32 = (2.0 * self.fRec7[0]);
			let mut fTemp58: f32 = (fTemp57 + -1.0);
			let mut fTemp59: f32 = mydsp_faustpower2_f(fTemp58);
			self.fVec29[0] = fTemp59;
			let mut fTemp60: f32 = (((self.iVec0[1] as f32) * (fTemp59 - self.fVec29[1])) / fTemp55);
			self.fVec30[(self.IOTA & 4095) as usize] = fTemp60;
			let mut fTemp61: f32 = f32::max(0.0, f32::min(2047.0, (self.fConst6 / fTemp54)));
			let mut iTemp62: i32 = (fTemp61 as i32);
			let mut fTemp63: f32 = f32::floor(fTemp61);
			let mut fTemp64: f32 = ((fTemp60 - (self.fVec30[((self.IOTA - iTemp62) & 4095) as usize] * (fTemp63 + (1.0 - fTemp61)))) - ((fTemp61 - fTemp63) * self.fVec30[((self.IOTA - (iTemp62 + 1)) & 4095) as usize]));
			self.fRec8[0] = ((self.fConst2 * fTemp42) + (0.999000013 * self.fRec8[1]));
			self.fRec9[0] = ((self.fConst2 * fTemp53) + (0.999000013 * self.fRec9[1]));
			self.fRec10[0] = ((self.fConst2 * fTemp64) + (0.999000013 * self.fRec10[1]));
			self.fRec11[0] = (fSlow16 + (0.99000001 * self.fRec11[1]));
			let mut fTemp65: f32 = f32::max(0.0, f32::min(2047.0, (self.fConst0 * (self.fRec11[0] / fTemp32))));
			let mut fTemp66: f32 = f32::floor(fTemp65);
			let mut fTemp67: f32 = (fTemp66 + (1.0 - fTemp65));
			let mut iTemp68: i32 = (fTemp65 as i32);
			let mut fTemp69: f32 = (fTemp65 - fTemp66);
			let mut iTemp70: i32 = (iTemp68 + 1);
			let mut fTemp71: f32 = f32::max(0.0, f32::min(2047.0, (self.fConst0 * (self.fRec11[0] / fTemp43))));
			let mut fTemp72: f32 = f32::floor(fTemp71);
			let mut fTemp73: f32 = (fTemp72 + (1.0 - fTemp71));
			let mut iTemp74: i32 = (fTemp71 as i32);
			let mut fTemp75: f32 = (fTemp71 - fTemp72);
			let mut iTemp76: i32 = (iTemp74 + 1);
			let mut fTemp77: f32 = f32::max(0.0, f32::min(2047.0, (self.fConst0 * (self.fRec11[0] / fTemp54))));
			let mut fTemp78: f32 = f32::floor(fTemp77);
			let mut fTemp79: f32 = (fTemp78 + (1.0 - fTemp77));
			let mut iTemp80: i32 = (fTemp77 as i32);
			let mut fTemp81: f32 = (fTemp77 - fTemp78);
			let mut iTemp82: i32 = (iTemp80 + 1);
			let mut fTemp83: f32 = mydsp_faustpower3_f(fTemp36);
			self.fVec31[0] = (fTemp83 + (1.0 - fTemp35));
			let mut fTemp84: f32 = ((fTemp83 + (1.0 - (fTemp35 + self.fVec31[1]))) / fTemp33);
			self.fVec32[0] = fTemp84;
			let mut fTemp85: f32 = (((self.iVec0[2] as f32) * (fTemp84 - self.fVec32[1])) / fTemp33);
			self.fVec33[(self.IOTA & 4095) as usize] = fTemp85;
			let mut fTemp86: f32 = mydsp_faustpower3_f(fTemp47);
			self.fVec34[0] = (fTemp86 + (1.0 - fTemp46));
			let mut fTemp87: f32 = ((fTemp86 + (1.0 - (fTemp46 + self.fVec34[1]))) / fTemp44);
			self.fVec35[0] = fTemp87;
			let mut fTemp88: f32 = (((self.iVec0[2] as f32) * (fTemp87 - self.fVec35[1])) / fTemp44);
			self.fVec36[(self.IOTA & 4095) as usize] = fTemp88;
			let mut fTemp89: f32 = mydsp_faustpower3_f(fTemp58);
			self.fVec37[0] = (fTemp89 + (1.0 - fTemp57));
			let mut fTemp90: f32 = ((fTemp89 + (1.0 - (fTemp57 + self.fVec37[1]))) / fTemp55);
			self.fVec38[0] = fTemp90;
			let mut fTemp91: f32 = (((self.iVec0[2] as f32) * (fTemp90 - self.fVec38[1])) / fTemp55);
			self.fVec39[(self.IOTA & 4095) as usize] = fTemp91;
			self.iRec13[0] = ((1103515245 * self.iRec13[1]) + 12345);
			self.fRec12[0] = (((0.522189379 * self.fRec12[3]) + ((4.65661287e-10 * (self.iRec13[0] as f32)) + (2.49495602 * self.fRec12[1]))) - (2.0172658 * self.fRec12[2]));
			outputs[0][i as usize] = (((fSlow0 * (inputs[0][i as usize] as f32)) + (self.fRec0[0] * (((((fSlow2 * ((if (iSlow4 as i32 == 1) { if (iSlow8 as i32 == 1) { (self.fConst4 * (((self.iVec0[3] as f32) * (fTemp9 - self.fVec7[1])) / fTemp0)) } else { (self.fConst3 * (((self.iVec0[2] as f32) * (fTemp6 - self.fVec4[1])) / fTemp0)) } } else { if (iSlow5 as i32 == 1) { (self.fConst2 * (((self.iVec0[1] as f32) * (fTemp4 - self.fVec2[1])) / fTemp0)) } else { fTemp3 } } + if (iSlow4 as i32 == 1) { if (iSlow8 as i32 == 1) { (self.fConst4 * (((self.iVec0[3] as f32) * (fTemp20 - self.fVec14[1])) / fTemp11)) } else { (self.fConst3 * (((self.iVec0[2] as f32) * (fTemp17 - self.fVec11[1])) / fTemp11)) } } else { if (iSlow5 as i32 == 1) { (self.fConst2 * (((self.iVec0[1] as f32) * (fTemp15 - self.fVec9[1])) / fTemp11)) } else { fTemp14 } }) + if (iSlow4 as i32 == 1) { if (iSlow8 as i32 == 1) { (self.fConst4 * (((self.iVec0[3] as f32) * (fTemp31 - self.fVec21[1])) / fTemp22)) } else { (self.fConst3 * (((self.iVec0[2] as f32) * (fTemp28 - self.fVec18[1])) / fTemp22)) } } else { if (iSlow5 as i32 == 1) { (self.fConst2 * (((self.iVec0[1] as f32) * (fTemp26 - self.fVec16[1])) / fTemp22)) } else { fTemp25 } })) + (fSlow11 * ((fTemp42 + fTemp53) + fTemp64))) + (fSlow12 * (self.fRec2[0] * ((self.fRec8[0] + (fSlow9 * self.fRec9[0])) + (fSlow10 * self.fRec10[0]))))) + (fSlow13 * ((fSlow15 * ((((fTemp38 - (fTemp67 * self.fVec24[((self.IOTA - iTemp68) & 4095) as usize])) - (fTemp69 * self.fVec24[((self.IOTA - iTemp70) & 4095) as usize])) + ((fTemp49 - (fTemp73 * self.fVec27[((self.IOTA - iTemp74) & 4095) as usize])) - (fTemp75 * self.fVec27[((self.IOTA - iTemp76) & 4095) as usize]))) + ((fTemp60 - (fTemp79 * self.fVec30[((self.IOTA - iTemp80) & 4095) as usize])) - (fTemp81 * self.fVec30[((self.IOTA - iTemp82) & 4095) as usize])))) + (fSlow17 * ((((fTemp85 - (self.fVec33[((self.IOTA - iTemp68) & 4095) as usize] * fTemp67)) - (fTemp69 * self.fVec33[((self.IOTA - iTemp70) & 4095) as usize])) + ((fTemp88 - (self.fVec36[((self.IOTA - iTemp74) & 4095) as usize] * fTemp73)) - (fTemp75 * self.fVec36[((self.IOTA - iTemp76) & 4095) as usize]))) + ((fTemp91 - (self.fVec39[((self.IOTA - iTemp80) & 4095) as usize] * fTemp79)) - (fTemp81 * self.fVec39[((self.IOTA - iTemp82) & 4095) as usize]))))))) + (fSlow18 * (((0.0499220341 * self.fRec12[0]) + (0.0506126992 * self.fRec12[2])) - ((0.0959935337 * self.fRec12[1]) + (0.00440878607 * self.fRec12[3]))))))) as f32);
			let mut j0: i32 = 3;
			loop {
				self.iVec0[j0 as usize] = self.iVec0[(j0 - 1) as usize];
				j0 = (j0 - 1);
				if (j0 > 0) { continue; } else { break; }
			}
			self.fRec0[1] = self.fRec0[0];
			self.fRec2[1] = self.fRec2[0];
			self.fVec1[1] = self.fVec1[0];
			self.fRec1[1] = self.fRec1[0];
			self.fVec2[1] = self.fVec2[0];
			self.fVec3[1] = self.fVec3[0];
			self.fVec4[1] = self.fVec4[0];
			self.fVec5[1] = self.fVec5[0];
			self.fVec6[1] = self.fVec6[0];
			self.fVec7[1] = self.fVec7[0];
			self.fVec8[1] = self.fVec8[0];
			self.fRec3[1] = self.fRec3[0];
			self.fVec9[1] = self.fVec9[0];
			self.fVec10[1] = self.fVec10[0];
			self.fVec11[1] = self.fVec11[0];
			self.fVec12[1] = self.fVec12[0];
			self.fVec13[1] = self.fVec13[0];
			self.fVec14[1] = self.fVec14[0];
			self.fVec15[1] = self.fVec15[0];
			self.fRec4[1] = self.fRec4[0];
			self.fVec16[1] = self.fVec16[0];
			self.fVec17[1] = self.fVec17[0];
			self.fVec18[1] = self.fVec18[0];
			self.fVec19[1] = self.fVec19[0];
			self.fVec20[1] = self.fVec20[0];
			self.fVec21[1] = self.fVec21[0];
			self.fVec22[1] = self.fVec22[0];
			self.fRec5[1] = self.fRec5[0];
			self.fVec23[1] = self.fVec23[0];
			self.IOTA = (self.IOTA + 1);
			self.fVec25[1] = self.fVec25[0];
			self.fRec6[1] = self.fRec6[0];
			self.fVec26[1] = self.fVec26[0];
			self.fVec28[1] = self.fVec28[0];
			self.fRec7[1] = self.fRec7[0];
			self.fVec29[1] = self.fVec29[0];
			self.fRec8[1] = self.fRec8[0];
			self.fRec9[1] = self.fRec9[0];
			self.fRec10[1] = self.fRec10[0];
			self.fRec11[1] = self.fRec11[0];
			self.fVec31[1] = self.fVec31[0];
			self.fVec32[1] = self.fVec32[0];
			self.fVec34[1] = self.fVec34[0];
			self.fVec35[1] = self.fVec35[0];
			self.fVec37[1] = self.fVec37[0];
			self.fVec38[1] = self.fVec38[0];
			self.iRec13[1] = self.iRec13[0];
			let mut j1: i32 = 3;
			loop {
				self.fRec12[j1 as usize] = self.fRec12[(j1 - 1) as usize];
				j1 = (j1 - 1);
				if (j1 > 0) { continue; } else { break; }
			}
			i = (i + 1);
			if (i < count) { continue; } else { break; }
		}
		
	}

}

