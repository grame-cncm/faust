
pub fn mydsp_faustpower2_f(value: f32) -> f32 {
	(value * value)
}
pub fn mydsp_faustpower3_f(value: f32) -> f32 {
	((value * value) * value)
}


pub struct mydsp {
	
	fDummy: f32,
	fVslider0: f32,
	iVec0: [i32;4],
	fRec0: [f32;2],
	fCheckbox0: f32,
	fCheckbox1: f32,
	fEntry0: f32,
	fSamplingFreq: i32,
	fConst0: f32,
	fConst1: f32,
	fVslider1: f32,
	fVslider2: f32,
	fRec2: [f32;2],
	fVec1: [f32;2],
	fRec1: [f32;2],
	fConst2: f32,
	fVec2: [f32;2],
	fConst3: f32,
	fVec3: [f32;2],
	fVec4: [f32;2],
	fConst4: f32,
	fVec5: [f32;2],
	fVec6: [f32;2],
	fVec7: [f32;2],
	fVslider3: f32,
	fVec8: [f32;2],
	fRec3: [f32;2],
	fVec9: [f32;2],
	fVec10: [f32;2],
	fVec11: [f32;2],
	fVec12: [f32;2],
	fVec13: [f32;2],
	fVec14: [f32;2],
	fVslider4: f32,
	fVec15: [f32;2],
	fRec4: [f32;2],
	fVec16: [f32;2],
	fVec17: [f32;2],
	fVec18: [f32;2],
	fVec19: [f32;2],
	fVec20: [f32;2],
	fVec21: [f32;2],
	fCheckbox2: f32,
	iRec5: [i32;2],
	fRec6: [f32;4],
	
}

impl mydsp {
		
	pub fn new() -> mydsp { 
		mydsp {
			fDummy: 0 as f32,
			fVslider0: 0.0,
			iVec0: [0;4],
			fRec0: [0.0;2],
			fCheckbox0: 0.0,
			fCheckbox1: 0.0,
			fEntry0: 0.0,
			fSamplingFreq: 0,
			fConst0: 0.0,
			fConst1: 0.0,
			fVslider1: 0.0,
			fVslider2: 0.0,
			fRec2: [0.0;2],
			fVec1: [0.0;2],
			fRec1: [0.0;2],
			fConst2: 0.0,
			fVec2: [0.0;2],
			fConst3: 0.0,
			fVec3: [0.0;2],
			fVec4: [0.0;2],
			fConst4: 0.0,
			fVec5: [0.0;2],
			fVec6: [0.0;2],
			fVec7: [0.0;2],
			fVslider3: 0.0,
			fVec8: [0.0;2],
			fRec3: [0.0;2],
			fVec9: [0.0;2],
			fVec10: [0.0;2],
			fVec11: [0.0;2],
			fVec12: [0.0;2],
			fVec13: [0.0;2],
			fVec14: [0.0;2],
			fVslider4: 0.0,
			fVec15: [0.0;2],
			fRec4: [0.0;2],
			fVec16: [0.0;2],
			fVec17: [0.0;2],
			fVec18: [0.0;2],
			fVec19: [0.0;2],
			fVec20: [0.0;2],
			fVec21: [0.0;2],
			fCheckbox2: 0.0,
			iRec5: [0;2],
			fRec6: [0.0;4],
		}
	}
	
	pub fn metadata(&mut self, m: &mut Meta) { 
		m.declare("author", "JOS, revised by RM");
		m.declare("basics.lib/name", "Faust Basic Element Library");
		m.declare("basics.lib/version", "0.0");
		m.declare("description", "An application demonstrating the different sawtooth oscillators of Faust.");
		m.declare("filters.lib/name", "Faust Filters Library");
		m.declare("filters.lib/version", "0.0");
		m.declare("maths.lib/author", "GRAME");
		m.declare("maths.lib/copyright", "GRAME");
		m.declare("maths.lib/license", "LGPL with exception");
		m.declare("maths.lib/name", "Faust Math Library");
		m.declare("maths.lib/version", "2.1");
		m.declare("name", "sawtoothLab");
		m.declare("noises.lib/name", "Faust Noise Generator Library");
		m.declare("noises.lib/version", "0.0");
		m.declare("oscillators.lib/name", "Faust Oscillator Library");
		m.declare("oscillators.lib/version", "0.0");
		m.declare("signals.lib/name", "Faust Signal Routing Library");
		m.declare("signals.lib/version", "0.0");
		m.declare("version", "0.0");
	}

	pub fn getSampleRate(&mut self) -> i32 {
		self.fSamplingFreq
	}
	pub fn getNumInputs(&mut self) -> i32 {
		1
	}
	pub fn getNumOutputs(&mut self) -> i32 {
		1
	}
	pub fn getInputRate(&mut self, channel: i32) -> i32 {
		let mut rate: i32;
		match (channel) {
			0 => {
				rate = 1;
				
			},
			_ => {
				rate = -1;
				
			},
			
		} 
		rate
	}
	pub fn getOutputRate(&mut self, channel: i32) -> i32 {
		let mut rate: i32;
		match (channel) {
			0 => {
				rate = 1;
				
			},
			_ => {
				rate = -1;
				
			},
			
		} 
		rate
	}
	
	pub fn classInit(samplingFreq: i32) {
		
	}
	
	pub fn instanceResetUserInterface(&mut self) {
		self.fVslider0 = -20.0;
		self.fCheckbox0 = 0.0;
		self.fCheckbox1 = 0.0;
		self.fEntry0 = 2.0;
		self.fVslider1 = 49.0;
		self.fVslider2 = 0.100000001;
		self.fVslider3 = -0.100000001;
		self.fVslider4 = 0.100000001;
		self.fCheckbox2 = 0.0;
		
	}
	
	pub fn instanceClear(&mut self) {
		let mut l0: i32 = 0;
		loop {
			self.iVec0[l0 as usize] = 0;
			l0 = (l0 + 1);
			if (l0 < 4) { continue; } else { break; }
		}
		let mut l1: i32 = 0;
		loop {
			self.fRec0[l1 as usize] = 0.0;
			l1 = (l1 + 1);
			if (l1 < 2) { continue; } else { break; }
		}
		let mut l2: i32 = 0;
		loop {
			self.fRec2[l2 as usize] = 0.0;
			l2 = (l2 + 1);
			if (l2 < 2) { continue; } else { break; }
		}
		let mut l3: i32 = 0;
		loop {
			self.fVec1[l3 as usize] = 0.0;
			l3 = (l3 + 1);
			if (l3 < 2) { continue; } else { break; }
		}
		let mut l4: i32 = 0;
		loop {
			self.fRec1[l4 as usize] = 0.0;
			l4 = (l4 + 1);
			if (l4 < 2) { continue; } else { break; }
		}
		let mut l5: i32 = 0;
		loop {
			self.fVec2[l5 as usize] = 0.0;
			l5 = (l5 + 1);
			if (l5 < 2) { continue; } else { break; }
		}
		let mut l6: i32 = 0;
		loop {
			self.fVec3[l6 as usize] = 0.0;
			l6 = (l6 + 1);
			if (l6 < 2) { continue; } else { break; }
		}
		let mut l7: i32 = 0;
		loop {
			self.fVec4[l7 as usize] = 0.0;
			l7 = (l7 + 1);
			if (l7 < 2) { continue; } else { break; }
		}
		let mut l8: i32 = 0;
		loop {
			self.fVec5[l8 as usize] = 0.0;
			l8 = (l8 + 1);
			if (l8 < 2) { continue; } else { break; }
		}
		let mut l9: i32 = 0;
		loop {
			self.fVec6[l9 as usize] = 0.0;
			l9 = (l9 + 1);
			if (l9 < 2) { continue; } else { break; }
		}
		let mut l10: i32 = 0;
		loop {
			self.fVec7[l10 as usize] = 0.0;
			l10 = (l10 + 1);
			if (l10 < 2) { continue; } else { break; }
		}
		let mut l11: i32 = 0;
		loop {
			self.fVec8[l11 as usize] = 0.0;
			l11 = (l11 + 1);
			if (l11 < 2) { continue; } else { break; }
		}
		let mut l12: i32 = 0;
		loop {
			self.fRec3[l12 as usize] = 0.0;
			l12 = (l12 + 1);
			if (l12 < 2) { continue; } else { break; }
		}
		let mut l13: i32 = 0;
		loop {
			self.fVec9[l13 as usize] = 0.0;
			l13 = (l13 + 1);
			if (l13 < 2) { continue; } else { break; }
		}
		let mut l14: i32 = 0;
		loop {
			self.fVec10[l14 as usize] = 0.0;
			l14 = (l14 + 1);
			if (l14 < 2) { continue; } else { break; }
		}
		let mut l15: i32 = 0;
		loop {
			self.fVec11[l15 as usize] = 0.0;
			l15 = (l15 + 1);
			if (l15 < 2) { continue; } else { break; }
		}
		let mut l16: i32 = 0;
		loop {
			self.fVec12[l16 as usize] = 0.0;
			l16 = (l16 + 1);
			if (l16 < 2) { continue; } else { break; }
		}
		let mut l17: i32 = 0;
		loop {
			self.fVec13[l17 as usize] = 0.0;
			l17 = (l17 + 1);
			if (l17 < 2) { continue; } else { break; }
		}
		let mut l18: i32 = 0;
		loop {
			self.fVec14[l18 as usize] = 0.0;
			l18 = (l18 + 1);
			if (l18 < 2) { continue; } else { break; }
		}
		let mut l19: i32 = 0;
		loop {
			self.fVec15[l19 as usize] = 0.0;
			l19 = (l19 + 1);
			if (l19 < 2) { continue; } else { break; }
		}
		let mut l20: i32 = 0;
		loop {
			self.fRec4[l20 as usize] = 0.0;
			l20 = (l20 + 1);
			if (l20 < 2) { continue; } else { break; }
		}
		let mut l21: i32 = 0;
		loop {
			self.fVec16[l21 as usize] = 0.0;
			l21 = (l21 + 1);
			if (l21 < 2) { continue; } else { break; }
		}
		let mut l22: i32 = 0;
		loop {
			self.fVec17[l22 as usize] = 0.0;
			l22 = (l22 + 1);
			if (l22 < 2) { continue; } else { break; }
		}
		let mut l23: i32 = 0;
		loop {
			self.fVec18[l23 as usize] = 0.0;
			l23 = (l23 + 1);
			if (l23 < 2) { continue; } else { break; }
		}
		let mut l24: i32 = 0;
		loop {
			self.fVec19[l24 as usize] = 0.0;
			l24 = (l24 + 1);
			if (l24 < 2) { continue; } else { break; }
		}
		let mut l25: i32 = 0;
		loop {
			self.fVec20[l25 as usize] = 0.0;
			l25 = (l25 + 1);
			if (l25 < 2) { continue; } else { break; }
		}
		let mut l26: i32 = 0;
		loop {
			self.fVec21[l26 as usize] = 0.0;
			l26 = (l26 + 1);
			if (l26 < 2) { continue; } else { break; }
		}
		let mut l27: i32 = 0;
		loop {
			self.iRec5[l27 as usize] = 0;
			l27 = (l27 + 1);
			if (l27 < 2) { continue; } else { break; }
		}
		let mut l28: i32 = 0;
		loop {
			self.fRec6[l28 as usize] = 0.0;
			l28 = (l28 + 1);
			if (l28 < 4) { continue; } else { break; }
		}
		
	}
	
	pub fn instanceConstants(&mut self, samplingFreq: i32) {
		self.fSamplingFreq = samplingFreq;
		self.fConst0 = f32::min(192000.0, f32::max(1.0, (self.fSamplingFreq as f32)));
		self.fConst1 = (1.0 / self.fConst0);
		self.fConst2 = (0.25 * self.fConst0);
		self.fConst3 = (0.0416666679 * mydsp_faustpower2_f(self.fConst0));
		self.fConst4 = (0.00520833349 * mydsp_faustpower3_f(self.fConst0));
		
	}
	
	pub fn instanceInit(&mut self, samplingFreq: i32) {
		self.instanceConstants(samplingFreq);
		self.instanceResetUserInterface();
		self.instanceClear();
	}
	
	pub fn init(&mut self, samplingFreq: i32) {
		mydsp::classInit(samplingFreq);
		self.instanceInit(samplingFreq);
	}
	
	pub fn buildUserInterface(&mut self, ui_interface: &mut UI<f32>) {
		ui_interface.declare(&mut self.fDummy, "0", "");
		ui_interface.declare(&mut self.fDummy, "tooltip", "See Faust's oscillators.lib   for documentation and references");
		ui_interface.openVerticalBox("SAWTOOTH OSCILLATOR");
		ui_interface.declare(&mut self.fDummy, "1", "");
		ui_interface.openHorizontalBox("0x00");
		ui_interface.declare(&mut self.fVslider0, "1", "");
		ui_interface.declare(&mut self.fVslider0, "style", "knob");
		ui_interface.declare(&mut self.fVslider0, "tooltip", "Sawtooth   waveform amplitude");
		ui_interface.declare(&mut self.fVslider0, "unit", "dB");
		ui_interface.addVerticalSlider("Amplitude", &mut self.fVslider0, -20.0, -120.0, 10.0, 0.10000000000000001);
		ui_interface.declare(&mut self.fVslider1, "2", "");
		ui_interface.declare(&mut self.fVslider1, "style", "knob");
		ui_interface.declare(&mut self.fVslider1, "tooltip", "Sawtooth   frequency as a Piano Key (PK) number (A440 = key 49)");
		ui_interface.declare(&mut self.fVslider1, "unit", "PK");
		ui_interface.addVerticalSlider("Frequency", &mut self.fVslider1, 49.0, 1.0, 88.0, 0.01);
		ui_interface.declare(&mut self.fVslider3, "3", "");
		ui_interface.declare(&mut self.fVslider3, "style", "knob");
		ui_interface.declare(&mut self.fVslider3, "tooltip", "Percentange frequency-shift  up or down for second oscillator");
		ui_interface.declare(&mut self.fVslider3, "unit", "%%");
		ui_interface.addVerticalSlider("Detuning 1", &mut self.fVslider3, -0.10000000000000001, -10.0, 10.0, 0.01);
		ui_interface.declare(&mut self.fVslider4, "4", "");
		ui_interface.declare(&mut self.fVslider4, "style", "knob");
		ui_interface.declare(&mut self.fVslider4, "tooltip", "Percentange frequency-shift up or down for third detuned oscillator");
		ui_interface.declare(&mut self.fVslider4, "unit", "%%");
		ui_interface.addVerticalSlider("Detuning 2", &mut self.fVslider4, 0.10000000000000001, -10.0, 10.0, 0.01);
		ui_interface.declare(&mut self.fVslider2, "5", "");
		ui_interface.declare(&mut self.fVslider2, "scale", "log");
		ui_interface.declare(&mut self.fVslider2, "style", "knob");
		ui_interface.declare(&mut self.fVslider2, "tooltip", "Portamento (frequency-glide) time-constant in seconds");
		ui_interface.declare(&mut self.fVslider2, "unit", "sec");
		ui_interface.addVerticalSlider("Portamento", &mut self.fVslider2, 0.10000000000000001, 0.001, 10.0, 0.001);
		ui_interface.declare(&mut self.fEntry0, "6", "");
		ui_interface.declare(&mut self.fEntry0, "tooltip", "Order of sawtootn aliasing   suppression");
		ui_interface.addNumEntry("Saw Order", &mut self.fEntry0, 2.0, 1.0, 4.0, 1.0);
		ui_interface.declare(&mut self.fDummy, "7", "");
		ui_interface.openVerticalBox("Alternate Signals");
		ui_interface.declare(&mut self.fCheckbox1, "0", "");
		ui_interface.addCheckButton("Noise (White or Pink - uses only Amplitude control on   the left)", &mut self.fCheckbox1);
		ui_interface.declare(&mut self.fCheckbox2, "1", "");
		ui_interface.declare(&mut self.fCheckbox2, "tooltip", "Pink Noise (or 1/f noise) is Constant-Q Noise, meaning that it has the   same total power in every octave");
		ui_interface.addCheckButton("Pink instead of White Noise (also called 1/f Noise)", &mut self.fCheckbox2);
		ui_interface.declare(&mut self.fCheckbox0, "2", "");
		ui_interface.addCheckButton("External Signal Input (overrides Sawtooth/Noise   selection above)", &mut self.fCheckbox0);
		ui_interface.closeBox();
		ui_interface.closeBox();
		ui_interface.closeBox();
		
	}
	
	pub fn compute(&mut self, count: i32, inputs: &[&[f32]], outputs: &mut[&mut[f32]]) {
		let mut fSlow0: f32 = (0.00100000005 * f32::powf(10.0, (0.0500000007 * (self.fVslider0 as f32))));
		let mut iSlow1: i32 = ((self.fCheckbox0 as f32) as i32);
		let mut iSlow2: i32 = ((self.fCheckbox1 as f32) as i32);
		let mut iSlow3: i32 = (((self.fEntry0 as f32) + -1.0) as i32);
		let mut iSlow4: i32 = ((iSlow3 >= 2) as i32);
		let mut iSlow5: i32 = ((iSlow3 >= 1) as i32);
		let mut fSlow6: f32 = f32::exp((0.0 - (self.fConst1 / (self.fVslider2 as f32))));
		let mut fSlow7: f32 = (440.0 * (f32::powf(2.0, (0.0833333358 * ((self.fVslider1 as f32) + -49.0))) * (1.0 - fSlow6)));
		let mut iSlow8: i32 = ((iSlow3 >= 3) as i32);
		let mut fSlow9: f32 = ((0.00999999978 * (self.fVslider3 as f32)) + 1.0);
		let mut fSlow10: f32 = ((0.00999999978 * (self.fVslider4 as f32)) + 1.0);
		let mut iSlow11: i32 = ((self.fCheckbox2 as f32) as i32);
		let mut i: i32 = 0;
		loop {
			self.iVec0[0] = 1;
			self.fRec0[0] = (fSlow0 + (0.999000013 * self.fRec0[1]));
			self.fRec2[0] = (fSlow7 + (fSlow6 * self.fRec2[1]));
			let mut fTemp0: f32 = f32::max(20.0, f32::abs(self.fRec2[0]));
			self.fVec1[0] = fTemp0;
			let mut fTemp1: f32 = (self.fRec1[1] + (self.fConst1 * self.fVec1[1]));
			self.fRec1[0] = (fTemp1 - f32::floor(fTemp1));
			let mut fTemp2: f32 = (2.0 * self.fRec1[0]);
			let mut fTemp3: f32 = (fTemp2 + -1.0);
			let mut fTemp4: f32 = mydsp_faustpower2_f(fTemp3);
			self.fVec2[0] = fTemp4;
			let mut fTemp5: f32 = mydsp_faustpower3_f(fTemp3);
			self.fVec3[0] = (fTemp5 + (1.0 - fTemp2));
			let mut fTemp6: f32 = ((fTemp5 + (1.0 - (fTemp2 + self.fVec3[1]))) / fTemp0);
			self.fVec4[0] = fTemp6;
			let mut fTemp7: f32 = (fTemp4 * (fTemp4 + -2.0));
			self.fVec5[0] = fTemp7;
			let mut fTemp8: f32 = ((fTemp7 - self.fVec5[1]) / fTemp0);
			self.fVec6[0] = fTemp8;
			let mut fTemp9: f32 = ((fTemp8 - self.fVec6[1]) / fTemp0);
			self.fVec7[0] = fTemp9;
			let mut fTemp10: f32 = f32::max(20.0, f32::abs((fSlow9 * self.fRec2[0])));
			self.fVec8[0] = fTemp10;
			let mut fTemp11: f32 = (self.fRec3[1] + (self.fConst1 * self.fVec8[1]));
			self.fRec3[0] = (fTemp11 - f32::floor(fTemp11));
			let mut fTemp12: f32 = (2.0 * self.fRec3[0]);
			let mut fTemp13: f32 = (fTemp12 + -1.0);
			let mut fTemp14: f32 = mydsp_faustpower2_f(fTemp13);
			self.fVec9[0] = fTemp14;
			let mut fTemp15: f32 = mydsp_faustpower3_f(fTemp13);
			self.fVec10[0] = (fTemp15 + (1.0 - fTemp12));
			let mut fTemp16: f32 = ((fTemp15 + (1.0 - (fTemp12 + self.fVec10[1]))) / fTemp10);
			self.fVec11[0] = fTemp16;
			let mut fTemp17: f32 = (fTemp14 * (fTemp14 + -2.0));
			self.fVec12[0] = fTemp17;
			let mut fTemp18: f32 = ((fTemp17 - self.fVec12[1]) / fTemp10);
			self.fVec13[0] = fTemp18;
			let mut fTemp19: f32 = ((fTemp18 - self.fVec13[1]) / fTemp10);
			self.fVec14[0] = fTemp19;
			let mut fTemp20: f32 = f32::max(20.0, f32::abs((fSlow10 * self.fRec2[0])));
			self.fVec15[0] = fTemp20;
			let mut fTemp21: f32 = (self.fRec4[1] + (self.fConst1 * self.fVec15[1]));
			self.fRec4[0] = (fTemp21 - f32::floor(fTemp21));
			let mut fTemp22: f32 = (2.0 * self.fRec4[0]);
			let mut fTemp23: f32 = (fTemp22 + -1.0);
			let mut fTemp24: f32 = mydsp_faustpower2_f(fTemp23);
			self.fVec16[0] = fTemp24;
			let mut fTemp25: f32 = mydsp_faustpower3_f(fTemp23);
			self.fVec17[0] = (fTemp25 + (1.0 - fTemp22));
			let mut fTemp26: f32 = ((fTemp25 + (1.0 - (fTemp22 + self.fVec17[1]))) / fTemp20);
			self.fVec18[0] = fTemp26;
			let mut fTemp27: f32 = (fTemp24 * (fTemp24 + -2.0));
			self.fVec19[0] = fTemp27;
			let mut fTemp28: f32 = ((fTemp27 - self.fVec19[1]) / fTemp20);
			self.fVec20[0] = fTemp28;
			let mut fTemp29: f32 = ((fTemp28 - self.fVec20[1]) / fTemp20);
			self.fVec21[0] = fTemp29;
			self.iRec5[0] = ((1103515245 * self.iRec5[1]) + 12345);
			let mut fTemp30: f32 = (4.65661287e-10 * (self.iRec5[0] as f32));
			self.fRec6[0] = (((0.522189379 * self.fRec6[3]) + (fTemp30 + (2.49495602 * self.fRec6[1]))) - (2.0172658 * self.fRec6[2]));
			outputs[0][i as usize] = ((self.fRec0[0] * if (iSlow1 as i32 == 1) { (inputs[0][i as usize] as f32) } else { if (iSlow2 as i32 == 1) { if (iSlow11 as i32 == 1) { (((0.0499220341 * self.fRec6[0]) + (0.0506126992 * self.fRec6[2])) - ((0.0959935337 * self.fRec6[1]) + (0.00440878607 * self.fRec6[3]))) } else { fTemp30 } } else { (0.333333343 * (self.fRec0[0] * ((if (iSlow4 as i32 == 1) { if (iSlow8 as i32 == 1) { (self.fConst4 * (((self.iVec0[3] as f32) * (fTemp9 - self.fVec7[1])) / fTemp0)) } else { (self.fConst3 * (((self.iVec0[2] as f32) * (fTemp6 - self.fVec4[1])) / fTemp0)) } } else { if (iSlow5 as i32 == 1) { (self.fConst2 * (((self.iVec0[1] as f32) * (fTemp4 - self.fVec2[1])) / fTemp0)) } else { fTemp3 } } + if (iSlow4 as i32 == 1) { if (iSlow8 as i32 == 1) { (self.fConst4 * (((self.iVec0[3] as f32) * (fTemp19 - self.fVec14[1])) / fTemp10)) } else { (self.fConst3 * (((self.iVec0[2] as f32) * (fTemp16 - self.fVec11[1])) / fTemp10)) } } else { if (iSlow5 as i32 == 1) { (self.fConst2 * (((self.iVec0[1] as f32) * (fTemp14 - self.fVec9[1])) / fTemp10)) } else { fTemp13 } }) + if (iSlow4 as i32 == 1) { if (iSlow8 as i32 == 1) { (self.fConst4 * (((self.iVec0[3] as f32) * (fTemp29 - self.fVec21[1])) / fTemp20)) } else { (self.fConst3 * (((self.iVec0[2] as f32) * (fTemp26 - self.fVec18[1])) / fTemp20)) } } else { if (iSlow5 as i32 == 1) { (self.fConst2 * (((self.iVec0[1] as f32) * (fTemp24 - self.fVec16[1])) / fTemp20)) } else { fTemp23 } }))) } }) as f32);
			let mut j0: i32 = 3;
			loop {
				self.iVec0[j0 as usize] = self.iVec0[(j0 - 1) as usize];
				j0 = (j0 - 1);
				if (j0 > 0) { continue; } else { break; }
			}
			self.fRec0[1] = self.fRec0[0];
			self.fRec2[1] = self.fRec2[0];
			self.fVec1[1] = self.fVec1[0];
			self.fRec1[1] = self.fRec1[0];
			self.fVec2[1] = self.fVec2[0];
			self.fVec3[1] = self.fVec3[0];
			self.fVec4[1] = self.fVec4[0];
			self.fVec5[1] = self.fVec5[0];
			self.fVec6[1] = self.fVec6[0];
			self.fVec7[1] = self.fVec7[0];
			self.fVec8[1] = self.fVec8[0];
			self.fRec3[1] = self.fRec3[0];
			self.fVec9[1] = self.fVec9[0];
			self.fVec10[1] = self.fVec10[0];
			self.fVec11[1] = self.fVec11[0];
			self.fVec12[1] = self.fVec12[0];
			self.fVec13[1] = self.fVec13[0];
			self.fVec14[1] = self.fVec14[0];
			self.fVec15[1] = self.fVec15[0];
			self.fRec4[1] = self.fRec4[0];
			self.fVec16[1] = self.fVec16[0];
			self.fVec17[1] = self.fVec17[0];
			self.fVec18[1] = self.fVec18[0];
			self.fVec19[1] = self.fVec19[0];
			self.fVec20[1] = self.fVec20[0];
			self.fVec21[1] = self.fVec21[0];
			self.iRec5[1] = self.iRec5[0];
			let mut j1: i32 = 3;
			loop {
				self.fRec6[j1 as usize] = self.fRec6[(j1 - 1) as usize];
				j1 = (j1 - 1);
				if (j1 > 0) { continue; } else { break; }
			}
			i = (i + 1);
			if (i < count) { continue; } else { break; }
		}
		
	}

}

