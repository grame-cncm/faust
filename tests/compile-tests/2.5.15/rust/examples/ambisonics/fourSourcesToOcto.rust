
pub fn mydsp_faustpower2_f(value: f32) -> f32 {
	(value * value)
}


pub struct mydsp {
	
	fDummy: f32,
	fSamplingFreq: i32,
	fConst0: f32,
	fConst1: f32,
	fHslider0: f32,
	fRec0: [f32;2],
	fHslider1: f32,
	fRec1: [f32;2],
	fHslider2: f32,
	fRec2: [f32;2],
	fHslider3: f32,
	fRec3: [f32;2],
	fHslider4: f32,
	fRec4: [f32;2],
	fHslider5: f32,
	fRec5: [f32;2],
	fHslider6: f32,
	fRec6: [f32;2],
	fHslider7: f32,
	fRec7: [f32;2],
	
}

impl mydsp {
		
	pub fn new() -> mydsp { 
		mydsp {
			fDummy: 0 as f32,
			fSamplingFreq: 0,
			fConst0: 0.0,
			fConst1: 0.0,
			fHslider0: 0.0,
			fRec0: [0.0;2],
			fHslider1: 0.0,
			fRec1: [0.0;2],
			fHslider2: 0.0,
			fRec2: [0.0;2],
			fHslider3: 0.0,
			fRec3: [0.0;2],
			fHslider4: 0.0,
			fRec4: [0.0;2],
			fHslider5: 0.0,
			fRec5: [0.0;2],
			fHslider6: 0.0,
			fRec6: [0.0;2],
			fHslider7: 0.0,
			fRec7: [0.0;2],
		}
	}
	
	pub fn metadata(&mut self, m: &mut Meta) { 
		m.declare("author", "CICM");
		m.declare("basics.lib/name", "Faust Basic Element Library");
		m.declare("basics.lib/version", "0.0");
		m.declare("copyright", "(c)CICM 2013");
		m.declare("hoa.lib/author", "Pierre Guillot");
		m.declare("hoa.lib/copyright", "2012-2013 Guillot, Paris, Colafrancesco, CICM labex art H2H, U. Paris 8");
		m.declare("hoa.lib/name", "High Order Ambisonics library");
		m.declare("license", "BSD");
		m.declare("maths.lib/author", "GRAME");
		m.declare("maths.lib/copyright", "GRAME");
		m.declare("maths.lib/license", "LGPL with exception");
		m.declare("maths.lib/name", "Faust Math Library");
		m.declare("maths.lib/version", "2.1");
		m.declare("name", "fourSourcesToOcto");
		m.declare("routes.lib/name", "Faust Signal Routing Library");
		m.declare("routes.lib/version", "0.0");
		m.declare("signals.lib/name", "Faust Signal Routing Library");
		m.declare("signals.lib/version", "0.0");
		m.declare("version", "1.0");
	}

	pub fn getSampleRate(&mut self) -> i32 {
		self.fSamplingFreq
	}
	pub fn getNumInputs(&mut self) -> i32 {
		4
	}
	pub fn getNumOutputs(&mut self) -> i32 {
		8
	}
	pub fn getInputRate(&mut self, channel: i32) -> i32 {
		let mut rate: i32;
		match (channel) {
			0 => {
				rate = 1;
				
			},
			1 => {
				rate = 1;
				
			},
			2 => {
				rate = 1;
				
			},
			3 => {
				rate = 1;
				
			},
			_ => {
				rate = -1;
				
			},
			
		} 
		rate
	}
	pub fn getOutputRate(&mut self, channel: i32) -> i32 {
		let mut rate: i32;
		match (channel) {
			0 => {
				rate = 1;
				
			},
			1 => {
				rate = 1;
				
			},
			2 => {
				rate = 1;
				
			},
			3 => {
				rate = 1;
				
			},
			4 => {
				rate = 1;
				
			},
			5 => {
				rate = 1;
				
			},
			6 => {
				rate = 1;
				
			},
			7 => {
				rate = 1;
				
			},
			_ => {
				rate = -1;
				
			},
			
		} 
		rate
	}
	
	pub fn classInit(samplingFreq: i32) {
		
	}
	
	pub fn instanceResetUserInterface(&mut self) {
		self.fHslider0 = 1.0;
		self.fHslider1 = 1.0;
		self.fHslider2 = 1.0;
		self.fHslider3 = 1.0;
		self.fHslider4 = 0.0;
		self.fHslider5 = 0.0;
		self.fHslider6 = 0.0;
		self.fHslider7 = 0.0;
		
	}
	
	pub fn instanceClear(&mut self) {
		let mut l0: i32 = 0;
		loop {
			self.fRec0[l0 as usize] = 0.0;
			l0 = (l0 + 1);
			if (l0 < 2) { continue; } else { break; }
		}
		let mut l1: i32 = 0;
		loop {
			self.fRec1[l1 as usize] = 0.0;
			l1 = (l1 + 1);
			if (l1 < 2) { continue; } else { break; }
		}
		let mut l2: i32 = 0;
		loop {
			self.fRec2[l2 as usize] = 0.0;
			l2 = (l2 + 1);
			if (l2 < 2) { continue; } else { break; }
		}
		let mut l3: i32 = 0;
		loop {
			self.fRec3[l3 as usize] = 0.0;
			l3 = (l3 + 1);
			if (l3 < 2) { continue; } else { break; }
		}
		let mut l4: i32 = 0;
		loop {
			self.fRec4[l4 as usize] = 0.0;
			l4 = (l4 + 1);
			if (l4 < 2) { continue; } else { break; }
		}
		let mut l5: i32 = 0;
		loop {
			self.fRec5[l5 as usize] = 0.0;
			l5 = (l5 + 1);
			if (l5 < 2) { continue; } else { break; }
		}
		let mut l6: i32 = 0;
		loop {
			self.fRec6[l6 as usize] = 0.0;
			l6 = (l6 + 1);
			if (l6 < 2) { continue; } else { break; }
		}
		let mut l7: i32 = 0;
		loop {
			self.fRec7[l7 as usize] = 0.0;
			l7 = (l7 + 1);
			if (l7 < 2) { continue; } else { break; }
		}
		
	}
	
	pub fn instanceConstants(&mut self, samplingFreq: i32) {
		self.fSamplingFreq = samplingFreq;
		self.fConst0 = f32::exp((0.0 - (50.0 / f32::min(192000.0, f32::max(1.0, (self.fSamplingFreq as f32))))));
		self.fConst1 = (1.0 - self.fConst0);
		
	}
	
	pub fn instanceInit(&mut self, samplingFreq: i32) {
		self.instanceConstants(samplingFreq);
		self.instanceResetUserInterface();
		self.instanceClear();
	}
	
	pub fn init(&mut self, samplingFreq: i32) {
		mydsp::classInit(samplingFreq);
		self.instanceInit(samplingFreq);
	}
	
	pub fn buildUserInterface(&mut self, ui_interface: &mut UI<f32>) {
		ui_interface.openVerticalBox("fourSourcesToOcto");
		ui_interface.addHorizontalSlider("Angle1", &mut self.fHslider4, 0.0, -6.2831853071795862, 6.2831853071795862, 0.001);
		ui_interface.addHorizontalSlider("Angle2", &mut self.fHslider5, 0.0, -6.2831853071795862, 6.2831853071795862, 0.001);
		ui_interface.addHorizontalSlider("Angle3", &mut self.fHslider6, 0.0, -6.2831853071795862, 6.2831853071795862, 0.001);
		ui_interface.addHorizontalSlider("Angle4", &mut self.fHslider7, 0.0, -6.2831853071795862, 6.2831853071795862, 0.001);
		ui_interface.addHorizontalSlider("Radius1", &mut self.fHslider0, 1.0, 0.0, 5.0, 0.001);
		ui_interface.addHorizontalSlider("Radius2", &mut self.fHslider1, 1.0, 0.0, 5.0, 0.001);
		ui_interface.addHorizontalSlider("Radius3", &mut self.fHslider2, 1.0, 0.0, 5.0, 0.001);
		ui_interface.addHorizontalSlider("Radius4", &mut self.fHslider3, 1.0, 0.0, 5.0, 0.001);
		ui_interface.closeBox();
		
	}
	
	pub fn compute(&mut self, count: i32, inputs: &[&[f32]], outputs: &mut[&mut[f32]]) {
		let mut fSlow0: f32 = (self.fConst1 * (self.fHslider0 as f32));
		let mut fSlow1: f32 = (self.fConst1 * (self.fHslider1 as f32));
		let mut fSlow2: f32 = (self.fConst1 * (self.fHslider2 as f32));
		let mut fSlow3: f32 = (self.fConst1 * (self.fHslider3 as f32));
		let mut fSlow4: f32 = (self.fConst1 * (self.fHslider4 as f32));
		let mut fSlow5: f32 = (self.fConst1 * (self.fHslider5 as f32));
		let mut fSlow6: f32 = (self.fConst1 * (self.fHslider6 as f32));
		let mut fSlow7: f32 = (self.fConst1 * (self.fHslider7 as f32));
		let mut i: i32 = 0;
		loop {
			let mut fTemp0: f32 = (inputs[0][i as usize] as f32);
			self.fRec0[0] = (fSlow0 + (self.fConst0 * self.fRec0[1]));
			let mut iTemp1: i32 = ((self.fRec0[0] > 1.0) as i32);
			let mut iTemp2: i32 = ((self.fRec0[0] < 1.0) as i32);
			let mut fTemp3: f32 = ((iTemp1 as f32) + (self.fRec0[0] * (iTemp2 as f32)));
			let mut fTemp4: f32 = ((1.38629436 * (1.0 - fTemp3)) + 1.0);
			let mut fTemp5: f32 = (fTemp0 * fTemp4);
			let mut fTemp6: f32 = ((iTemp2 as f32) + (mydsp_faustpower2_f(self.fRec0[0]) * (iTemp1 as f32)));
			let mut fTemp7: f32 = (inputs[1][i as usize] as f32);
			self.fRec1[0] = (fSlow1 + (self.fConst0 * self.fRec1[1]));
			let mut iTemp8: i32 = ((self.fRec1[0] > 1.0) as i32);
			let mut iTemp9: i32 = ((self.fRec1[0] < 1.0) as i32);
			let mut fTemp10: f32 = ((iTemp8 as f32) + (self.fRec1[0] * (iTemp9 as f32)));
			let mut fTemp11: f32 = ((1.38629436 * (1.0 - fTemp10)) + 1.0);
			let mut fTemp12: f32 = (fTemp7 * fTemp11);
			let mut fTemp13: f32 = ((iTemp9 as f32) + (mydsp_faustpower2_f(self.fRec1[0]) * (iTemp8 as f32)));
			let mut fTemp14: f32 = (inputs[2][i as usize] as f32);
			self.fRec2[0] = (fSlow2 + (self.fConst0 * self.fRec2[1]));
			let mut iTemp15: i32 = ((self.fRec2[0] > 1.0) as i32);
			let mut iTemp16: i32 = ((self.fRec2[0] < 1.0) as i32);
			let mut fTemp17: f32 = ((iTemp15 as f32) + (self.fRec2[0] * (iTemp16 as f32)));
			let mut fTemp18: f32 = ((1.38629436 * (1.0 - fTemp17)) + 1.0);
			let mut fTemp19: f32 = (fTemp14 * fTemp18);
			let mut fTemp20: f32 = ((iTemp16 as f32) + (mydsp_faustpower2_f(self.fRec2[0]) * (iTemp15 as f32)));
			let mut fTemp21: f32 = (inputs[3][i as usize] as f32);
			self.fRec3[0] = (fSlow3 + (self.fConst0 * self.fRec3[1]));
			let mut iTemp22: i32 = ((self.fRec3[0] > 1.0) as i32);
			let mut iTemp23: i32 = ((self.fRec3[0] < 1.0) as i32);
			let mut fTemp24: f32 = ((iTemp22 as f32) + (self.fRec3[0] * (iTemp23 as f32)));
			let mut fTemp25: f32 = ((1.38629436 * (1.0 - fTemp24)) + 1.0);
			let mut fTemp26: f32 = (fTemp21 * fTemp25);
			let mut fTemp27: f32 = ((iTemp23 as f32) + (mydsp_faustpower2_f(self.fRec3[0]) * (iTemp22 as f32)));
			let mut fTemp28: f32 = (0.142857149 * ((((fTemp5 / fTemp6) + (fTemp12 / fTemp13)) + (fTemp19 / fTemp20)) + (fTemp26 / fTemp27)));
			let mut fTemp29: f32 = (2.0 * fTemp3);
			let mut fTemp30: f32 = ((2.0 * ((fTemp3 * (((fTemp29 > 0.0) as i32) as f32)) * (((fTemp29 <= 1.0) as i32) as f32))) + (((fTemp29 > 1.0) as i32) as f32));
			self.fRec4[0] = (fSlow4 + (self.fConst0 * self.fRec4[1]));
			let mut fTemp31: f32 = (2.0 * fTemp10);
			let mut fTemp32: f32 = ((2.0 * ((fTemp10 * (((fTemp31 > 0.0) as i32) as f32)) * (((fTemp31 <= 1.0) as i32) as f32))) + (((fTemp31 > 1.0) as i32) as f32));
			self.fRec5[0] = (fSlow5 + (self.fConst0 * self.fRec5[1]));
			let mut fTemp33: f32 = (2.0 * fTemp17);
			let mut fTemp34: f32 = ((2.0 * ((fTemp17 * (((fTemp33 > 0.0) as i32) as f32)) * (((fTemp33 <= 1.0) as i32) as f32))) + (((fTemp33 > 1.0) as i32) as f32));
			self.fRec6[0] = (fSlow6 + (self.fConst0 * self.fRec6[1]));
			let mut fTemp35: f32 = (2.0 * fTemp24);
			let mut fTemp36: f32 = ((2.0 * ((fTemp24 * (((fTemp35 > 0.0) as i32) as f32)) * (((fTemp35 <= 1.0) as i32) as f32))) + (((fTemp35 > 1.0) as i32) as f32));
			self.fRec7[0] = (fSlow7 + (self.fConst0 * self.fRec7[1]));
			let mut fTemp37: f32 = ((((((fTemp5 * fTemp30) * f32::cos(self.fRec4[0])) / fTemp6) + (((fTemp12 * fTemp32) * f32::cos(self.fRec5[0])) / fTemp13)) + (((fTemp19 * fTemp34) * f32::cos(self.fRec6[0])) / fTemp20)) + (((fTemp26 * fTemp36) * f32::cos(self.fRec7[0])) / fTemp27));
			let mut fTemp38: f32 = (0.214285716 * fTemp37);
			let mut fTemp39: f32 = (2.0 * self.fRec4[0]);
			let mut fTemp40: f32 = (1.38629436 * fTemp3);
			let mut fTemp41: f32 = (fTemp40 + -0.693147182);
			let mut fTemp42: f32 = (2.46630335 * fTemp41);
			let mut fTemp43: f32 = ((2.46630335 * ((fTemp41 * (((fTemp42 > 0.0) as i32) as f32)) * (((fTemp42 <= 1.0) as i32) as f32))) + (((fTemp42 > 1.0) as i32) as f32));
			let mut fTemp44: f32 = (2.0 * self.fRec5[0]);
			let mut fTemp45: f32 = (1.38629436 * fTemp10);
			let mut fTemp46: f32 = (fTemp45 + -0.693147182);
			let mut fTemp47: f32 = (2.46630335 * fTemp46);
			let mut fTemp48: f32 = ((2.46630335 * ((fTemp46 * (((fTemp47 > 0.0) as i32) as f32)) * (((fTemp47 <= 1.0) as i32) as f32))) + (((fTemp47 > 1.0) as i32) as f32));
			let mut fTemp49: f32 = (2.0 * self.fRec6[0]);
			let mut fTemp50: f32 = (1.38629436 * fTemp17);
			let mut fTemp51: f32 = (fTemp50 + -0.693147182);
			let mut fTemp52: f32 = (2.46630335 * fTemp51);
			let mut fTemp53: f32 = ((2.46630335 * ((fTemp51 * (((fTemp52 > 0.0) as i32) as f32)) * (((fTemp52 <= 1.0) as i32) as f32))) + (((fTemp52 > 1.0) as i32) as f32));
			let mut fTemp54: f32 = (2.0 * self.fRec7[0]);
			let mut fTemp55: f32 = (1.38629436 * fTemp24);
			let mut fTemp56: f32 = (fTemp55 + -0.693147182);
			let mut fTemp57: f32 = (2.46630335 * fTemp56);
			let mut fTemp58: f32 = ((2.46630335 * ((fTemp56 * (((fTemp57 > 0.0) as i32) as f32)) * (((fTemp57 <= 1.0) as i32) as f32))) + (((fTemp57 > 1.0) as i32) as f32));
			let mut fTemp59: f32 = (0.0857142881 * (((((((fTemp0 * f32::cos(fTemp39)) * fTemp4) * fTemp43) / fTemp6) + ((((fTemp7 * f32::cos(fTemp44)) * fTemp11) * fTemp48) / fTemp13)) + ((((fTemp14 * f32::cos(fTemp49)) * fTemp18) * fTemp53) / fTemp20)) + ((((fTemp21 * f32::cos(fTemp54)) * fTemp25) * fTemp58) / fTemp27)));
			let mut fTemp60: f32 = (3.0 * self.fRec4[0]);
			let mut fTemp61: f32 = (fTemp40 + -1.09861231);
			let mut fTemp62: f32 = (3.47605944 * fTemp61);
			let mut fTemp63: f32 = ((3.47605944 * ((fTemp61 * (((fTemp62 > 0.0) as i32) as f32)) * (((fTemp62 <= 1.0) as i32) as f32))) + (((fTemp62 > 1.0) as i32) as f32));
			let mut fTemp64: f32 = (3.0 * self.fRec5[0]);
			let mut fTemp65: f32 = (fTemp45 + -1.09861231);
			let mut fTemp66: f32 = (3.47605944 * fTemp65);
			let mut fTemp67: f32 = ((3.47605944 * ((fTemp65 * (((fTemp66 > 0.0) as i32) as f32)) * (((fTemp66 <= 1.0) as i32) as f32))) + (((fTemp66 > 1.0) as i32) as f32));
			let mut fTemp68: f32 = (3.0 * self.fRec6[0]);
			let mut fTemp69: f32 = (fTemp50 + -1.09861231);
			let mut fTemp70: f32 = (3.47605944 * fTemp69);
			let mut fTemp71: f32 = ((3.47605944 * ((fTemp69 * (((fTemp70 > 0.0) as i32) as f32)) * (((fTemp70 <= 1.0) as i32) as f32))) + (((fTemp70 > 1.0) as i32) as f32));
			let mut fTemp72: f32 = (3.0 * self.fRec7[0]);
			let mut fTemp73: f32 = (fTemp55 + -1.09861231);
			let mut fTemp74: f32 = (3.47605944 * fTemp73);
			let mut fTemp75: f32 = ((3.47605944 * ((fTemp73 * (((fTemp74 > 0.0) as i32) as f32)) * (((fTemp74 <= 1.0) as i32) as f32))) + (((fTemp74 > 1.0) as i32) as f32));
			let mut fTemp76: f32 = (((((((fTemp0 * f32::cos(fTemp60)) * fTemp4) * fTemp63) / fTemp6) + ((((fTemp7 * f32::cos(fTemp64)) * fTemp11) * fTemp67) / fTemp13)) + ((((fTemp14 * f32::cos(fTemp68)) * fTemp18) * fTemp71) / fTemp20)) + ((((fTemp21 * f32::cos(fTemp72)) * fTemp25) * fTemp75) / fTemp27));
			let mut fTemp77: f32 = (0.0142857144 * fTemp76);
			outputs[0][i as usize] = ((((fTemp28 + fTemp38) + fTemp59) + fTemp77) as f32);
			let mut fTemp78: f32 = ((((((fTemp5 * f32::sin(self.fRec4[0])) * fTemp30) / fTemp6) + (((fTemp12 * f32::sin(self.fRec5[0])) * fTemp32) / fTemp13)) + (((fTemp19 * f32::sin(self.fRec6[0])) * fTemp34) / fTemp20)) + (((fTemp26 * f32::sin(self.fRec7[0])) * fTemp36) / fTemp27));
			let mut fTemp79: f32 = (0.151522875 * fTemp78);
			let mut fTemp80: f32 = (0.0857142881 * (((((((fTemp0 * f32::sin(fTemp39)) * fTemp4) * fTemp43) / fTemp6) + ((((fTemp7 * f32::sin(fTemp44)) * fTemp11) * fTemp48) / fTemp13)) + ((((fTemp14 * f32::sin(fTemp49)) * fTemp18) * fTemp53) / fTemp20)) + ((((fTemp21 * f32::sin(fTemp54)) * fTemp25) * fTemp58) / fTemp27)));
			let mut fTemp81: f32 = (((((((fTemp0 * f32::sin(fTemp60)) * fTemp4) * fTemp63) / fTemp6) + ((((fTemp7 * f32::sin(fTemp64)) * fTemp11) * fTemp67) / fTemp13)) + ((((fTemp14 * f32::sin(fTemp68)) * fTemp18) * fTemp71) / fTemp20)) + ((((fTemp21 * f32::sin(fTemp72)) * fTemp25) * fTemp75) / fTemp27));
			outputs[1][i as usize] = ((((((fTemp28 + fTemp79) + (0.151522875 * fTemp37)) + fTemp80) + (0.0101015251 * fTemp81)) - (0.0101015251 * fTemp76)) as f32);
			let mut fTemp82: f32 = (0.214285716 * fTemp78);
			let mut fTemp83: f32 = (0.0142857144 * fTemp81);
			outputs[2][i as usize] = (((fTemp28 + fTemp82) - (fTemp59 + fTemp83)) as f32);
			let mut fTemp84: f32 = (0.151522875 * fTemp37);
			outputs[3][i as usize] = (((((fTemp28 + (0.151522875 * fTemp78)) + (0.0101015251 * fTemp81)) + (0.0101015251 * fTemp76)) - (fTemp80 + fTemp84)) as f32);
			outputs[4][i as usize] = (((fTemp28 + fTemp59) - (fTemp38 + fTemp77)) as f32);
			outputs[5][i as usize] = ((((fTemp28 + fTemp80) + (0.0101015251 * fTemp76)) - ((fTemp79 + (0.151522875 * fTemp37)) + (0.0101015251 * fTemp81))) as f32);
			outputs[6][i as usize] = (((fTemp28 + fTemp83) - (fTemp59 + fTemp82)) as f32);
			outputs[7][i as usize] = (((fTemp28 + fTemp84) - (((fTemp80 + (0.151522875 * fTemp78)) + (0.0101015251 * fTemp81)) + (0.0101015251 * fTemp76))) as f32);
			self.fRec0[1] = self.fRec0[0];
			self.fRec1[1] = self.fRec1[0];
			self.fRec2[1] = self.fRec2[0];
			self.fRec3[1] = self.fRec3[0];
			self.fRec4[1] = self.fRec4[0];
			self.fRec5[1] = self.fRec5[0];
			self.fRec6[1] = self.fRec6[0];
			self.fRec7[1] = self.fRec7[0];
			i = (i + 1);
			if (i < count) { continue; } else { break; }
		}
		
	}

}

