.TH "man" "1" "" "Version 1.01 (20 February 2018)" "Faust man page"
.SH NAME
.PP
Faust \- DSP to C/C++, Rust, LLVM IR, JAVA, JavaScript, asm.js,
WebAssembly (wast/wasm), Interpreter compiler
.SH SYNOPSIS
.PP
\f[B]faust\f[] [options] file1 [file2 ...]
.SH DESCRIPTION
.PP
Faust (Functional Audio Stream) is a functional programming language
specifically designed for real\-time signal processing and synthesis.
Faust targets high\-performance signal processing applications and audio
plug\-ins for a variety of platforms and standards.
.SH OPTIONS
.PP
\f[B]\-h\f[], \f[B]\-\-help\f[] print help message
.PP
\f[B]\-v\f[], \f[B]\-\-version\f[] print the compiler version
.PP
\f[B]\-d\f[], \f[B]\-\-details\f[] print compilation details
.PP
\f[B]\-tg\f[], \f[B]\-\-task\-graph\f[] generate the internal task graph
in dot format file
.PP
\f[B]\-sg\f[], \f[B]\-\-signal\-graph\f[] generate the internal signal
graph in dot format file
.PP
\f[B]\-ps\f[], \f[B]\-\-postscript\f[] generate a block\-diagram
representation of the program as a postscript file
.PP
\f[B]\-svg\f[], \f[B]\-\-svg\f[] generate a block\-diagram
representation of the program as an SVG file
.PP
\f[B]\-mdoc\f[], \f[B]\-\-mathdoc\f[] generate the mathematical
documentation of a program in LaTeX format
.PP
\f[B]\-mdlang <l>\f[], \f[B]\-\-mathdoc\-lang <l>\f[] load mathdoc
language <l> if translation file exists (<l> = en, fr, ...)
.PP
\f[B]\-stripmdoc\f[], \f[B]\-\-strip\-mdoc\-tags\f[] strip mdoc tags
when printing Faust \-mdoc listings
.PP
\f[B]\-sd\f[], \f[B]\-\-simplify\-diagrams\f[] try to further simplify
block\-diagrams before drawing them
.PP
\f[B]\-f <n>\f[], \f[B]\-\-fold <n>\f[] set fold threshold used during
block\-diagram generation (default 25 elements)
.PP
\f[B]\-mns <n>\f[], \f[B]\-\-max\-name\-size <n>\f[] set max name size
threshold during block\-diagram generation (default 40 char)
.PP
\f[B]\-sn\f[], \f[B]\-\-simple\-names\f[] use simpler names (without
arguments) during block\-diagram generation
.PP
\f[B]\-xml\f[] generate an XML description file of the user interface
.PP
\f[B]\-exp10\f[], \f[B]\-\-generate\-exp10\f[] function call instead of
pow(10) function
.PP
\f[B]\-json\f[] generate a JSON description file of the user interface
.PP
\f[B]\-blur\f[], \f[B]\-\-shadow\-blur\f[] add a shadow blur to SVG
boxes
.PP
\f[B]\-lb\f[], \f[B]\-\-left\-balanced\f[] generate left\-balanced
expressions
.PP
\f[B]\-mb\f[], \f[B]\-\-mid\-balanced\f[] generate mid\-balanced
expressions (default)
.PP
\f[B]\-rb\f[], \f[B]\-\-right\-balanced\f[] generate right\-balanced
expressions
.PP
\f[B]\-lt\f[], \f[B]\-\-less\-temporaries\f[] generate less\-temporaries
when compiling delay lines
.PP
\f[B]\-mcd <n>\f[], \f[B]\-\-max\-copy\-delay <n>\f[] threshold used to
switch from copy based to ring buffer based delay lines (default 16
samples)
.PP
\f[B]\-mem\f[], \f[B]\-\-memory\f[] allocate static memory in global
state using a custom memory manager
.PP
\f[B]\-a <file>\f[] indicate the architecture file to use
.PP
\f[B]\-i\f[], \f[B]\-\-inline\-architecture\-files\f[] inline all
architecture files in the generated code
.PP
\f[B]\-cn <name>\f[], \f[B]\-\-class\-name <name>\f[] specify the name
of the dsp class to be used instead of mydsp
.PP
\f[B]\-pn <name>\f[], \f[B]\-\-process\-name <name>\f[] specify the name
of the dsp entry\-point instead of process
.PP
\f[B]\-t <sec>\f[], \f[B]\-\-timeout <sec>\f[] abort compilation after
seconds (default 120)
.PP
\f[B]\-time\f[], \f[B]\-\-compilation\-time\f[] display timing
information of the various compilation phases
.PP
\f[B]\-o <file>\f[] output file to use for the generated code
.PP
\f[B]\-scal\f[], \f[B]\-\-scalar\f[] generate code as a single loop
.PP
\f[B]\-vec\f[], \f[B]\-\-vectorize\f[] generate code as a DAG of
multiple loops easier to auto vectorize
.PP
\f[B]\-vls <n>\f[], \f[B]\-\-vec\-loop\-size <n>\f[] size of the vector
DSP loop for auto\-vectorization (experimental)
.PP
\f[B]\-vs <n>\f[], \f[B]\-\-vec\-size <n>\f[] size of the vector
(default 32 samples)
.PP
\f[B]\-lv <n>\f[], \f[B]\-\-loop\-variant <n>\f[] Control how loops are
generated [ = 0:fastest (default), 1:simple]
.PP
\f[B]\-omp\f[], \f[B]\-\-openMP\f[] generate OpenMP pragmas, activates
\-\-vectorize option
.PP
\f[B]\-pl\f[], \f[B]\-\-par\-loop\f[] generate parallel loops in
\-\-openMP mode
.PP
\f[B]\-sch\f[], \f[B]\-\-scheduler\f[] generate tasks and use a Work
Stealing scheduler, activates \-\-vectorize option
.PP
\f[B]\-ocl\f[], \f[B]\-\-openCL\f[] generate tasks with OpenCL
(experimental)
.PP
\f[B]\-cuda\f[], \f[B]\-\-cuda\f[] generate tasks with CUDA
(experimental)
.PP
\f[B]\-dfs\f[], \f[B]\-\-deepFirstScheduling\f[] schedule vector loops
in deep first order
.PP
\f[B]\-g\f[], \f[B]\-\-groupTasks\f[] group single\-threaded sequential
tasks together when \-omp or \-sch is used
.PP
\f[B]\-fun\f[], \f[B]\-\-funTasks\f[] separate tasks code as separated
functions (in \-vec, \-sch, or \-omp mode)
.PP
\f[B]\-lang <lang>\f[], \f[B]\-\-language <lang>\f[] generate various
output formats : c, ocpp, cpp, rust, java, js, ajs, llvm, cllvm, fir,
wast/wasm, interp (default cpp)
.PP
\f[B]\-uim\f[], \f[B]\-\-user\-interface\-macros\f[] add user interface
macro definitions in the output code
.PP
\f[B]\-single\f[], \f[B]\-\-single\-precision\-floats\f[] uses
single\-precisions floats for audio computations (default)
.PP
\f[B]\-double\f[], \f[B]\-\-double\-precision\-floats\f[] uses
double\-precision floats for audio computations
.PP
\f[B]\-quad\f[], \f[B]\-\-quad\-precision\-floats\f[] uses
quad\-precision floats for audio computations
.PP
\f[B]\-es 1|0\f[], \f[B]\-\-enable\-semantics 1|0\f[] use enable
semantics when 1, and simple multiplication otherwise
.PP
\f[B]\-flist\f[], \f[B]\-\-file\-list\f[] list all the files used to
eval process
.PP
\f[B]\-norm\f[], \f[B]\-\-normalized\-form\f[] prints signals in
normalized form and exits
.PP
\f[B]\-A <dir>\f[], \f[B]\-\-architecture\-dir <dir>\f[] add the
directory <dir> to the architecture search path
.PP
\f[B]\-I <dir>\f[], \f[B]\-\-import\-dir <dir>\f[] add the directory
<dir> to the import search path
.PP
\f[B]\-L <file>\f[], \f[B]\-\-library <file>\f[] link with the LLVM
module <file>
.PP
\f[B]\-O <dir>\f[], \f[B]\-\-output\-dir <dir>\f[] specify the relative
directory of the generated output code, and the output directory of
additional generated files (SVG, XML...)
.PP
\f[B]\-e\f[], \f[B]\-\-export\-dsp\f[] export expanded DSP code (all
included libraries)
.PP
\f[B]\-inpl\f[], \f[B]\-\-in\-place\f[] generate inplace code when input
and output buffers are the same (in scalar mode only)
.PP
\f[B]\-inj <f>\f[], \f[B]\-\-inject <f>\f[] inject source file <f> into
architecture file instead of compiling a dsp file
.PP
\f[B]\-ftz\f[], \f[B]\-\-flush\-to\-zero\f[] Adds flush\-to\-zero code
to recursive signals [0:no (default), 1:fabs based, 2:mask based
(fastest)]
.PP
\f[B]\-fm <file>\f[], \f[B]\-\-fast\-math <file>\f[] uses optimized
versions of mathematical functions implemented in <file>, takes the
\[aq]/faust/dsp/fastmath.cpp\[aq] file if \[aq]def\[aq] is used
.SH SEE ALSO
.PP
Grame Faust site at: \f[B]<http://faust.grame.fr>\f[]
.SH BUGS
.PP
Please report bugs to:
\f[B]<https://github.com/grame-cncm/faust/issues>\f[]
.SH AUTHOR
.PP
Copyright (C) 2002\-2018, GRAME \- Centre National de Creation Musicale.
All rights reserved.
