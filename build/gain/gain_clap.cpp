/* ------------------------------------------------------------
name: "gain"
Code generated with Faust 2.81.0 (https://faust.grame.fr)
Compilation options: -a /Users/cucu/Documents/GitHub/faust/architecture/clap/clap-arch.cpp -lang cpp -ct 1 -es 1 -mcd 16 -mdd 1024 -mdy 33 -single -ftz 0
------------------------------------------------------------ */

#ifndef  __mydsp_H__
#define  __mydsp_H__

//dummy clap architecture file
//this file will translate faust's mydsp c++ class into the clap plugin interface
//it should include plugin lifecycle, audio block processing calls, parameter registration and ui integration using buildUserInterface () and CLAP API
//core of the plugin backend
<<includeclass>> //this will be replaced by the code generated by the FAUST compiler
#include <clap/all.h> //core c header for clap
#include <clap/helpers/plugin.hh> //c++ wrapper around the core c interface
#include <clap/helpers/host-proxy.hh> //c++ wrapper for the host
#include <clap/helpers/param.hh> //not needed now tbh but eventually for parameter mgmt and whatnot

struct FaustCLAPPlugin : public clap::helpers::Plugin<clap::helpers::MisbehaviourHandler::Terminate, clap::helpers::CheckingLevel::Minimal> {
    mydsp fDSP; //instance of the faust generated dsp class

    clap::helpers::Param<float> fGainParam {
        0, CLAP_PARAM_IS_AUTOMATABLE, "gain", "", 0.0f, 10.0f, 0.1f, 1.0f

    };

    FaustCLAPPlugin(const clap_plugin_descriptor* desc, const clap_host* host)
        : Plugin(desc, host) {}

    bool init() noexcept override {
        fDSP.init(48000); //hardcoding thr SR for now...
        if(!add_param(&fGainParam)){
            log(CLAP_LOG_ERROR,"failed to register gain param");
            return false;
        }
        log(CLAP_LOG_DEBUG, "FaustCLAPPlugin initialised and gain param registered!");
        return true;
    }

    void buildUserInterface(UI* ui_interface){
    fDSP.buildUserInterface(ui_interface);
    }

    clap_process_status process(const clap_process* process) noexcept override {
    //if process or the audio in/outs are missing, bail out with an error
    if (!process || !process->audio_inputs || !process->audio_outputs) return CLAP_PROCESS_ERROR;

    //for the sake of simplicity i will assume mono in/out and faust using fVslider0
    //get pointers to the actual audio in and out buffers
    FAUSTFLOAT* input=reinterpret_cast<FAUSTFLOAT*>(process->audio_inputs[0].data32);
    FAUSTFLOAT* output=reinterpret_cast<FAUSTFLOAT*>(process->audio_outputs[0].data32);
    int frameCount=process->frames_count;

    //update the dsp gain value from the plugin parameter
    fDSP.fVslider0=fGainParam.value(); //host controlled gain
    //run the faust dsp on the input and produce output
    fDSP.compute(frameCount,&input,&output); //process audio?
    return CLAP_PROCESS_CONTINUE; //tell host to keep running the plugin

    }

};
#ifndef FAUSTFLOAT
#define FAUSTFLOAT float
#endif 

#include <algorithm>
#include <cmath>
#include <cstdint>

#ifndef FAUSTCLASS 
#define FAUSTCLASS mydsp
#endif

#ifdef __APPLE__ 
#define exp10f __exp10f
#define exp10 __exp10
#endif

#if defined(_WIN32)
#define RESTRICT __restrict
#else
#define RESTRICT __restrict__
#endif


class mydsp : public dsp {
	
 private:
	
	FAUSTFLOAT fVslider0;
	int fSampleRate;
	
 public:
	mydsp() {
	}
	
	void metadata(Meta* m) { 
		m->declare("compile_options", "-a /Users/cucu/Documents/GitHub/faust/architecture/clap/clap-arch.cpp -lang cpp -ct 1 -es 1 -mcd 16 -mdd 1024 -mdy 33 -single -ftz 0");
		m->declare("filename", "gain.dsp");
		m->declare("name", "gain");
	}

	virtual int getNumInputs() {
		return 1;
	}
	virtual int getNumOutputs() {
		return 1;
	}
	
	static void classInit(int sample_rate) {
	}
	
	virtual void instanceConstants(int sample_rate) {
		fSampleRate = sample_rate;
	}
	
	virtual void instanceResetUserInterface() {
		fVslider0 = FAUSTFLOAT(1.0f);
	}
	
	virtual void instanceClear() {
	}
	
	virtual void init(int sample_rate) {
		classInit(sample_rate);
		instanceInit(sample_rate);
	}
	
	virtual void instanceInit(int sample_rate) {
		instanceConstants(sample_rate);
		instanceResetUserInterface();
		instanceClear();
	}
	
	virtual mydsp* clone() {
		return new mydsp();
	}
	
	virtual int getSampleRate() {
		return fSampleRate;
	}
	
	virtual void buildUserInterface(UI* ui_interface) {
		ui_interface->openVerticalBox("gain");
		ui_interface->addVerticalSlider("gain", &fVslider0, FAUSTFLOAT(1.0f), FAUSTFLOAT(0.0f), FAUSTFLOAT(1e+01f), FAUSTFLOAT(0.1f));
		ui_interface->closeBox();
	}
	
	virtual void compute(int count, FAUSTFLOAT** RESTRICT inputs, FAUSTFLOAT** RESTRICT outputs) {
		FAUSTFLOAT* input0 = inputs[0];
		FAUSTFLOAT* output0 = outputs[0];
		float fSlow0 = float(fVslider0);
		for (int i0 = 0; i0 < count; i0 = i0 + 1) {
			output0[i0] = FAUSTFLOAT(fSlow0 * float(input0[i0]));
		}
	}

};

#endif
