/************************************************************************
 ************************************************************************
    FAUST compiler
    Copyright (C) 2022 GRAME, Centre National de Creation Musicale
    ---------------------------------------------------------------------
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2.1 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 ************************************************************************
 ************************************************************************/

#include <regex>
#include <string>

#include "Text.hh"
#include "exception.hh"
#include "fir_function_builder.hh"
#include "floats.hh"
#include "global.hh"
#include "glsl_code_container.hh"

using namespace std;

map<string, bool> GLSLInstVisitor::gFunctionSymbolTable;

dsp_factory_base* GLSLCodeContainer::produceFactory()
{
    return new text_dsp_factory_aux(
        fKlassName, "", "",
        ((dynamic_cast<ostringstream*>(fOut)) ? dynamic_cast<ostringstream*>(fOut)->str() : ""),
        "");
}

GLSLCodeContainer::GLSLCodeContainer(const string& name, int numInputs, int numOutputs,
                                     ostream* out)
{
    // Mandatory
    initialize(numInputs, numOutputs);
    fKlassName = name;
    fOut       = out;
    sOut = std::stringstream(std::ios::out);

    // Allocate one static visitor to be shared by main module and sub containers
    if (!gGlobal->gGLSLVisitor) {
        gGlobal->gGLSLVisitor = new GLSLInstVisitor(out, name);
    }
}

CodeContainer* GLSLCodeContainer::createScalarContainer(const string& name, int sub_container_type)
{
    return new GLSLScalarCodeContainer(name, 0, 1, fOut, sub_container_type);
}

CodeContainer* GLSLCodeContainer::createContainer(const string& name, int numInputs, int numOutputs,
                                                  ostream* dst)
{
    CodeContainer* container;

    if (gGlobal->gOpenCLSwitch) {
        throw faustexception("ERROR : OpenCL not supported for GLSL\n");
    }
    if (gGlobal->gCUDASwitch) {
        throw faustexception("ERROR : CUDA not supported for GLSL\n");
    }

    if (gGlobal->gOpenMPSwitch) {
        throw faustexception("ERROR : OpenMP not supported for GLSL\n");
    } else if (gGlobal->gSchedulerSwitch) {
        throw faustexception("ERROR : Scheduler not supported for GLSL\n");
    } else if (gGlobal->gVectorSwitch) {
        throw faustexception("ERROR : Vector not supported for GLSL\n");
    } else {
        container = new GLSLScalarCodeContainer(name, numInputs, numOutputs, dst, kInt);
    }

    return container;
}

// Used for subcontainers if 'inlining sub containers' model is not used
void GLSLCodeContainer::produceInternal()
{
}

/*
 Given as an example of what a real backend would have to do: add or remove FIR visiting code etc.
*/
void GLSLCodeContainer::produceClass()
{
    // Necessary to set precision and use << fixed << num to write literal float numbers since GLSL
    // doesn't allow 0.5f or exponent 9.58738e-05
    fOut->precision(numeric_limits<double>::digits10 + 1);
    int n = 0;

    *fOut << "#version " << glsl_version << endl; 

    //*fOut << "/*\n"
    //      << " * Generated by 'faust " << gGlobal->printCompilationOptions1() << "'\n" << endl;

    //*fOut << "desc: Effect " << fKlassName << "\n";

    //produceMetadata(n);
    //*fOut << "*/\n";

    // buildUserInterface > Sliders buttons and checkboxes only are available on GLSL

    *fOut << "uniform float width;" << endl;
    *fOut << "uniform float height;" << endl;
    *fOut << "uniform sampler2DRect current;" << endl;

    // inputs/outputs
    tab(n, *fOut);

    if( (fNumInputs != 3 && fNumInputs != 4 ) && (gGlobal->gOutputLang != "glsl-test")) {
        throw(faustexception("ERROR : GLSL format does not support different number of inputs than 3 (RGB) or 4 (RGBA)\n"));
    }
    if (fNumOutputs != fNumInputs && (gGlobal->gOutputLang != "glsl-test")) {
        throw(faustexception("ERROR : GLSL number of outputs must match the number of inputs\n"));
    }

    *fOut << "out vec" << fNumInputs << " fragColor;" << endl;
    *fOut << "in vec" << fNumInputs << " vertexColor;" << endl;

    generateUserInterface(gGlobal->gGLSLVisitor);

    mergeSubContainers();

    gGlobal->gGLSLVisitor->Tab(n);
    GLSLInitFieldsVisitor initializer(fOut, n);
    for (const auto& it : fGlobalDeclarationInstructions->fCode) {
        if (dynamic_cast<DeclareVarInst*>(it)) {
            it->accept(&initializer);
        }
    }
    tab(n, *fOut);

    StructInstVisitor struct_visitor;
    fDeclarationInstructions->accept(&struct_visitor);
    /*
    for (const auto& it : fDeclarationInstructions->fCode) {
        auto desc = struct_visitor.getMemoryDesc(it->getName());
        *fOut << gGlobal->gGLSLVisitor->get_type(desc.fType) << " " <<  it->getName() << ";\n";
    }
    */
    for (const auto& it : fComputeBlockInstructions->fCode) {
        auto desc = struct_visitor.getMemoryDesc(it->getName());
        string name = it->getName();
        if (glsl_strfind(name, "output") || glsl_strfind(name, "input")) {
            continue;
        }
        *fOut << gGlobal->gGLSLVisitor->get_type(desc.fType) << " " << it->getName() << ";\n";
    }


    *fOut << endl << "// Declarations " << endl;
    generateDeclarations(&initializer);
    *fOut << endl;
    *fOut << endl  <<"// Clear " << endl;
    generateClear(gGlobal->gGLSLVisitor);
    *fOut << endl;
    *fOut << endl << "// Inline subcontainers 1 " << endl;
    inlineSubcontainersFunCalls(fStaticInitInstructions)->accept(gGlobal->gGLSLVisitor);
    tab(n + 2, *fOut);
    *fOut << endl << "// Inline subcontainers 2 " << endl;
    inlineSubcontainersFunCalls(fInitInstructions)->accept(gGlobal->gGLSLVisitor);
    tab(n, *fOut);

    *fOut << "void main()" << endl;
    *fOut << "{" << endl;
    tab(n, *fOut);
    *fOut << "vec2 coords = vec2(gl_FragCoord.x, gl_FragCoord.y);" << endl;
    *fOut << "vec" << fNumOutputs << " src = texture(current, coords)." << ((fNumOutputs == 3) ? "rgb" : "rgba") << ";" << endl;  


    generateCompute(n);

    *fOut << "}" << endl;
    tab(n, *fOut);
}

void GLSLCodeContainer::produceMetadata(int tabs)
{
    // Here, we retrieve two kind of metadata :
    //  * Description fields are parsed to be translated in GLSL description fields
    //  * MIDI metadata like ["midi:on"] is used to activate MIDI, while ["nvoices:N"] indicates the
    //  polyphonic number of voices
    // Note that ["nvoices:1"] is useful to create a monophonic instrument that can respond to midi
    // key numbers
    for (const auto& i : gGlobal->gMetaDataSet) {
        if (i.first == tree("options")) {
            for (set<Tree>::iterator j = i.second.begin(); j != i.second.end(); j++) {
                stringstream ss;
                ss << **j;
                string s;
                ss >> s;
                if (glsl_strfind(s, "[midi:on]")) {
                    midi = true;
                }
                if (s.find("[nvoices:")) {
                    regex r("\\[nvoices:([0-9]+)\\]");
                    for (sregex_iterator i = sregex_iterator(s.begin(), s.end(), r);
                         i != sregex_iterator(); ++i) {
                        poly          = true;
                        midi          = true;
                        std::smatch m = *i;
                        nvoices       = std::stoi(m[1].str());
                        if (nvoices < 1) {
                            throw(faustexception("ERROR : nvoices must be >= to 1"));
                        }
                    }
                    gGlobal->gGLSLVisitor->poly    = poly;
                    gGlobal->gGLSLVisitor->nvoices = nvoices;
                }
                *fOut << "description : " << *(i.first) << " " << **j << "\n";
            }
        } else {
            // But the "author" meta data is accumulated, the upper level becomes the main author
            // and sub-levels become "contributor"
            for (set<Tree>::iterator j = i.second.begin(); j != i.second.end(); j++) {
                if (j == i.second.begin()) {
                    *fOut << "desc: " << *(i.first) << " " << **j << "\n";
                } else {
                    *fOut << "desc: "
                          << "contributor"
                          << " " << **j << "\n";
                }
            }
        }
    }
    tab(tabs, *fOut);
    *fOut << endl;
}

// Scalar
GLSLScalarCodeContainer::GLSLScalarCodeContainer(const string& name, int numInputs, int numOutputs,
                                                 ostream* out, int sub_container_type)
    : GLSLCodeContainer(name, numInputs, numOutputs, out)
{
    fSubContainerType = sub_container_type;
}

// Given as an example of what a real backend would have to implement.
void GLSLScalarCodeContainer::generateCompute(int n)
{
    SimpleForLoopInst* loop = fCurLoop->generateSimpleScalarLoop(fFullCount);
    loop->accept(gGlobal->gGLSLVisitor);
    tab(n, *fOut);
}
