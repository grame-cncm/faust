//################################### hoa.lib ############################################
// Faust library for high order ambisonic. Its official prefix is `ho`.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/hoa.lib>
//########################################################################################

/************************************************************************
 ************************************************************************
FAUST library file
Copyright (C) 2003-2012 GRAME, Centre National de Creation Musicale
----------------------------------------------------------------------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.

 ************************************************************************
 ************************************************************************/

ma = library("maths.lib");
si = library("signals.lib");

declare name "High Order Ambisonics library";
declare author "Pierre Guillot";
declare author "Eliott Paris";
declare author "Julien Colafrancesco";
declare author "Wargreen";
declare copyright "2012-2013 Guillot, Paris, Colafrancesco, CICM labex art H2H, U. Paris 8, 2019 Wargreen";

//============================Encoding/decoding Functions=================================
//========================================================================================

//----------------------`(ho.)encoder`---------------------------------
// Ambisonic encoder. Encodes a signal in the circular harmonics domain
// depending on an order of decomposition and an angle.
//
// #### Usage
//
// ```
// encoder(n, x, a) : _
// ```
//
// Where:
//
// * `n`: the order
// * `x`: the signal
// * `a`: the angle
//----------------------------------------------------------------
encoder(0, x, a) = x;
encoder(n, x, a) = encoder(n-1, x, a), x*sin(n*a), x*cos(n*a);


//--------------------------`(ho.)decoder`--------------------------------
// Decodes an ambisonics sound field for a circular array of loudspeakers.
//
// #### Usage
//
// ```
// _ : decoder(n, p) : _
// ```
//
// Where:
//
// * `n`: the order
// * `p`: the number of speakers
//
// #### Note
//
// Number of loudspeakers must be greater or equal to 2n+1. It's preferable
// to use 2n+2 loudspeakers.
//-------------------------------------------------------------------
decoder(n, p) = par(i, 2*n+1, _) <: par(i, p, speaker(n, 2*ma.PI*i/p))
with {
   speaker(n,a)	= /(2), par(i, 2*n, _), encoder(n,2/(2*n+1),a) : si.dot(2*n+1);
};


//-----------------------`(ho.)decoderStereo`------------------------
// Decodes an ambisonic sound field for stereophonic configuration.
// An "home made" ambisonic decoder for stereophonic restitution
// (30° - 330°) : Sound field lose energy around 180°. You should
// use `inPhase` optimization with ponctual sources.
// #### Usage
//
// ```
// _ : decoderStereo(n) : _
// ```
//
// Where:
//
// * `n`: the order
//--------------------------------------------------------------
decoderStereo(n) = decoder(n, p) <: (par(i, 2*n+2, gainLeft(360 * i / p)) :> _),
	(par(i, 2*n+2, gainRight(360 * i / p)) :> _)
with {
	p = 2*n+2;

   	gainLeft(a) = _ * sin(ratio_minus + ratio_cortex)
	with {
		ratio_minus = ma.PI*.5 * abs((30 + a) / 60 * ((a <= 30)) + (a - 330) / 60 * (a >= 330));
		ratio_cortex= ma.PI*.5 * abs((120 + a) / 150 * (a > 30) * (a <= 180));
	};

	gainRight(a) = _ * sin(ratio_minus + ratio_cortex)
	with {
		ratio_minus = ma.PI*.5 * abs((390 - a) / 60 * (a >= 330) + (30 - a) / 60 * (a <= 30));
		ratio_cortex= ma.PI*.5 * abs((180 - a) / 150 * (a < 330) * (a >= 180));
	};
};


//============================Optimization Functions======================================
// Functions to weight the circular harmonics signals depending to the
// ambisonics optimization.
// It can be `basic` for no optimization, `maxRe` or `inPhase`.
//========================================================================================


//----------------`(ho.)optimBasic`-------------------------
// The basic optimization has no effect and should be used for a perfect
// circle of loudspeakers with one listener at the perfect center loudspeakers
// array.
//
// #### Usage
//
// ```
// _ : optimBasic(n) : _
// ```
//
// Where:
//
// * `n`: the order
//-----------------------------------------------------
optimBasic(n) = par(i, 2*n+1, _);


//----------------`(ho.)optimMaxRe`-------------------------
// The maxRe optimization optimizes energy vector. It should be used for an
// auditory confined in the center of the loudspeakers array.
//
// #### Usage
//
// ```
// _ : optimMaxRe(n) : _
// ```
//
// Where:
//
// * `n`: the order
//-----------------------------------------------------
optimMaxRe(n) = par(i, 2*n+1, optim(i, n, _))
 with {
   	optim(i, n, _)= _ * cos(indexabs / (2*n+1) * ma.PI)
	with {
		numberOfharmonics = 2 *n + 1;
		indexabs = (int)((i - 1) / 2 + 1);
	};
};


//----------------`(ho.)optimInPhase`-------------------------
//  The inPhase Optimization optimizes energy vector and put all loudspeakers signals
// in phase. It should be used for an auditory.
//
// #### Usage
//
// ```
// _ : optimInPhase(n) : _
// ```
//
// Where:
//
// * `n`: the order
//-----------------------------------------------------
optimInPhase(n)	= par(i, 2*n+1, optim(i, n, _))
with {
   	optim(i, n, _)= _ * (fact(n)^2.) / (fact(n+indexabs) * fact(n-indexabs))
	with {
		indexabs = (int)((i - 1) / 2 + 1);
		fact(0) = 1;
		fact(n) = n * fact(n-1);
	};
};


//----------------`(ho.)wider`-------------------------
// Can be used to wide the diffusion of a localized sound. The order
// depending signals are weighted and appear in a logarithmic way to
// have linear changes.
//
// #### Usage
//
// ```
// _ : wider(n,w) : _
// ```
//
// Where:
//
// * `n`: the order
// * `w`: the width value between 0 - 1
//-----------------------------------------------------
wider(n, w)	= par(i, 2*n+1, perform(n, w, i, _))
with {
	perform(n, w, i, _) = _ * (log(n+1) * (1 - w) + 1) * clipweight
	with {
		clipweight = weighter(n, w, i) * (weighter(n, w, i) > 0) * (weighter(n, w, i) <= 1) + (weighter(n, w, i) > 1)
		with {
			weighter(n, w, 0) = 1.;
			weighter(n, w, i) = (((w * log(n+1)) - log(indexabs)) / (log(indexabs+1) - log(indexabs)))
			with {
				indexabs = (int)((i - 1) / 2 + 1);
			};
		};
	};
};


//----------------`(ho.)map`-------------------------
// It simulates the distance of the source by applying a gain
// on the signal and a wider processing on the soundfield.
//
// #### Usage
//
// ```
// map(n, x, r, a)
// ```
//
// Where:
//
// * `n`: the order
// * `x`: the signal
// * `r`: the radius
// * `a`: the angle in radian
//-----------------------------------------------------
map(n, x, r, a)	= encoder(n, x * volume(r), a) : wider(n, ouverture(r))
with {
	volume(r) = 1. / (r * r * (r > 1) + (r <= 1));
	ouverture(r) = r * (r < 1) + (r >= 1);
};


//----------------`(ho.)rotate`-------------------------
// Rotates the sound field.
//
// #### Usage
//
// ```
// _ : rotate(n, a) : _
// ```
//
// Where:
//
// * `n`: the order
// * `a`: the angle in radian
//-----------------------------------------------------
rotate(n, a) = par(i, 2*n+1, _) <: par(i, 2*n+1, rotation(i, a))
with {
	rotation(i, a) = (par(j, 2*n+1, gain1(i, j, a)), par(j, 2*n+1, gain2(i, j, a)), par(j, 2*n+1, gain3(i, j, a)) :> _)
	with {
		indexabs = (int)((i - 1) / 2 + 1);
		gain1(i, j, a) = _ * cos(a * indexabs) * (j == i);
		gain2(i, j, a) = _ * sin(a * indexabs) * (j-1 == i) * (j != 0) * (i%2 == 1);
		gain3(i, j, a) = (_ * sin(a * indexabs)) * (j+1 == i) * (j != 0) * (i%2 == 0) * (-1);
	};
};


//============================3D Functions================================================
//========================================================================================

//----------------------`(ho.)encoder3D`---------------------------------
// Ambisonic encoder. Encodes a signal in the circular harmonics domain
// depending on an order of decomposition, an angle and an elevation.
//
// #### Usage
//
// ```
// encoder3D(n, x, a, e) : _
// ```
//
// Where:
//
// * `n`: the order
// * `x`: the signal
// * `a`: the angle
// * `e`: the elevation
//----------------------------------------------------------------

encoder3D(N, x, theta, phi) = par(i, (N+1) * (N+1), x * y(degree(i), order(i), theta, phi))
with {
	// The degree l of the harmonic[l, m]	
	degree(index) = int(sqrt(index));
	// The order m of the harmonic[l, m]	
	order(index) = int(index - int(degree(index) * int(degree(index) + 1)));

	// The spherical harmonics
	y(l, m, theta, phi) =  e(m, theta) * k(l, m) * p(l, m, cos(phi + ma.PI * 0.5))
	with {	
		// The associated Legendre polynomial
		// If l = 0   => p = 1
		// If l = m   => p = -1 * (2 * (l-1) + 1) * sqrt(1 - cphi*cphi) * p(l-1, l-1, cphi)
		// If l = m+1 => p = phi * (2 * (l-1) + 1) * p(l-1, l-1, cphi)
		// Else => p = (cphi * (2 * (l-1) + 1) * p(l-1, abs(m), cphi) - ((l-1) + abs(m)) * p(l-2, abs(m), cphi)) / ((l-1) - abs(m) + 1)
		p(l, m, cphi) = pcalcul(((l != 0) & (l == abs(m))) + ((l != 0) & (l == abs(m)+1)) * 2 + ((l != 0) & (l != abs(m)) & (l != abs(m)+1)) * 3, l, m, cphi)
		with {
			pcalcul(0, l, m, cphi) = 1;
			pcalcul(1, l, m, cphi) = -1 * (2 * (l-1) + 1) * sqrt(1 - cphi*cphi) * p(l-1, l-1, cphi);
			pcalcul(2, l, m, cphi) = cphi * (2 * (l-1) + 1) * p(l-1, l-1, cphi);
			pcalcul(s, l, m, cphi) = (cphi * (2 * (l-1) + 1) * p(l-1, abs(m), cphi) - ((l-1) + abs(m)) * p(l-2, abs(m), cphi)) / ((l-1) - abs(m) + 1);
		};	

		// The exponential imaginary
		// If m > 0 => e^i*m*theta = cos(m * theta)
		// If m < 0 => e^i*m*theta = sin(-m * theta)
		// If m = 0 => e^i*m*theta = 1
		e(m, theta) = ecalcul((m > 0) * 2 + (m < 0), m, theta)
		with {
			ecalcul(2, m, theta) = cos(m * theta);
			ecalcul(1, m, theta) = sin(abs(m) * theta);
			ecalcul(s, m, theta) = 1;
		}; 
		
		// The normalization
		// If m  = 0 => k(l, m) = 1
		// If m != 0 => k(l, m) = sqrt((l - abs(m))! / l + abs(m))!) * sqrt(2)
		k(l, m) = kcalcul((m != 0), l, m)
		with {	
			kcalcul(0, l, m) = 1;
			kcalcul(1, l, m) = sqrt(fact(l - abs(m)) / fact(l + abs(m))) * sqrt(2)
			with {
				fact(0) = 1;
				fact(n) = n * fact(n-1);
			};
		};		
	};
};


//----------------`(ho.)optimBasic3D`-------------------------
// The basic optimization has no effect and should be used for a perfect
// sphere of loudspeakers with one listener at the perfect center loudspeakers
// array.
//
// #### Usage
//
// ```
// _ : optimBasic3D(n) : _
// ```
//
// Where:
//
// * `n`: the order
//-----------------------------------------------------

optimBasic3D(N) = par(i, (N+1) * (N+1), _);


//----------------`(ho.)optimMaxRe3D`-------------------------
// The maxRe optimization optimize energy vector. It should be used for an
// auditory confined in the center of the loudspeakers array.
//
// #### Usage
//
// ```
// _ : optimMaxRe3D(n) : _
// ```
//
// Where:
//
// * `n`: the order
//-----------------------------------------------------

optimMaxRe3D(N) = par(i, (N+1) * (N+1), MaxRe(N, degree(i), _))
with {
	// The degree l of the harmonic[l, m]	
	degree(index)  = int(sqrt(index));
   	MaxRe(N, l, _)= _ * cos(l  / (2*N+2) * ma.PI);
};


//----------------`(ho.)optimInPhase3D`-------------------------
// The inPhase Optimization optimizes energy vector and put all loudspeakers signals
// in phase. It should be used for an auditory.
//
// #### Usage
//
// ```
// _ : optimInPhase3D(n) : _
// ```
//
// Where:
//
// * `n`: the order
//-----------------------------------------------------

optimInPhase3D(N) = par(i, (N+1) * (N+1), InPhase(N, degree(i), _))
with {
	// The degree l of the harmonic[l, m]	
	degree(index)  = int(sqrt(index));
   	InPhase(N, l, _)= _ * (fact(N) * fact(N)) / (fact(N - l) * fact(N + l))
	with {
		fact(0) = 1;
		fact(n) = n * fact(n-1);
	};
};


//#################################### compressors.lib ###################################
// A library of compressor effects. Its official prefix is `co`.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/compressors.lib>
//########################################################################################

/************************************************************************
************************************************************************
FAUST library file
Copyright (C) 2003-2016 GRAME, Centre National de Creation Musicale
----------------------------------------------------------------------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

ba = library("basics.lib");
si = library("signals.lib");
an = library("analyzers.lib");
ro = library("routes.lib");
ma = library("maths.lib");
it = library("interpolators.lib");

declare name "Faust Compressor Effect Library";
declare version "0.1";

//=============================Functions Reference========================================
//========================================================================================

//--------------------`(co.)peak_compression_gain_mono`-------------------
// Mono dynamic range compressor gain computer.
// `peak_compression_gain_mono` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : peak_compression_gain_mono(strength,thresh,att,rel,knee,prePost) : _
// ```
//
// Where:
//
// * `strength`: strength of the compression (0 = no compression, 1 means hard limiting, >1 means over-compression)
// * `thresh`: dB level threshold above which compression kicks in
// * `att`: attack time = time constant (sec) when level & compression going up
// * `rel`: release time = time constant (sec) coming out of compression
// * `knee`: a gradual increase in gain reduction around the threshold:
// Below thresh-(knee/2) there is no gain reduction,
// above thresh+(knee/2) there is the same gain reduction as without a knee,
// and in between there is a gradual increase in gain reduction.
// * `prePost`: places the level detector either at the input or after the gain computer;
// this turns it from a linear return-to-zero detector into a log  domain return-to-threshold detector
//
// It uses a strength parameter instead of the traditional ratio, in order to be able to
// function as a hard limiter.
// For that you'd need a ratio of infinity:1, and you cannot express that in Faust
//
// Sometimes even bigger ratios are useful:
// For example a group recording where one instrument is recorded with both a close microphone and a room microphone,
// and the instrument is loud enough in the room mic when playing loud, but you want to boost it when it is playing soft.
//
// #### References
//
// * <http://en.wikipedia.org/wiki/Dynamic_range_compression>
// * Digital Dynamic Range Compressor Design
// A Tutorial and Analysis
// DIMITRIOS GIANNOULIS (Dimitrios.Giannoulis@eecs.qmul.ac.uk)
// MICHAEL MASSBERG (michael@massberg.org)
// AND JOSHUA D. REISS (josh.reiss@eecs.qmul.ac.uk)
//------------------------------------------------------------

// Author: Bart Brouns
// License: GPLv3

// note: si.lag_ud has a bug where if you compile with standard precision,
// down is 0 and prePost is 1, you go into infinite GR and stay there
peak_compression_gain_mono(strength,thresh,att,rel,knee,prePost) =
  abs:ba.bypass1(prePost,si.lag_ud(att,rel)) : ba.linear2db : gain_computer(strength,thresh,knee):ba.bypass1((prePost*-1)+1,si.lag_ud(rel,att)) : ba.db2linear
with {
  gain_computer(strength,thresh,knee,level) =
    select3((level>(thresh-(knee/2)))+(level>(thresh+(knee/2))),
            0,
            ((level-thresh+(knee/2)):pow(2)/(2*knee)),
            (level-thresh)) : max(0)*-strength;
};


//--------------------`(co.)peak_compression_gain_N_chan`-------------------
// N channel dynamic range compressor gain computer.
// `peak_compression_gain_N_chan` is a standard Faust function.
//
// #### Usage
//
// ```
// si.bus(N) : peak_compression_gain_N_chan(strength,thresh,att,rel,knee,prePost,link,N) : si.bus(N)
// ```
//
// Where:
//
// * `strength`: strength of the compression (0 = no compression, 1 means hard limiting, >1 means over-compression)
// * `thresh`: dB level threshold above which compression kicks in
// * `att`: attack time = time constant (sec) when level & compression going up
// * `rel`: release time = time constant (sec) coming out of compression
// * `knee`: a gradual increase in gain reduction around the threshold:
// Below thresh-(knee/2) there is no gain reduction,
// above thresh+(knee/2) there is the same gain reduction as without a knee,
// and in between there is a gradual increase in gain reduction.
// * `prePost`: places the level detector either at the input or after the gain computer;
// this turns it from a linear return-to-zero detector into a log  domain return-to-threshold detector
// * `link`: the amount of linkage between the channels. 0 = each channel is independent, 1 = all channels have the same amount of gain reduction
// * `N`: the number of channels of the compressor
//
// It uses a strength parameter instead of the traditional ratio, in order to be able to
// function as a hard limiter.
// For that you'd need a ratio of infinity:1, and you cannot express that in Faust.
//
// Sometimes even bigger ratios are useful:
// for example a group recording where one instrument is recorded with both a close microphone and a room microphone,
// and the instrument is loud enough in the room mic when playing loud, but you want to boost it when it is playing soft.
//
// #### References
//
// * <http://en.wikipedia.org/wiki/Dynamic_range_compression>
// * Digital Dynamic Range Compressor Design
// A Tutorial and Analysis
// DIMITRIOS GIANNOULIS (Dimitrios.Giannoulis@eecs.qmul.ac.uk)
// MICHAEL MASSBERG (michael@massberg.org)
// AND JOSHUA D. REISS (josh.reiss@eecs.qmul.ac.uk)
//------------------------------------------------------------
// Author: Bart Brouns
// License: GPLv3

// generalise compression gains for N channels.
// first we define a mono version:
peak_compression_gain_N_chan(strength,thresh,att,rel,knee,prePost,link,1) =
  peak_compression_gain_mono(strength,thresh,att,rel,knee,prePost);

// The actual N-channel version:
// Calculate the maximum gain reduction of N channels,
// and then crossfade between that and each channel's own gain reduction,
// to link/unlink channels
peak_compression_gain_N_chan(strength,thresh,att,rel,knee,prePost,link,N) =
  par(i, N, peak_compression_gain_mono(strength,thresh,att,rel,knee,prePost))
  <:(si.bus(N),(ba.parallelMin(N)<:si.bus(N))):ro.interleave(N,2):par(i,N,(it.interpolate_linear(link)));


//--------------------`(co.)FFcompressor_N_chan`-------------------
// feed forward N channel dynamic range compressor.
// `FFcompressor_N_chan` is a standard Faust function.
//
// #### Usage
//
// ```
// si.bus(N) : FFcompressor_N_chan(strength,thresh,att,rel,knee,prePost,link,meter,N) : si.bus(N)
// ```
//
// Where:
//
// * `strength`: strength of the compression (0 = no compression, 1 means hard limiting, >1 means over-compression)
// * `thresh`: dB level threshold above which compression kicks in
// * `att`: attack time = time constant (sec) when level & compression going up
// * `rel`: release time = time constant (sec) coming out of compression
// * `knee`: a gradual increase in gain reduction around the threshold:
// Below thresh-(knee/2) there is no gain reduction,
// above thresh+(knee/2) there is the same gain reduction as without a knee,
// and in between there is a gradual increase in gain reduction.
// * `prePost`: places the level detector either at the input or after the gain computer;
// this turns it from a linear return-to-zero detector into a log  domain return-to-threshold detector
// * `link`: the amount of linkage between the channels. 0 = each channel is independent, 1 = all channels have the same amount of gain reduction
// * `meter`: a gain reduction meter. It can be implemented like so:
// meter = _<:(_, (ba.linear2db:max(maxGR):meter_group((hbargraph("[1][unit:dB][tooltip: gain reduction in dB]", maxGR, 0))))):attach;
// * `N`: the number of channels of the compressor
//
// It uses a strength parameter instead of the traditional ratio, in order to be able to
// function as a hard limiter.
// For that you'd need a ratio of infinity:1, and you cannot express that in Faust.
//
// Sometimes even bigger ratios are useful:
// for example a group recording where one instrument is recorded with both a close microphone and a room microphone,
// and the instrument is loud enough in the room mic when playing loud, but you want to boost it when it is playing soft.
//
// #### References
//
// * <http://en.wikipedia.org/wiki/Dynamic_range_compression>
// * Digital Dynamic Range Compressor Design
// A Tutorial and Analysis
// DIMITRIOS GIANNOULIS (Dimitrios.Giannoulis@eecs.qmul.ac.uk)
// MICHAEL MASSBERG (michael@massberg.org)
// AND JOSHUA D. REISS (josh.reiss@eecs.qmul.ac.uk)
//------------------------------------------------------------
// Author: Bart Brouns
// License: GPLv3

// feed forward compressor
FFcompressor_N_chan(strength,thresh,att,rel,knee,prePost,link,meter,N) =
  (si.bus(N) <:
    (peak_compression_gain_N_chan(strength,thresh,att,rel,knee,prePost,link,N),si.bus(N))
  )
  :(ro.interleave(N,2):par(i,N,meter*_));

//--------------------`(co.)FBcompressor_N_chan`-------------------
// feed back N channel dynamic range compressor.
// `FBcompressor_N_chan` is a standard Faust function.
//
// #### Usage
//
// ```
// si.bus(N) : FBcompressor_N_chan(strength,thresh,att,rel,knee,prePost,link,meter,N) : si.bus(N)
// ```
//
// Where:
//
// * `strength`: strength of the compression (0 = no compression, 1 means hard limiting, >1 means over-compression)
// * `thresh`: dB level threshold above which compression kicks in
// * `att`: attack time = time constant (sec) when level & compression going up
// * `rel`: release time = time constant (sec) coming out of compression
// * `knee`: a gradual increase in gain reduction around the threshold:
// Below thresh-(knee/2) there is no gain reduction,
// above thresh+(knee/2) there is the same gain reduction as without a knee,
// and in between there is a gradual increase in gain reduction.
// * `prePost`: places the level detector either at the input or after the gain computer;
// this turns it from a linear return-to-zero detector into a log  domain return-to-threshold detector
// * `link`: the amount of linkage between the channels. 0 = each channel is independent, 1 = all channels have the same amount of gain reduction
// * `meter`: a gain reduction meter. It can be implemented like so:
// meter = _<:(_, (ba.linear2db:max(maxGR):meter_group((hbargraph("[1][unit:dB][tooltip: gain reduction in dB]", maxGR, 0))))):attach;
// or it can be omitted by defining 'meter = _'.
// * `N`: the number of channels of the compressor
//
// It uses a strength parameter instead of the traditional ratio, in order to be able to
// function as a hard limiter.
// For that you'd need a ratio of infinity:1, and you cannot express that in Faust.
//
// Sometimes even bigger ratios are useful:
// for example a group recording where one instrument is recorded with both a close microphone and a room microphone,
// and the instrument is loud enough in the room mic when playing loud, but you want to boost it when it is playing soft.
//
// #### References
//
// * <http://en.wikipedia.org/wiki/Dynamic_range_compression>
// * Digital Dynamic Range Compressor Design
// A Tutorial and Analysis
// DIMITRIOS GIANNOULIS (Dimitrios.Giannoulis@eecs.qmul.ac.uk)
// MICHAEL MASSBERG (michael@massberg.org)
// AND JOSHUA D. REISS (josh.reiss@eecs.qmul.ac.uk)
//------------------------------------------------------------
// Author: Bart Brouns
// License: GPLv3

FBcompressor_N_chan(strength,thresh,att,rel,knee,prePost,link,meter,N) =
  (
    (peak_compression_gain_N_chan(strength,thresh,att,rel,knee,prePost,link,N),si.bus(N))
    :(ro.interleave(N,2):par(i,N,meter*_))
  )~si.bus(N);

//--------------------`(co.)FBFFcompressor_N_chan`-------------------
// feed forward / feed back N channel dynamic range compressor.
// the feedback part has a much higher strength, so they end up sounding similar
// `FBFFcompressor_N_chan` is a standard Faust function.
//
// #### Usage
//
// ```
// si.bus(N) : FBFFcompressor_N_chan(strength,thresh,att,rel,knee,prePost,link,FBFF,meter,N) : si.bus(N)
// ```
//
// Where:
//
// * `strength`: strength of the compression (0 = no compression, 1 means hard limiting, >1 means over-compression)
// * `thresh`: dB level threshold above which compression kicks in
// * `att`: attack time = time constant (sec) when level & compression going up
// * `rel`: release time = time constant (sec) coming out of compression
// * `knee`: a gradual increase in gain reduction around the threshold:
// Below thresh-(knee/2) there is no gain reduction,
// above thresh+(knee/2) there is the same gain reduction as without a knee,
// and in between there is a gradual increase in gain reduction.
// * `prePost`: places the level detector either at the input or after the gain computer;
// this turns it from a linear return-to-zero detector into a log  domain return-to-threshold detector
// * `link`: the amount of linkage between the channels. 0 = each channel is independent, 1 = all channels have the same amount of gain reduction
// * `FBFF`: fade between feed forward (0) and feed back (1) compression.
// * `meter`: a gain reduction meter. It can be implemented like so:
// meter = _<:(_, (ba.linear2db:max(maxGR):meter_group((hbargraph("[1][unit:dB][tooltip: gain reduction in dB]", maxGR, 0))))):attach;
// * `N`: the number of channels of the compressor
//
// It uses a strength parameter instead of the traditional ratio, in order to be able to
// function as a hard limiter.
// For that you'd need a ratio of infinity:1, and you cannot express that in Faust.
//
// Sometimes even bigger ratios are useful:
// for example a group recording where one instrument is recorded with both a close microphone and a room microphone,
// and the instrument is loud enough in the room mic when playing loud, but you want to boost it when it is playing soft.
//
// #### References
//
// * <http://en.wikipedia.org/wiki/Dynamic_range_compression>
// * Digital Dynamic Range Compressor Design
// A Tutorial and Analysis
// DIMITRIOS GIANNOULIS (Dimitrios.Giannoulis@eecs.qmul.ac.uk)
// MICHAEL MASSBERG (michael@massberg.org)
// AND JOSHUA D. REISS (josh.reiss@eecs.qmul.ac.uk)
//------------------------------------------------------------
// Author: Bart Brouns
// License: GPLv3

FBFFcompressor_N_chan(strength,thresh,att,rel,knee,prePost,link,FBFF,meter,N) =
  si.bus(N) <: si.bus(N*2):
  (
    ((
      (par(i, 2, peak_compression_gain_N_chan(strength*(1+((i==0)*2)),thresh,att,rel,knee,prePost,link,N)):ro.interleave(N,2):par(i, N, it.interpolate_linear(FBFF)))
     ,si.bus(N))
      :(ro.interleave(N,2):par(i,N,meter*_))
    )~si.bus(N)
  );


//--------------------`(co.)RMS_compression_gain_mono`-------------------
// Mono RMS dynamic range compressor gain computer.
// `RMS_compression_gain_mono` is a standard Faust function
//
// #### Usage
//
// ```
// _ : RMS_compression_gain_mono(strength,thresh,att,rel,knee,prePost) : _
// ```
//
// Where:
//
// * `strength`: strength of the compression (0 = no compression, 1 means hard limiting, >1 means over-compression)
// * `thresh`: dB level threshold above which compression kicks in
// * `att`: attack time = time constant (sec) when level & compression going up
// * `rel`: release time = time constant (sec) coming out of compression
// * `knee`: a gradual increase in gain reduction around the threshold:
// Below thresh-(knee/2) there is no gain reduction,
// above thresh+(knee/2) there is the same gain reduction as without a knee,
// and in between there is a gradual increase in gain reduction.
// * `prePost`: places the level detector either at the input or after the gain computer;
// this turns it from a linear return-to-zero detector into a log  domain return-to-threshold detector
//
// It uses a strength parameter instead of the traditional ratio, in order to be able to
// function as a hard limiter.
// For that you'd need a ratio of infinity:1, and you cannot express that in Faust.
//
// Sometimes even bigger ratios are useful:
// for example a group recording where one instrument is recorded with both a close microphone and a room microphone,
// and the instrument is loud enough in the room mic when playing loud, but you want to boost it when it is playing soft.
//
// #### References
//
// * <http://en.wikipedia.org/wiki/Dynamic_range_compression>
// * Digital Dynamic Range Compressor Design
// A Tutorial and Analysis
// DIMITRIOS GIANNOULIS (Dimitrios.Giannoulis@eecs.qmul.ac.uk)
// MICHAEL MASSBERG (michael@massberg.org)
// AND JOSHUA D. REISS (josh.reiss@eecs.qmul.ac.uk)
//------------------------------------------------------------
// Author: Bart Brouns
// License: GPLv3

RMS_compression_gain_mono(strength,thresh,att,rel,knee,prePost) =
  RMS(rel): ba.bypass1(prePost,si.lag_ud(att,0)) : ba.linear2db : gain_computer(strength,thresh,knee) : ba.bypass1((prePost*-1)+1,si.lag_ud(0,att)) : ba.db2linear
with {
  gain_computer(strength,thresh,knee,level) =
    select3((level>(thresh-(knee/2)))+(level>(thresh+(knee/2))),
            0,
            ((level-thresh+(knee/2)):pow(2)/(2*knee)),
            (level-thresh)) : max(0)*-strength;
  	RMS(time) = ba.slidingRMS(s) with { s = ba.sec2samp(time):int:max(1); };
};

//--------------------`(co.)RMS_compression_gain_N_chan`-------------------
// RMS N channel dynamic range compressor gain computer.
// `RMS_compression_gain_N_chan` is a standard Faust function.
//
// #### Usage
//
// ```
// si.bus(N) : RMS_compression_gain_N_chan(strength,thresh,att,rel,knee,prePost,link,N) : si.bus(N)
// ```
//
// Where:
//
// * `strength`: strength of the compression (0 = no compression, 1 means hard limiting, >1 means over-compression)
// * `thresh`: dB level threshold above which compression kicks in
// * `att`: attack time = time constant (sec) when level & compression going up
// * `rel`: release time = time constant (sec) coming out of compression
// * `knee`: a gradual increase in gain reduction around the threshold:
// Below thresh-(knee/2) there is no gain reduction,
// above thresh+(knee/2) there is the same gain reduction as without a knee,
// and in between there is a gradual increase in gain reduction.
// * `prePost`: places the level detector either at the input or after the gain computer;
// this turns it from a linear return-to-zero detector into a log  domain return-to-threshold detector
// * `link`: the amount of linkage between the channels. 0 = each channel is independent, 1 = all channels have the same amount of gain reduction
// * `N`: the number of channels of the compressor
//
// It uses a strength parameter instead of the traditional ratio, in order to be able to
// function as a hard limiter.
// For that you'd need a ratio of infinity:1, and you cannot express that in Faust.
//
// Sometimes even bigger ratios are useful:
// for example a group recording where one instrument is recorded with both a close microphone and a room microphone,
// and the instrument is loud enough in the room mic when playing loud, but you want to boost it when it is playing soft.
//
// #### References
//
// * <http://en.wikipedia.org/wiki/Dynamic_range_compression>
// * Digital Dynamic Range Compressor Design
// A Tutorial and Analysis
// DIMITRIOS GIANNOULIS (Dimitrios.Giannoulis@eecs.qmul.ac.uk)
// MICHAEL MASSBERG (michael@massberg.org)
// AND JOSHUA D. REISS (josh.reiss@eecs.qmul.ac.uk)
//------------------------------------------------------------
// Author: Bart Brouns
// License: GPLv3

RMS_compression_gain_N_chan(strength,thresh,att,rel,knee,prePost,link,1) =
  RMS_compression_gain_mono(strength,thresh,att,rel,knee,prePost);

RMS_compression_gain_N_chan(strength,thresh,att,rel,knee,prePost,link,N) =
  par(i, N, RMS_compression_gain_mono(strength,thresh,att,rel,knee,prePost))
  <:(si.bus(N),(ba.parallelMin(N)<:si.bus(N))):ro.interleave(N,2):par(i,N,(it.interpolate_linear(link)));


//--------------------`(co.)RMS_FBFFcompressor_N_chan`-------------------
// RMS feed forward / feed back N channel dynamic range compressor.
// the feedback part has a much higher strength, so they end up sounding similar
// `RMS_FBFFcompressor_N_chan` is a standard Faust function.
//
// #### Usage
//
// ```
// si.bus(N) : RMS_FBFFcompressor_N_chan(strength,thresh,att,rel,knee,prePost,link,FBFF,meter,N) : si.bus(N)
// ```
//
// Where:
//
// * `strength`: strength of the compression (0 = no compression, 1 means hard limiting, >1 means over-compression)
// * `thresh`: dB level threshold above which compression kicks in
// * `att`: attack time = time constant (sec) when level & compression going up
// * `rel`: release time = time constant (sec) coming out of compression
// * `knee`: a gradual increase in gain reduction around the threshold:
// Below thresh-(knee/2) there is no gain reduction,
// above thresh+(knee/2) there is the same gain reduction as without a knee,
// and in between there is a gradual increase in gain reduction.
// * `prePost`: places the level detector either at the input or after the gain computer;
// this turns it from a linear return-to-zero detector into a log  domain return-to-threshold detector
// * `link`: the amount of linkage between the channels. 0 = each channel is independent, 1 = all channels have the same amount of gain reduction
// * `FBFF`: fade between feed forward (0) and feed back (1) compression.
// * `meter`: a gain reduction meter. It can be implemented like so:
// meter = _<:(_, (ba.linear2db:max(maxGR):meter_group((hbargraph("[1][unit:dB][tooltip: gain reduction in dB]", maxGR, 0))))):attach;
// * `N`: the number of channels of the compressor
//
// It uses a strength parameter instead of the traditional ratio, in order to be able to
// function as a hard limiter.
// For that you'd need a ratio of infinity:1, and you cannot express that in Faust.
//
// Sometimes even bigger ratios are useful:
// for example a group recording where one instrument is recorded with both a close microphone and a room microphone,
// and the instrument is loud enough in the room mic when playing loud, but you want to boost it when it is playing soft.
//
// to save CPU we cheat a bit, in a similar way as in the original libs:
// instead of crosfading between two sets of gain calculators as above,
// we take the abs of the audio from both the FF and FB, and crossfade between those,
// and feed that into one set of gain calculators
// again the strength is much higher when in FB mode, but implemented differently
//
// #### References
//
// * <http://en.wikipedia.org/wiki/Dynamic_range_compression>
// * Digital Dynamic Range Compressor Design
// A Tutorial and Analysis
// DIMITRIOS GIANNOULIS (Dimitrios.Giannoulis@eecs.qmul.ac.uk)
// MICHAEL MASSBERG (michael@massberg.org)
// AND JOSHUA D. REISS (josh.reiss@eecs.qmul.ac.uk)
//------------------------------------------------------------
// Author: Bart Brouns
// License: GPLv3

RMS_FBFFcompressor_N_chan(strength,thresh,att,rel,knee,prePost,link,FBFF,meter,N) =
  si.bus(N) <: si.bus(N*2):
  (
    (
      (
        (ro.interleave(N,2):par(i, N*2, abs) :par(i, N, it.interpolate_linear(FBFF)) : RMS_compression_gain_N_chan(strength*(1+(((FBFF*-1)+1)*1)),thresh,att,rel,knee,prePost,link,N))
       ,si.bus(N)
      )
    :(ro.interleave(N,2):par(i,N,meter*_))
    )~si.bus(N)
  );


//--------------------`(co.)RMS_FBcompressor_peak_limiter_N_chan`-------------------
// N channel RMS feed back compressor into peak limiter feeding back into the FB compressor.
// By combining them this way, they complement each other optimally:
// The RMS compressor doesn't have to deal with the peaks,
// and the peak limiter get's spared from the steady state signal.
// the feedback part has a much higher strength, so they end up sounding similar
// `RMS_FBcompressor_peak_limiter_N_chan` is a standard Faust function.
//
// #### Usage
//
// ```
// si.bus(N) : RMS_FBcompressor_peak_limiter_N_chan(strength,thresh,threshLim,att,rel,knee,link,meter,meterLim,N) : si.bus(N)
// ```
//
// Where:
//
// * `strength`: strength of the compression (0 = no compression, 1 means hard limiting, >1 means over-compression)
// * `thresh`: dB level threshold above which compression kicks in
// * `threshLim`: dB level threshold above which the brickwall limiter kicks in
// * `att`: attack time = time constant (sec) when level & compression going up
// this is also used as the release time of the limiter
// * `rel`: release time = time constant (sec) coming out of compression
// * `knee`: a gradual increase in gain reduction around the threshold:
// Below thresh-(knee/2) there is no gain reduction,
// above thresh+(knee/2) there is the same gain reduction as without a knee,
// and in between there is a gradual increase in gain reduction.
// the limiter uses a knee half this size
// * `link`: the amount of linkage between the channels. 0 = each channel is independent, 1 = all channels have the same amount of gain reduction
// * `meter`: compressor gain reduction meter. It can be implemented like so:
// meter = _<:(_, (ba.linear2db:max(maxGR):meter_group((hbargraph("[1][unit:dB][tooltip: gain reduction in dB]", maxGR, 0))))):attach;
// * `meterLim`: brickwall limiter gain reduction meter. It can be implemented like so:
// meter = _<:(_, (ba.linear2db:max(maxGR):meter_group((hbargraph("[1][unit:dB][tooltip: gain reduction in dB]", maxGR, 0))))):attach;
// * `N`: the number of channels of the compressor
//
// It uses a strength parameter instead of the traditional ratio, in order to be able to
// function as a hard limiter.
// For that you'd need a ratio of infinity:1, and you cannot express that in Faust.
//
// Sometimes even bigger ratios are useful:
// for example a group recording where one instrument is recorded with both a close microphone and a room microphone,
// and the instrument is loud enough in the room mic when playing loud, but you want to boost it when it is playing soft.
//
// #### References
//
// * <http://en.wikipedia.org/wiki/Dynamic_range_compression>
// * Digital Dynamic Range Compressor Design
// A Tutorial and Analysis
// DIMITRIOS GIANNOULIS (Dimitrios.Giannoulis@eecs.qmul.ac.uk)
// MICHAEL MASSBERG (michael@massberg.org)
// AND JOSHUA D. REISS (josh.reiss@eecs.qmul.ac.uk)
//------------------------------------------------------------
// Author: Bart Brouns
// License: GPLv3

RMS_FBcompressor_peak_limiter_N_chan(strength,thresh,threshLim,att,rel,knee,link,meter,meterLim,N) =
  (
    (
      (
        (RMS_compression_gain_N_chan(strength,thresh,att,rel,knee,0,link,N))
        ,si.bus(N)
      ):(ro.interleave(N,2):par(i,N,meter*_))
    ):FFcompressor_N_chan(1,threshLim,0,att:min(rel),knee*0.5,0,link,meterLim,N)
  )~si.bus(N);


//=============================Original versions section=============================
// The functions in this section are largely superseded by the limiters above, but we
// retain them for backward compatibility and for situations in which a more permissive,
// MIT-style license is required.
//========================================================================================

//=============================Functions Reference========================================
//========================================================================================

//--------------------`(co.)compressor_lad_mono`-------------------
// Mono dynamic range compressor with lookahead delay.
// `compressor_lad_mono` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : compressor_lad_mono(lad,ratio,thresh,att,rel) : _
// ```
//
// Where:
//
// * `lad`: lookahead delay in seconds (nonnegative) - gets rounded to nearest sample.
//          The effective attack time is a good setting.
// * `ratio`: compression ratio (1 = no compression, >1 means compression)
//            Ratios: 4 is moderate compression, 8 is strong compression,
//            12 is mild limiting, and 20 is pretty hard limiting at the threshold.
// * `thresh`: dB level threshold above which compression kicks in (0 dB = max level)
// * `att`: attack time = time constant (sec) when level & compression are going up
// * `rel`: release time = time constant (sec) coming out of compression
//
// #### References
//
// * <http://en.wikipedia.org/wiki/Dynamic_range_compression>
// * <https://ccrma.stanford.edu/~jos/filters/Nonlinear_Filter_Example_Dynamic.html>
// * Albert Graef's "faust2pd"/examples/synth/compressor_.dsp
// * More features: <https://github.com/magnetophon/faustCompressors>
//------------------------------------------------------------
declare compressor_lad_mono author "Julius O. Smith III";
declare compressor_lad_mono copyright
        "Copyright (C) 2014-2020 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare compressor_lad_mono license "MIT-style STK-4.3 license";
compressor_lad_mono(lad,ratio,thresh,att,rel,x)
	= x@max(0,floor(0.5+ma.SR*lad)) * compression_gain_mono(ratio,thresh,att,rel,x);

//--------------------`(co.)compressor_mono`-------------------
// Mono dynamic range compressors.
// `compressor_mono` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : compressor_mono(ratio,thresh,att,rel) : _
// ```
//
// Where:
//
// * `ratio`: compression ratio (1 = no compression, >1 means compression)
//            Ratios: 4 is moderate compression, 8 is strong compression,
//            12 is mild limiting, and 20 is pretty hard limiting at the threshold.
// * `thresh`: dB level threshold above which compression kicks in (0 dB = max level)
// * `att`: attack time = time constant (sec) when level & compression are going up
// * `rel`: release time = time constant (sec) coming out of compression
//
// #### References
//
// * <http://en.wikipedia.org/wiki/Dynamic_range_compression>
// * <https://ccrma.stanford.edu/~jos/filters/Nonlinear_Filter_Example_Dynamic.html>
// * Albert Graef's "faust2pd"/examples/synth/compressor_.dsp
// * More features: <https://github.com/magnetophon/faustCompressors>
//------------------------------------------------------------
declare compressor_mono author "Julius O. Smith III";
declare compressor_mono copyright
        "Copyright (C) 2014-2020 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare compressor_mono license "MIT-style STK-4.3 license";
compressor_mono = compressor_lad_mono(0);

//--------------------`(co.)compressor_stereo`-------------------
// Stereo dynamic range compressors.
//
// #### Usage
//
// ```
// _,_ : compressor_stereo(ratio,thresh,att,rel) : _,_
// ```
//
// Where:
//
// * `ratio`: compression ratio (1 = no compression, >1 means compression)
// * `thresh`: dB level threshold above which compression kicks in (0 dB = max level)
// * `att`: attack time = time constant (sec) when level & compression going up
// * `rel`: release time = time constant (sec) coming out of compression
//
// #### References
//
// * <http://en.wikipedia.org/wiki/Dynamic_range_compression>
// * <https://ccrma.stanford.edu/~jos/filters/Nonlinear_Filter_Example_Dynamic.html>
// * Albert Graef's "faust2pd"/examples/synth/compressor_.dsp
// * More features: <https://github.com/magnetophon/faustCompressors>
//------------------------------------------------------------
declare compressor_stereo author "Julius O. Smith III";
declare compressor_stereo copyright
        "Copyright (C) 2014-2020 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare compressor_stereo license "MIT-style STK-4.3 license";
compressor_stereo(ratio,thresh,att,rel,x,y) = cgm*x, cgm*y with {
  cgm = compression_gain_mono(ratio,thresh,att,rel,abs(x)+abs(y));
};

//--------------------`(co.)compression_gain_mono`-------------------
// Compression-gain calculation for dynamic range compressors.
//
// #### Usage
//
// ```
// _ : compression_gain_mono(ratio,thresh,att,rel) : _
// ```
//
// Where:
//
// * `ratio`: compression ratio (1 = no compression, >1 means compression)
// * `thresh`: dB level threshold above which compression kicks in (0 dB = max level)
// * `att`: attack time = time constant (sec) when level & compression going up
// * `rel`: release time = time constant (sec) coming out of compression
//
// #### References
//
// * <http://en.wikipedia.org/wiki/Dynamic_range_compression>
// * <https://ccrma.stanford.edu/~jos/filters/Nonlinear_Filter_Example_Dynamic.html>
// * Albert Graef's "faust2pd"/examples/synth/compressor_.dsp
// * More features: <https://github.com/magnetophon/faustCompressors>
//------------------------------------------------------------
declare compression_gain_mono author "Julius O. Smith III";
declare compression_gain_mono copyright
        "Copyright (C) 2014-2020 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare compression_gain_mono license "MIT-style STK-4.3 license";
compression_gain_mono(ratio,thresh,att,rel) =
  an.amp_follower_ar(att,rel) : ba.linear2db : outminusindb(ratio,thresh) :
  kneesmooth(att) : ba.db2linear
with {
  // kneesmooth(att) installs a "knee" in the dynamic-range compression,
  // where knee smoothness is set equal to half that of the compression-attack.
  // A general 'knee' parameter could be used instead of tying it to att/2:
  kneesmooth(att) = si.smooth(ba.tau2pole(att/2.0));
  // compression gain in dB:
   outminusindb(ratio,thresh,level) = max(level-thresh,0.0) * (1.0/max(ma.EPSILON,float(ratio))-1.0);
  // Note: "float(ratio)" REQUIRED when ratio is an integer > 1!
};

//----------------`(co.)limiter_1176_R4_mono`----------------------
// A limiter guards against hard-clipping.  It can be
// implemented as a compressor having a high threshold (near the
// clipping level), fast attack, and high ratio.  Since
// the compression ratio is so high, some knee smoothing is
// desirable (for softer limiting).  This example is intended
// to get you started using compressors as limiters, so all
// parameters are hardwired here to nominal values.
//  Ratio: 4 (moderate compression)
//        See compressor_mono() comments for a guide to other choices.
//        Mike Shipley likes this (lowest) setting on the 1176.
//        (Grammy award-winning mixer for Queen, Tom Petty, etc.)
// Thresh: -6 dB, meaning 4:1 compression begins at amplitude 1/2.
//    Att: 800 MICROseconds (Note: scaled by ratio in the 1176)
//         The 1176 range is said to be 20-800 microseconds.
//         Faster attack gives "more bite" (e.g. on vocals),
//         and makes hard-clipping less likely on fast overloads.
//    Rel: 0.5 s (Note: scaled by ratio in the 1176)
//         The 1176 range is said to be 50-1100 ms.
// The 1176 also has a "bright, clear eq effect" (use filters.lib if desired).
// `limiter_1176_R4_mono` is a standard Faust function.
//
// #### Usage
//
// ```
//  _ : limiter_1176_R4_mono : _
// ```
//
// #### Reference:
//
// <http://en.wikipedia.org/wiki/1176_Peak_Limiter>
//------------------------------------------------------------
declare limiter_1176_R4_mono author "Julius O. Smith III";
declare limiter_1176_R4_mono copyright
        "Copyright (C) 2014-2020 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare limiter_1176_R4_mono license "MIT-style STK-4.3 license";
limiter_1176_R4_mono = compressor_mono(4,-6,0.0008,0.5);

//-------------------`(co.)limiter_1176_R4_stereo`---------------------
// A limiter guards against hard-clipping.  It can be
// implemented as a compressor having a high threshold (near the
// clipping level), fast attack and release, and high ratio.  Since
// the ratio is so high, some knee smoothing is
// desirable ("soft limiting").  This example is intended
// to get you started using compressor_* as a limiter, so all
// parameters are hardwired to nominal values here.
// Ratios: 4 (moderate compression), 8 (severe compression),
//          12 (mild limiting), or 20 to 1 (hard limiting)
//   Att: 20-800 MICROseconds (Note: scaled by ratio in the 1176)
//   Rel: 50-1100 ms (Note: scaled by ratio in the 1176)
//   Mike Shipley likes 4:1 (Grammy-winning mixer for Queen, Tom Petty, etc.)
//     Faster attack gives "more bite" (e.g. on vocals)
//     He hears a bright, clear eq effect as well (not implemented here)
//
// #### Usage
//
// ```
//  _,_ : limiter_1176_R4_stereo : _,_
// ```
//
// #### Reference:
//
// <http://en.wikipedia.org/wiki/1176_Peak_Limiter>
//------------------------------------------------------------
declare limiter_1176_R4_stereo author "Julius O. Smith III";
declare limiter_1176_R4_stereo copyright
        "Copyright (C) 2014-2020 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare limiter_1176_R4_stereo license "MIT-style STK-4.3 license";
limiter_1176_R4_stereo = compressor_stereo(4,-6,0.0008,0.5);

//-----------------------`(co.)limiter_lad_N`---------------------------------
// N-channel lookahead limiter inspired by IOhannes Zmölnig's post, which is 
// in turn based on the thesis by Peter Falkner "Entwicklung eines digitalen
// Stereo-Limiters mit Hilfe des Signalprozessors DSP56001".
// This version of the limiter uses a peak-holder with smoothed
// attack and release based on tau time constant filters.
//
// It is also possible to use a time constant that is 2*PI*tau by dividing 
// the attack and release times by 2*PI. This time constant allows for 
// the amplitude profile to reach 1 - e^(-2pi) of the final 
// peak after the attack time. The input path can be delayed by the same 
// amount as the attack time to synchronise input and amplitude profile, 
// realising a system that is particularly effective as a colourless
// (ideally) brickwall limiter.
//
// Note that the effectiveness of the ceiling settings are dependent on
// the other parameters, especially the time constant used for the
// smoothing filters and the lookahead delay. 
//
// Similarly, the colourless characteristics are also dependent on attack,
// hold, and release times. Since fluctuations above ~15 Hz are
// perceived as timbral effects, [Vassilakis and Kendall 2010] it is
// reasonable to set the attack time to 1/15 seconds for a smooth amplitude
// modulation. On the other hand, the hold time can be set to the
// peak-to-peak period of the expected lowest frequency in the signal,
// which allows for minimal distortion of the low frequencies. The
// release time can then provide a perceptually linear and gradual gain 
// increase determined by the user for any specific application.
//
// The scaling factor for all the channels is determined by the loudest peak 
// between them all, so that amplitude ratios between the signals are kept.
//
// #### Usage
//
// ```
// si.bus(N) : limiter_lad_N(N, LD, ceiling, attack, hold, release) : 
//    si.bus(N)
// ```
//
// Where:
//
// * `N` is the number of channels, known at compile-time.
// * `LD` is the lookahead delay in seconds, known at compile-time.
// * `ceiling` is the linear amplitude output limit.
// * `attack` is the attack time in seconds.
// * `hold` is the hold time in seconds.
// * `release` is the release time in seconds.
//
// Example for a stereo limiter: limiter_lad_N(2, .01, 1, .01, .1, 1);
//
// #### Reference:
//
// <http://iem.at/~zmoelnig/publications/limiter/>.
//------------------------------------------------------------------------------
declare limiter_lad_N author "Dario Sanfilippo";
declare limiter_lad_N copyright "Copyright (C) 2020 Dario Sanfilippo
      <sanfilippo.dario@gmail.com>";
declare limiter_lad_N license "GPLv3 license";
limiter_lad_N(N, LD, ceiling, attack, hold, release) = 
      si.bus(N) <: par(i, N, @ (LD * ma.SR)), 
                   (scaling <: si.bus(N)) : ro.interleave(N, 2) : par(i, N, *)
      with {
           scaling = ceiling / max(amp_profile, ma.EPSILON) : min(1);
           amp_profile = par(i, N, abs) : maxN(N) : ba.peakholder(hold * ma.SR) :
               att_smooth(attack) : rel_smooth(release);
           att_smooth(time, in) = si.smooth(ba.tau2pole(time), in);
           rel_smooth(time, in) = an.peak_envelope(time, in);
           maxN(1) = _;
           maxN(2) = max;
           maxN(N) = max(maxN(N - 1));
      };

//-------------`(co.)limiter_lad_mono`----------------------------------------
//
// Specialised case of limiter_lad_N: mono limiter.
//
// #### Usage
//
// ```
// _ : limiter_lad_mono(LD, ceiling, attack, hold, release) : _
// ```
//
// Where:
//
// * `LD` is the lookahead delay in seconds, known at compile-time.
// * `ceiling` is the linear amplitude output limit.
// * `attack` is the attack time in seconds.
// * `hold` is the hold time in seconds.
// * `release` is the release time in seconds.
//
// #### Reference:
//
// <http://iem.at/~zmoelnig/publications/limiter/>.
//------------------------------------------------------------------------------
declare limiter_lad_mono author "Dario Sanfilippo";
declare limiter_lad_mono copyright "Copyright (C) 2020 Dario Sanfilippo
      <sanfilippo.dario@gmail.com>";
declare limiter_lad_mono license "GPLv3 license";
limiter_lad_mono(LD) = limiter_lad_N(1, LD);

//-------------`(co.)limiter_lad_stereo`--------------------------------------
//
// Specialised case of limiter_lad_N: stereo limiter.
//
// #### Usage
//
// ```
// _,_ : limiter_lad_stereo(LD, ceiling, attack, hold, release) : _,_
// ```
//
// Where:
//
// * `LD` is the lookahead delay in seconds, known at compile-time.
// * `ceiling` is the linear amplitude output limit.
// * `attack` is the attack time in seconds.
// * `hold` is the hold time in seconds.
// * `release` is the release time in seconds.
//
// #### Reference:
//
// <http://iem.at/~zmoelnig/publications/limiter/>.
//------------------------------------------------------------------------------
declare limiter_lad_stereo author "Dario Sanfilippo";
declare limiter_lad_stereo copyright "Copyright (C) 2020 Dario Sanfilippo
      <sanfilippo.dario@gmail.com>";
declare limiter_lad_stereo license "GPLv3 license";
limiter_lad_stereo(LD) = limiter_lad_N(2, LD);

//-------------`(co.)limiter_lad_quad`----------------------------------------
//
// Specialised case of limiter_lad_N: quadraphonic limiter.
//
// #### Usage
//
// ```
// si.bus(4) : limiter_lad_quad(LD, ceiling, attack, hold, release) : 
//    si.bus(4)
// ```
//
// Where:
//
// * `LD` is the lookahead delay in seconds, known at compile-time.
// * `ceiling` is the linear amplitude output limit.
// * `attack` is the attack time in seconds.
// * `hold` is the hold time in seconds.
// * `release` is the release time in seconds.
//
// #### Reference:
//
// <http://iem.at/~zmoelnig/publications/limiter/>.
//------------------------------------------------------------------------------
declare limiter_lad_quad author "Dario Sanfilippo";
declare limiter_lad_quad copyright "Copyright (C) 2020 Dario Sanfilippo
      <sanfilippo.dario@gmail.com>";
declare limiter_lad_quad license "GPLv3 license";
limiter_lad_quad(LD) = limiter_lad_N(4, LD);

//-------------`(co.)limiter_lad_bw`-----------------------------------------
//
// Specialised case of limiter_lad_N and ready-to-use unit-amplitude mono 
// limiting function. This implementation, in particular, uses 2pi*tau
// time constant filters for attack and release smoothing with
// synchronised input and gain signals. 
//
// This function's best application is to be used as a brickwall limiter with 
// the least colouring artefacts while keeping a not-so-slow release curve. 
// Tests have shown that, given a pop song with 60 dB of amplification
// and a 0-dB-ceiling, the loudest peak recorded was ~0.38 dB.
//
// #### Usage
//
// ```
// _ : limiter_lad_bw : _
// ```
//
// #### Reference:
//
// <http://iem.at/~zmoelnig/publications/limiter/>.
//------------------------------------------------------------------------------
declare limiter_lad_bw author "Dario Sanfilippo";
declare limiter_lad_bw copyright "Copyright (C) 2020 Dario Sanfilippo
      <sanfilippo.dario@gmail.com>";
declare limiter_lad_bw license "GPLv3 license";
limiter_lad_bw = limiter_lad_mono(.01, 1, .01 / twopi, .1, 1 / twopi)
with {
    twopi = 2 * ma.PI;
};
//#################################### basics.lib ########################################
// A library of basic elements. Its official prefix is `ba`.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/basics.lib>
//########################################################################################
// A library of basic elements for Faust organized in 5 sections:
//
// * Conversion Tools
// * Counters and Time/Tempo Tools
// * Array Processing/Pattern Matching
// * Selectors (Conditions)
// * Other Tools (Misc)

//########################################################################################

/************************************************************************
************************************************************************
FAUST library file, GRAME section

Except where noted otherwise, Copyright (C) 2003-2017 by GRAME,
Centre National de Creation Musicale.
----------------------------------------------------------------------
GRAME LICENSE

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

ma = library("maths.lib");
ro = library("routes.lib");
ba = library("basics.lib"); // for compatible copy/paste out of this file
fi = library("filters.lib");
it = library("interpolators.lib");
si = library("signals.lib");

declare name "Faust Basic Element Library";
declare version "0.3";

//=============================Conversion Tools===========================================
//========================================================================================

//-------`(ba.)samp2sec`----------
// Converts a number of samples to a duration in seconds.
// `samp2sec` is a standard Faust function.
//
// #### Usage
//
// ```
// samp2sec(n) : _
// ```
//
// Where:
//
// * `n`: number of samples
//----------------------------
samp2sec(n) = n/ma.SR;


//-------`(ba.)sec2samp`----------
// Converts a duration in seconds to a number of samples.
// `samp2sec` is a standard Faust function.
//
// #### Usage
//
// ```
// sec2samp(d) : _
// ```
//
// Where:
//
// * `d`: duration in seconds
//----------------------------
sec2samp(d) = d*ma.SR;


//-------`(ba.)db2linear`----------
// Converts a loudness in dB to a linear gain (0-1).
// `db2linear` is a standard Faust function.
//
// #### Usage
//
// ```
// db2linear(l) : _
// ```
//
// Where:
//
// * `l`: loudness in dB
//-----------------------------
db2linear(l) = pow(10.0, l/20.0);


//-------`(ba.)linear2db`----------
// Converts a linear gain (0-1) to a loudness in dB.
// `linear2db` is a standard Faust function.
//
// #### Usage
//
// ```
// linear2db(g) : _
// ```
//
// Where:
//
// * `g`: a linear gain
//-----------------------------
linear2db(g) = 20.0*log10(max(ma.MIN, g));


//----------`(ba.)lin2LogGain`------------------
// Converts a linear gain (0-1) to a log gain (0-1).
//
// #### Usage
//
// ```
// lin2LogGain(n) : _
// ```
//---------------------------------------------
lin2LogGain(n) = n*n;


//----------`(ba.)log2LinGain`------------------
// Converts a log gain (0-1) to a linear gain (0-1).
//
// #### Usage
//
// ```
// log2LinGain(n) : _
// ```
//---------------------------------------------
log2LinGain(n) = sqrt(n);


// end GRAME section
//########################################################################################
/************************************************************************
FAUST library file, jos section

Except where noted otherwise, The Faust functions below in this
section are Copyright (C) 2003-2017 by Julius O. Smith III <jos@ccrma.stanford.edu>
([jos](http://ccrma.stanford.edu/~jos/)), and released under the
(MIT-style) [STK-4.3](#stk-4.3-license) license.

The MarkDown comments in this section are Copyright 2016-2017 by Romain
Michon and Julius O. Smith III, and are released under the
[CCA4I](https://creativecommons.org/licenses/by/4.0/) license (TODO: if/when Romain agrees)

************************************************************************/

//-------`(ba.)tau2pole`----------
// Returns a real pole giving exponential decay.
// Note that t60 (time to decay 60 dB) is ~6.91 time constants.
// `tau2pole` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : smooth(tau2pole(tau)) : _
// ```
//
// Where:
//
// * `tau`: time-constant in seconds
//-----------------------------
// tau2pole(tau) = exp(-1.0/(tau*ma.SR));

tau2pole(tau) = ba.if(clipCond, 0.0, exp(-1.0/(tauCenterClipped*float(ma.SR)))) with {
 clipCond = abs(tau)<ma.EPSILON;
 tauCenterClipped = ba.if(clipCond, 1.0, tau); // 1.0 can be any nonzero value (not used)
};


//-------`(ba.)pole2tau`----------
// Returns the time-constant, in seconds, corresponding to the given real,
// positive pole in (0-1).
// `pole2tau` is a standard Faust function.
//
// #### Usage
//
// ```
// pole2tau(pole) : _
// ```
//
// Where:
//
// * `pole`: the pole
//-----------------------------
pole2tau(pole) = -1.0/(log(max(ma.MIN, pole))*ma.SR);


//-------`(ba.)midikey2hz`----------
// Converts a MIDI key number to a frequency in Hz (MIDI key 69 = A440).
// `midikey2hz` is a standard Faust function.
//
// #### Usage
//
// ```
// midikey2hz(mk) : _
// ```
//
// Where:
//
// * `mk`: the MIDI key number
//-----------------------------
midikey2hz(mk) = 440.0*pow(2.0, (mk-69.0)/12.0);


//-------`(ba.)hz2midikey`----------
// Converts a frequency in Hz to a MIDI key number (MIDI key 69 = A440).
// `hz2midikey` is a standard Faust function.
//
// #### Usage
//
// ```
// hz2midikey(freq) : _
// ```
//
// Where:
//
// * `freq`: frequency in Hz
//-----------------------------
hz2midikey(freq) = 12.0*ma.log2(freq/440.0) + 69.0;


//-------`(ba.)semi2ratio`----------
// Converts semitones in a frequency multiplicative ratio.
// `semi2ratio` is a standard Faust function.
//
// #### Usage
//
// ```
// semi2ratio(semi) : _
// ```
//
// Where:
//
// * `semi`: number of semitone 
//-----------------------------
semi2ratio(semi) = pow(2.0, semi/12.0);


//-------`(ba.)ratio2semi`----------
// Converts a frequency multiplicative ratio in semitones.
// `ratio2semi` is a standard Faust function.
//
// #### Usage
//
// ```
// ratio2semi(ratio) : _
// ```
//
// Where:
//
// * `ratio`: frequency multiplicative ratio
//-----------------------------
ratio2semi(ratio) = 12.0*log(ratio)/log(2.0);


//-------`(ba.)pianokey2hz`----------
// Converts a piano key number to a frequency in Hz (piano key 49 = A440).
//
// #### Usage
//
// ```
// pianokey2hz(pk) : _
// ```
//
// Where:
//
// * `pk`: the piano key number
//-----------------------------
pianokey2hz(pk) = 440.0*pow(2.0, (pk-49.0)/12.0);


//-------`(ba.)hz2pianokey`----------
// Converts a frequency in Hz to a piano key number (piano key 49 = A440).
//
// #### Usage
//
// ```
// hz2pianokey(f) : _
// ```
//
// Where:
//
// * `f`: frequency in Hz
//-----------------------------
hz2pianokey(f) = 12.0*ma.log2(f/440.0) + 49.0;


// end jos section
//########################################################################################
/************************************************************************
FAUST library file, GRAME section 2
************************************************************************/

//==============================Counters and Time/Tempo Tools=============================
//========================================================================================

//----------------------------`(ba.)countdown`------------------------------
// Starts counting down from n included to 0. While trig is 1 the output is n.
// The countdown starts with the transition of trig from 1 to 0. At the end
// of the countdown the output value will remain at 0 until the next trig.
// `countdown` is a standard Faust function.
//
// #### Usage
//
// ```
// countdown(n,trig) : _
// ```
//
// Where:
//
// * `n`: the starting point of the countdown
// * `trig`: the trigger signal (1: start at `n`; 0: decrease until 0)
//-----------------------------------------------------------------------------
countdown(n, trig) = \(c).(if(trig>0, n, max(0, c-1))) ~_;


//----------------------------`(ba.)countup`--------------------------------
// Starts counting up from 0 to n included. While trig is 1 the output is 0.
// The countup starts with the transition of trig from 1 to 0. At the end
// of the countup the output value will remain at n until the next trig.
// `countup` is a standard Faust function.
//
// #### Usage
//
// ```
// countup(n,trig) : _
// ```
//
// Where:
//
// * `n`: the maximum count value
// * `trig`: the trigger signal (1: start at 0; 0: increase until `n`)
//-----------------------------------------------------------------------------
countup(n, trig) = \(c).(if(trig>0, 0, min(n, c+1))) ~_;


//--------------------`(ba.)sweep`--------------------------
// Counts from 0 to `period-1` repeatedly, generating a
// sawtooth waveform, like os.lf_rawsaw,
// starting at 1 when `run` transitions from 0 to 1.
// Outputs zero while `run` is 0.
//
// #### Usage
//
// ```
// sweep(period,run) : _
// ```
//-----------------------------------------------------------------
// Author: Jonatan Liljedahl, markdown by JOS & RM
sweep = %(int(*:max(1)))~+(1);


//-------`(ba.)time`----------
// A simple timer that counts every samples from the beginning of the process.
// `time` is a standard Faust function.
//
// #### Usage
//
// ```
// time : _
// ```
//------------------------
time = (+(1)~_) - 1;


//-------`(ba.)ramp`----------
// A linear ramp with a slope of '(+/-)1/n' samples to reach the next value.
//
// #### Usage
//
// ```
// _ : ramp(n) : _
// ```
// Where:
//
// * `n`: number of samples to reach the next value 
//------------------------
ramp = case {
	(0) => _;
	(n) => \(y,x).(if(y+1.0/n < x, y+1.0/n, if(y-1.0/n > x, y-1.0/n, x))) ~ _;
};


//-------`(ba.)line`----------
// A linear ramp to reach a next value in 'n' samples. 
// Note that the interpolation process is restarted every time 
// the desired output value changes, the interpolation time is sampled only then.
//
// #### Usage
//
// ```
// _ : line(n) : _
// ```
// Where:
//
// * `n`: number of samples to reach the next value
//------------------------
line(n, x) = state ~ (_,_) : !,_
with {
    state(t, c) = nt,nc 
    with {
        nt = ba.if(x != x', n, t-1);
        nc = ba.if(nt > 0, c + (x - c)/nt, x);
    };
};


//-------`(ba.)tempo`----------
// Converts a tempo in BPM into a number of samples.
//
// #### Usage
//
// ```
// tempo(t) : _
// ```
//
// Where:
//
// * `t`: tempo in BPM
//------------------------
tempo(t) = (60*ma.SR)/t;


//-------`(ba.)period`----------
// Basic sawtooth wave of period `p`.
//
// #### Usage
//
// ```
// period(p) : _
// ```
//
// Where:
//
// * `p`: period as a number of samples
//------------------------
// NOTE: may be this should go in oscillators.lib
period(p) = %(int(p))~+(1');


//-------`(ba.)pulse`----------
// Pulses (like 10000) generated at period `p`.
//
// #### Usage
//
// ```
// pulse(p) : _
// ```
//
// Where:
//
// * `p`: period as a number of samples
//------------------------
// NOTE: may be this should go in oscillators.lib
pulse(p) = period(p) : \(x).(x <= x');


//-------`(ba.)pulsen`----------
// Pulses (like 11110000) of length `n` generated at period `p`.
//
// #### Usage
//
// ```
// pulsen(n,p) : _
// ```
//
// Where:
//
// * `n`: pulse length as a number of samples
// * `p`: period as a number of samples
//------------------------
// NOTE: may be this should go in oscillators.lib
pulsen(n,p) = period(p)<n;


//-----------------------`(ba.)cycle`---------------------------
// Split nonzero input values into `n` cycles.
//
// #### Usage
//
// ```
// _ : cycle(n) : si.bus(n)
// ```
//
// Where:
//
// * `n`: the number of cycles/output signals
//---------------------------------------------------------
// Author: Mike Olsen
cycle(n) = _ <: par(i,n,resetCtr(n,(i+1)));


//-------`(ba.)beat`----------
// Pulses at tempo `t`.
// `beat` is a standard Faust function.
//
// #### Usage
//
// ```
// beat(t) : _
// ```
//
// Where:
//
// * `t`: tempo in BPM
//------------------------
beat(t) = pulse(tempo(t));


//----------------------------`(ba.)pulse_countup`-----------------------------------
// Starts counting up pulses. While trig is 1 the output is
// counting up, while trig is 0 the counter is reset to 0.
//
// #### Usage
//
// ```
// _ : pulse_countup(trig) : _
// ```
//
// Where:
//
// * `trig`: the trigger signal (1: start at next pulse; 0: reset to 0)
//------------------------------------------------------------------------------
//TODO: author "Vince"
pulse_countup(trig) = + ~ _ * trig;


//----------------------------`(ba.)pulse_countdown`---------------------------------
// Starts counting down pulses. While trig is 1 the output is
// counting down, while trig is 0 the counter is reset to 0.
//
// #### Usage
//
// ```
// _ : pulse_countdown(trig) : _
// ```
//
// Where:
//
// * `trig`: the trigger signal (1: start at next pulse; 0: reset to 0)
//------------------------------------------------------------------------------
//TODO: author "Vince"
pulse_countdown(trig) = - ~ _ * trig;


//----------------------------`(ba.)pulse_countup_loop`------------------------------
// Starts counting up pulses from 0 to n included. While trig is 1 the output is
// counting up, while trig is 0 the counter is reset to 0. At the end
// of the countup (n) the output value will be reset to 0.
//
// #### Usage
//
// ```
// _ : pulse_countup_loop(n,trig) : _
// ```
//
// Where:
//
// * `n`: the highest number of the countup (included) before reset to 0
// * `trig`: the trigger signal (1: start at next pulse; 0: reset to 0)
//------------------------------------------------------------------------------
//TODO: author "Vince"
pulse_countup_loop(n, trig) = + ~ cond(n)*trig
with {
  	cond(n) = _ <: _ * (_ <= n);
};


//-----------------------`(ba.)resetCtr`------------------------
// Function that lets through the mth impulse out of
// each consecutive group of `n` impulses.
//
// #### Usage
//
// ```
// _ : resetCtr(n,m) : _
// ```
//
// Where:
//
// * `n`: the total number of impulses being split
// * `m`: index of impulse to allow to be output
//---------------------------------------------------------
// Author: Mike Olsen
resetCtr(n,m) = _ <: (_,pulse_countup_loop(n-1,1)) : (_,(_==m)) : *;


//----------------------------`(ba.)pulse_countdown_loop`----------------------------
// Starts counting down pulses from 0 to n included. While trig is 1 the output
// is counting down, while trig is 0 the counter is reset to 0. At the end
// of the countdown (n) the output value will be reset to 0.
//
// #### Usage
//
// ```
// _ : pulse_countdown_loop(n,trig) : _
// ```
//
// Where:
//
// * `n`: the highest number of the countup (included) before reset to 0
// * `trig`: the trigger signal (1: start at next pulse; 0: reset to 0)
//------------------------------------------------------------------------------
//TODO: author "Vince:
pulse_countdown_loop(n, trig) = - ~ cond(n)*trig
with {
  	cond(n) = _ <: _ * (_ >= n);
};


//===============================Array Processing/Pattern Matching========================
//========================================================================================

//---------------------------------`(ba.)count`---------------------------------
// Count the number of elements of list l.
// `count` is a standard Faust function.
//
// #### Usage
//
// ```
// count(l)
// count((10,20,30,40)) -> 4
// ```
//
// Where:
//
// * `l`: list of elements
//-----------------------------------------------------------------------------
count((xs, xxs)) = 1 + count(xxs);
count(xx) = 1;


//-------------------------------`(ba.)take`-----------------------------------
// Take an element from a list.
// `take` is a standard Faust function.
//
// #### Usage
//
// ```
// take(P,l)
// take(3,(10,20,30,40)) -> 30
// ```
//
// Where:
//
// * `P`: position (int, known at compile time, P > 0)
// * `l`: list of elements
//-----------------------------------------------------------------------------
take(1, (xs, xxs))  = xs;
take(1, xs)         = xs;
take(N, (xs, xxs)) = take(N-1, xxs);


//----------------------------`(ba.)subseq`--------------------------------
// Extract a part of a list.
//
// #### Usage
//
// ```
// subseq(l, P, N)
// subseq((10,20,30,40,50,60), 1, 3) -> (20,30,40)
// subseq((10,20,30,40,50,60), 4, 1) -> 50
// ```
//
// Where:
//
// * `l`: list
// * `P`: start point (int, known at compile time, 0: begin of list)
// * `N`: number of elements (int, known at compile time)
//
// #### Note:
//
// Faust doesn't have proper lists. Lists are simulated with parallel
// compositions and there is no empty list.
//-----------------------------------------------------------------------------
subseq((head, tail), 0, 1) = head;
subseq((head, tail), 0, N) = head, subseq(tail, 0, N-1);
subseq((head, tail), P, N) = subseq(tail, P-1, N);
subseq(head, 0, N)         = head;


//============================Function tabulation=========================================
//========================================================================================

//-------`(ba.)tabulate`----------
// Tabulate an unary function on a [r0, r1] range in a table. 
// The table value can then be read directly or with linear or cubic interpolation.
//
// #### Usage
//
// ```
// tabulate(C, fun, size, r0, r1, x).(val|lin|cub) : _
// ```
//
// Where:
//
// * `C`: whether to dynamically force the index in [r0, r1] range: 1 force the check, 0 deactivate it (given at compile time)
// * `fun`: unary function
// * `size`: size of the table (integer)
// * `r0`: range minimal value
// * `r1`: range maximal value
// * `x`: input value to compute using the tabulated function
//
// ```
// tabulate(C, fun, size, r0, r1, x).val uses the value in the table
// ```
//
// ```
// tabulate(C, fun, size, r0, r1, x).lin uses the value in the table with linear interpolation
// ```
//
// ```
// tabulate(C, fun, size, r0, r1, x).cub uses the value in the table with cubic interpolation
// ```
//--------------------------------------------
tabulate(C, fun, size, r0, r1, x) = environment {

    // Maximum index to access
    mid = size-1;

    // Create the table
    wf(size) = r0 + float(ba.time)*(r1-r0)/float(mid) : fun;

    // Prepare the 'float' table read index
    id = (x-r0)/(r1-r0)*mid;

    // Limit the table read index in [0, mid] if C = 1
    rid(x, 0) = x;
    rid(x, 1) = max(0, min(x, mid));

    // Tabulate an unary 'fun' function on a range [r0, r1]
    val = y0 with { y0 = rdtable(size, wf(size), rid(int(id), C)); };

    // Tabulate an unary 'fun' function on a range [r0, r1] with linear interpolation
    lin = it.interpolate_linear(d,y0,y1)
    with {
        x0 = int(id);
        x1 = x0+1;
        d  = id-x0;
        y0 = rdtable(size, wf(size), rid(x0, C));
        y1 = rdtable(size, wf(size), rid(x1, C));
    };

    // Tabulate an unary 'fun' function on a range [r0, r1] with cubic interpolation
    cub = it.interpolate_cubic(d,y0,y1,y2,y3)
    with {
        x0 = x1-1;
        x1 = int(id);
        x2 = x1+1;
        x3 = x2+1;
        d  = id-x1;
        y0 = rdtable(size, wf(size), rid(x0, C));
        y1 = rdtable(size, wf(size), rid(x1, C));
        y2 = rdtable(size, wf(size), rid(x2, C));
        y3 = rdtable(size, wf(size), rid(x3, C));
    };
};


//============================Selectors (Conditions)======================================
//========================================================================================

//-----------------------------`(ba.)if`-----------------------------------
// if-then-else implemented with a select2. WARNING: since select2 is strict (always evaluating both branches),
// the resulting if does not have the usual "lazy" semantic of the C if form, and thus cannot be used to 
// protect against forbidden computations like division-by-zero for instance.
//
// #### Usage
//
// *   `if(cond, then, else) : _`
//
// Where:
//
// * `cond`: condition
// * `then`: signal selected while cond is true
// * `else`: signal selected while cond is false
//-----------------------------------------------------------------------------
if(cond,then,else) = select2(cond,else,then);
// TODO: perhaps it would make more sense to have an if(a,b) and an ifelse(a,b,c)?


//-----------------------------`(ba.)selector`---------------------------------
// Selects the ith input among n at compile time.
//
// #### Usage
//
// ```
// selector(I,N)
// _,_,_,_ : selector(2,4) : _ // selects the 3rd input among 4
// ```
//
// Where:
//
// * `I`: input to select (int, numbered from 0, known at compile time)
// * `N`: number of inputs (int, known at compile time, N > I)
//
// There is also cselector for selecting among complex input signals of the form (real,imag).
//
//-----------------------------------------------------------------------------
selector(i,n) = par(j, n, S(i, j))    with { S(i,i) = _; S(i,j) = !; };
cselector(i,n) = par(j, n, S(i, j))   with { S(i,i) = (_,_); S(i,j) = (!,!); }; // for complex numbers


//--------------------`(ba.)select2stereo`--------------------
// Select between 2 stereo signals.
//
// #### Usage
//
// ```
// _,_,_,_ : select2stereo(bpc) : _,_    
// ```
//
// Where:
//
// * `bpc`: the selector switch (0/1)
//------------------------------------------------------------
select2stereo(bpc) = ro.cross2 : select2(bpc), select2(bpc) : _,_;


//-----------------------------`(ba.)selectn`---------------------------------
// Selects the ith input among N at run time.
//
// #### Usage
//
// ```
// selectn(N,i)
// _,_,_,_ : selectn(4,2) : _ // selects the 3rd input among 4
// ```
//
// Where:
//
// * `N`: number of inputs (int, known at compile time, N > 0)
// * `i`: input to select (int, numbered from 0)
//
// #### Example test program
//
// ```
// N = 64;
// process = par(n, N, (par(i,N,i) : selectn(N,n)));
// ```
//-----------------------------------------------------------------------------
selectn(N,i) = selectnX(N,i,selector)
with {
    selector(i,j,x,y) = select2((i >= j), x, y);
};

// The generic version with a 'sel' function to be applied on: 
// - the channel index as a (possibly) fractional value
// - the next channel index as an integer value
// - the 2 signals to be selected between

selectnX(N,i,sel) = S(N,0)
with {
    S(1,offset) = _;
    S(n,offset) = S(left, offset), S(right, offset+left) : sel(i, offset+left)
    with {
        right = int(n/2);
        left  = n-right;
    };
};


//-----------------------------`(ba.)selectmulti`---------------------------------
// Selects the ith circuit among N at run time (all should have the same number of inputs and outputs)
// with a crossfade.
//
// #### Usage
//
// ```
// selectmulti(n,lgen,id)
// ```
//
// Where:
//
// * `n`: crossfade in samples
// * `lgen`: list of circuits
// * `id`: circuit to select (int, numbered from 0)
//
// #### Example test program
//
// ```
// process = selectmulti(ma.SR/10, ((3,9),(2,8),(5,7)), nentry("choice", 0, 0, 2, 1));
// process = selectmulti(ma.SR/10, ((_*3,_*9),(_*2,_*8),(_*5,_*7)), nentry("choice", 0, 0, 2, 1));
// ```
//-----------------------------------------------------------------------------
selectmulti(n, lgen, id) = selectmultiX(ins, lgen, id)
with {
    selectmultiX(0, lgen, id) = selector;                    // No inputs
    selectmultiX(N, lgen, id) = par(i, ins, _) <: selector;  // General case

    selector = lgen : ro.interleave(outs, N) : par(i, outs, selectnX(N, id, xfade))
    with {
        // crossfade of 'n' samples between 'x' and 'y' channels when the channel index changes
        xfade(i, j, x, y) = x*(1-xb) + y*xb with { xb = ramp(n, (i >= j)); };
    };

    outs = outputs(take(1, lgen));  // Number of outputs of the first circuit (all should have the same value)
    ins = inputs(take(1, lgen));    // Number of inputs of the first circuit (all should have the same value)
    N = outputs(lgen)/outs;         // Number of items in the list
};


//-----------------------------`(ba.)selectoutn`---------------------------------
// Route input to the output among N at run time.
//
// #### Usage
//
// ```
// _ : selectoutn(N, i) : _,_,...N
// ```
//
// Where:
//
// * `N`: number of outputs (int, known at compile time, N > 0)
// * `i`: output number to route to (int, numbered from 0) (i.e. slider)
//
// #### Example
//
// ```
// process = 1 : selectoutn(3, sel) : par(i, 3, vbargraph("v.bargraph %i", 0, 1));
// sel = hslider("volume", 0, 0, 2, 1) : int;
// ```
//--------------------------------------------------------------------------
// TODO: author "Vince"
selectoutn(n, s) = _ <: par(i, n, *(s==i));


//=====================================Other==============================================
//========================================================================================

//----------------------------`(ba.)latch`--------------------------------
// Latch input on positive-going transition of "clock" ("sample-and-hold").
//
// #### Usage
//
// ```
// _ : latch(clocksig) : _
// ```
//
// Where:
//
// * `clocksig`: hold trigger (0 for hold, 1 for bypass)
//------------------------------------------------------------
latch(c,x) = x * s : + ~ *(1-s) with { s = ((c'<=0)&(c>0)); };


//--------------------------`(ba.)sAndH`-------------------------------
// Sample And Hold.
// `sAndH` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : sAndH(t) : _
// ```
//
// Where:
//
// * `t`: hold trigger (0 for hold, 1 for bypass)
//----------------------------------------------------------------
// Author: RM
sAndH(t) = select2(t,_,_)~_;


//--------------------------`(ba.)downSample`-------------------------------
// Down sample a signal. WARNING: this function doesn't change the
// rate of a signal, it just holds samples...
// `downSample` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : downSample(freq) : _
// ```
//
// Where:
//
// * `freq`: new rate in Hz
//----------------------------------------------------------------
// Author: RM
downSample(freq) = sAndH(hold)
with {
  	hold = time%int(ma.SR/freq) == 0;
};


//------------------`(ba.)peakhold`---------------------------
// Outputs current max value above zero.
//
// #### Usage
//
// ```
// _ : peakhold(mode) : _
// ```
//
// Where:
//
// `mode` means: 
//	0 - Pass through. A single sample 0 trigger will work as a reset.
//  1 - Track and hold max value.
//----------------------------------------------------------------
// TODO: author Jonatan Liljedahl, revised by RM
peakhold = (*,_:max) ~ _;


//------------------`(ba.)peakholder`---------------------------
// Tracks abs peak and holds peak for 'n' samples.
//
// #### Usage
//
// ```
// _ : peakholder(n) : _
// ```
//
// Where:
//
// * `n`: number of samples
//----------------------------------------------------------------
// TODO: author Jonatan Liljedahl
peakholder(n) = peakhold2 ~ reset : (!,_) with {
    reset = sweep(n) > 0;
    // first out is gate that is 1 while holding last peak
    peakhold2 = _,abs <: peakhold,!,_ <: >=,_,!;
};


//--------------------------`(ba.)impulsify`---------------------------
// Turns a signal into an impulse with the value of the current sample 
// (0.3,0.2,0.1 becomes 0.3,0.0,0.0). This function is typically used with a 
// `button` to turn its output into an impulse. `impulsify` is a standard Faust 
// function.
//
// #### Usage
//
// ```
// button("gate") : impulsify;
// ```
//----------------------------------------------------------------
impulsify = _ <: _,mem : - <: >(0)*_;


//-----------------------`(ba.)automat`------------------------------
// Record and replay to the values the input signal in a loop.
//
// #### Usage
//
// ```
// hslider(...) : automat(bps, size, init) : _
// ```
//-----------------------------------------------------------------------
automat(bps, size, init, input) = rwtable(size+1, init, windex, input, rindex)
with {
	clock 	= beat(bps);
	rindex 	= int(clock) : (+ : %(size)) ~ _;		// each clock read the next entry of the table
	windex 	= if(timeToRenew, rindex, size);		// we ignore input unless it is time to renew
	timeToRenew 	= int(clock) & (inputHasMoved | (input <= init));
	inputHasMoved 	= abs(input-input') : countfrom(int(clock)') : >(0);
	countfrom(reset) = (+ : if(reset, 0, _)) ~ _;
};


//-----------------`(ba.)bpf`-------------------
// bpf is an environment (a group of related definitions) that can be used to
// create break-point functions. It contains three functions:
//
// * `start(x,y)` to start a break-point function
// * `end(x,y)` to end a break-point function
// * `point(x,y)` to add intermediate points to a break-point function
//
// A minimal break-point function must contain at least a start and an end point:
//
// ```
// f = bpf.start(x0,y0) : bpf.end(x1,y1);
// ```
//
// A more involved break-point function can contains any number of intermediate
// points:
//
// ```
// f = bpf.start(x0,y0) : bpf.point(x1,y1) : bpf.point(x2,y2) : bpf.end(x3,y3);
// ```
//
// In any case the `x_{i}` must be in increasing order (for all `i`, `x_{i} < x_{i+1}`).
// For example the following definition:
//
// ```
// f = bpf.start(x0,y0) : ... : bpf.point(xi,yi) : ... : bpf.end(xn,yn);
// ```
//
// implements a break-point function f such that:
//
// * `f(x) = y_{0}` when `x < x_{0}`
// * `f(x) = y_{n}` when `x > x_{n}`
// * `f(x) = y_{i} + (y_{i+1}-y_{i})*(x-x_{i})/(x_{i+1}-x_{i})` when `x_{i} <= x`
// and `x < x_{i+1}`
//
// `bpf` is a standard Faust function.
//--------------------------------------------------------
bpf = environment
{
  	// Start a break-point function
  	start(x0,y0) = \(x).(x0,y0,x,y0);
  	// Add a break-point
  	point(x1,y1) = \(x0,y0,x,y).(x1, y1, x, if(x < x0, y, if(x < x1, y0 + (x-x0)*(y1-y0)/(x1-x0), y1)));
  	// End a break-point function
  	end(x1,y1) = \(x0,y0,x,y).(if(x < x0, y, if(x < x1, y0 + (x-x0)*(y1-y0)/(x1-x0), y1)));
};


//-------------------`(ba.)listInterp`-------------------------
// Linearly interpolates between the elements of a list.
//
// #### Usage
//
// ```
// index = 1.69; // range is 0-4
// process = listInterp((800,400,350,450,325),index);
// ```
//
// Where:
//
// * `index`: the index (float) to interpolate between the different values.
// The range of `index` depends on the size of the list.
//------------------------------------------------------------
// Author: RM
listInterp(v) =
  	bpf.start(0,take(1,v)) :
  	seq(i,count(v)-2,bpf.point(i+1,take(i+2,v))) :
  	bpf.end(count(v)-1,take(count(v),v));


//-------------------`(ba.)bypass1`-------------------------
// Takes a mono input signal, route it to `e` and bypass it if `bpc = 1`. 
// When bypassed, `e` is feed with zeros so that its state is cleanup up.
// `bypass1` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : bypass1(bpc,e) : _
// ```
//
// Where:
//
// * `bpc`: bypass switch (0/1)
// * `e`: a mono effect
//------------------------------------------------------------
// Author: JOS
// License: STK-4.3
bypass1(bpc,e) = _ <: select2(bpc,(inswitch:e),_)
with {
    inswitch = select2(bpc,_,0);
};


//-------------------`(ba.)bypass2`-------------------------
// Takes a stereo input signal, route it to `e` and bypass it if `bpc = 1`. 
// When bypassed, `e` is feed with zeros so that its state is cleanup up.
// `bypass2` is a standard Faust function.
//
// #### Usage
//
// ```
// _,_ : bypass2(bpc,e) : _,_
// ```
//
// Where:
//
// * `bpc`: bypass switch (0/1)
// * `e`: a stereo effect
//------------------------------------------------------------
// Author: JOS
// License: STK-4.3
bypass2(bpc,e) = _,_ <: ((inswitch:e),_,_) : select2stereo(bpc)
with {
    inswitch = _,_ : (select2(bpc,_,0), select2(bpc,_,0)) : _,_;
};


//-------------------`(ba.)bypass1to2`-------------------------
// Bypass switch for effect `e` having mono input signal and stereo output. 
// Effect `e` is bypassed if `bpc = 1`.When bypassed, `e` is feed with zeros 
// so that its state is cleanup up.
// `bypass1to2` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : bypass1to2(bpc,e) : _,_
// ```
//
// Where:
//
// * `bpc`: bypass switch (0/1)
// * `e`: a mono-to-stereo effect
//------------------------------------------------------------
// Author: JOS
// License: STK-4.3
bypass1to2(bpc,e) = _ <: ((inswitch:e),_,_) : select2stereo(bpc)
with {
    inswitch = select2(bpc,_,0);
};


//-------------------`(ba.)bypass_fade`-------------------------
// Bypass an arbitrary (N x N) circuit with 'n' samples crossfade. 
// Inputs and outputs signals are faded out when 'e' is bypassed, 
// so that 'e' state is cleanup up. 
// Once bypassed the effect is replaced by par(i,N,_). 
// Bypassed circuits can be chained.
//
// #### Usage
//
// ```
// _ : bypass_fade(n,b,e) : _
// or
// _,_ : bypass_fade(n,b,e) : _,_ 
// ```
// * `n`: number of samples for the crossfade
// * `b`: bypass switch (0/1)
// * `e`: N x N circuit
//
// #### Examples
//
// ```
// process = bypass_fade(ma.SR/10, checkbox("bypass echo"), echo);
// process = bypass_fade(ma.SR/10, checkbox("bypass reverb"), freeverb);
// ```
//---------------------------------------------------------------
bypass_fade(n, b, e) = par(i, ins, _) 
			<: (par(i, ins, *(1-xb)) : e : par(i, outs, *(1-xb))), par(i, ins, *(xb))
			:> par(i, outs, _)
with {
    ins = inputs(e);
    outs = outputs(e);
    xb = ramp(n, b);
};


//----------------------------`(ba.)toggle`------------------------------------------
// Triggered by the change of 0 to 1, it toggles the output value
// between 0 and 1.
//
// #### Usage
//
// ```
// _ : toggle : _
// ```
// #### Examples
//
// ```
// button("toggle") : toggle : vbargraph("output", 0, 1)
// (an.amp_follower(0.1) > 0.01) : toggle : vbargraph("output", 0, 1) // takes audio input
// ```
//
//------------------------------------------------------------------------------
// TODO: author "Vince"
toggle = trig : loop
with {
    trig(x) = (x-x') == 1;
    loop = != ~ _;
};


//----------------------------`(ba.)on_and_off`------------------------------------------
// The first channel set the output to 1, the second channel to 0.
//
// #### Usage
//
// ```
// _,_ : on_and_off : _
// ```
//
// #### Example
//
// ```
// button("on"), button("off") : on_and_off : vbargraph("output", 0, 1)
// ```
//
//------------------------------------------------------------------------------
// TODO: author "Vince"
on_and_off(a, b) = (a : trig) : loop(b)
with {
    trig(x) = (x-x') == 1;
    loop(b) = + ~ (_ >= 1) * ((b : trig) == 0);
};


//=================================Sliding Reduce=========================================
// Provides various operations on the last N samples using a high order
// `slidingReduce(op,N,maxN,disabledVal,x)`` fold-like function:
//
// * `slidingSum(n)`: the sliding sum of the last n input samples, CPU-light
// * `slidingSump(n,maxn)`: the sliding sum of the last n input samples, numerically stable "forever"
// * `slidingMax(n,maxn)`: the sliding max of the last n input samples
// * `slidingMin(n,maxn)`: the sliding min of the last n input samples
// * `slidingMean(n)`: the sliding mean of the last n input samples, CPU-light
// * `slidingMeanp(n,maxn)`: the sliding mean of the last n input samples, numerically stable "forever"
// * `slidingRMS(n)`: the sliding RMS of the last n input samples, CPU-light
// * `slidingRMSp(n,maxn)`: the sliding RMS of the last n input samples, numerically stable "forever"
//
// #### Working Principle
//
// If we want the maximum of the last 8 values, we can do that as:
//
// ```
// simpleMax(x) =
//  (
//    (
//      max(x@0,x@1),
//      max(x@2,x@3)
//    ) :max
//  ),
//  (
//    (
//      max(x@4,x@5),
//      max(x@6,x@7)
//    ) :max
//  )
//  :max;
// ```
//
// `max(x@2,x@3)` is the same as `max(x@0,x@1)@2` but the latter re-uses a
// value we already computed,so is more efficient. Using the same trick for
// values 4 trough 7, we can write:
//
// ```
// efficientMax(x)=
//  (
//    (
//      max(x@0,x@1),
//      max(x@0,x@1)@2
//    ) :max
//  ),
//  (
//    (
//      max(x@0,x@1),
//      max(x@0,x@1)@2
//    ) :max@4
//  )
//  :max;
// ```
//
// We can rewrite it recursively, so it becomes possible to get the maximum at
// have any number of values, as long as it's a power of 2.
//
// ```
// recursiveMax =
//  case {
//    (1,x) => x;
//    (N,x) => max(recursiveMax(N/2,x), recursiveMax(N/2,x)@(N/2));
//  };
// ```
//
// What if we want to look at a number of values that's not a power of 2?
// For each value, we will have to decide whether to use it or not.
// If N is bigger than the index of the value, we use it, otherwise we replace
// it with (`0-(ma.INFINITY)`):
//
// ```
// variableMax(N,x) =
//  max(
//    max(
//      (
//        (x@0 : useVal(0)),
//        (x@1 : useVal(1))
//      ):max,
//      (
//        (x@2 : useVal(2)),
//        (x@3 : useVal(3))
//      ):max
//    ),
//    max(
//      (
//        (x@4 : useVal(4)),
//        (x@5 : useVal(5))
//      ):max,
//      (
//        (x@6 : useVal(6)),
//        (x@7 : useVal(7))
//      ):max
//    )
//  )
// with {
//  useVal(i) = select2((N>=i) , (0-(ma.INFINITY)),_);
// };
// ```
//
// Now it becomes impossible to re-use any values. To fix that let's first look
// at how we'd implement it using recursiveMax, but with a fixed N that is not
// a power of 2. For example, this is how you'd do it with `N=3`:
//
// ```
// binaryMaxThree(x) =
//  (
//    recursiveMax(1,x)@0, // the first x
//    recursiveMax(2,x)@1  // the second and third x
//  ):max;
// ```
//
// `N=6`
//
// ```
// binaryMaxSix(x) =
//  (
//    recursiveMax(2,x)@0, // first two
//    recursiveMax(4,x)@2  // third trough sixth
//  ):max;
// ```
//
// Note that `recursiveMax(2,x)` is used at a different delay then in
// `binaryMaxThree`, since it represents 1 and 2, not 2 and 3. Each block is
// delayed the combined size of the previous blocks.
//
// `N=7`
//
// ```
// binaryMaxSeven(x) =
//  (
//    (
//      recursiveMax(1,x)@0, // first x
//      recursiveMax(2,x)@1  // second and third
//    ):max,
//    (
//      recursiveMax(4,x)@3  // fourth trough seventh
//    )
//  ):max;
// ```
//
// To make a variable version, we need to know which powers of two are used,
// and at which delay time.
//
// Then it becomes a matter of:
//
// * lining up all the different block sizes in parallel: the first `par()`
//  statement
// * delaying each the appropriate amount: `sumOfPrevBlockSizes()`
// * turning it on or off: `useVal()`
// * getting the maximum of all of them: `combine()`
//
// In Faust, we can only do that for a fixed maximum number of values: `maxN`
//
// ```
// variableBinaryMaxN(N,maxN,x) =
//  par(i,maxNrBits,recursiveMax(pow2(i),x)@sumOfPrevBlockSizes(N,maxN,i) : useVal(i)) : combine(maxNrBits) with {
//    // The sum of all the sizes of the previous blocks
//    sumOfPrevBlockSizes(N,maxN,0) = 0;
//    sumOfPrevBlockSizes(N,maxN,i) = (subseq((allBlockSizes(N,maxN)),0,i):>_);
//    allBlockSizes(N,maxN) = par(i, maxNrBits, pow2(i) * isUsed(i) );
//    maxNrBits = int2nrOfBits(maxN);
//    // get the maximum of all blocks
//    combine(2) = max;
//    combine(N) = max(combine(N-1),_);
//    // Decide wether or not to use a certain value, based on N
//    useVal(i) = select2(isUsed(i), (0-(ma.INFINITY)),_);
//    isUsed(i) = take(i+1, (int2bin(N,maxN)));
//  };
// ```
//========================================================================================
// Section contributed by Bart Brouns (bart@magnetophon.nl).
// SPDX-License-Identifier: GPL-3.0
// Copyright (C) 2018 Bart Brouns


//-----------------------------`(ba.)slidingReduce`-----------------------------
// Fold-like high order function. Apply a commutative binary operation `<op>` to
// the last `<n>` consecutive samples of a signal `<x>`. For example :
// `slidingReduce(max,128,128,-(ma.INFINITY))` will compute the maximum of the last
// 128 samples. The output is updated each sample, unlike reduce, where the
// output is constant for the duration of a block.
//
// #### Usage
//
// ```
// _ : slidingReduce(op,N,maxN,disabledVal) : _
// ```
//
// Where:
//
// * `N`: the number of values to process
// * `maxN`: the maximum number of values to process, needs to be a power of 2
// * `op`: the operator. Needs to be a commutative one.
// * `disabledVal`: the value to use when we want to ignore a value.
//
// In other words, `op(x,disabledVal)` should equal to `x`. For example,
// `+(x,0)` equals `x` and `min(x,ma.INFINITY)` equals `x`. So if we want to
// calculate the sum, we need to give 0 as `disabledVal`, and if we want the
// minimum, we need to give `ma.INFINITY` as `disabledVal`.
//------------------------------------------------------------------------------
slidingReduce(op,N,maxN,disabledVal,x) =
  par(i,maxNrBits,fixedDelayOp(pow2(i),x)@sumOfPrevBlockSizes(N,maxN,i)
    : useVal(i)) : combine(maxNrBits)
with {

    // Apply <op> to the last <N> values of <x>, where <N> is fixed
    fixedDelayOp = case {
      (1,x) => x;
      (N,x) => op(fixedDelayOp(N/2,x), fixedDelayOp(N/2,x)@(N/2));
    };

    // The sum of all the sizes of the previous blocks
    sumOfPrevBlockSizes(N,maxN,0) = 0;
    sumOfPrevBlockSizes(N,maxN,i) = (subseq((allBlockSizes(N,maxN)),0,i):>_);
    allBlockSizes(N,maxN) = par(i, maxNrBits, (pow2(i)) * isUsed(i));
    maxNrBits = int2nrOfBits(maxN);

    // Apply <op> to <N> parallel input signals
    combine(2) = op;
    combine(N) = op(combine(N-1),_);

    // Decide wether or not to use a certain value, based on N
    // Basically only the second <select2> is needed,
    // but this version also works for N == 0
    // 'works' in this case means 'does the same as reduce'
    useVal(i) =
      _ <: select2(
        (i==0) & (N==0),
        select2(isUsed(i), disabledVal, _),
        _
      );

    // useVal(i) =
    //     select2(isUsed(i), disabledVal,_);
    isUsed(i) = take(i+1, (int2bin(N,maxN)));
    pow2(i) = 1<<i;
    // same as:
    // pow2(i) = int(pow(2,i));
    // but in the block diagram, it will be displayed as a number, instead of a formula

    // convert N into a list of ones and zeros
    int2bin(N,maxN) = par(j, int2nrOfBits(maxN), int(floor(N/(pow2(j))))%2);
    // calculate how many ones and zeros are needed to represent maxN
    int2nrOfBits(0) = 0;
    int2nrOfBits(maxN) = int(floor(log(maxN)/log(2))+1);
};


//------------------------------`(ba.)slidingSum`------------------------------
// The sliding sum of the last n input samples.
//
// It will eventually run into numerical trouble when there is a persistent dc component.
// If that matters in your application, use the more CPU-intensive (ba.)slidingSump.
//
// #### Usage
//
// ```
// _ : slidingSum(N) : _
// ```
//
// Where:
//
// * `N`: the number of values to process
//------------------------------------------------------------------------------
slidingSum(n) = fi.integrator <: _, _@int(max(0,n)) :> -;


//------------------------------`(ba.)slidingSump`------------------------------
// The sliding sum of the last n input samples.
//
// It uses a lot more CPU then (ba.)slidingSum(n,maxn), but is numerically stable "forever" in return.
//
// #### Usage
//
// ```
// _ : slidingSump(N,maxN) : _
// ```
//
// Where:
//
// * `N`: the number of values to process
// * `maxN`: the maximum number of values to process, needs to be a power of 2
//------------------------------------------------------------------------------
slidingSump(n,maxn) = slidingReduce(+,n,maxn,0);


//----------------------------`(ba.)slidingMax`--------------------------------
// The sliding maximum of the last n input samples.
//
// #### Usage
//
// ```
// _ : slidingMax(N,maxN) : _
// ```
//
// Where:
//
// * `N`: the number of values to process
// * `maxN`: the maximum number of values to process, needs to be a power of 2
//------------------------------------------------------------------------------
slidingMax(n,maxn) = slidingReduce(max,n,maxn,-(ma.INFINITY));


//----------------------------`(ba.)slidingMin`--------------------------------
// The sliding minimum of the last n input samples.
//
// #### Usage
//
// ```
// _ : slidingMin(N,maxN) : _
// ```
//
// Where:
//
// * `N`: the number of values to process
// * `maxN`: the maximum number of values to process, needs to be a power of 2
//------------------------------------------------------------------------------
slidingMin(n,maxn) = slidingReduce(min,n,maxn,ma.INFINITY);


//----------------------------`(ba.)slidingMean`-------------------------------
// The sliding mean of the last n input samples.
//
// It will eventually run into numerical trouble when there is a persistent dc component.
// If that matters in your application, use the more CPU-intensive (ba.)slidinRMSp.
//
// #### Usage
//
// ```
// _ : slidingMean(N,maxN) : _
// ```
//
// Where:
//
// * `N`: the number of values to process
//------------------------------------------------------------------------------
slidingMean(n) = slidingSum(n)/n;


//----------------------------`(ba.)slidingMeanp`-------------------------------
// The sliding mean of the last n input samples.
//
// It uses a lot more CPU then (ba.)slidingMean(n,maxn), but is numerically stable "forever" in return.
//
// #### Usage
//
// ```
// _ : slidingMeanp(N,maxN) : _
// ```
//
// Where:
//
// * `N`: the number of values to process
// * `maxN`: the maximum number of values to process, needs to be a power of 2
//------------------------------------------------------------------------------
slidingMeanp(n,maxn) = slidingSump(n,maxn)/n;


//---------------------------`(ba.)slidingRMS`---------------------------------
// The root mean square of the last n input samples.
//
// It will eventually run into numerical trouble when there is a persistent dc component.
// If that matters in your application, use the more CPU-intensive (ba.)slidinRMSp.

//
// #### Usage
//
// ```
// _ : slidingRMS(N) : _
// ```
//
// Where:
//
// * `N`: the number of values to process
//------------------------------------------------------------------------------
slidingRMS(n) = pow(2) : slidingMean(n) : sqrt;


//---------------------------`(ba.)slidingRMSp`---------------------------------
// The root mean square of the last n input samples.
//
// It uses a lot more CPU then (ba.)slidingRMS(n,maxn), but is numerically stable "forever" in return.
//
// #### Usage
//
// ```
// _ : slidingRMSp(N,maxN) : _
// ```
//
// Where:
//
// * `N`: the number of values to process
// * `maxN`: the maximum number of values to process, needs to be a power of 2
//------------------------------------------------------------------------------
slidingRMSp(n,maxn) = pow(2) : slidingMeanp(n,maxn) : sqrt;


//========================================================================================
// section contributed by Bart Brouns (bart@magnetophon.nl).
// spdx-license-identifier: gpl-3.0
// copyright (c) 2020 Bart Brouns

//=================================Parallel Operator=========================================
// Provides various operations on N parallel inputs using a high order
// `parallelOp(op,N,x)` function:
//
// * `parallelMax(n)`: the max of n parallel inputs
// * `parallelMin(n)`: the min of n parallel inputs
// * `parallelMean(n)`: the mean of n parallel inputs
// * `parallelRMS(n)`: the RMS of n parallel inputs

//-----------------------------`(ba.)parallelOp`-----------------------------
// Apply a commutative binary operation `<op>` to N parallel inputs.
//
// #### usage
//
// ```
// si.bus(n) : parallelOp(op,n) : _
// ```
//
// where:
//
// * `N`: the number of parallel inputs known at compile time
// * `op`: the operator which needs to be commutative
//
//------------------------------------------------------------------------------

parallelOp(op,1) = _;
parallelOp(op,2) = op;
parallelOp(op,n) = op(parallelOp(op,n-1));

//---------------------------`(ba.)parallelMax`---------------------------------
// The maximum of N parallel inputs.
//
// #### Usage
//
// ```
// si.bus(n) : parallelMax(n) : _
// ```
//
// Where:
//
// * `N`: the number of parallel inputs known at compile time
//------------------------------------------------------------------------------
parallelMax(n) = parallelOp(max,n);


//---------------------------`(ba.)parallelMin`---------------------------------
// The minimum of N parallel inputs.
//
// #### Usage
//
// ```
// si.bus(n) : parallelMin(n) : _
// ```
//
// Where:
//
// * `N`: the number of parallel inputs known at compile time
//------------------------------------------------------------------------------
parallelMin(n) = parallelOp(min,n);


//---------------------------`(ba.)parallelMean`---------------------------------
// The mean of N parallel inputs.
//
// #### Usage
//
// ```
// si.bus(n) : parallelMean(n) : _
// ```
//
// Where:
//
// * `N`: the number of parallel inputs known at compile time
//------------------------------------------------------------------------------
parallelMean(n) = si.bus(n):>_/n;


//---------------------------`(ba.)parallelRMS`---------------------------------
// The RMS of N parallel inputs.
//
// #### Usage
//
// ```
// si.bus(n) : parallelRMS(n) : _
// ```
//
// Where:
//
// * `N`: the number of parallel inputs known at compile time
//------------------------------------------------------------------------------
parallelRMS(n) = par(i, n, pow(2)) : parallelMean(n) : sqrt;


//////////////////////////////////Deprecated Functions////////////////////////////////////
// This section implements functions that used to be in music.lib but that are now
// considered as "deprecated".
//////////////////////////////////////////////////////////////////////////////////////////

millisec = ma.SR/1000.0;

time1s 	= hslider("time", 0, 0,  1000, 0.1)*millisec;
time2s 	= hslider("time", 0, 0,  2000, 0.1)*millisec;
time5s 	= hslider("time", 0, 0,  5000, 0.1)*millisec;
time10s = hslider("time", 0, 0, 10000, 0.1)*millisec;
time21s = hslider("time", 0, 0, 21000, 0.1)*millisec;
time43s = hslider("time", 0, 0, 43000, 0.1)*millisec;
//#################################### dx7.lib #########################################
// Yamaha DX7 emulation library. Its official prefix is `dx`.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/dx7.lib>
//########################################################################################
// Yamaha DX7 emulation library. The various functions available in this library
// are used by the libraries generated from `.syx` DX7 preset files. This
// toolkit was greatly inspired by the CSOUND DX7 emulation package:
// <http://www.parnasse.com/dx72csnd.shtml>.
//
// This library and its related tools are under development. Use it at your
// own risk!
//##############################################################################

/************************************************************************
************************************************************************
FAUST library file, GRAME section

Except where noted otherwise, Copyright (C) 2003-2017 by GRAME,
Centre National de Creation Musicale.
----------------------------------------------------------------------
GRAME LICENSE

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

/*
TODO:
  * LFO not implemented yet
  * The whole system needs some tuning
*/

ba = library("basics.lib");
en = library("envelopes.lib");
ma = library("maths.lib");
os = library("oscillators.lib");

//----------------------`(dx.)dx7_ampf`--------------------------
// DX7 amplitude conversion function. 3 versions of this function
// are available:
//
// * `dx7_amp_bpf`: BPF version (same as in the CSOUND toolkit)
// * `dx7_amp_func`: estimated mathematical equivalent of `dx7_amp_bpf`
// * `dx7_ampf`: default (sugar for `dx7_amp_func`)
//
// #### Usage:
//
// ```
// dx7AmpPreset : dx7_ampf_bpf : _
// ```
//
// Where:
//
// * `dx7AmpPreset`: DX7 amplitude value (0-99)
//----------------------------------------------------------
// CSOUND function implemented as a BPF
// Corresponds to F2 in the CSOUND implementation.
dx7_amp_bpf = ba.bpf.start(0,0) : seq(i,14,ba.bpf.point(xPoints(i)+1,yPoints(i))) : ba.bpf.end(127,1)
with{
  xPoints(n) = ba.take(n+1,(9,19,29,39,49,59,64,69,74,79,84,89,94,98));
  yPoints(n) = ba.take(n+1,(0.000227445,0.000985595,0.002350265,0.005989386,0.014253222,0.033813495,0.052312358,0.080970432,0.124260804,0.190447309,0.295223654,0.457088704,0.70227445,1));
};
// Function estimated from the CSOUND function (default)
dx7_amp_func = min(98)/98 : pow(_,8);
dx7_ampf = dx7_amp_func;

//----------------------`(dx.)dx7_egraterisef`--------------------------
// DX7 envelope generator rise conversion function. 3 versions of this function
// are available:
//
// * `dx7_egraterise_bpf`: BPF version (same as in the CSOUND toolkit)
// * `dx7_egraterise_func`: estimated mathematical equivalent of `dx7_egraterise_bpf`
// * `dx7_egraterisef`: default (sugar for `dx7_egraterise_func`)
//
// #### Usage:
//
// ```
// dx7envelopeRise : dx7_egraterisef : _
// ```
//
// Where:
//
// * `dx7envelopeRise`: DX7 envelope rise value (0-99)
//----------------------------------------------------------
// CSOUND function implemented as a BPF
// Corresponds to F4 in the CSOUND implementation.
dx7_egraterise_bpf = ba.bpf.start(0,38) : seq(i,24,ba.bpf.point(xPoints(i)+1,yPoints(i))) : ba.bpf.end(127,0.003)
with{
  xPoints(n) = ba.take(n+1,(4,9,14,19,24,29,34,42,45,48,51,54,60,66,68,71,74,77,
    80,83,86,89,92,95));
  yPoints(n) = ba.take(n+1,(22.8,12,7.5,4.8,2.7,1.8,1.3,.737,.615,
    .505,.409,.321,.080,.055,.032,.024,.018,.014,.011,.008,.008,
    .007,.005,.003));
};
// Function estimated from the CSOUND function (default)
dx7_egraterise_func = 38*pow((127-_)/127,12) : max(0.003);
dx7_egraterisef = dx7_egraterise_func;

//----------------------`(dx.)dx7_egraterisepercf`--------------------------
// DX7 envelope generator percussive rise conversion function. 3 versions of
// this function are available:
//
// * `dx7_egrateriseperc_bpf`: BPF version (same as in the CSOUND toolkit)
// * `dx7_egrateriseperc_func`: estimated mathematical equivalent of `dx7_egrateriseperc_bpf`
// * `dx7_egraterisepercf`: default (sugar for `dx7_egrateriseperc_func`)
//
// #### Usage:
//
// ```
// dx7envelopePercRise : dx7_egraterisepercf : _
// ```
//
// Where:
//
// * `dx7envelopePercRise`: DX7 envelope percussive rise value (0-99)
//----------------------------------------------------------
// CSOUND function implemented as a BPF
// Corresponds to F5 in the CSOUND implementation.
dx7_egrateriseperc_bpf = ba.bpf.start(0,0.00001) : seq(i,10,ba.bpf.point(xPoints(i)+1,yPoints(i))) : ba.bpf.end(127,1)
with{
  xPoints(n) = ba.take(n+1,(30,34,39,49,59,69,79,89,94,98));
  yPoints(n) = ba.take(n+1,(0.00001,0.02,0.06,0.14,0.24,0.35,0.5,0.7,0.86,1));
};
// Function estimated from the CSOUND function (default)
dx7_egrateriseperc_func = >=(30)*min(_-30,68)/68 : pow(_,1.8);
dx7_egraterisepercf = dx7_egrateriseperc_func;

//----------------------`(dx.)dx7_egratedecayf`--------------------------
// DX7 envelope generator decay conversion function. 3 versions of
// this function are available:
//
// * `dx7_egratedecay_bpf`: BPF version (same as in the CSOUND toolkit)
// * `dx7_egratedecay_func`: estimated mathematical equivalent of `dx7_egratedecay_bpf`
// * `dx7_egratedecayf`: default (sugar for `dx7_egratedecay_func`)
//
// #### Usage:
//
// ```
// dx7envelopeDecay : dx7_egratedecayf : _
// ```
//
// Where:
//
// * `dx7envelopeDecay`: DX7 envelope decay value (0-99)
//----------------------------------------------------------
// CSOUND function implemented as a BPF
// Corresponds to F6 in the CSOUND implementation.
dx7_egratedecay_bpf = ba.bpf.start(0,318) : seq(i,23,ba.bpf.point(xPoints(i)+1,yPoints(i))) : ba.bpf.end(127,.008)
with{
  xPoints(n) = ba.take(n+1,(3,7,12,17,22,27,32,40,43,49,52,55,58,63,66,69,72,75,
    78,81,84,87,90));
  yPoints(n) = ba.take(n+1,(181,115,63,39.7,20,11.2,7,5.66,3.98,1.99,
    1.34,.99,.71,.41,.15,.081,.068,.047,.037,.025,.02,.013,.008));
};
// Function estimated from the CSOUND function (default)
dx7_egratedecay_func = 318*pow((127-_)/127,12.6) : max(0.008);
dx7_egratedecayf = dx7_egratedecay_func;

//----------------------`(dx.)dx7_egratedecaypercf`--------------------------
// DX7 envelope generator percussive decay conversion function. 3 versions of
// this function are available:
//
// * `dx7_egratedecayperc_bpf`: BPF version (same as in the CSOUND toolkit)
// * `dx7_egratedecayperc_func`: estimated mathematical equivalent of `dx7_egratedecayperc_bpf`
// * `dx7_egratedecaypercf`: default (sugar for `dx7_egratedecayperc_func`)
//
// #### Usage:
//
// ```
// dx7envelopePercDecay : dx7_egratedecaypercf : _
// ```
//
// Where:
//
// * `dx7envelopePercDecay`: DX7 envelope decay value (0-99)
//----------------------------------------------------------
// CSOUND function implemented as a BPF
// Corresponds to F7 in the CSOUND implementation.
dx7_egratedecayperc_bpf = ba.bpf.start(0,0.00001) : seq(i,10,ba.bpf.point(xPoints(i),yPoints(i))) : ba.bpf.end(127,1)
with{
  xPoints(n) = ba.take(n+1,(10,20,30,40,50,60,70,80,90,99));
  yPoints(n) = ba.take(n+1,(0.25,0.35,0.43,0.52,0.59,0.7,0.77,0.84,0.92,1));
};
// Function estimated from the CSOUND function (default)
dx7_egratedecayperc_func = min(99)/99 : pow(_,0.7);
dx7_egratedecaypercf = dx7_egratedecayperc_func;

//----------------------`(dx.)dx7_eglv2peakf`--------------------------
// DX7 envelope level to peak conversion function. 3 versions of
// this function are available:
//
// * `dx7_eglv2peak_bpf`: BPF version (same as in the CSOUND toolkit)
// * `dx7_eglv2peak_func`: estimated mathematical equivalent of `dx7_eglv2peak_bpf`
// * `dx7_eglv2peakf`: default (sugar for `dx7_eglv2peak_func`)
//
// #### Usage:
//
// ```
// dx7Level : dx7_eglv2peakf : _
// ```
//
// Where:
//
// * `dx7Level`: DX7 level value (0-99)
//-----------------------------------------------------------
// CSOUND function implemented as a BPF
// Corresponds to F8 in the CSOUND implementation.
dx7_eglv2peak_bpf = ba.bpf.start(0,0) : seq(i,14,ba.bpf.point(xPoints(i)+1,yPoints(i))) : ba.bpf.end(127,2.08795)
with{
  xPoints(n) = ba.take(n+1,(9,19,29,39,49,59,64,59,74,79,84,89,94,98));
  yPoints(n) = ba.take(n+1,(0.000477,0.002,0.00493,0.01257,0.02992,0.07098,0.10981,0.16997,0.260855,0.39979,0.61974,0.95954,1.47425,2.08795));
};
// Function estimated from the CSOUND function (default)
dx7_eglv2peak_func = min(98)/98 : pow(_,8) : *(2.08795);
dx7_eglv2peakf = dx7_eglv2peak_func;

//----------------------`(dx.)dx7_velsensf`--------------------------
// DX7 velocity sensitivity conversion function.
//
// #### Usage:
//
// ```
// dx7Velocity  : dx7_velsensf : _
// ```
//
// Where:
//
// * `dx7Velocity`: DX7 level value (0-8)
//-----------------------------------------------------------
// Corresponds to F10 in the CSOUND implementation
dx7_velsensf = /(8);

//----------------------`(dx.)dx7_fdbkscalef`--------------------------
// DX7 feedback scaling conversion function.
//
// #### Usage:
//
// ```
// dx7Feedback  : dx7_fdbkscalef : _
// ```
//
// Where:
//
// * `dx7Feedback`: DX7 feedback value
//-----------------------------------------------------------
// Corresponds to F11 in the CSOUND implementation
dx7_fdbkscalef = *(0.875);

//------------------------------`(dx.)dx7_op`---------------------------
// DX7 Operator. Implements a phase-modulable sine wave oscillator connected
// to a DX7 envelope generator.
//
// #### Usage:
//
// ```
// dx7_op(freq,phaseMod,outLev,R1,R2,R3,R4,L1,L2,L3,L4,keyVel,rateScale,type,gain,gate) : _
// ```
//
// Where:
//
// * `freq`: frequency of the oscillator
// * `phaseMod`: phase deviation (-1 - 1)
// * `outLev`: preset output level (0-99)
// * `R1`: preset envelope rate 1 (0-99)
// * `R2`: preset envelope rate 2 (0-99)
// * `R3`: preset envelope rate 3 (0-99)
// * `R4`: preset envelope rate 4 (0-99)
// * `L1`: preset envelope level 1 (0-99)
// * `L2`: preset envelope level 2 (0-99)
// * `L3`: preset envelope level 3 (0-99)
// * `L4`: preset envelope level 4 (0-99)
// * `keyVel`: preset key velocity sensitivity (0-99)
// * `rateScale`: preset envelope rate scale
// * `type`: preset operator type
// * `gain`: general gain
// * `gate`: trigger signal
//-----------------------------------------------------------------
dx7_op(freq,phaseMod,outLev,R1,R2,R3,R4,L1,L2,L3,L4,keyVel,rateScale,type,gain,gate) =
(en.dx7envelope(egr1,egr2,egr3,egr4,egl1,egl2,egl3,egl4,gate) : envTable)*sineWave
with{
  tablesize = 1 << 16;
  // phase modulation, not freq modulation
  sineWave = rdtable(tablesize, os.sinwaveform(tablesize), ma.modulo(int(os.phasor(tablesize,freq) + phaseMod*tablesize),tablesize));
  amp = outLev/99; // the corresponding "CSOUND table" has just been hardcoded here
  // computing levels
  vFac = keyVel : dx7_velsensf;
  egl1 = L1*amp <: *(1-vFac) + *(vFac*gain);
  egl2 = L2*amp <: *(1-vFac) + *(vFac*gain);
  egl3 = L3*amp <: *(1-vFac) + *(vFac*gain);
  egl4 = L4*amp <: *(1-vFac) + *(vFac*gain);
  // computing rates
  rs = (freq : ba.hz2midikey)-21 : /(105)*6*rateScale;
  egr1 = R1+rs : min(99) <:
  select2(egl1>egl4,dx7_egratedecayf,dx7_egraterisef) <:
  *(egl4 <: select2(egl1>egl4,dx7_egratedecaypercf,dx7_egraterisepercf)),
  *(egl1 <: select2(egl1>egl4,dx7_egratedecaypercf,dx7_egraterisepercf)) :
  - : abs : max(0.001);
  egr2 = R2+rs : min(99) <:
  select2(egl2>egl1,dx7_egratedecayf,dx7_egraterisef) <:
  *(egl2 <: select2(egl2>egl1,dx7_egratedecaypercf,dx7_egraterisepercf)),
  *(egl1 <: select2(egl2>egl1,dx7_egratedecaypercf,dx7_egraterisepercf)) :
  - : abs : max(0.001);
  egr3 = R3+rs : min(99) <:
  select2(egl3>egl2,dx7_egratedecayf,dx7_egraterisef) <:
  *(egl2 <: select2(egl3>egl2,dx7_egratedecaypercf,dx7_egraterisepercf)),
  *(egl3 <: select2(egl3>egl2,dx7_egratedecaypercf,dx7_egraterisepercf)) :
  - : abs : max(0.001);
  egr4 = R4+rs : min(99) <:
  select2(egl3<=egl4,dx7_egratedecayf,dx7_egraterisef) <:
  *(egl3 <: select2(egl3<=egl4,dx7_egratedecaypercf,dx7_egraterisepercf)),
  *(egl4 <: select2(egl3<=egl4,dx7_egratedecaypercf,dx7_egraterisepercf)) :
  - : abs : max(0.001);
  envTable = _ <: select2(type,dx7_eglv2peakf,dx7_ampf);
};

//------------------------------`(dx.)dx7_algo`---------------------------
// DX7 algorithms. Implements the 32 DX7 algorithms (a quick Google search
// should give your more details on this). Each algorithm uses 6 operators.
//
// #### Usage:
//
// ```
// dx7_algo(algN,egR1,egR2,egR3,egR4,egL1,egL2,egL3,egL4,outLevel,keyVelSens,ampModSens,opMode,opFreq,opDetune,opRateScale,feedback,lfoDelay,lfoDepth,lfoSpeed,freq,gain,gate) : _
// ```
//
// Where:
//
// * `algN`: algorithm number (0-31, should be an int...)
// * `egR1`: preset envelope rates 1 (a list of 6 values between 0-99)
// * `egR2`: preset envelope rates 2 (a list of 6 values between 0-99)
// * `egR3`: preset envelope rates 3 (a list of 6 values between 0-99)
// * `egR4`: preset envelope rates 4 (a list of 6 values between 0-99)
// * `egL1`: preset envelope levels 1 (a list of 6 values between 0-99)
// * `egL2`: preset envelope levels 2 (a list of 6 values between 0-99)
// * `egL3`: preset envelope levels 3 (a list of 6 values between 0-99)
// * `egL4`: preset envelope levels 4 (a list of 6 values between 0-99)
// * `outLev`: preset output levels (a list of 6 values between 0-99)
// * `keyVel`: preset key velocity sensitivities (a list of 6 values between 0-99)
// * `ampModSens`: preset amplitude sensitivities (a list of 6 values between 0-99)
// * `opMode`: preset operator mode (a list of 6 values between 0-1)
// * `opFreq`: preset operator frequencies (a list of 6 values between 0-99)
// * `opDetune`: preset operator detuning (a list of 6 values between 0-99)
// * `opRateScale`: preset operator rate scale (a list of 6 values between 0-99)
// * `feedback`: preset operator feedback (a list of 6 values between 0-99)
// * `lfoDelay`: preset LFO delay (a list of 6 values between 0-99)
// * `lfoDepth`: preset LFO depth (a list of 6 values between 0-99)
// * `lfoSpeed`: preset LFO speed (a list of 6 values between 0-99)
// * `freq`: fundamental frequency
// * `gain`: general gain
// * `gate`: trigger signal
//-----------------------------------------------------------------

// Alg 1
// NOTE: the .2 for feedback was hardcoded in the csound orchestra, not sure why
// we need it
dx7_algo(0,egR1,egR2,egR3,egR4,egL1,egL2,egL3,egL4,outLevel,keyVelSens,ampModSens,opMode,opFreq,opDetune,opRateScale,feedback,lfoDelay,lfoDepth,lfoSpeed,freq,gain,gate) =
(op2 : op1),(op6~*(feedback*.2) : op5 : op4 : op3) :> _
with{
  op6Freq = select2(opMode(5),opFreq(5)*freq,opFreq(5)) + opDetune(5)/4;
  op6 = dx7_op(op6Freq,_,outLevel(5),egR1(5),egR2(5),egR3(5),egR4(5),egL1(5),egL2(5),egL3(5),egL4(5),keyVelSens(5),opRateScale(5),1,gain,gate);
  op5Freq = select2(opMode(4),opFreq(4)*freq,opFreq(4)) + opDetune(4)/4;
  op5 = dx7_op(op5Freq,_,outLevel(4),egR1(4),egR2(4),egR3(4),egR4(4),egL1(4),egL2(4),egL3(4),egL4(4),keyVelSens(4),opRateScale(4),1,gain,gate);
  op4Freq = select2(opMode(3),opFreq(3)*freq,opFreq(3)) + opDetune(3)/4;
  op4 = dx7_op(op4Freq,_,outLevel(3),egR1(3),egR2(3),egR3(3),egR4(3),egL1(3),egL2(3),egL3(3),egL4(3),keyVelSens(3),opRateScale(3),1,gain,gate);
  op3Freq = select2(opMode(2),opFreq(2)*freq,opFreq(2)) + opDetune(2)/4;
  op3 = dx7_op(op3Freq,_,outLevel(2),egR1(2),egR2(2),egR3(2),egR4(2),egL1(2),egL2(2),egL3(2),egL4(2),keyVelSens(2),opRateScale(2),0,gain,gate);
  op2Freq = select2(opMode(1),opFreq(1)*freq,opFreq(1)) + opDetune(1)/4;
  op2 = dx7_op(op2Freq,0,outLevel(1),egR1(1),egR2(1),egR3(1),egR4(1),egL1(1),egL2(1),egL3(1),egL4(1),keyVelSens(1),opRateScale(1),1,gain,gate);
  op1Freq = select2(opMode(0),opFreq(0)*freq,opFreq(0)) + opDetune(0)/4;
  op1 = dx7_op(op1Freq,_,outLevel(0),egR1(0),egR2(0),egR3(0),egR4(0),egL1(0),egL2(0),egL3(0),egL4(0),keyVelSens(0),opRateScale(0),0,gain,gate);
};

// Alg 2
// NOTE: the .2 for feedback was hardcoded in the csound orchestra, not sure why
// we need it
dx7_algo(1,egR1,egR2,egR3,egR4,egL1,egL2,egL3,egL4,outLevel,keyVelSens,ampModSens,opMode,opFreq,opDetune,opRateScale,feedback,lfoDelay,lfoDepth,lfoSpeed,freq,gain,gate) =
(op2~*(feedback*.2) : op1),(op6 : op5 : op4 : op3) :> _
with{
  op6Freq = select2(opMode(5),opFreq(5)*freq,opFreq(5)) + opDetune(5)/4;
  op6 = dx7_op(op6Freq,0,outLevel(5),egR1(5),egR2(5),egR3(5),egR4(5),egL1(5),egL2(5),egL3(5),egL4(5),keyVelSens(5),opRateScale(5),1,gain,gate);
  op5Freq = select2(opMode(4),opFreq(4)*freq,opFreq(4)) + opDetune(4)/4;
  op5 = dx7_op(op5Freq,_,outLevel(4),egR1(4),egR2(4),egR3(4),egR4(4),egL1(4),egL2(4),egL3(4),egL4(4),keyVelSens(4),opRateScale(4),1,gain,gate);
  op4Freq = select2(opMode(3),opFreq(3)*freq,opFreq(3)) + opDetune(3)/4;
  op4 = dx7_op(op4Freq,_,outLevel(3),egR1(3),egR2(3),egR3(3),egR4(3),egL1(3),egL2(3),egL3(3),egL4(3),keyVelSens(3),opRateScale(3),1,gain,gate);
  op3Freq = select2(opMode(2),opFreq(2)*freq,opFreq(2)) + opDetune(2)/4;
  op3 = dx7_op(op3Freq,_,outLevel(2),egR1(2),egR2(2),egR3(2),egR4(2),egL1(2),egL2(2),egL3(2),egL4(2),keyVelSens(2),opRateScale(2),0,gain,gate);
  op2Freq = select2(opMode(1),opFreq(1)*freq,opFreq(1)) + opDetune(1)/4;
  op2 = dx7_op(op2Freq,_,outLevel(1),egR1(1),egR2(1),egR3(1),egR4(1),egL1(1),egL2(1),egL3(1),egL4(1),keyVelSens(1),opRateScale(1),1,gain,gate);
  op1Freq = select2(opMode(0),opFreq(0)*freq,opFreq(0)) + opDetune(0)/4;
  op1 = dx7_op(op1Freq,_,outLevel(0),egR1(0),egR2(0),egR3(0),egR4(0),egL1(0),egL2(0),egL3(0),egL4(0),keyVelSens(0),opRateScale(0),0,gain,gate);
};

// Alg 3
// Note: weird rand and delay implemented in the csound orchestra and not
// really sure why...
dx7_algo(2,egR1,egR2,egR3,egR4,egL1,egL2,egL3,egL4,outLevel,keyVelSens,ampModSens,opMode,opFreq,opDetune,opRateScale,feedback,lfoDelay,lfoDepth,lfoSpeed,freq,gain,gate) =
(op3 : op2 : op1),(op6~*(feedback) : op5 : op4) :> _
with{
  op6Freq = select2(opMode(5),opFreq(5)*freq,opFreq(5)) + opDetune(5)/4;
  op6 = dx7_op(op6Freq,_,outLevel(5),egR1(5),egR2(5),egR3(5),egR4(5),egL1(5),egL2(5),egL3(5),egL4(5),keyVelSens(5),opRateScale(5),1,gain,gate);
  op5Freq = select2(opMode(4),opFreq(4)*freq,opFreq(4)) + opDetune(4)/4;
  op5 = dx7_op(op5Freq,_,outLevel(4),egR1(4),egR2(4),egR3(4),egR4(4),egL1(4),egL2(4),egL3(4),egL4(4),keyVelSens(4),opRateScale(4),1,gain,gate);
  op4Freq = select2(opMode(3),opFreq(3)*freq,opFreq(3)) + opDetune(3)/4;
  op4 = dx7_op(op4Freq,_,outLevel(3),egR1(3),egR2(3),egR3(3),egR4(3),egL1(3),egL2(3),egL3(3),egL4(3),keyVelSens(3),opRateScale(3),0,gain,gate);
  op3Freq = select2(opMode(2),opFreq(2)*freq,opFreq(2)) + opDetune(2)/4;
  op3 = dx7_op(op3Freq,0,outLevel(2),egR1(2),egR2(2),egR3(2),egR4(2),egL1(2),egL2(2),egL3(2),egL4(2),keyVelSens(2),opRateScale(2),1,gain,gate);
  op2Freq = select2(opMode(1),opFreq(1)*freq,opFreq(1)) + opDetune(1)/4;
  op2 = dx7_op(op2Freq,_,outLevel(1),egR1(1),egR2(1),egR3(1),egR4(1),egL1(1),egL2(1),egL3(1),egL4(1),keyVelSens(1),opRateScale(1),1,gain,gate);
  op1Freq = select2(opMode(0),opFreq(0)*freq,opFreq(0)) + opDetune(0)/4;
  op1 = dx7_op(op1Freq,_,outLevel(0),egR1(0),egR2(0),egR3(0),egR4(0),egL1(0),egL2(0),egL3(0),egL4(0),keyVelSens(0),opRateScale(0),0,gain,gate);
};

// Alg 4
dx7_algo(3,egR1,egR2,egR3,egR4,egL1,egL2,egL3,egL4,outLevel,keyVelSens,ampModSens,opMode,opFreq,opDetune,opRateScale,feedback,lfoDelay,lfoDepth,lfoSpeed,freq,gain,gate) =
(op3 : op2 : op1),(op6 : op5 : op4)~*(feedback) :> _
with{
  op6Freq = select2(opMode(5),opFreq(5)*freq,opFreq(5)) + opDetune(5)/4;
  op6 = dx7_op(op6Freq,_,outLevel(5),egR1(5),egR2(5),egR3(5),egR4(5),egL1(5),egL2(5),egL3(5),egL4(5),keyVelSens(5),opRateScale(5),1,gain,gate);
  op5Freq = select2(opMode(4),opFreq(4)*freq,opFreq(4)) + opDetune(4)/4;
  op5 = dx7_op(op5Freq,_,outLevel(4),egR1(4),egR2(4),egR3(4),egR4(4),egL1(4),egL2(4),egL3(4),egL4(4),keyVelSens(4),opRateScale(4),1,gain,gate);
  op4Freq = select2(opMode(3),opFreq(3)*freq,opFreq(3)) + opDetune(3)/4;
  op4 = dx7_op(op4Freq,_,outLevel(3),egR1(3),egR2(3),egR3(3),egR4(3),egL1(3),egL2(3),egL3(3),egL4(3),keyVelSens(3),opRateScale(3),0,gain,gate);
  op3Freq = select2(opMode(2),opFreq(2)*freq,opFreq(2)) + opDetune(2)/4;
  op3 = dx7_op(op3Freq,0,outLevel(2),egR1(2),egR2(2),egR3(2),egR4(2),egL1(2),egL2(2),egL3(2),egL4(2),keyVelSens(2),opRateScale(2),1,gain,gate);
  op2Freq = select2(opMode(1),opFreq(1)*freq,opFreq(1)) + opDetune(1)/4;
  op2 = dx7_op(op2Freq,_,outLevel(1),egR1(1),egR2(1),egR3(1),egR4(1),egL1(1),egL2(1),egL3(1),egL4(1),keyVelSens(1),opRateScale(1),1,gain,gate);
  op1Freq = select2(opMode(0),opFreq(0)*freq,opFreq(0)) + opDetune(0)/4;
  op1 = dx7_op(op1Freq,_,outLevel(0),egR1(0),egR2(0),egR3(0),egR4(0),egL1(0),egL2(0),egL3(0),egL4(0),keyVelSens(0),opRateScale(0),0,gain,gate);
};

// Alg 5
// NOTE: the .1 for feedback was hardcoded in the csound orchestra, not sure why
// we need it
dx7_algo(4,egR1,egR2,egR3,egR4,egL1,egL2,egL3,egL4,outLevel,keyVelSens,ampModSens,opMode,opFreq,opDetune,opRateScale,feedback,lfoDelay,lfoDepth,lfoSpeed,freq,gain,gate) =
(op2 : op1),(op4 : op3),(op6~*(feedback*.1) : op5) :> _
with{
  op6Freq = select2(opMode(5),opFreq(5)*freq,opFreq(5)) + opDetune(5)/4;
  op6 = dx7_op(op6Freq,_,outLevel(5),egR1(5),egR2(5),egR3(5),egR4(5),egL1(5),egL2(5),egL3(5),egL4(5),keyVelSens(5),opRateScale(5),1,gain,gate);
  op5Freq = select2(opMode(4),opFreq(4)*freq,opFreq(4)) + opDetune(4)/4;
  op5 = dx7_op(op5Freq,_,outLevel(4),egR1(4),egR2(4),egR3(4),egR4(4),egL1(4),egL2(4),egL3(4),egL4(4),keyVelSens(4),opRateScale(4),0,gain,gate);
  op4Freq = select2(opMode(3),opFreq(3)*freq,opFreq(3)) + opDetune(3)/4;
  op4 = dx7_op(op4Freq,0,outLevel(3),egR1(3),egR2(3),egR3(3),egR4(3),egL1(3),egL2(3),egL3(3),egL4(3),keyVelSens(3),opRateScale(3),1,gain,gate);
  op3Freq = select2(opMode(2),opFreq(2)*freq,opFreq(2)) + opDetune(2)/4;
  op3 = dx7_op(op3Freq,_,outLevel(2),egR1(2),egR2(2),egR3(2),egR4(2),egL1(2),egL2(2),egL3(2),egL4(2),keyVelSens(2),opRateScale(2),0,gain,gate);
  op2Freq = select2(opMode(1),opFreq(1)*freq,opFreq(1)) + opDetune(1)/4;
  op2 = dx7_op(op2Freq,0,outLevel(1),egR1(1),egR2(1),egR3(1),egR4(1),egL1(1),egL2(1),egL3(1),egL4(1),keyVelSens(1),opRateScale(1),1,gain,gate);
  op1Freq = select2(opMode(0),opFreq(0)*freq,opFreq(0)) + opDetune(0)/4;
  op1 = dx7_op(op1Freq,_,outLevel(0),egR1(0),egR2(0),egR3(0),egR4(0),egL1(0),egL2(0),egL3(0),egL4(0),keyVelSens(0),opRateScale(0),0,gain,gate);
};

// Alg 6
dx7_algo(5,egR1,egR2,egR3,egR4,egL1,egL2,egL3,egL4,outLevel,keyVelSens,ampModSens,opMode,opFreq,opDetune,opRateScale,feedback,lfoDelay,lfoDepth,lfoSpeed,freq,gain,gate) =
(op2 : op1),(op4 : op3),(op6 : op5)~*(feedback) :> _
with{
  op6Freq = select2(opMode(5),opFreq(5)*freq,opFreq(5)) + opDetune(5)/4;
  op6 = dx7_op(op6Freq,_,outLevel(5),egR1(5),egR2(5),egR3(5),egR4(5),egL1(5),egL2(5),egL3(5),egL4(5),keyVelSens(5),opRateScale(5),1,gain,gate);
  op5Freq = select2(opMode(4),opFreq(4)*freq,opFreq(4)) + opDetune(4)/4;
  op5 = dx7_op(op5Freq,_,outLevel(4),egR1(4),egR2(4),egR3(4),egR4(4),egL1(4),egL2(4),egL3(4),egL4(4),keyVelSens(4),opRateScale(4),0,gain,gate);
  op4Freq = select2(opMode(3),opFreq(3)*freq,opFreq(3)) + opDetune(3)/4;
  op4 = dx7_op(op4Freq,0,outLevel(3),egR1(3),egR2(3),egR3(3),egR4(3),egL1(3),egL2(3),egL3(3),egL4(3),keyVelSens(3),opRateScale(3),1,gain,gate);
  op3Freq = select2(opMode(2),opFreq(2)*freq,opFreq(2)) + opDetune(2)/4;
  op3 = dx7_op(op3Freq,_,outLevel(2),egR1(2),egR2(2),egR3(2),egR4(2),egL1(2),egL2(2),egL3(2),egL4(2),keyVelSens(2),opRateScale(2),0,gain,gate);
  op2Freq = select2(opMode(1),opFreq(1)*freq,opFreq(1)) + opDetune(1)/4;
  op2 = dx7_op(op2Freq,0,outLevel(1),egR1(1),egR2(1),egR3(1),egR4(1),egL1(1),egL2(1),egL3(1),egL4(1),keyVelSens(1),opRateScale(1),1,gain,gate);
  op1Freq = select2(opMode(0),opFreq(0)*freq,opFreq(0)) + opDetune(0)/4;
  op1 = dx7_op(op1Freq,_,outLevel(0),egR1(0),egR2(0),egR3(0),egR4(0),egL1(0),egL2(0),egL3(0),egL4(0),keyVelSens(0),opRateScale(0),0,gain,gate);
};

// Alg 7
dx7_algo(6,egR1,egR2,egR3,egR4,egL1,egL2,egL3,egL4,outLevel,keyVelSens,ampModSens,opMode,opFreq,opDetune,opRateScale,feedback,lfoDelay,lfoDepth,lfoSpeed,freq,gain,gate) =
(op2 : op1),(op4,(op6~*(feedback) : op5) :> op3) :> _
with{
  op6Freq = select2(opMode(5),opFreq(5)*freq,opFreq(5)) + opDetune(5)/4;
  op6 = dx7_op(op6Freq,_,outLevel(5),egR1(5),egR2(5),egR3(5),egR4(5),egL1(5),egL2(5),egL3(5),egL4(5),keyVelSens(5),opRateScale(5),1,gain,gate);
  op5Freq = select2(opMode(4),opFreq(4)*freq,opFreq(4)) + opDetune(4)/4;
  op5 = dx7_op(op5Freq,_,outLevel(4),egR1(4),egR2(4),egR3(4),egR4(4),egL1(4),egL2(4),egL3(4),egL4(4),keyVelSens(4),opRateScale(4),1,gain,gate);
  op4Freq = select2(opMode(3),opFreq(3)*freq,opFreq(3)) + opDetune(3)/4;
  op4 = dx7_op(op4Freq,0,outLevel(3),egR1(3),egR2(3),egR3(3),egR4(3),egL1(3),egL2(3),egL3(3),egL4(3),keyVelSens(3),opRateScale(3),1,gain,gate);
  op3Freq = select2(opMode(2),opFreq(2)*freq,opFreq(2)) + opDetune(2)/4;
  op3 = dx7_op(op3Freq,_,outLevel(2),egR1(2),egR2(2),egR3(2),egR4(2),egL1(2),egL2(2),egL3(2),egL4(2),keyVelSens(2),opRateScale(2),0,gain,gate);
  op2Freq = select2(opMode(1),opFreq(1)*freq,opFreq(1)) + opDetune(1)/4;
  op2 = dx7_op(op2Freq,0,outLevel(1),egR1(1),egR2(1),egR3(1),egR4(1),egL1(1),egL2(1),egL3(1),egL4(1),keyVelSens(1),opRateScale(1),1,gain,gate);
  op1Freq = select2(opMode(0),opFreq(0)*freq,opFreq(0)) + opDetune(0)/4;
  op1 = dx7_op(op1Freq,_,outLevel(0),egR1(0),egR2(0),egR3(0),egR4(0),egL1(0),egL2(0),egL3(0),egL4(0),keyVelSens(0),opRateScale(0),0,gain,gate);
};

// Alg 8
// NOTE: the .1 for feedback was hardcoded in the csound orchestra, not sure why
// we need it
dx7_algo(7,egR1,egR2,egR3,egR4,egL1,egL2,egL3,egL4,outLevel,keyVelSens,ampModSens,opMode,opFreq,opDetune,opRateScale,feedback,lfoDelay,lfoDepth,lfoSpeed,freq,gain,gate) =
(op2 : op1),(op4~*(feedback*.1),(op6 : op5) :> op3) :> _
with{
  op6Freq = select2(opMode(5),opFreq(5)*freq,opFreq(5)) + opDetune(5)/4;
  op6 = dx7_op(op6Freq,0,outLevel(5),egR1(5),egR2(5),egR3(5),egR4(5),egL1(5),egL2(5),egL3(5),egL4(5),keyVelSens(5),opRateScale(5),1,gain,gate);
  op5Freq = select2(opMode(4),opFreq(4)*freq,opFreq(4)) + opDetune(4)/4;
  op5 = dx7_op(op5Freq,_,outLevel(4),egR1(4),egR2(4),egR3(4),egR4(4),egL1(4),egL2(4),egL3(4),egL4(4),keyVelSens(4),opRateScale(4),1,gain,gate);
  op4Freq = select2(opMode(3),opFreq(3)*freq,opFreq(3)) + opDetune(3)/4;
  op4 = dx7_op(op4Freq,_,outLevel(3),egR1(3),egR2(3),egR3(3),egR4(3),egL1(3),egL2(3),egL3(3),egL4(3),keyVelSens(3),opRateScale(3),1,gain,gate);
  op3Freq = select2(opMode(2),opFreq(2)*freq,opFreq(2)) + opDetune(2)/4;
  op3 = dx7_op(op3Freq,_,outLevel(2),egR1(2),egR2(2),egR3(2),egR4(2),egL1(2),egL2(2),egL3(2),egL4(2),keyVelSens(2),opRateScale(2),0,gain,gate);
  op2Freq = select2(opMode(1),opFreq(1)*freq,opFreq(1)) + opDetune(1)/4;
  op2 = dx7_op(op2Freq,0,outLevel(1),egR1(1),egR2(1),egR3(1),egR4(1),egL1(1),egL2(1),egL3(1),egL4(1),keyVelSens(1),opRateScale(1),1,gain,gate);
  op1Freq = select2(opMode(0),opFreq(0)*freq,opFreq(0)) + opDetune(0)/4;
  op1 = dx7_op(op1Freq,_,outLevel(0),egR1(0),egR2(0),egR3(0),egR4(0),egL1(0),egL2(0),egL3(0),egL4(0),keyVelSens(0),opRateScale(0),0,gain,gate);
};

// Alg 9
// NOTE: the .4 for feedback was hardcoded in the csound orchestra, not sure why
// we need it
dx7_algo(8,egR1,egR2,egR3,egR4,egL1,egL2,egL3,egL4,outLevel,keyVelSens,ampModSens,opMode,opFreq,opDetune,opRateScale,feedback,lfoDelay,lfoDepth,lfoSpeed,freq,gain,gate) =
(op2~*(feedback*.4) : op1),(op4,(op6 : op5) :> op3) :> _
with{
  op6Freq = select2(opMode(5),opFreq(5)*freq,opFreq(5)) + opDetune(5)/4;
  op6 = dx7_op(op6Freq,0,outLevel(5),egR1(5),egR2(5),egR3(5),egR4(5),egL1(5),egL2(5),egL3(5),egL4(5),keyVelSens(5),opRateScale(5),1,gain,gate);
  op5Freq = select2(opMode(4),opFreq(4)*freq,opFreq(4)) + opDetune(4)/4;
  op5 = dx7_op(op5Freq,_,outLevel(4),egR1(4),egR2(4),egR3(4),egR4(4),egL1(4),egL2(4),egL3(4),egL4(4),keyVelSens(4),opRateScale(4),1,gain,gate);
  op4Freq = select2(opMode(3),opFreq(3)*freq,opFreq(3)) + opDetune(3)/4;
  op4 = dx7_op(op4Freq,0,outLevel(3),egR1(3),egR2(3),egR3(3),egR4(3),egL1(3),egL2(3),egL3(3),egL4(3),keyVelSens(3),opRateScale(3),1,gain,gate);
  op3Freq = select2(opMode(2),opFreq(2)*freq,opFreq(2)) + opDetune(2)/4;
  op3 = dx7_op(op3Freq,_,outLevel(2),egR1(2),egR2(2),egR3(2),egR4(2),egL1(2),egL2(2),egL3(2),egL4(2),keyVelSens(2),opRateScale(2),0,gain,gate);
  op2Freq = select2(opMode(1),opFreq(1)*freq,opFreq(1)) + opDetune(1)/4;
  op2 = dx7_op(op2Freq,_,outLevel(1),egR1(1),egR2(1),egR3(1),egR4(1),egL1(1),egL2(1),egL3(1),egL4(1),keyVelSens(1),opRateScale(1),1,gain,gate);
  op1Freq = select2(opMode(0),opFreq(0)*freq,opFreq(0)) + opDetune(0)/4;
  op1 = dx7_op(op1Freq,_,outLevel(0),egR1(0),egR2(0),egR3(0),egR4(0),egL1(0),egL2(0),egL3(0),egL4(0),keyVelSens(0),opRateScale(0),0,gain,gate);
};

// Alg 10
// NOTE: the .2 for feedback was hardcoded in the csound orchestra, not sure why
// we need it
dx7_algo(9,egR1,egR2,egR3,egR4,egL1,egL2,egL3,egL4,outLevel,keyVelSens,ampModSens,opMode,opFreq,opDetune,opRateScale,feedback,lfoDelay,lfoDepth,lfoSpeed,freq,gain,gate) =
(op5,op6 :> op4),(op3~*(feedback*.2) : op2 : op1) :> _
with{
  op6Freq = select2(opMode(5),opFreq(5)*freq,opFreq(5)) + opDetune(5)/4;
  op6 = dx7_op(op6Freq,0,outLevel(5),egR1(5),egR2(5),egR3(5),egR4(5),egL1(5),egL2(5),egL3(5),egL4(5),keyVelSens(5),opRateScale(5),1,gain,gate);
  op5Freq = select2(opMode(4),opFreq(4)*freq,opFreq(4)) + opDetune(4)/4;
  op5 = dx7_op(op5Freq,0,outLevel(4),egR1(4),egR2(4),egR3(4),egR4(4),egL1(4),egL2(4),egL3(4),egL4(4),keyVelSens(4),opRateScale(4),1,gain,gate);
  op4Freq = select2(opMode(3),opFreq(3)*freq,opFreq(3)) + opDetune(3)/4;
  op4 = dx7_op(op4Freq,_,outLevel(3),egR1(3),egR2(3),egR3(3),egR4(3),egL1(3),egL2(3),egL3(3),egL4(3),keyVelSens(3),opRateScale(3),0,gain,gate);
  op3Freq = select2(opMode(2),opFreq(2)*freq,opFreq(2)) + opDetune(2)/4;
  op3 = dx7_op(op3Freq,_,outLevel(2),egR1(2),egR2(2),egR3(2),egR4(2),egL1(2),egL2(2),egL3(2),egL4(2),keyVelSens(2),opRateScale(2),1,gain,gate);
  op2Freq = select2(opMode(1),opFreq(1)*freq,opFreq(1)) + opDetune(1)/4;
  op2 = dx7_op(op2Freq,_,outLevel(1),egR1(1),egR2(1),egR3(1),egR4(1),egL1(1),egL2(1),egL3(1),egL4(1),keyVelSens(1),opRateScale(1),1,gain,gate);
  op1Freq = select2(opMode(0),opFreq(0)*freq,opFreq(0)) + opDetune(0)/4;
  op1 = dx7_op(op1Freq,_,outLevel(0),egR1(0),egR2(0),egR3(0),egR4(0),egL1(0),egL2(0),egL3(0),egL4(0),keyVelSens(0),opRateScale(0),0,gain,gate);
};

// Alg 11
// NOTE: the .2 for feedback was hardcoded in the csound orchestra, not sure why
// we need it
dx7_algo(10,egR1,egR2,egR3,egR4,egL1,egL2,egL3,egL4,outLevel,keyVelSens,ampModSens,opMode,opFreq,opDetune,opRateScale,feedback,lfoDelay,lfoDepth,lfoSpeed,freq,gain,gate) =
(op5,op6~*(feedback*.2) :> op4),(op3 : op2 : op1) :> _
with{
  op6Freq = select2(opMode(5),opFreq(5)*freq,opFreq(5)) + opDetune(5)/4;
  op6 = dx7_op(op6Freq,_,outLevel(5),egR1(5),egR2(5),egR3(5),egR4(5),egL1(5),egL2(5),egL3(5),egL4(5),keyVelSens(5),opRateScale(5),1,gain,gate);
  op5Freq = select2(opMode(4),opFreq(4)*freq,opFreq(4)) + opDetune(4)/4;
  op5 = dx7_op(op5Freq,0,outLevel(4),egR1(4),egR2(4),egR3(4),egR4(4),egL1(4),egL2(4),egL3(4),egL4(4),keyVelSens(4),opRateScale(4),1,gain,gate);
  op4Freq = select2(opMode(3),opFreq(3)*freq,opFreq(3)) + opDetune(3)/4;
  op4 = dx7_op(op4Freq,_,outLevel(3),egR1(3),egR2(3),egR3(3),egR4(3),egL1(3),egL2(3),egL3(3),egL4(3),keyVelSens(3),opRateScale(3),0,gain,gate);
  op3Freq = select2(opMode(2),opFreq(2)*freq,opFreq(2)) + opDetune(2)/4;
  op3 = dx7_op(op3Freq,0,outLevel(2),egR1(2),egR2(2),egR3(2),egR4(2),egL1(2),egL2(2),egL3(2),egL4(2),keyVelSens(2),opRateScale(2),1,gain,gate);
  op2Freq = select2(opMode(1),opFreq(1)*freq,opFreq(1)) + opDetune(1)/4;
  op2 = dx7_op(op2Freq,_,outLevel(1),egR1(1),egR2(1),egR3(1),egR4(1),egL1(1),egL2(1),egL3(1),egL4(1),keyVelSens(1),opRateScale(1),1,gain,gate);
  op1Freq = select2(opMode(0),opFreq(0)*freq,opFreq(0)) + opDetune(0)/4;
  op1 = dx7_op(op1Freq,_,outLevel(0),egR1(0),egR2(0),egR3(0),egR4(0),egL1(0),egL2(0),egL3(0),egL4(0),keyVelSens(0),opRateScale(0),0,gain,gate);
};

// Alg 12
// NOTE: the .2 for feedback was hardcoded in the csound orchestra, not sure why
// we need it
dx7_algo(11,egR1,egR2,egR3,egR4,egL1,egL2,egL3,egL4,outLevel,keyVelSens,ampModSens,opMode,opFreq,opDetune,opRateScale,feedback,lfoDelay,lfoDepth,lfoSpeed,freq,gain,gate) =
(op4,op5,op6 :> op3),(op2~*(feedback*.2) : op1) :> _
with{
  op6Freq = select2(opMode(5),opFreq(5)*freq,opFreq(5)) + opDetune(5)/4;
  op6 = dx7_op(op6Freq,0,outLevel(5),egR1(5),egR2(5),egR3(5),egR4(5),egL1(5),egL2(5),egL3(5),egL4(5),keyVelSens(5),opRateScale(5),1,gain,gate);
  op5Freq = select2(opMode(4),opFreq(4)*freq,opFreq(4)) + opDetune(4)/4;
  op5 = dx7_op(op5Freq,0,outLevel(4),egR1(4),egR2(4),egR3(4),egR4(4),egL1(4),egL2(4),egL3(4),egL4(4),keyVelSens(4),opRateScale(4),1,gain,gate);
  op4Freq = select2(opMode(3),opFreq(3)*freq,opFreq(3)) + opDetune(3)/4;
  op4 = dx7_op(op4Freq,0,outLevel(3),egR1(3),egR2(3),egR3(3),egR4(3),egL1(3),egL2(3),egL3(3),egL4(3),keyVelSens(3),opRateScale(3),1,gain,gate);
  op3Freq = select2(opMode(2),opFreq(2)*freq,opFreq(2)) + opDetune(2)/4;
  op3 = dx7_op(op3Freq,_,outLevel(2),egR1(2),egR2(2),egR3(2),egR4(2),egL1(2),egL2(2),egL3(2),egL4(2),keyVelSens(2),opRateScale(2),0,gain,gate);
  op2Freq = select2(opMode(1),opFreq(1)*freq,opFreq(1)) + opDetune(1)/4;
  op2 = dx7_op(op2Freq,_,outLevel(1),egR1(1),egR2(1),egR3(1),egR4(1),egL1(1),egL2(1),egL3(1),egL4(1),keyVelSens(1),opRateScale(1),1,gain,gate);
  op1Freq = select2(opMode(0),opFreq(0)*freq,opFreq(0)) + opDetune(0)/4;
  op1 = dx7_op(op1Freq,_,outLevel(0),egR1(0),egR2(0),egR3(0),egR4(0),egL1(0),egL2(0),egL3(0),egL4(0),keyVelSens(0),opRateScale(0),0,gain,gate);
};

// Alg 13
dx7_algo(12,egR1,egR2,egR3,egR4,egL1,egL2,egL3,egL4,outLevel,keyVelSens,ampModSens,opMode,opFreq,opDetune,opRateScale,feedback,lfoDelay,lfoDepth,lfoSpeed,freq,gain,gate) =
(op4,op5,op6~*(feedback) :> op3),(op2 : op1) :> _
with{
  op6Freq = select2(opMode(5),opFreq(5)*freq,opFreq(5)) + opDetune(5)/4;
  op6 = dx7_op(op6Freq,_,outLevel(5),egR1(5),egR2(5),egR3(5),egR4(5),egL1(5),egL2(5),egL3(5),egL4(5),keyVelSens(5),opRateScale(5),1,gain,gate);
  op5Freq = select2(opMode(4),opFreq(4)*freq,opFreq(4)) + opDetune(4)/4;
  op5 = dx7_op(op5Freq,0,outLevel(4),egR1(4),egR2(4),egR3(4),egR4(4),egL1(4),egL2(4),egL3(4),egL4(4),keyVelSens(4),opRateScale(4),1,gain,gate);
  op4Freq = select2(opMode(3),opFreq(3)*freq,opFreq(3)) + opDetune(3)/4;
  op4 = dx7_op(op4Freq,0,outLevel(3),egR1(3),egR2(3),egR3(3),egR4(3),egL1(3),egL2(3),egL3(3),egL4(3),keyVelSens(3),opRateScale(3),1,gain,gate);
  op3Freq = select2(opMode(2),opFreq(2)*freq,opFreq(2)) + opDetune(2)/4;
  op3 = dx7_op(op3Freq,_,outLevel(2),egR1(2),egR2(2),egR3(2),egR4(2),egL1(2),egL2(2),egL3(2),egL4(2),keyVelSens(2),opRateScale(2),0,gain,gate);
  op2Freq = select2(opMode(1),opFreq(1)*freq,opFreq(1)) + opDetune(1)/4;
  op2 = dx7_op(op2Freq,0,outLevel(1),egR1(1),egR2(1),egR3(1),egR4(1),egL1(1),egL2(1),egL3(1),egL4(1),keyVelSens(1),opRateScale(1),1,gain,gate);
  op1Freq = select2(opMode(0),opFreq(0)*freq,opFreq(0)) + opDetune(0)/4;
  op1 = dx7_op(op1Freq,_,outLevel(0),egR1(0),egR2(0),egR3(0),egR4(0),egL1(0),egL2(0),egL3(0),egL4(0),keyVelSens(0),opRateScale(0),0,gain,gate);
};

// Alg 14
dx7_algo(13,egR1,egR2,egR3,egR4,egL1,egL2,egL3,egL4,outLevel,keyVelSens,ampModSens,opMode,opFreq,opDetune,opRateScale,feedback,lfoDelay,lfoDepth,lfoSpeed,freq,gain,gate) =
(op2 : op1),(op5,op6~*(feedback) :> op4 : op3) :> _
with{
  op6Freq = select2(opMode(5),opFreq(5)*freq,opFreq(5)) + opDetune(5)/4;
  op6 = dx7_op(op6Freq,_,outLevel(5),egR1(5),egR2(5),egR3(5),egR4(5),egL1(5),egL2(5),egL3(5),egL4(5),keyVelSens(5),opRateScale(5),1,gain,gate);
  op5Freq = select2(opMode(4),opFreq(4)*freq,opFreq(4)) + opDetune(4)/4;
  op5 = dx7_op(op5Freq,0,outLevel(4),egR1(4),egR2(4),egR3(4),egR4(4),egL1(4),egL2(4),egL3(4),egL4(4),keyVelSens(4),opRateScale(4),1,gain,gate);
  op4Freq = select2(opMode(3),opFreq(3)*freq,opFreq(3)) + opDetune(3)/4;
  op4 = dx7_op(op4Freq,_,outLevel(3),egR1(3),egR2(3),egR3(3),egR4(3),egL1(3),egL2(3),egL3(3),egL4(3),keyVelSens(3),opRateScale(3),1,gain,gate);
  op3Freq = select2(opMode(2),opFreq(2)*freq,opFreq(2)) + opDetune(2)/4;
  op3 = dx7_op(op3Freq,_,outLevel(2),egR1(2),egR2(2),egR3(2),egR4(2),egL1(2),egL2(2),egL3(2),egL4(2),keyVelSens(2),opRateScale(2),0,gain,gate);
  op2Freq = select2(opMode(1),opFreq(1)*freq,opFreq(1)) + opDetune(1)/4;
  op2 = dx7_op(op2Freq,0,outLevel(1),egR1(1),egR2(1),egR3(1),egR4(1),egL1(1),egL2(1),egL3(1),egL4(1),keyVelSens(1),opRateScale(1),1,gain,gate);
  op1Freq = select2(opMode(0),opFreq(0)*freq,opFreq(0)) + opDetune(0)/4;
  op1 = dx7_op(op1Freq,_,outLevel(0),egR1(0),egR2(0),egR3(0),egR4(0),egL1(0),egL2(0),egL3(0),egL4(0),keyVelSens(0),opRateScale(0),0,gain,gate);
};

// Alg 15
// NOTE: the .4 for feedback was hardcoded in the csound orchestra, not sure why
// we need it
dx7_algo(14,egR1,egR2,egR3,egR4,egL1,egL2,egL3,egL4,outLevel,keyVelSens,ampModSens,opMode,opFreq,opDetune,opRateScale,feedback,lfoDelay,lfoDepth,lfoSpeed,freq,gain,gate) =
(op2~*(feedback*.4) : op1),(op5,op6 :> op4 : op3) :> _
with{
  op6Freq = select2(opMode(5),opFreq(5)*freq,opFreq(5)) + opDetune(5)/4;
  op6 = dx7_op(op6Freq,0,outLevel(5),egR1(5),egR2(5),egR3(5),egR4(5),egL1(5),egL2(5),egL3(5),egL4(5),keyVelSens(5),opRateScale(5),1,gain,gate);
  op5Freq = select2(opMode(4),opFreq(4)*freq,opFreq(4)) + opDetune(4)/4;
  op5 = dx7_op(op5Freq,0,outLevel(4),egR1(4),egR2(4),egR3(4),egR4(4),egL1(4),egL2(4),egL3(4),egL4(4),keyVelSens(4),opRateScale(4),1,gain,gate);
  op4Freq = select2(opMode(3),opFreq(3)*freq,opFreq(3)) + opDetune(3)/4;
  op4 = dx7_op(op4Freq,_,outLevel(3),egR1(3),egR2(3),egR3(3),egR4(3),egL1(3),egL2(3),egL3(3),egL4(3),keyVelSens(3),opRateScale(3),1,gain,gate);
  op3Freq = select2(opMode(2),opFreq(2)*freq,opFreq(2)) + opDetune(2)/4;
  op3 = dx7_op(op3Freq,_,outLevel(2),egR1(2),egR2(2),egR3(2),egR4(2),egL1(2),egL2(2),egL3(2),egL4(2),keyVelSens(2),opRateScale(2),0,gain,gate);
  op2Freq = select2(opMode(1),opFreq(1)*freq,opFreq(1)) + opDetune(1)/4;
  op2 = dx7_op(op2Freq,_,outLevel(1),egR1(1),egR2(1),egR3(1),egR4(1),egL1(1),egL2(1),egL3(1),egL4(1),keyVelSens(1),opRateScale(1),1,gain,gate);
  op1Freq = select2(opMode(0),opFreq(0)*freq,opFreq(0)) + opDetune(0)/4;
  op1 = dx7_op(op1Freq,_,outLevel(0),egR1(0),egR2(0),egR3(0),egR4(0),egL1(0),egL2(0),egL3(0),egL4(0),keyVelSens(0),opRateScale(0),0,gain,gate);
};

// Alg 16
dx7_algo(15,egR1,egR2,egR3,egR4,egL1,egL2,egL3,egL4,outLevel,keyVelSens,ampModSens,opMode,opFreq,opDetune,opRateScale,feedback,lfoDelay,lfoDepth,lfoSpeed,freq,gain,gate) =
op2,(op4 : op3),(op6~*(feedback) : op5) :> op1
with{
  op6Freq = select2(opMode(5),opFreq(5)*freq,opFreq(5)) + opDetune(5)/4;
  op6 = dx7_op(op6Freq,_,outLevel(5),egR1(5),egR2(5),egR3(5),egR4(5),egL1(5),egL2(5),egL3(5),egL4(5),keyVelSens(5),opRateScale(5),1,gain,gate);
  op5Freq = select2(opMode(4),opFreq(4)*freq,opFreq(4)) + opDetune(4)/4;
  op5 = dx7_op(op5Freq,_,outLevel(4),egR1(4),egR2(4),egR3(4),egR4(4),egL1(4),egL2(4),egL3(4),egL4(4),keyVelSens(4),opRateScale(4),1,gain,gate);
  op4Freq = select2(opMode(3),opFreq(3)*freq,opFreq(3)) + opDetune(3)/4;
  op4 = dx7_op(op4Freq,0,outLevel(3),egR1(3),egR2(3),egR3(3),egR4(3),egL1(3),egL2(3),egL3(3),egL4(3),keyVelSens(3),opRateScale(3),1,gain,gate);
  op3Freq = select2(opMode(2),opFreq(2)*freq,opFreq(2)) + opDetune(2)/4;
  op3 = dx7_op(op3Freq,_,outLevel(2),egR1(2),egR2(2),egR3(2),egR4(2),egL1(2),egL2(2),egL3(2),egL4(2),keyVelSens(2),opRateScale(2),1,gain,gate);
  op2Freq = select2(opMode(1),opFreq(1)*freq,opFreq(1)) + opDetune(1)/4;
  op2 = dx7_op(op2Freq,0,outLevel(1),egR1(1),egR2(1),egR3(1),egR4(1),egL1(1),egL2(1),egL3(1),egL4(1),keyVelSens(1),opRateScale(1),1,gain,gate);
  op1Freq = select2(opMode(0),opFreq(0)*freq,opFreq(0)) + opDetune(0)/4;
  op1 = dx7_op(op1Freq,_,outLevel(0),egR1(0),egR2(0),egR3(0),egR4(0),egL1(0),egL2(0),egL3(0),egL4(0),keyVelSens(0),opRateScale(0),0,gain,gate);
};

// Alg 17
// NOTE: the .5 for feedback was hardcoded in the csound orchestra, not sure why
// we need it
dx7_algo(16,egR1,egR2,egR3,egR4,egL1,egL2,egL3,egL4,outLevel,keyVelSens,ampModSens,opMode,opFreq,opDetune,opRateScale,feedback,lfoDelay,lfoDepth,lfoSpeed,freq,gain,gate) =
op2~*(feedback*.5),(op4 : op3),(op6 : op5) :> op1
with{
  op6Freq = select2(opMode(5),opFreq(5)*freq,opFreq(5)) + opDetune(5)/4;
  op6 = dx7_op(op6Freq,0,outLevel(5),egR1(5),egR2(5),egR3(5),egR4(5),egL1(5),egL2(5),egL3(5),egL4(5),keyVelSens(5),opRateScale(5),1,gain,gate);
  op5Freq = select2(opMode(4),opFreq(4)*freq,opFreq(4)) + opDetune(4)/4;
  op5 = dx7_op(op5Freq,_,outLevel(4),egR1(4),egR2(4),egR3(4),egR4(4),egL1(4),egL2(4),egL3(4),egL4(4),keyVelSens(4),opRateScale(4),1,gain,gate);
  op4Freq = select2(opMode(3),opFreq(3)*freq,opFreq(3)) + opDetune(3)/4;
  op4 = dx7_op(op4Freq,0,outLevel(3),egR1(3),egR2(3),egR3(3),egR4(3),egL1(3),egL2(3),egL3(3),egL4(3),keyVelSens(3),opRateScale(3),1,gain,gate);
  op3Freq = select2(opMode(2),opFreq(2)*freq,opFreq(2)) + opDetune(2)/4;
  op3 = dx7_op(op3Freq,_,outLevel(2),egR1(2),egR2(2),egR3(2),egR4(2),egL1(2),egL2(2),egL3(2),egL4(2),keyVelSens(2),opRateScale(2),1,gain,gate);
  op2Freq = select2(opMode(1),opFreq(1)*freq,opFreq(1)) + opDetune(1)/4;
  op2 = dx7_op(op2Freq,_,outLevel(1),egR1(1),egR2(1),egR3(1),egR4(1),egL1(1),egL2(1),egL3(1),egL4(1),keyVelSens(1),opRateScale(1),1,gain,gate);
  op1Freq = select2(opMode(0),opFreq(0)*freq,opFreq(0)) + opDetune(0)/4;
  op1 = dx7_op(op1Freq,_,outLevel(0),egR1(0),egR2(0),egR3(0),egR4(0),egL1(0),egL2(0),egL3(0),egL4(0),keyVelSens(0),opRateScale(0),0,gain,gate);
};

// Alg 18
dx7_algo(17,egR1,egR2,egR3,egR4,egL1,egL2,egL3,egL4,outLevel,keyVelSens,ampModSens,opMode,opFreq,opDetune,opRateScale,feedback,lfoDelay,lfoDepth,lfoSpeed,freq,gain,gate) =
op2,op3~*(feedback),(op6 : op5 : op4) :> op1
with{
  op6Freq = select2(opMode(5),opFreq(5)*freq,opFreq(5)) + opDetune(5)/4;
  op6 = dx7_op(op6Freq,0,outLevel(5),egR1(5),egR2(5),egR3(5),egR4(5),egL1(5),egL2(5),egL3(5),egL4(5),keyVelSens(5),opRateScale(5),1,gain,gate);
  op5Freq = select2(opMode(4),opFreq(4)*freq,opFreq(4)) + opDetune(4)/4;
  op5 = dx7_op(op5Freq,_,outLevel(4),egR1(4),egR2(4),egR3(4),egR4(4),egL1(4),egL2(4),egL3(4),egL4(4),keyVelSens(4),opRateScale(4),1,gain,gate);
  op4Freq = select2(opMode(3),opFreq(3)*freq,opFreq(3)) + opDetune(3)/4;
  op4 = dx7_op(op4Freq,_,outLevel(3),egR1(3),egR2(3),egR3(3),egR4(3),egL1(3),egL2(3),egL3(3),egL4(3),keyVelSens(3),opRateScale(3),1,gain,gate);
  op3Freq = select2(opMode(2),opFreq(2)*freq,opFreq(2)) + opDetune(2)/4;
  op3 = dx7_op(op3Freq,_,outLevel(2),egR1(2),egR2(2),egR3(2),egR4(2),egL1(2),egL2(2),egL3(2),egL4(2),keyVelSens(2),opRateScale(2),1,gain,gate);
  op2Freq = select2(opMode(1),opFreq(1)*freq,opFreq(1)) + opDetune(1)/4;
  op2 = dx7_op(op2Freq,0,outLevel(1),egR1(1),egR2(1),egR3(1),egR4(1),egL1(1),egL2(1),egL3(1),egL4(1),keyVelSens(1),opRateScale(1),1,gain,gate);
  op1Freq = select2(opMode(0),opFreq(0)*freq,opFreq(0)) + opDetune(0)/4;
  op1 = dx7_op(op1Freq,_,outLevel(0),egR1(0),egR2(0),egR3(0),egR4(0),egL1(0),egL2(0),egL3(0),egL4(0),keyVelSens(0),opRateScale(0),0,gain,gate);
};

// Alg 19
// NOTE: the .4 for feedback was hardcoded in the csound orchestra, not sure why
// we need it
dx7_algo(18,egR1,egR2,egR3,egR4,egL1,egL2,egL3,egL4,outLevel,keyVelSens,ampModSens,opMode,opFreq,opDetune,opRateScale,feedback,lfoDelay,lfoDepth,lfoSpeed,freq,gain,gate) =
(op3 : op2 : op1),(op6~*(feedback*.4) <: op4,op5) :> _
with{
  op6Freq = select2(opMode(5),opFreq(5)*freq,opFreq(5)) + opDetune(5)/4;
  op6 = dx7_op(op6Freq,_,outLevel(5),egR1(5),egR2(5),egR3(5),egR4(5),egL1(5),egL2(5),egL3(5),egL4(5),keyVelSens(5),opRateScale(5),1,gain,gate);
  op5Freq = select2(opMode(4),opFreq(4)*freq,opFreq(4)) + opDetune(4)/4;
  op5 = dx7_op(op5Freq,_,outLevel(4),egR1(4),egR2(4),egR3(4),egR4(4),egL1(4),egL2(4),egL3(4),egL4(4),keyVelSens(4),opRateScale(4),0,gain,gate);
  op4Freq = select2(opMode(3),opFreq(3)*freq,opFreq(3)) + opDetune(3)/4;
  op4 = dx7_op(op4Freq,_,outLevel(3),egR1(3),egR2(3),egR3(3),egR4(3),egL1(3),egL2(3),egL3(3),egL4(3),keyVelSens(3),opRateScale(3),0,gain,gate);
  op3Freq = select2(opMode(2),opFreq(2)*freq,opFreq(2)) + opDetune(2)/4;
  op3 = dx7_op(op3Freq,0,outLevel(2),egR1(2),egR2(2),egR3(2),egR4(2),egL1(2),egL2(2),egL3(2),egL4(2),keyVelSens(2),opRateScale(2),1,gain,gate);
  op2Freq = select2(opMode(1),opFreq(1)*freq,opFreq(1)) + opDetune(1)/4;
  op2 = dx7_op(op2Freq,_,outLevel(1),egR1(1),egR2(1),egR3(1),egR4(1),egL1(1),egL2(1),egL3(1),egL4(1),keyVelSens(1),opRateScale(1),1,gain,gate);
  op1Freq = select2(opMode(0),opFreq(0)*freq,opFreq(0)) + opDetune(0)/4;
  op1 = dx7_op(op1Freq,_,outLevel(0),egR1(0),egR2(0),egR3(0),egR4(0),egL1(0),egL2(0),egL3(0),egL4(0),keyVelSens(0),opRateScale(0),0,gain,gate);
};

// Alg 20
dx7_algo(19,egR1,egR2,egR3,egR4,egL1,egL2,egL3,egL4,outLevel,keyVelSens,ampModSens,opMode,opFreq,opDetune,opRateScale,feedback,lfoDelay,lfoDepth,lfoSpeed,freq,gain,gate) =
(op3~*(feedback) <: op1,op2),(op5,op6 :> op4) :> _
with{
  op6Freq = select2(opMode(5),opFreq(5)*freq,opFreq(5)) + opDetune(5)/4;
  op6 = dx7_op(op6Freq,0,outLevel(5),egR1(5),egR2(5),egR3(5),egR4(5),egL1(5),egL2(5),egL3(5),egL4(5),keyVelSens(5),opRateScale(5),1,gain,gate);
  op5Freq = select2(opMode(4),opFreq(4)*freq,opFreq(4)) + opDetune(4)/4;
  op5 = dx7_op(op5Freq,0,outLevel(4),egR1(4),egR2(4),egR3(4),egR4(4),egL1(4),egL2(4),egL3(4),egL4(4),keyVelSens(4),opRateScale(4),1,gain,gate);
  op4Freq = select2(opMode(3),opFreq(3)*freq,opFreq(3)) + opDetune(3)/4;
  op4 = dx7_op(op4Freq,_,outLevel(3),egR1(3),egR2(3),egR3(3),egR4(3),egL1(3),egL2(3),egL3(3),egL4(3),keyVelSens(3),opRateScale(3),0,gain,gate);
  op3Freq = select2(opMode(2),opFreq(2)*freq,opFreq(2)) + opDetune(2)/4;
  op3 = dx7_op(op3Freq,_,outLevel(2),egR1(2),egR2(2),egR3(2),egR4(2),egL1(2),egL2(2),egL3(2),egL4(2),keyVelSens(2),opRateScale(2),1,gain,gate);
  op2Freq = select2(opMode(1),opFreq(1)*freq,opFreq(1)) + opDetune(1)/4;
  op2 = dx7_op(op2Freq,_,outLevel(1),egR1(1),egR2(1),egR3(1),egR4(1),egL1(1),egL2(1),egL3(1),egL4(1),keyVelSens(1),opRateScale(1),0,gain,gate);
  op1Freq = select2(opMode(0),opFreq(0)*freq,opFreq(0)) + opDetune(0)/4;
  op1 = dx7_op(op1Freq,_,outLevel(0),egR1(0),egR2(0),egR3(0),egR4(0),egL1(0),egL2(0),egL3(0),egL4(0),keyVelSens(0),opRateScale(0),0,gain,gate);
};

// Alg 21
dx7_algo(20,egR1,egR2,egR3,egR4,egL1,egL2,egL3,egL4,outLevel,keyVelSens,ampModSens,opMode,opFreq,opDetune,opRateScale,feedback,lfoDelay,lfoDepth,lfoSpeed,freq,gain,gate) =
(op3~*(feedback) <: op1,op2),(op6 <: op4,op5) :> _
with{
  op6Freq = select2(opMode(5),opFreq(5)*freq,opFreq(5)) + opDetune(5)/4;
  op6 = dx7_op(op6Freq,0,outLevel(5),egR1(5),egR2(5),egR3(5),egR4(5),egL1(5),egL2(5),egL3(5),egL4(5),keyVelSens(5),opRateScale(5),1,gain,gate);
  op5Freq = select2(opMode(4),opFreq(4)*freq,opFreq(4)) + opDetune(4)/4;
  op5 = dx7_op(op5Freq,_,outLevel(4),egR1(4),egR2(4),egR3(4),egR4(4),egL1(4),egL2(4),egL3(4),egL4(4),keyVelSens(4),opRateScale(4),0,gain,gate);
  op4Freq = select2(opMode(3),opFreq(3)*freq,opFreq(3)) + opDetune(3)/4;
  op4 = dx7_op(op4Freq,_,outLevel(3),egR1(3),egR2(3),egR3(3),egR4(3),egL1(3),egL2(3),egL3(3),egL4(3),keyVelSens(3),opRateScale(3),0,gain,gate);
  op3Freq = select2(opMode(2),opFreq(2)*freq,opFreq(2)) + opDetune(2)/4;
  op3 = dx7_op(op3Freq,_,outLevel(2),egR1(2),egR2(2),egR3(2),egR4(2),egL1(2),egL2(2),egL3(2),egL4(2),keyVelSens(2),opRateScale(2),1,gain,gate);
  op2Freq = select2(opMode(1),opFreq(1)*freq,opFreq(1)) + opDetune(1)/4;
  op2 = dx7_op(op2Freq,_,outLevel(1),egR1(1),egR2(1),egR3(1),egR4(1),egL1(1),egL2(1),egL3(1),egL4(1),keyVelSens(1),opRateScale(1),0,gain,gate);
  op1Freq = select2(opMode(0),opFreq(0)*freq,opFreq(0)) + opDetune(0)/4;
  op1 = dx7_op(op1Freq,_,outLevel(0),egR1(0),egR2(0),egR3(0),egR4(0),egL1(0),egL2(0),egL3(0),egL4(0),keyVelSens(0),opRateScale(0),0,gain,gate);
};

// Alg 22
// NOTE: the .1 for feedback was hardcoded in the csound orchestra, not sure why
// we need it
dx7_algo(21,egR1,egR2,egR3,egR4,egL1,egL2,egL3,egL4,outLevel,keyVelSens,ampModSens,opMode,opFreq,opDetune,opRateScale,feedback,lfoDelay,lfoDepth,lfoSpeed,freq,gain,gate) =
(op2 : op1),(op6~*(feedback*.1) <: op3,op4,op5) :> _
with{
  op6Freq = select2(opMode(5),opFreq(5)*freq,opFreq(5)) + opDetune(5)/4;
  op6 = dx7_op(op6Freq,_,outLevel(5),egR1(5),egR2(5),egR3(5),egR4(5),egL1(5),egL2(5),egL3(5),egL4(5),keyVelSens(5),opRateScale(5),1,gain,gate);
  op5Freq = select2(opMode(4),opFreq(4)*freq,opFreq(4)) + opDetune(4)/4;
  op5 = dx7_op(op5Freq,_,outLevel(4),egR1(4),egR2(4),egR3(4),egR4(4),egL1(4),egL2(4),egL3(4),egL4(4),keyVelSens(4),opRateScale(4),0,gain,gate);
  op4Freq = select2(opMode(3),opFreq(3)*freq,opFreq(3)) + opDetune(3)/4;
  op4 = dx7_op(op4Freq,_,outLevel(3),egR1(3),egR2(3),egR3(3),egR4(3),egL1(3),egL2(3),egL3(3),egL4(3),keyVelSens(3),opRateScale(3),0,gain,gate);
  op3Freq = select2(opMode(2),opFreq(2)*freq,opFreq(2)) + opDetune(2)/4;
  op3 = dx7_op(op3Freq,_,outLevel(2),egR1(2),egR2(2),egR3(2),egR4(2),egL1(2),egL2(2),egL3(2),egL4(2),keyVelSens(2),opRateScale(2),1,gain,gate);
  op2Freq = select2(opMode(1),opFreq(1)*freq,opFreq(1)) + opDetune(1)/4;
  op2 = dx7_op(op2Freq,0,outLevel(1),egR1(1),egR2(1),egR3(1),egR4(1),egL1(1),egL2(1),egL3(1),egL4(1),keyVelSens(1),opRateScale(1),0,gain,gate);
  op1Freq = select2(opMode(0),opFreq(0)*freq,opFreq(0)) + opDetune(0)/4;
  op1 = dx7_op(op1Freq,_,outLevel(0),egR1(0),egR2(0),egR3(0),egR4(0),egL1(0),egL2(0),egL3(0),egL4(0),keyVelSens(0),opRateScale(0),0,gain,gate);
};

// Alg 23
dx7_algo(22,egR1,egR2,egR3,egR4,egL1,egL2,egL3,egL4,outLevel,keyVelSens,ampModSens,opMode,opFreq,opDetune,opRateScale,feedback,lfoDelay,lfoDepth,lfoSpeed,freq,gain,gate) =
op1,(op3 : op2),(op6~*(feedback) <: op4,op5) :> _
with{
  op6Freq = select2(opMode(5),opFreq(5)*freq,opFreq(5)) + opDetune(5)/4;
  op6 = dx7_op(op6Freq,_,outLevel(5),egR1(5),egR2(5),egR3(5),egR4(5),egL1(5),egL2(5),egL3(5),egL4(5),keyVelSens(5),opRateScale(5),1,gain,gate);
  op5Freq = select2(opMode(4),opFreq(4)*freq,opFreq(4)) + opDetune(4)/4;
  op5 = dx7_op(op5Freq,_,outLevel(4),egR1(4),egR2(4),egR3(4),egR4(4),egL1(4),egL2(4),egL3(4),egL4(4),keyVelSens(4),opRateScale(4),0,gain,gate);
  op4Freq = select2(opMode(3),opFreq(3)*freq,opFreq(3)) + opDetune(3)/4;
  op4 = dx7_op(op4Freq,_,outLevel(3),egR1(3),egR2(3),egR3(3),egR4(3),egL1(3),egL2(3),egL3(3),egL4(3),keyVelSens(3),opRateScale(3),0,gain,gate);
  op3Freq = select2(opMode(2),opFreq(2)*freq,opFreq(2)) + opDetune(2)/4;
  op3 = dx7_op(op3Freq,0,outLevel(2),egR1(2),egR2(2),egR3(2),egR4(2),egL1(2),egL2(2),egL3(2),egL4(2),keyVelSens(2),opRateScale(2),1,gain,gate);
  op2Freq = select2(opMode(1),opFreq(1)*freq,opFreq(1)) + opDetune(1)/4;
  op2 = dx7_op(op2Freq,_,outLevel(1),egR1(1),egR2(1),egR3(1),egR4(1),egL1(1),egL2(1),egL3(1),egL4(1),keyVelSens(1),opRateScale(1),0,gain,gate);
  op1Freq = select2(opMode(0),opFreq(0)*freq,opFreq(0)) + opDetune(0)/4;
  op1 = dx7_op(op1Freq,0,outLevel(0),egR1(0),egR2(0),egR3(0),egR4(0),egL1(0),egL2(0),egL3(0),egL4(0),keyVelSens(0),opRateScale(0),0,gain,gate);
};

// Alg 24
// NOTE: the .6 for feedback was hardcoded in the csound orchestra, not sure why
// we need it
dx7_algo(23,egR1,egR2,egR3,egR4,egL1,egL2,egL3,egL4,outLevel,keyVelSens,ampModSens,opMode,opFreq,opDetune,opRateScale,feedback,lfoDelay,lfoDepth,lfoSpeed,freq,gain,gate) =
op1,op2,(op6~*(feedback*.6) <: op3,op4,op5) :> _
with{
  op6Freq = select2(opMode(5),opFreq(5)*freq,opFreq(5)) + opDetune(5)/4;
  op6 = dx7_op(op6Freq,_,outLevel(5),egR1(5),egR2(5),egR3(5),egR4(5),egL1(5),egL2(5),egL3(5),egL4(5),keyVelSens(5),opRateScale(5),1,gain,gate);
  op5Freq = select2(opMode(4),opFreq(4)*freq,opFreq(4)) + opDetune(4)/4;
  op5 = dx7_op(op5Freq,_,outLevel(4),egR1(4),egR2(4),egR3(4),egR4(4),egL1(4),egL2(4),egL3(4),egL4(4),keyVelSens(4),opRateScale(4),0,gain,gate);
  op4Freq = select2(opMode(3),opFreq(3)*freq,opFreq(3)) + opDetune(3)/4;
  op4 = dx7_op(op4Freq,_,outLevel(3),egR1(3),egR2(3),egR3(3),egR4(3),egL1(3),egL2(3),egL3(3),egL4(3),keyVelSens(3),opRateScale(3),0,gain,gate);
  op3Freq = select2(opMode(2),opFreq(2)*freq,opFreq(2)) + opDetune(2)/4;
  op3 = dx7_op(op3Freq,_,outLevel(2),egR1(2),egR2(2),egR3(2),egR4(2),egL1(2),egL2(2),egL3(2),egL4(2),keyVelSens(2),opRateScale(2),0,gain,gate);
  op2Freq = select2(opMode(1),opFreq(1)*freq,opFreq(1)) + opDetune(1)/4;
  op2 = dx7_op(op2Freq,0,outLevel(1),egR1(1),egR2(1),egR3(1),egR4(1),egL1(1),egL2(1),egL3(1),egL4(1),keyVelSens(1),opRateScale(1),0,gain,gate);
  op1Freq = select2(opMode(0),opFreq(0)*freq,opFreq(0)) + opDetune(0)/4;
  op1 = dx7_op(op1Freq,0,outLevel(0),egR1(0),egR2(0),egR3(0),egR4(0),egL1(0),egL2(0),egL3(0),egL4(0),keyVelSens(0),opRateScale(0),0,gain,gate);
};

// Alg 25
dx7_algo(24,egR1,egR2,egR3,egR4,egL1,egL2,egL3,egL4,outLevel,keyVelSens,ampModSens,opMode,opFreq,opDetune,opRateScale,feedback,lfoDelay,lfoDepth,lfoSpeed,freq,gain,gate) =
op1,op2,op3,(op6~*(feedback) <: op4,op5) :> _
with{
  op6Freq = select2(opMode(5),opFreq(5)*freq,opFreq(5)) + opDetune(5)/4;
  op6 = dx7_op(op6Freq,_,outLevel(5),egR1(5),egR2(5),egR3(5),egR4(5),egL1(5),egL2(5),egL3(5),egL4(5),keyVelSens(5),opRateScale(5),1,gain,gate);
  op5Freq = select2(opMode(4),opFreq(4)*freq,opFreq(4)) + opDetune(4)/4;
  op5 = dx7_op(op5Freq,_,outLevel(4),egR1(4),egR2(4),egR3(4),egR4(4),egL1(4),egL2(4),egL3(4),egL4(4),keyVelSens(4),opRateScale(4),0,gain,gate);
  op4Freq = select2(opMode(3),opFreq(3)*freq,opFreq(3)) + opDetune(3)/4;
  op4 = dx7_op(op4Freq,_,outLevel(3),egR1(3),egR2(3),egR3(3),egR4(3),egL1(3),egL2(3),egL3(3),egL4(3),keyVelSens(3),opRateScale(3),0,gain,gate);
  op3Freq = select2(opMode(2),opFreq(2)*freq,opFreq(2)) + opDetune(2)/4;
  op3 = dx7_op(op3Freq,0,outLevel(2),egR1(2),egR2(2),egR3(2),egR4(2),egL1(2),egL2(2),egL3(2),egL4(2),keyVelSens(2),opRateScale(2),0,gain,gate);
  op2Freq = select2(opMode(1),opFreq(1)*freq,opFreq(1)) + opDetune(1)/4;
  op2 = dx7_op(op2Freq,0,outLevel(1),egR1(1),egR2(1),egR3(1),egR4(1),egL1(1),egL2(1),egL3(1),egL4(1),keyVelSens(1),opRateScale(1),0,gain,gate);
  op1Freq = select2(opMode(0),opFreq(0)*freq,opFreq(0)) + opDetune(0)/4;
  op1 = dx7_op(op1Freq,0,outLevel(0),egR1(0),egR2(0),egR3(0),egR4(0),egL1(0),egL2(0),egL3(0),egL4(0),keyVelSens(0),opRateScale(0),0,gain,gate);
};

// Alg 26
dx7_algo(25,egR1,egR2,egR3,egR4,egL1,egL2,egL3,egL4,outLevel,keyVelSens,ampModSens,opMode,opFreq,opDetune,opRateScale,feedback,lfoDelay,lfoDepth,lfoSpeed,freq,gain,gate) =
op1,(op3 : op2),(op5,op6~*(feedback) :> op4) :> _
with{
  op6Freq = select2(opMode(5),opFreq(5)*freq,opFreq(5)) + opDetune(5)/4;
  op6 = dx7_op(op6Freq,_,outLevel(5),egR1(5),egR2(5),egR3(5),egR4(5),egL1(5),egL2(5),egL3(5),egL4(5),keyVelSens(5),opRateScale(5),1,gain,gate);
  op5Freq = select2(opMode(4),opFreq(4)*freq,opFreq(4)) + opDetune(4)/4;
  op5 = dx7_op(op5Freq,0,outLevel(4),egR1(4),egR2(4),egR3(4),egR4(4),egL1(4),egL2(4),egL3(4),egL4(4),keyVelSens(4),opRateScale(4),1,gain,gate);
  op4Freq = select2(opMode(3),opFreq(3)*freq,opFreq(3)) + opDetune(3)/4;
  op4 = dx7_op(op4Freq,_,outLevel(3),egR1(3),egR2(3),egR3(3),egR4(3),egL1(3),egL2(3),egL3(3),egL4(3),keyVelSens(3),opRateScale(3),0,gain,gate);
  op3Freq = select2(opMode(2),opFreq(2)*freq,opFreq(2)) + opDetune(2)/4;
  op3 = dx7_op(op3Freq,0,outLevel(2),egR1(2),egR2(2),egR3(2),egR4(2),egL1(2),egL2(2),egL3(2),egL4(2),keyVelSens(2),opRateScale(2),1,gain,gate);
  op2Freq = select2(opMode(1),opFreq(1)*freq,opFreq(1)) + opDetune(1)/4;
  op2 = dx7_op(op2Freq,_,outLevel(1),egR1(1),egR2(1),egR3(1),egR4(1),egL1(1),egL2(1),egL3(1),egL4(1),keyVelSens(1),opRateScale(1),0,gain,gate);
  op1Freq = select2(opMode(0),opFreq(0)*freq,opFreq(0)) + opDetune(0)/4;
  op1 = dx7_op(op1Freq,0,outLevel(0),egR1(0),egR2(0),egR3(0),egR4(0),egL1(0),egL2(0),egL3(0),egL4(0),keyVelSens(0),opRateScale(0),0,gain,gate);
};

// Alg 27
dx7_algo(26,egR1,egR2,egR3,egR4,egL1,egL2,egL3,egL4,outLevel,keyVelSens,ampModSens,opMode,opFreq,opDetune,opRateScale,feedback,lfoDelay,lfoDepth,lfoSpeed,freq,gain,gate) =
op1,(op3~*(feedback) : op2),(op5,op6 :> op4) :> _
with{
  op6Freq = select2(opMode(5),opFreq(5)*freq,opFreq(5)) + opDetune(5)/4;
  op6 = dx7_op(op6Freq,0,outLevel(5),egR1(5),egR2(5),egR3(5),egR4(5),egL1(5),egL2(5),egL3(5),egL4(5),keyVelSens(5),opRateScale(5),1,gain,gate);
  op5Freq = select2(opMode(4),opFreq(4)*freq,opFreq(4)) + opDetune(4)/4;
  op5 = dx7_op(op5Freq,0,outLevel(4),egR1(4),egR2(4),egR3(4),egR4(4),egL1(4),egL2(4),egL3(4),egL4(4),keyVelSens(4),opRateScale(4),1,gain,gate);
  op4Freq = select2(opMode(3),opFreq(3)*freq,opFreq(3)) + opDetune(3)/4;
  op4 = dx7_op(op4Freq,_,outLevel(3),egR1(3),egR2(3),egR3(3),egR4(3),egL1(3),egL2(3),egL3(3),egL4(3),keyVelSens(3),opRateScale(3),0,gain,gate);
  op3Freq = select2(opMode(2),opFreq(2)*freq,opFreq(2)) + opDetune(2)/4;
  op3 = dx7_op(op3Freq,_,outLevel(2),egR1(2),egR2(2),egR3(2),egR4(2),egL1(2),egL2(2),egL3(2),egL4(2),keyVelSens(2),opRateScale(2),1,gain,gate);
  op2Freq = select2(opMode(1),opFreq(1)*freq,opFreq(1)) + opDetune(1)/4;
  op2 = dx7_op(op2Freq,_,outLevel(1),egR1(1),egR2(1),egR3(1),egR4(1),egL1(1),egL2(1),egL3(1),egL4(1),keyVelSens(1),opRateScale(1),0,gain,gate);
  op1Freq = select2(opMode(0),opFreq(0)*freq,opFreq(0)) + opDetune(0)/4;
  op1 = dx7_op(op1Freq,0,outLevel(0),egR1(0),egR2(0),egR3(0),egR4(0),egL1(0),egL2(0),egL3(0),egL4(0),keyVelSens(0),opRateScale(0),0,gain,gate);
};

// Alg 28
dx7_algo(27,egR1,egR2,egR3,egR4,egL1,egL2,egL3,egL4,outLevel,keyVelSens,ampModSens,opMode,opFreq,opDetune,opRateScale,feedback,lfoDelay,lfoDepth,lfoSpeed,freq,gain,gate) =
(op2 : op1),(op5~*(feedback) : op4 : op3),op6 :> _
with{
  op6Freq = select2(opMode(5),opFreq(5)*freq,opFreq(5)) + opDetune(5)/4;
  op6 = dx7_op(op6Freq,0,outLevel(5),egR1(5),egR2(5),egR3(5),egR4(5),egL1(5),egL2(5),egL3(5),egL4(5),keyVelSens(5),opRateScale(5),0,gain,gate);
  op5Freq = select2(opMode(4),opFreq(4)*freq,opFreq(4)) + opDetune(4)/4;
  op5 = dx7_op(op5Freq,_,outLevel(4),egR1(4),egR2(4),egR3(4),egR4(4),egL1(4),egL2(4),egL3(4),egL4(4),keyVelSens(4),opRateScale(4),1,gain,gate);
  op4Freq = select2(opMode(3),opFreq(3)*freq,opFreq(3)) + opDetune(3)/4;
  op4 = dx7_op(op4Freq,_,outLevel(3),egR1(3),egR2(3),egR3(3),egR4(3),egL1(3),egL2(3),egL3(3),egL4(3),keyVelSens(3),opRateScale(3),1,gain,gate);
  op3Freq = select2(opMode(2),opFreq(2)*freq,opFreq(2)) + opDetune(2)/4;
  op3 = dx7_op(op3Freq,_,outLevel(2),egR1(2),egR2(2),egR3(2),egR4(2),egL1(2),egL2(2),egL3(2),egL4(2),keyVelSens(2),opRateScale(2),0,gain,gate);
  op2Freq = select2(opMode(1),opFreq(1)*freq,opFreq(1)) + opDetune(1)/4;
  op2 = dx7_op(op2Freq,0,outLevel(1),egR1(1),egR2(1),egR3(1),egR4(1),egL1(1),egL2(1),egL3(1),egL4(1),keyVelSens(1),opRateScale(1),1,gain,gate);
  op1Freq = select2(opMode(0),opFreq(0)*freq,opFreq(0)) + opDetune(0)/4;
  op1 = dx7_op(op1Freq,_,outLevel(0),egR1(0),egR2(0),egR3(0),egR4(0),egL1(0),egL2(0),egL3(0),egL4(0),keyVelSens(0),opRateScale(0),0,gain,gate);
};

// Alg 29
dx7_algo(28,egR1,egR2,egR3,egR4,egL1,egL2,egL3,egL4,outLevel,keyVelSens,ampModSens,opMode,opFreq,opDetune,opRateScale,feedback,lfoDelay,lfoDepth,lfoSpeed,freq,gain,gate) =
op1,op2,(op4 : op3),(op6~*(feedback) : op5) :> _
with{
  op6Freq = select2(opMode(5),opFreq(5)*freq,opFreq(5)) + opDetune(5)/4;
  op6 = dx7_op(op6Freq,_,outLevel(5),egR1(5),egR2(5),egR3(5),egR4(5),egL1(5),egL2(5),egL3(5),egL4(5),keyVelSens(5),opRateScale(5),1,gain,gate);
  op5Freq = select2(opMode(4),opFreq(4)*freq,opFreq(4)) + opDetune(4)/4;
  op5 = dx7_op(op5Freq,_,outLevel(4),egR1(4),egR2(4),egR3(4),egR4(4),egL1(4),egL2(4),egL3(4),egL4(4),keyVelSens(4),opRateScale(4),0,gain,gate);
  op4Freq = select2(opMode(3),opFreq(3)*freq,opFreq(3)) + opDetune(3)/4;
  op4 = dx7_op(op4Freq,0,outLevel(3),egR1(3),egR2(3),egR3(3),egR4(3),egL1(3),egL2(3),egL3(3),egL4(3),keyVelSens(3),opRateScale(3),1,gain,gate);
  op3Freq = select2(opMode(2),opFreq(2)*freq,opFreq(2)) + opDetune(2)/4;
  op3 = dx7_op(op3Freq,_,outLevel(2),egR1(2),egR2(2),egR3(2),egR4(2),egL1(2),egL2(2),egL3(2),egL4(2),keyVelSens(2),opRateScale(2),0,gain,gate);
  op2Freq = select2(opMode(1),opFreq(1)*freq,opFreq(1)) + opDetune(1)/4;
  op2 = dx7_op(op2Freq,0,outLevel(1),egR1(1),egR2(1),egR3(1),egR4(1),egL1(1),egL2(1),egL3(1),egL4(1),keyVelSens(1),opRateScale(1),0,gain,gate);
  op1Freq = select2(opMode(0),opFreq(0)*freq,opFreq(0)) + opDetune(0)/4;
  op1 = dx7_op(op1Freq,0,outLevel(0),egR1(0),egR2(0),egR3(0),egR4(0),egL1(0),egL2(0),egL3(0),egL4(0),keyVelSens(0),opRateScale(0),0,gain,gate);
};

// Alg 30
dx7_algo(29,egR1,egR2,egR3,egR4,egL1,egL2,egL3,egL4,outLevel,keyVelSens,ampModSens,opMode,opFreq,opDetune,opRateScale,feedback,lfoDelay,lfoDepth,lfoSpeed,freq,gain,gate) =
op1,op2,(op5~*(feedback) : op4 : op3),op6 :> _
with{
  op6Freq = select2(opMode(5),opFreq(5)*freq,opFreq(5)) + opDetune(5)/4;
  op6 = dx7_op(op6Freq,0,outLevel(5),egR1(5),egR2(5),egR3(5),egR4(5),egL1(5),egL2(5),egL3(5),egL4(5),keyVelSens(5),opRateScale(5),0,gain,gate);
  op5Freq = select2(opMode(4),opFreq(4)*freq,opFreq(4)) + opDetune(4)/4;
  op5 = dx7_op(op5Freq,_,outLevel(4),egR1(4),egR2(4),egR3(4),egR4(4),egL1(4),egL2(4),egL3(4),egL4(4),keyVelSens(4),opRateScale(4),1,gain,gate);
  op4Freq = select2(opMode(3),opFreq(3)*freq,opFreq(3)) + opDetune(3)/4;
  op4 = dx7_op(op4Freq,_,outLevel(3),egR1(3),egR2(3),egR3(3),egR4(3),egL1(3),egL2(3),egL3(3),egL4(3),keyVelSens(3),opRateScale(3),1,gain,gate);
  op3Freq = select2(opMode(2),opFreq(2)*freq,opFreq(2)) + opDetune(2)/4;
  op3 = dx7_op(op3Freq,_,outLevel(2),egR1(2),egR2(2),egR3(2),egR4(2),egL1(2),egL2(2),egL3(2),egL4(2),keyVelSens(2),opRateScale(2),0,gain,gate);
  op2Freq = select2(opMode(1),opFreq(1)*freq,opFreq(1)) + opDetune(1)/4;
  op2 = dx7_op(op2Freq,0,outLevel(1),egR1(1),egR2(1),egR3(1),egR4(1),egL1(1),egL2(1),egL3(1),egL4(1),keyVelSens(1),opRateScale(1),0,gain,gate);
  op1Freq = select2(opMode(0),opFreq(0)*freq,opFreq(0)) + opDetune(0)/4;
  op1 = dx7_op(op1Freq,0,outLevel(0),egR1(0),egR2(0),egR3(0),egR4(0),egL1(0),egL2(0),egL3(0),egL4(0),keyVelSens(0),opRateScale(0),0,gain,gate);
};

// Alg 31
dx7_algo(30,egR1,egR2,egR3,egR4,egL1,egL2,egL3,egL4,outLevel,keyVelSens,ampModSens,opMode,opFreq,opDetune,opRateScale,feedback,lfoDelay,lfoDepth,lfoSpeed,freq,gain,gate) =
op1,op2,op3,op4,(op6~*(feedback) : op5) :> _
with{
  op6Freq = select2(opMode(5),opFreq(5)*freq,opFreq(5)) + opDetune(5)/4;
  op6 = dx7_op(op6Freq,_,outLevel(5),egR1(5),egR2(5),egR3(5),egR4(5),egL1(5),egL2(5),egL3(5),egL4(5),keyVelSens(5),opRateScale(5),1,gain,gate);
  op5Freq = select2(opMode(4),opFreq(4)*freq,opFreq(4)) + opDetune(4)/4;
  op5 = dx7_op(op5Freq,_,outLevel(4),egR1(4),egR2(4),egR3(4),egR4(4),egL1(4),egL2(4),egL3(4),egL4(4),keyVelSens(4),opRateScale(4),0,gain,gate);
  op4Freq = select2(opMode(3),opFreq(3)*freq,opFreq(3)) + opDetune(3)/4;
  op4 = dx7_op(op4Freq,0,outLevel(3),egR1(3),egR2(3),egR3(3),egR4(3),egL1(3),egL2(3),egL3(3),egL4(3),keyVelSens(3),opRateScale(3),0,gain,gate);
  op3Freq = select2(opMode(2),opFreq(2)*freq,opFreq(2)) + opDetune(2)/4;
  op3 = dx7_op(op3Freq,0,outLevel(2),egR1(2),egR2(2),egR3(2),egR4(2),egL1(2),egL2(2),egL3(2),egL4(2),keyVelSens(2),opRateScale(2),0,gain,gate);
  op2Freq = select2(opMode(1),opFreq(1)*freq,opFreq(1)) + opDetune(1)/4;
  op2 = dx7_op(op2Freq,0,outLevel(1),egR1(1),egR2(1),egR3(1),egR4(1),egL1(1),egL2(1),egL3(1),egL4(1),keyVelSens(1),opRateScale(1),0,gain,gate);
  op1Freq = select2(opMode(0),opFreq(0)*freq,opFreq(0)) + opDetune(0)/4;
  op1 = dx7_op(op1Freq,0,outLevel(0),egR1(0),egR2(0),egR3(0),egR4(0),egL1(0),egL2(0),egL3(0),egL4(0),keyVelSens(0),opRateScale(0),0,gain,gate);
};

// Alg 32
dx7_algo(31,egR1,egR2,egR3,egR4,egL1,egL2,egL3,egL4,outLevel,keyVelSens,ampModSens,opMode,opFreq,opDetune,opRateScale,feedback,lfoDelay,lfoDepth,lfoSpeed,freq,gain,gate) =
op1,op2,op3,op4,op5,op6 :> _
with{
  op6Freq = select2(opMode(5),opFreq(5)*freq,opFreq(5)) + opDetune(5)/4;
  op6 = dx7_op(op6Freq,0,outLevel(5),egR1(5),egR2(5),egR3(5),egR4(5),egL1(5),egL2(5),egL3(5),egL4(5),keyVelSens(5),opRateScale(5),0,gain,gate);
  op5Freq = select2(opMode(4),opFreq(4)*freq,opFreq(4)) + opDetune(4)/4;
  op5 = dx7_op(op5Freq,0,outLevel(4),egR1(4),egR2(4),egR3(4),egR4(4),egL1(4),egL2(4),egL3(4),egL4(4),keyVelSens(4),opRateScale(4),0,gain,gate);
  op4Freq = select2(opMode(3),opFreq(3)*freq,opFreq(3)) + opDetune(3)/4;
  op4 = dx7_op(op4Freq,0,outLevel(3),egR1(3),egR2(3),egR3(3),egR4(3),egL1(3),egL2(3),egL3(3),egL4(3),keyVelSens(3),opRateScale(3),0,gain,gate);
  op3Freq = select2(opMode(2),opFreq(2)*freq,opFreq(2)) + opDetune(2)/4;
  op3 = dx7_op(op3Freq,0,outLevel(2),egR1(2),egR2(2),egR3(2),egR4(2),egL1(2),egL2(2),egL3(2),egL4(2),keyVelSens(2),opRateScale(2),0,gain,gate);
  op2Freq = select2(opMode(1),opFreq(1)*freq,opFreq(1)) + opDetune(1)/4;
  op2 = dx7_op(op2Freq,0,outLevel(1),egR1(1),egR2(1),egR3(1),egR4(1),egL1(1),egL2(1),egL3(1),egL4(1),keyVelSens(1),opRateScale(1),0,gain,gate);
  op1Freq = select2(opMode(0),opFreq(0)*freq,opFreq(0)) + opDetune(0)/4;
  op1 = dx7_op(op1Freq,0,outLevel(0),egR1(0),egR2(0),egR3(0),egR4(0),egL1(0),egL2(0),egL3(0),egL4(0),keyVelSens(0),opRateScale(0),0,gain,gate);
};

//------------------------------`(dx.)dx7_ui`---------------------------
// Generic DX7 function where all parameters are controllable using UI elements.
// The `master-with-mute` branch must be used for this function to work...
// This function is MIDI-compatible.
//
// #### Usage
//
// ```
// dx7_ui : _
// ```
//-----------------------------------------------------------------
dx7_ui =
par(i,32,dx7_algo(i,egR1,egR2,egR3,egR4,egL1,egL2,egL3,egL4,outLevel,keyVelSens,ampModSens,opMode,opFreq,opDetune,opRateScale,feedback,lfoDelay,lfoDepth,lfoSpeed,freq,gain,gate) : control(algorithm == i)) :> _
with{
	algorithm = nentry("h:dx7/v:global/[0]algorithm",0,0,31,1) : int;
	feedback = nentry("h:dx7/v:global/[1]feedback",0,0,99,1) : dx7_fdbkscalef/(2*ma.PI);
	lfoDelay = nentry("h:dx7/v:global/[2]lfoDelay",0,0,99,1);
	lfoDepth = nentry("h:dx7/v:global/[3]lfoDepth",0,0,99,1);
	lfoSpeed = nentry("h:dx7/v:global/[4]lfoSpeed",0,0,99,1);
	freq = hslider("h:dx7/v:global/[5]freq",400,50,1000,0.01);
	gain = hslider("h:dx7/v:global/[6]gain",0.8,0,1,0.01);
	gate = button("h:dx7/v:global/[7]gate");
	egR1UI = par(i,6,nentry("h:dx7/v:[%i]op%i/[0]egR1",90,0,99,1));
	egR1(n) = ba.take(n+1,egR1UI);
	egR2UI = par(i,6,nentry("h:dx7/v:[%i]op%i/[1]egR2",90,0,99,1));
	egR2(n) = ba.take(n+1,egR2UI);
	egR3UI = par(i,6,nentry("h:dx7/v:[%i]op%i/[2]egR3",90,0,99,1));
	egR3(n) = ba.take(n+1,egR3UI);
	egR4UI = par(i,6,nentry("h:dx7/v:[%i]op%i/[3]egR4",90,0,99,1));
	egR4(n) = ba.take(n+1,egR4UI);
	egL1UI = par(i,6,nentry("h:dx7/v:[%i]op%i/[4]egL1",0,0,99,1));
	egL1(n) = ba.take(n+1,egL1UI);
	egL2UI = par(i,6,nentry("h:dx7/v:[%i]op%i/[5]egL2",90,0,99,1));
	egL2(n) = ba.take(n+1,egL2UI);
	egL3UI = par(i,6,nentry("h:dx7/v:[%i]op%i/[6]egL3",90,0,99,1));
	egL3(n) = ba.take(n+1,egL3UI);
	egL4UI = par(i,6,nentry("h:dx7/v:[%i]op%i/[7]egL4",0,0,99,1));
	egL4(n) = ba.take(n+1,egL4UI);
	outLevelUI = par(i,6,nentry("h:dx7/v:[%i]op%i/[8]level",95,0,99,1));
	outLevel(n) = ba.take(n+1,outLevelUI);
	keyVelSensUI = par(i,6,nentry("h:dx7/v:[%i]op%i/[9]keyVelSens",1,0,8,1));
	keyVelSens(n) = ba.take(n+1,keyVelSensUI);
	ampModSensUI = par(i,6,nentry("h:dx7/v:[%i]op%i/[10]ampModSens",0,0,99,1));
	ampModSens(n) = ba.take(n+1,ampModSensUI);
	opModeUI = par(i,6,nentry("h:dx7/v:[%i]op%i/[11]opMode",0,0,1,1));
	opMode(n) = ba.take(n+1,opModeUI);
	opFreqUI = par(i,6,nentry("h:dx7/v:[%i]op%i/[12]opFreq",1.0,0.0,2.0,0.01));
	opFreq(n) = ba.take(n+1,opFreqUI);
	opDetuneUI = par(i,6,nentry("h:dx7/v:[%i]op%i/[13]opDetune",1,-10,10,1));
	opDetune(n) = ba.take(n+1,opDetuneUI);
	opRateScaleUI = par(i,6,nentry("h:dx7/v:[%i]op%i/[14]opRateScale",0,0,10,1));
	opRateScale(n) = ba.take(n+1,opRateScaleUI);
};
//################################ analyzers.lib ##########################################
// Analyzers library. Its official prefix is `an`.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/analyzers.lib>
//########################################################################################

ma = library("maths.lib");
ba = library("basics.lib");
ro = library("routes.lib");
si = library("signals.lib");
fi = library("filters.lib");
an = library("analyzers.lib"); // for compatible copy/paste out of this file

declare name "Faust Analyzer Library";
declare version "0.1";

/************************************************************************
FAUST library file, jos section

Except where noted otherwise, The Faust functions below in this
section are Copyright (C) 2003-2017 by Julius O. Smith III <jos@ccrma.stanford.edu>
([jos](http://ccrma.stanford.edu/~jos/)), and released under the
(MIT-style) [STK-4.3](#stk-4.3-license) license.

All MarkDown comments in this section is Copyright 2016-2017 by Romain
Michon and Julius O. Smith III, and is released under the
[CCA4I](https://creativecommons.org/licenses/by/4.0/) license (TODO: if/when Romain agrees)

************************************************************************/

//==============================Amplitude Tracking========================================
//========================================================================================

//------------------`(an.)abs_envelope_rect`-----------------------------------
// Absolute value average with moving-average algorithm.
//
// #### Usage
//
// ```
// _ : abs_envelope_rect(period) : _
// ```
//
//  Where:
//
// * `period`: sets the averaging frame in seconds
//-----------------------------------------------------------------------------
declare abs_envelope_rect author "Dario Sanfilippo and Julius O. Smith III";
declare abs_envelope_rect copyright "Copyright (C) 2020 Dario Sanfilippo 
      <sanfilippo.dario@gmail.com> and 
       2003-2020 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare abs_envelope_rect license "MIT-style STK-4.3 license";
abs_envelope_rect(period, x) = abs(x) : fi.avg_rect(period);


//------------------`(an.)abs_envelope_tau`------------------------------------
// Absolute value average with one-pole lowpass and tau response. 
// (See filters.lib.)
//
// #### Usage
//
// ```
// _ : abs_envelope_tau(period) : _
// ```
//
//  Where:
//
// * `period`: (time to decay by 1/e) sets the averaging frame in secs
//-----------------------------------------------------------------------------
declare abs_envelope_tau author "Dario Sanfilippo and Julius O. Smith III";
declare abs_envelope_tau copyright "Copyright (C) 2020 Dario Sanfilippo 
      <sanfilippo.dario@gmail.com> and 
       2003-2020 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare abs_envelope_tau license "MIT-style STK-4.3 license";
abs_envelope_tau(period, x) = abs(x) : fi.avg_tau(period);


//------------------`(an.)abs_envelope_t60`------------------------------------
// Absolute value average with one-pole lowpass and t60 response.
// (See filters.lib.)
//
// #### Usage
//
// ```
// _ : abs_envelope_t60(period) : _
// ```
//
//  Where:
//
// * `period`: (time to decay by 60 dB) sets the averaging frame in secs
//-----------------------------------------------------------------------------
declare abs_envelope_t60 author "Dario Sanfilippo and Julius O. Smith III";
declare abs_envelope_t60 copyright "Copyright (C) 2020 Dario Sanfilippo 
      <sanfilippo.dario@gmail.com> and 
       2003-2020 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare abs_envelope_t60 license "MIT-style STK-4.3 license";
abs_envelope_t60(period, x) = abs(x) : fi.avg_t60(period);


//------------------`(an.)abs_envelope_t19`------------------------------------
// Absolute value average with one-pole lowpass and t19 response. 
// (See filters.lib.)
//
// #### Usage
//
// ```
// _ : abs_envelope_t19(period) : _
// ```
//
//  Where:
//
// * `period`: (time to decay by 1/e^2.2) sets the averaging frame in secs
//-----------------------------------------------------------------------------
declare abs_envelope_t19 author "Dario Sanfilippo and Julius O. Smith III";
declare abs_envelope_t19 copyright "Copyright (C) 2020 Dario Sanfilippo 
      <sanfilippo.dario@gmail.com> and 
       2003-2020 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare abs_envelope_t19 license "MIT-style STK-4.3 license";
abs_envelope_t19(period, x) = abs(x) : fi.avg_t19(period);


//---------------------------`(an.)amp_follower`---------------------------
// Classic analog audio envelope follower with infinitely fast rise and
// exponential decay.  The amplitude envelope instantaneously follows
// the absolute value going up, but then floats down exponentially.
// 
// `amp_follower` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : amp_follower(rel) : _
// ```
//
// Where:
//
// * `rel`: release time = amplitude-envelope time-constant (sec) going down
//
// #### References
//
// * Musical Engineer's Handbook, Bernie Hutchins, Ithaca NY
// * 1975 Electronotes Newsletter, Bernie Hutchins
//------------------------------------------------------------
amp_follower(rel) = abs : env with {
 	p = ba.tau2pole(rel);
 	env(x) = x * (1.0 - p) : (+ : max(x,_)) ~ *(p);
};

peak_envelope = amp_follower; // Synonym for more standard naming


//---------------------------`(an.)amp_follower_ud`---------------------------
// Envelope follower with different up and down time-constants
// (also called a "peak detector").
//
// #### Usage
//
// ```
//    _ : amp_follower_ud(att,rel) : _
// ```
//
// Where:
//
// * `att`: attack time = amplitude-envelope time constant (sec) going up
// * `rel`: release time = amplitude-envelope time constant (sec) going down
//
// #### Note
//
// We assume rel >> att.  Otherwise, consider rel ~ max(rel,att).
// For audio, att is normally faster (smaller) than rel (e.g., 0.001 and 0.01).
// Use `amp_follower_ar` below to remove this restriction.
//
// #### Reference
//
// * "Digital Dynamic Range Compressor Design --- A Tutorial and Analysis", by
//   Dimitrios Giannoulis, Michael Massberg, and Joshua D. Reiss
//   <https://www.eecs.qmul.ac.uk/~josh/documents/2012/GiannoulisMassbergReiss-dynamicrangecompression-JAES2012.pdf>
//------------------------------------------------------------
amp_follower_ud(att,rel) = amp_follower(rel) : si.smooth(ba.tau2pole(att));


//---------------`(an.)amp_follower_ar`----------------
// Envelope follower with independent attack and release times. The
// release can be shorter than the attack (unlike in `amp_follower_ud`
// above).
//
// #### Usage
//
// ```
// _ : amp_follower_ar(att,rel) : _
// ```
// * Author Jonatan Liljedahl, revised by RM
//---------------------------------------------------------
amp_follower_ar(att,rel) = abs : si.lag_ud(att,rel);


//------------------`(an.)ms_envelope_rect`------------------------------------
// Mean square with moving-average algorithm.
//
// #### Usage
//
// ```
// _ : ms_envelope_rect(period) : _
// ```
//
//  Where:
//
// * `period`: sets the averaging frame in secs
//-----------------------------------------------------------------------------
declare ms_envelope_rect author "Dario Sanfilippo and Julius O. Smith III";
declare ms_envelope_rect copyright "Copyright (C) 2020 Dario Sanfilippo 
      <sanfilippo.dario@gmail.com> and 
       2003-2020 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare ms_envelope_rect license "MIT-style STK-4.3 license";
ms_envelope_rect(period, x) = x * x : fi.avg_rect(period);


//------------------`(an.)ms_envelope_tau`-------------------------------------
// Mean square average with one-pole lowpass and tau response. 
// (See filters.lib.)
//
// #### Usage
//
// ```
// _ : ms_envelope_tau(period) : _
// ```
//
//  Where:
//
// * `period`: (time to decay by 1/e) sets the averaging frame in secs
//-----------------------------------------------------------------------------
declare ms_envelope_tau author "Dario Sanfilippo and Julius O. Smith III";
declare ms_envelope_tau copyright "Copyright (C) 2020 Dario Sanfilippo 
      <sanfilippo.dario@gmail.com> and 
       2003-2020 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare ms_envelope_tau license "MIT-style STK-4.3 license";
ms_envelope_tau(period, x) = x * x : fi.avg_tau(period);


//------------------`(an.)ms_envelope_t60`-------------------------------------
// Mean square with one-pole lowpass and t60 response. 
// (See filters.lib.)
//
// #### Usage
//
// ```
// _ : ms_envelope_t60(period) : _
// ```
//
//  Where:
//
// * `period`: (time to decay by 60 dB) sets the averaging frame in secs
//-----------------------------------------------------------------------------
declare ms_envelope_t60 author "Dario Sanfilippo and Julius O. Smith III";
declare ms_envelope_t60 copyright "Copyright (C) 2020 Dario Sanfilippo 
      <sanfilippo.dario@gmail.com> and 
       2003-2020 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare ms_envelope_t60 license "MIT-style STK-4.3 license";
ms_envelope_t60(period, x) = x * x : fi.avg_t60(period);


//------------------`(an.)ms_envelope_t19`-------------------------------------
// Mean square with one-pole lowpass and t19 response. 
// (See filters.lib.)
//
// #### Usage
//
// ```
// _ : ms_envelope_t19(period) : _
// ```
//
//  Where:
//
// * `period`: (time to decay by 1/e^2.2) sets the averaging frame in secs
//-----------------------------------------------------------------------------
declare ms_envelope_t19 author "Dario Sanfilippo and Julius O. Smith III";
declare ms_envelope_t19 copyright "Copyright (C) 2020 Dario Sanfilippo 
      <sanfilippo.dario@gmail.com> and 
       2003-2020 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare ms_envelope_t19 license "MIT-style STK-4.3 license";
ms_envelope_t19(period, x) = x * x : fi.avg_t19(period);


//------------------`(an.)rms_envelope_rect`-----------------------------------
// Root mean square with moving-average algorithm.
//
// #### Usage
//
// ```
// _ : rms_envelope_rect(period) : _
// ```
//
//  Where:
//
// * `period`: sets the averaging frame in secs
//-----------------------------------------------------------------------------
declare rms_envelope_rect author "Dario Sanfilippo and Julius O. Smith III";
declare rms_envelope_rect copyright "Copyright (C) 2020 Dario Sanfilippo 
      <sanfilippo.dario@gmail.com> and 
       2003-2020 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare rms_envelope_rect license "MIT-style STK-4.3 license";
rms_envelope_rect(period, x) = ms_envelope_rect(period, x) : sqrt;


//------------------`(an.)rms_envelope_tau`------------------------------------
// Root mean square with one-pole lowpass and tau response.
// (See filters.lib.)
//
// #### Usage
//
// ```
// _ : rms_envelope_tau(period) : _
// ```
//
//  Where:
//
// * `period`: (time to decay by 1/e) sets the averaging frame in secs
//-----------------------------------------------------------------------------
declare rms_envelope_tau author "Dario Sanfilippo and Julius O. Smith III";
declare rms_envelope_tau copyright "Copyright (C) 2020 Dario Sanfilippo 
      <sanfilippo.dario@gmail.com> and 
       2003-2020 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare rms_envelope_tau license "MIT-style STK-4.3 license";
rms_envelope_tau(period, x) = ms_envelope_tau(period, x) : sqrt;


//------------------`(an.)rms_envelope_t60`------------------------------------
// Root mean square with one-pole lowpass and t60 response.
// (See filters.lib.)
//
// #### Usage
//
// ```
// _ : rms_envelope_t60(period) : _
// ```
//
//  Where:
//
// * `period`: (time to decay by 60 dB) sets the averaging frame in secs
//-----------------------------------------------------------------------------
declare rms_envelope_t60 author "Dario Sanfilippo and Julius O. Smith III";
declare rms_envelope_t60 copyright "Copyright (C) 2020 Dario Sanfilippo 
      <sanfilippo.dario@gmail.com> and 
       2003-2020 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare rms_envelope_t60 license "MIT-style STK-4.3 license";
rms_envelope_t60(period, x) = ms_envelope_t60(period, x) : sqrt;


//------------------`(an.)rms_envelope_t19`------------------------------------
// Root mean square with one-pole lowpass and t19 response.
// (See filters.lib.)
//
// #### Usage
//
// ```
// _ : rms_envelope_t19(period) : _
// ```
//
//  Where:
//
// * `period`: (time to decay by 1/e^2.2) sets the averaging frame in secs
//-----------------------------------------------------------------------------
declare rms_envelope_t19 author "Dario Sanfilippo and Julius O. Smith III";
declare rms_envelope_t19 copyright "Copyright (C) 2020 Dario Sanfilippo 
      <sanfilippo.dario@gmail.com> and 
       2003-2020 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare rms_envelope_t19 license "MIT-style STK-4.3 license";
rms_envelope_t19(period, x) = ms_envelope_t19(period, x) : sqrt;


//-----------------------`(an.)zcr`--------------------------------------------
// Zero-crossing rate (ZCR) with one-pole lowpass averaging based on the tau 
// constant. It outputs an index between 0 and 1 at a desired analysis frame. 
// The ZCR of a signal correlates with the noisiness [Gouyon et al. 2000] and 
// the spectral centroid [Herrera-Boyer et al. 2006] of a signal. 
// For sinusoidal signals, the ZCR can be multiplied by ma.SR/2 and used
// as a frequency detector. For example, it can be deployed as a
// computationally efficient adaptive mechanism for automatic Larsen
// suppression.
//
// #### Usage
//
// ```
// _ : zcr(tau) : _
// ```
//
// Where:
//
// * `tau`: (time to decay by e^-1) sets the averaging frame in seconds.
declare zcr author "Dario Sanfilippo";
declare zcr copyright "Copyright (C) 2020 Dario Sanfilippo
      <sanfilippo.dario@gmail.com>";
declare zcr license "MIT-style STK-4.3 license";
zcr(period, x) = ma.zc(x) : fi.lptau(period);


//=============================Spectrum-Analyzers=========================================
// Spectrum-analyzers split the input signal into a bank of parallel signals, one for
// each spectral band. They are related to the Mth-Octave Filter-Banks in `filters.lib`.
// The documentation of this library contains more details about the implementation.
// The parameters are:
//
// * `M`: number of band-slices per octave (>1)
// * `N`: total number of bands (>2)
// * `ftop` = upper bandlimit of the Mth-octave bands (<SR/2)
//
// In addition to the Mth-octave output signals, there is a highpass signal
// containing frequencies from ftop to SR/2, and a "dc band" lowpass signal
// containing frequencies from 0 (dc) up to the start of the Mth-octave bands.
// Thus, the N output signals are:
// ```
// highpass(ftop), MthOctaveBands(M,N-2,ftop), dcBand(ftop*2^(-M*(N-1)))
// ```
//
// A Spectrum-Analyzer is defined here as any band-split whose bands span
// the relevant spectrum, but whose band-signals do not
// necessarily sum to the original signal, either exactly or to within an
// allpass filtering. Spectrum analyzer outputs are normally at least nearly
// "power complementary", i.e., the power spectra of the individual bands
// sum to the original power spectrum (to within some negligible tolerance).
//
// #### Increasing Channel Isolation
//
// Go to higher filter orders - see Regalia et al. or Vaidyanathan (cited
// below) regarding the construction of more aggressive recursive
// filter-banks using elliptic or Chebyshev prototype filters.
//
// #### References
//
// * "Tree-structured complementary filter banks using all-pass sections",
//   Regalia et al., IEEE Trans. Circuits & Systems, CAS-34:1470-1484, Dec. 1987
// * "Multirate Systems and Filter Banks", P. Vaidyanathan, Prentice-Hall, 1993
// * Elementary filter theory: <https://ccrma.stanford.edu/~jos/filters/>
//========================================================================================


//-------------------------`(an.)mth_octave_analyzer`----------------------------
// Octave analyzer.
// `mth_octave_analyzer[N]` are standard Faust functions.
//
// #### Usage
// ```
// _ : mth_octave_analyzer(O,M,ftop,N) : par(i,N,_) // Oth-order Butterworth
// _ : mth_octave_analyzer6e(M,ftop,N) : par(i,N,_) // 6th-order elliptic
// ```
//
// Also for convenience:
//
// ```
// _ : mth_octave_analyzer3(M,ftop,N) : par(i,N,_) // 3d-order Butterworth
// _ : mth_octave_analyzer5(M,ftop,N) : par(i,N,_) // 5th-roder Butterworth
// mth_octave_analyzer_default = mth_octave_analyzer6e;
// ```
//
// Where:
//
// * `O`: order of filter used to split each frequency band into two
// * `M`: number of band-slices per octave
// * `ftop`: highest band-split crossover frequency (e.g., 20 kHz)
// * `N`: total number of bands (including dc and Nyquist)
//------------------------------------------------------------
mth_octave_analyzer6e(M,ftop,N) = _ <: bsplit(N-1) with {
  fc(n) = ftop * 2^(float(n-N+1)/float(M)); // -3dB crossover frequencies
  lp(n) = fi.lowpass6e(fc(n));  // 6th-order elliptic - see other choices above
  hp(n) = fi.highpass6e(fc(n)); //   (search for lowpass* and highpass*)
  bsplit(0)  = _;
  bsplit(i) = hp(i), (lp(i) <: bsplit(i-1));
};

// Butterworth analyzers may be cascaded with allpass
// delay-equalizers to make (allpass-complementary) filter banks:

mth_octave_analyzer(O,M,ftop,N) = _ <: bsplit(N-1) with {
  fc(n) = ftop * 2^(float(n-N+1)/float(M));
  lp(n) = fi.lowpass(O,fc(n)); // Order O Butterworth
  hp(n) = fi.highpass(O,fc(n));
  bsplit(0)  = _;
  bsplit(i) = hp(i), (lp(i) <: bsplit(i-1));
};

mth_octave_analyzer3(M,ftop,N) = mth_octave_analyzer(3,M,ftop,N);
mth_octave_analyzer5(M,ftop,N) = mth_octave_analyzer(5,M,ftop,N);
mth_octave_analyzer_default = mth_octave_analyzer6e; // default analyzer


//============================Mth-Octave Spectral Level===================================
// Spectral Level: Display (in bar graphs) the average signal level in each spectral band.
//========================================================================================


//------------------------`(an.)mth_octave_spectral_level6e`-------------------------
// Spectral level display.
//
// #### Usage:
//
// ```
// _ : mth_octave_spectral_level6e(M,ftop,NBands,tau,dB_offset) : _
// ```
//
// Where:
//
// * `M`: bands per octave
// * `ftop`: lower edge frequency of top band
// * `NBands`: number of passbands (including highpass and dc bands),
// * `tau`: spectral display averaging-time (time constant) in seconds,
// * `dB_offset`: constant dB offset in all band level meters.
//
// Also for convenience:
//
// ```
// mth_octave_spectral_level_default = mth_octave_spectral_level6e;
// spectral_level = mth_octave_spectral_level(2,10000,20);
// ```
//------------------------------------------------------------
mth_octave_spectral_level6e(M,ftop,N,tau,dB_offset) = _<:
    _,mth_octave_analyzer6e(M,ftop,N) :
    _,(display:>_):attach with {
  display = par(i,N,dbmeter(i));
  dbmeter(i) = abs : si.smooth(ba.tau2pole(tau)) : max(ma.EPSILON) : ba.linear2db : +(dB_offset) :
     meter(N-i-1);
    meter(i) = speclevel_group(vbargraph("[%2i] [unit:dB]
     [tooltip: Spectral Band Level in dB]", -50, 10));
  O = int(((N-2)/M)+0.4999);
  speclevel_group(x)  = hgroup("[0] CONSTANT-Q SPECTRUM ANALYZER (6E), %N bands spanning
  	LP, %O octaves below %ftop Hz, HP
     [tooltip: See Faust's filters.lib for documentation and references]", x);
};

mth_octave_spectral_level_default = mth_octave_spectral_level6e;
spectral_level = mth_octave_spectral_level(2,10000,20);  // simple default


//---------------`(an.)[third|half]_octave_[analyzer|filterbank]`----------------
// A bunch of special cases based on the different analyzer functions described above:
//
// ```
// third_octave_analyzer(N) = mth_octave_analyzer_default(3,10000,N);
// third_octave_filterbank(N) = mth_octave_filterbank_default(3,10000,N);
// half_octave_analyzer(N) = mth_octave_analyzer_default(2,10000,N);
// half_octave_filterbank(N) = mth_octave_filterbank_default(2,10000,N);
// octave_filterbank(N) = mth_octave_filterbank_default(1,10000,N);
// octave_analyzer(N) = mth_octave_analyzer_default(1,10000,N);
// ```
//
// #### Usage
//
// See `mth_octave_spectral_level_demo` in `demos.lib`.
//------------------------------------------------------------
third_octave_analyzer(N) = mth_octave_analyzer_default(3,10000,N);
third_octave_filterbank(N) = mth_octave_filterbank_default(3,10000,N);
// Third-Octave Filter-Banks have been used in audio for over a century.
// See, e.g.,
//   Acoustics [the book], by L. L. Beranek
//   Amer. Inst. Physics for the Acoustical Soc. America,
//   <http://asa.aip.org/publications.html, 1986 (1st ed.1954)>

// Third-octave bands across the audio spectrum are too wide for current
// typical computer screens, so half-octave bands are the default:
half_octave_analyzer(N) = mth_octave_analyzer_default(2,10000,N);
half_octave_filterbank(N) = mth_octave_filterbank_default(2,10000,N);

octave_filterbank(N) = mth_octave_filterbank_default(1,10000,N);
octave_analyzer(N) = mth_octave_analyzer_default(1,10000,N);


//===============Arbritary-Crossover Filter-Banks and Spectrum Analyzers==================
// These are similar to the Mth-octave analyzers above, except that the
// band-split frequencies are passed explicitly as arguments.
//========================================================================================

// ACKNOWLEDGMENT
// Technique for processing a variable number of signal arguments due
// to Yann Orlarey (as is the entire Faust framework!)

//---------------`(an.)analyzer`--------------------------
// Analyzer.
//
// #### Usage
//
// ```
// _ : analyzer(O,freqs) : par(i,N,_) // No delay equalizer
// ```
//
// Where:
//
// * `O`: band-split filter order (ODD integer required for filterbank[i])
// * `freqs`: (fc1,fc2,...,fcNs) [in numerically ascending order], where
//           Ns=N-1 is the number of octave band-splits
//           (total number of bands N=Ns+1).
//
// If frequencies are listed explicitly as arguments, enclose them in parens:
//
// ```
// _ : analyzer(3,(fc1,fc2)) : _,_,_
// ```
//---------------------------------------------------
analyzer(O,lfreqs) = _ <: bsplit(nb) with
{
   nb = ba.count(lfreqs);
   fc(n) = ba.take(n, lfreqs);
   lp(n) = fi.lowpass(O,fc(n));
   hp(n) = fi.highpass(O,fc(n));
   bsplit(0) = _;
   bsplit(i) = hp(i), (lp(i) <: bsplit(i-1));
};

//================ Fast Fourier Transform (fft) and its Inverse (ifft) ===================
// Sliding FFTs that compute a rectangularly windowed FFT each sample.
//========================================================================================

//---------------`(an.)gortzelOpt` --------------------------
// Optimized Goertzel filter. 
//
// #### Usage
//
// ```
// _ : goertzelOpt(freq,N) : _
// ```
//
// Where:
//
// * `freq`: frequency to be analyzed
// * `N`: the Goertzel block size
//
// #### Reference
//
// * <https://en.wikipedia.org/wiki/Goertzel_algorithm>
//---------------------------------------------------
goertzelOpt(freq,N,x) = mg 
with{
  mg = sqrt(eq^2 + eq'^2-eq*eq'*c) : ba.sAndH(reset0); // magnitude
  cnt = ba.time%N; // counter for windowing
  reset0 = cnt == (N-1); // reset when end of window
  reset1 = 1-(cnt == 0); // reset when beginning of window
  k = 0.5 + N*freq/ma.SR;
  w = (2*ma.PI/N)*k;
  c = 2*cos(w);
  eq = s // equation
  letrec{
    's = c*s*reset1 - s'*reset1*reset1' + x;
  };
};

//---------------`(an.)gortzelComp` --------------------------
// Complex Goertzel filter. 
//
// #### Usage
//
// ```
// _ : goertzelComp(freq,N) : _
// ```
//
// Where:
//
// * `freq`: frequency to be analyzed
// * `N`: the Goertzel block size
//
// #### Reference
//
// * <https://en.wikipedia.org/wiki/Goertzel_algorithm>
//---------------------------------------------------
goertzelComp(freq,N,x) = mg 
with{
  mg = sqrt(real^2 + imag^2); // magnitude
  cnt = ba.time%N; // counter for windowing
  reset0 = cnt == (N-1); // reset when end of window
  reset1 = 1-(cnt == 0); // reset when beginning of window
  k = 0.5 + N*freq/ma.SR;
  w = (2*ma.PI/N)*k;
  sine = sin(w);
  cosine = cos(w);
  c = 2*cosine;
  eq = s
  letrec{
    's = c*s*reset1 - s'*reset1*reset1' + x;
  };
  real = eq - eq'*cosine;
  imag = eq'*sine;
};

//---------------`(an.)goertzel` --------------------------
// Same as [`goertzelOpt`](#goertzelopt). 
//
// #### Usage
//
// ```
// _ : goertzel(freq,N) : _
// ```
//
// Where:
//
// * `freq`: frequency to be analyzed
// * `N`: the Goertzel block size
//
// #### Reference
//
// * <https://en.wikipedia.org/wiki/Goertzel_algorithm>
//---------------------------------------------------
goertzel = goertzelOpt;

// Undocumented utility functions used by fft and ifft:
c_magsq(N) = si.cbus(N) : par(i,N,(par(j,2,abs<:_*_):>_)) :> si.bus(N);
c_magdb(N) = si.cbus(N) : an.c_magsq(N) : par(i,N,(max(ma.EPSILON):log10:*(10.0)));
c_select_pos_freqs(2) = (_,_), (_,_); // both dc and SR/2 included with "positive frequencies"
c_select_pos_freqs(N) = si.cbus(N) : par(i,N/2+1,(_,_)),par(i,N/2-1,(!,!)) : si.cbus(N/2+1); // for complex spectra
  select_pos_freqs(2) = _,_; // both dc and SR/2 included
  select_pos_freqs(N) = si.bus(N) : par(i,N/2+1, _), par(i,N/2-1, !) : si. bus(N/2+1); // real power spectra etc.

rtorv(N,x) = par(i,N,x@i); // convert real scalar signal to length N real vector
rtocv(N,x) = par(i,N,(x@i,0)); // convert real scalar signal to length N complex vector with 0 imag part
rvtocv(N) = si.bus(N), par(i,N,0) : ro.interleave(N,2); // convert real N-vector to complex with 0 imag part

bit_reverse_selector(N,0) = 0;
bit_reverse_selector(N,i) = int(int(N)>>1)*(i&1) + bit_reverse_selector(int(N)>>1,(i>>1));

// decimation in time does this to the input:
bit_reverse_shuffle(N) = si.bus(N) <: par(i,N,bit_reverse_permuter(N,i)) with {
    bit_reverse_permuter(N,k) = ba.selector(bit_reverse_selector(N,k),N);
};

c_bit_reverse_shuffle(N) = si.cbus(N) <: par(i,N,c_bit_reverse_permuter(N,i)) with {
    c_bit_reverse_permuter(N,k) = ba.cselector(bit_reverse_selector(N,k),N);
};


//---------------`(an.)fft` --------------------------
// Fast Fourier Transform (FFT).
//
// #### Usage
//
// ```
// si.cbus(N) : fft(N) : si.cbus(N)
// ```
//
// Where:
//
// * `si.cbus(N)` is a bus of N complex signals, each specified by real and imaginary parts:
//   (r0,i0), (r1,i1), (r2,i2), ...
// * `N` is the FFT size (must be a power of 2: 2,4,8,16,...)
// * `fft(N)` performs a length `N` FFT for complex signals (radix 2)
// * The output is a bank of N complex signals containing the complex spectrum over time:
//   (R0, I0), (R1,I1), ...
//   - The dc component is (R0,I0), where I0=0 for real input signals.
//
// FFTs of Real Signals:
//
// * To perform a sliding FFT over a real input signal, you can say
// ```
// process = signal : an.rtocv(N) : an.fft(N);
// ```
// where `an.rtocv` converts a real (scalar) signal to a complex vector signal having a zero imaginary part.
//
//   * See `an.rfft_analyzer_c` (in `analyzers.lib`) and related functions for more detailed usage examples.
//
//   * Use `an.rfft_spectral_level(N,tau,dB_offset)` to display the power spectrum of a real signal.
//
//   * See `dm.fft_spectral_level_demo(N)` in `demos.lib` for an example GUI driving `an.rfft_spectral_level()`.
//
// #### Reference
//
// * [Decimation-in-time (DIT) Radix-2 FFT](https://cnx.org/contents/zmcmahhR@7/Decimation-in-time-DIT-Radix-2)
//
//---------------------------------------------------
fft(N) = si.cbus(N) : an.c_bit_reverse_shuffle(N) : an.fftb(N); // shuffle off to the butterflies:
fftb(1) = _,_; // each complex number is represented as (real,imag)
fftb(N) = si.cbus(N) : (fftb(No2) <: (si.cbus(No2), si.cbus(No2))), (fftb(No2)
	  <: (si.cbus(N):twiddleOdd(N))) :> si.cbus(N)
with {
  No2 = int(N)>>1;
  // Half of these multiplies can go away since w(k) = - w(k+N/2), and others as well (1,j,-j,-1,...)
  twiddleOdd(N) = par(k,N,si.cmul(cos(w(k)),0-sin(w(k))))
  with {
    w(k) = 2.0*ma.PI*float(k)/float(N);
  };
};

// `rfft`
// Slow to compile: rfft(N) = si.bus(N) : an.bit_reverse_shuffle(N) : an.rvtocv(N) : an.fftb(N);
// Order of magnitude faster to compile but takes a scalar input, so too different from fft:
// rfft(N) = an.rtocv(N) : an.fft(N);

//---------------`(an.)ifft`--------------------------
// Inverse Fast Fourier Transform (IFFT).
//
// #### Usage
//
// ```
// si.cbus(N) : ifft(N) : si.cbus(N)
// ```
//
// Where:
//
// * N is the IFFT size (power of 2)
// * Input is a complex spectrum represented as interleaved real and imaginary parts:
//   (R0, I0), (R1,I1), (R2,I2), ...
// * Output is a bank of N complex signals giving the complex signal in the time domain:
//   (r0, i0), (r1,i1), (r2,i2), ...
//---------------------------------------------------
ifft(N) = si.cbus(N) : an.c_bit_reverse_shuffle(N) : an.ifftb(N); // input is shuffled off to the butterflies:
ifftb(1) = _,_;
ifftb(N) = si.cbus(N) : (ifftb(No2) <: (si.cbus(No2), si.cbus(No2))), (ifftb(No2)
	<: (si.cbus(N):twiddleOddConj(N))) :> si.cbus(N) : par(i,2*N,/(2.0))
with {
  No2 = int(N)>>1;
  // Half of these multiplies can go away since w(k) = - w(k+N/2), and others as well (1,j,-j,-1,...)
  twiddleOddConj(N) = par(k,N,si.cmul(cos(w(k)),sin(w(k))))
  with {
    w(k) = 2.0*ma.PI*float(k)/float(N);
  };
};


// ========== FFT Analyzers ==========
rfft_analyzer_c(N) = an.rtocv(N) : an.fft(N) : an.c_select_pos_freqs(N); // complex spectral bins 0 to N/2
rfft_analyzer_db(N) = an.rfft_analyzer_c(N) : an.c_magdb(N/2+1); // assumes real input
rfft_analyzer_magsq(N) = an.rfft_analyzer_c(N) : an.c_magsq(N/2+1); // assumes real input

rfft_spectral_level(N,tau,dB_offset) = _<: _, an.rfft_analyzer_db(N) : _,(display:>_):attach with {
  display = par(i,N/2+1,dbmeter(i));
  dbmeter(i) = si.smooth(ba.tau2pole(tau)) : +(dB_offset) : meter(i);
    meter(i) = speclevel_group(vbargraph("[%2i] [unit:dB]
	       [tooltip: FFT Spectral Band Level in dB]", -50, 10));
  speclevel_group(x)  = hgroup("[0] FFT SPECTRUM ANALYZER, %N bands
			[tooltip: fft_spectral_level in Faust's analyzers.lib]", x);
};

// end jos section
/************************************************************************
************************************************************************
FAUST library file, GRAME section

Except where noted otherwise, Copyright (C) 2003-2017 by GRAME,
Centre National de Creation Musicale.
----------------------------------------------------------------------
GRAME LICENSE

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

// TODO: Add GRAME functions here

//########################################################################################
/************************************************************************
FAUST library file, further contributions section

All contributions below should indicate both the contributor and terms
of license.  If no such indication is found, "git blame" will say who
last edited each line, and that person can be emailed to inquire about
license disposition, if their license choice is not already indicated
elsewhere among the libraries.  It is expected that all software will be
released under LGPL, STK-4.3, MIT, BSD, or a similar FOSS license.
************************************************************************/
//#################################### spats.lib ##########################################
// This library contains a collection of tools for sound spatialization.
// Its official prefix is `sp`.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/spats.lib>
//########################################################################################

/************************************************************************
 ************************************************************************
FAUST library file
Copyright (C) 2003-2012 GRAME, Centre National de Creation Musicale
----------------------------------------------------------------------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.

 ************************************************************************
 ************************************************************************/

si = library("signals.lib");

declare name "Faust Spatialization Library";
declare version "0.0";

//-----------------------`(sp.)panner`------------------------
// A simple linear stereo panner.
// `panner` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : panner(g) : _,_
// ```
//
// Where:
//
// * `g`: the panning (0-1)
//------------------------------------------------------------
panner(g) = _ <: *(1-g), *(g);

// TODO: need demo function for panner here


//-----------------------`(sp.)spat`------------------------
// GMEM SPAT: n-outputs spatializer.
// `spat` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : spat(n,r,d) : _,_,...
// ```
//
// Where:
//
// * `n`: number of outputs
// * `r`: rotation (between 0 et 1)
// * `d`: distance of the source (between 0 et 1)
//------------------------------------------------------
// TODO: author Laurent Pottier, revised by RM
spat(n,a,d)	= _ <: par(i, n, *( scaler(i, n, a, d) : si.smooth(0.9999) ))
with {
	scaler(i,n,a,d) = (d/2.0+0.5)
		* sqrt( max(0.0, 1.0 - abs(fmod(a+0.5+float(n-i)/n, 1.0) - 0.5) * n * d) );
};


//---------------`(sp.)stereoize`-------------
// Transform an arbitrary processor `p` into a stereo processor with 2 inputs
// and 2 outputs.
//
// #### Usage
//
// ```
// _,_ : stereoize(p) : _,_
// ```
//
// Where:
//
// * `p`: the arbitrary processor
//----------------------------------------
stereoize(p) = S(inputs(p), outputs(p))
with {
	// degenerated processor with no outputs
	S(n,0) = !,! : 0,0; 		// just in case, probably a rare case
	// processors with no inputs
	S(0,1) = !,! : p <: _,_; 	// add two fake inputs and split output
	S(0,2) = !,! : p;
	S(0,n) = !,! : p,p :> _,_;	// we are sure this will work if n is odd
	// processors with one input
	S(1,1) = p,p; 				// add two fake inputs and split output
	S(1,n) = p,p :> _,_;		// we are sure this will work if n is odd
	// processors with two inputs
	S(2,1) = p <: _,_; 			// split the output
	S(2,2) = p; 				// nothing to do, p is already stereo
	// processors with inputs > 2 and outputs > 2
	S(n,m) = _,_ <: p,p :> _,_;	// we are sure this works if n or p are odd
};

// TODO: need demo function of spat here

//////////////////////////////////////////////////////////////////////////////////////////
// UNDOCUMENTED/DISMISSED ELEMENTS
//////////////////////////////////////////////////////////////////////////////////////////

// music.lib:
	// The following functions could remain available but they would have to be
	// factorized and reimplemented using the `par` function...
	// bus2 = _,_;
	// bus3 = _,_,_;
	// bus4 = _,_,_,_;
	// bus5 = _,_,_,_,_;
	// bus6 = _,_,_,_,_,_;
	// bus7 = _,_,_,_,_,_,_;
	// bus8 = _,_,_,_,_,_,_,_;
	// gain2(g) = *(g),*(g);
	// gain3(g) = *(g),*(g),*(g);
	// gain4(g) = *(g),*(g),*(g),*(g);
	// gain5(g) = *(g),*(g),*(g),*(g),*(g);
	// gain6(g) = *(g),*(g),*(g),*(g),*(g),*(g);
	// gain7(g) = *(g),*(g),*(g),*(g),*(g),*(g),*(g);
	// gain8(g) = *(g),*(g),*(g),*(g),*(g),*(g),*(g),*(g);
//################################ envelopes.lib ##########################################
// This library contains a collection of envelope generators. Its official prefix is `en`.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/envelopes.lib>
//########################################################################################

/************************************************************************
************************************************************************
FAUST library file, GRAME section

Except where noted otherwise, Copyright (C) 2003-2017 by GRAME,
Centre National de Creation Musicale.
----------------------------------------------------------------------
GRAME LICENSE

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

ma = library("maths.lib");
ba = library("basics.lib");
si = library("signals.lib");

declare name "Faust Envelope Library";
declare version "0.1";
declare author "GRAME";
declare copyright "GRAME";
declare license "LGPL with exception";

//=============================Functions Reference========================================
//========================================================================================

//------------------------`(en.)smoothEnvelope`------------------------
// An envelope with an exponential attack and release.
// `smoothEnvelope` is a standard Faust function.
//
// #### Usage
//
// ```
// smoothEnvelope(ar,t) : _
// ```
//
// * `ar`: attack and release duration (s)
// * `t`: trigger signal (attack is triggered when `t>0`, release is triggered
// when `t=0`)
//----------------------------------------------------------------
// Author: RM
smoothEnvelope(ar,t) = t : si.smooth(ba.tau2pole(ar));


//-----------------------`(en.)ar`--------------------------
// AR (Attack, Release) envelope generator (useful to create percussion envelopes).
// `ar` is a standard Faust function.
//
// #### Usage
//
// ```
// ar(at,rt,t) : _
// ```
//
// Where:
//
// * `at`: attack (sec)
// * `rt`: release (sec)
// * `t`: trigger signal (attack is triggered when `t>0`, release is triggered
// when `t=0`)
//-----------------------------------------------------
declare ar author "Yann Orlarey, Stéphane Letz";
ar(at,rt,gate) = AR : max(0)
with {

    // Durations in samples
    an = max(1, at*ma.SR);
    rn = max(1, rt*ma.SR);

    // Deltas per samples
    adelta = 1/an;
    rdelta = 1/rn;

    // Attack time (starts at gate upfront and raises infinitely)
    atime = (raise*reset + upfront) ~ _
    with {
        upfront = gate > gate';
        reset = gate <= gate';
        raise(x) = (x + (x > 0));
    };

    // Attack curve
    A = atime * adelta;

    // Release curve
    D0 = 1 + an * rdelta;
    D = D0 - atime * rdelta;

    // AR part
    AR = min(A, D);

};


//------------------------`(en.)arfe`----------------------
// ARFE (Attack and Release-to-Final-value Exponentially) envelope generator.
// Approximately equal to smoothEnvelope(Attack/6.91) when Attack == Release.
//
// #### Usage
//
// ```
// arfe(a,r,f,t) : _
// ```
//
// Where:
//
// * `a`, `r`: attack (sec), release (sec)
// * `f`: final value to approach upon release (such as 0)
// * `t`: trigger signal (attack is triggered when `t>0`, release is triggered
// when `t=0`)
//-----------------------------------------------------
// Author: JOS
// License: STK-4.3
arfe(attT60,relT60,fv,gate) = envelope with {
  ugate = gate>0;
  target = select2(ugate, fv, float(gate));
  t60 = select2(ugate, relT60, attT60);
  pole = ba.tau2pole(t60/6.91);
  envelope = target : si.smooth(pole);
};


//------------------------`(en.)are`----------------------
// ARE (Attack, Release) envelope generator with Exponential segments.
// Approximately equal to smoothEnvelope(Attack/6.91) when Attack == Release.
//
// #### Usage
//
// ```
// are(a,r,g) : _
// ```
//
// Where:
//
// * `a`: attack (sec)
// * `r`: release (sec)
// * `g`: gate signal (attack is triggered when `g>0`, release is triggered
//    when `g` returns to 0).
//-----------------------------------------------------
// Author: JOS
// License: STK-4.3
are(attT60,relT60,gate) = arfe(attT60,relT60,0,gate);


//------------------------`(en.)asr`----------------------
// ASR (Attack, Sustain, Release) envelope generator.
// `asr` is a standard Faust function.
//
// #### Usage
//
// ```
// asr(at,sl,rt,t) : _
// ```
//
// Where:
//
// * `at`: attack (sec)
// * `sl`: sustain level (between 0..1)
// * `r`: release (sec)
// * `t`: trigger signal (attack is triggered when `t>0`, release is triggered
// when `t=0`)
//-----------------------------------------------------
declare asr author "Yann Orlarey, Stéphane Letz";
asr(at,sl,rt,gate) = AS - R : max(0)
with {

    // Durations in samples
    an = max(1, at*ma.SR);
    rn = max(1, rt*ma.SR);

    // Deltas per samples
    adelta = sl/an;
    rdelta = sl/rn;

    // Attack time (starts when gate changes and raises until gate == 0)
    atime = +(gate) ~ *(gate' >= gate);

    // Attack curve
    A = atime * adelta;

    // AS part
    AS = min(A, sl);

    // Release time starts when gate is 0
    rtime = (+(1) : *(gate == 0)) ~ _;

    // Release curve starts when gate is 0 with the current value of the envelope
    R = rtime * rdelta;

};


//------------------------`(en.)adsr`----------------------
// ADSR (Attack, Decay, Sustain, Release) envelope generator.
// `adsr` is a standard Faust function.
//
// #### Usage
//
// ```
// adsr(at,dt,sl,rt,gate) : _
// ```
//
// Where:
//
// * `at`: attack time (sec)
// * `dt`: decay time (sec)
// * `sl`: sustain level (between 0..1)
// * `rt`: release time (sec)
// * `gate`: trigger signal (attack is triggered when `gate>0`, release is triggered
// when `gate=0`)
//-----------------------------------------------------
declare adsr author "Yann Orlarey and Andrey Bundin";
adsr(at,dt,sl,rt,gate) = ADS : *(1-R) : max(0)
with {

    // Durations in samples
    an = max(1, at*ma.SR);
    dn = max(1, dt*ma.SR);
    rn = max(1, rt*ma.SR);

    // Deltas per samples
    adelta = 1/an;
    ddelta = (1-sl)/dn;


    // Attack time (starts when gate changes and raises until gate == 0)
    atime = +(gate) ~ *(gate' >= gate);

    // Attack curve
    A = atime * adelta;

    // Decay curve
    D0 = 1 + an * ddelta;
    D = D0 - atime * ddelta;

    // ADS part
    ADS = min(A, max(D, sl));

    // Release time starts when gate is 0
    rtime = (+(1) : *(gate == 0)) ~ _;

    // Release curve starts when gate is 0 with the current value of the envelope
    R = rtime/rn;

};


//------------------------`(en.)adsre`----------------------
// ADSRE (Attack, Decay, Sustain, Release) envelope generator with Exponential
// segments.
//
// #### Usage
//
// ```
// adsre(a,d,s,r,g) : _
// ```
//
// Where:
//
// * `a`: attack (sec)
// * `d`: decay (sec)
// * `s`: sustain (fraction of `t`: 0-1)
// * `r`: release (sec)
// * `g`: gate signal:
//        attack is triggered when `g` goes from zero to positive,
//        release is triggered when `g` returns to 0
//-----------------------------------------------------
// Author: JOS
// License: STK-4.3
adsre(attT60,decT60,susLvl,relT60,gate) = envelope with {
  ugate = gate>0;
  samps = ugate : +~(*(ugate)); // ramp time in samples
  attSamps = int(attT60 * ma.SR);
  // if attSamps==0, go straight into the decay phase
  attPhase = (samps<attSamps) | (ugate:ba.impulsify);
  target = select2(ugate, 0.0,
           select2(attPhase, (susLvl)*float(ugate), ugate));
  t60 = select2(ugate, relT60, select2(attPhase, decT60, attT60));
  pole = ba.tau2pole(t60/6.91);
  envelope = target : si.smooth(pole);
};

//------------------------`(en.)asre`----------------------
// ASRE (Attack, Sustain, Release) envelope generator with Exponential segments.
//
// #### Usage
//
// ```
// asre(a,s,r,g) : _
// ```
//
// Where:
//
// * `a`: attack (sec)
// * `s`: sustain (fraction of `t`: 0-1)
// * `r`: release (sec)
// * `t`: trigger signal (attack is triggered when `t>0`, release is triggered
// when `t=0`)
//-----------------------------------------------------
// Author: JOS
// License: STK-4.3
asre(attT60,susLvl,relT60,gate) = envelope with {
  ugate = gate>0;
  target = select2(ugate, 0.0, (susLvl)*float(ugate));
  t60 = select2(ugate, relT60, attT60);
  pole = ba.tau2pole(t60/6.91);
  envelope = target : si.smooth(pole);
};


//----------------------`(en.)dx7envelope`----------------------
// DX7 operator envelope generator with 4 independent rates and levels. It is
// essentially a 4 points BPF.
//
// #### Usage
//
// ```
// dx7_envelope(R1,R2,R3,R4,L1,L2,L3,L4,t) : _
// ```
//
// Where:
//
// * `RN`: rates in seconds
// * `LN`: levels (0-1)
// * `t`: trigger signal
//-----------------------------------------------------
// Author: RM
dx7envelope(R1,R2,R3,R4,L1,L2,L3,L4,t) = up*on : ba.sAndH(on) : down
with {
  on = t>0;
  off = t==0;
  rs1 = R1*ma.SR;
  rs2 = R2*ma.SR;
  rs3 = R3*ma.SR;
  rs4 = R4*ma.SR;
  up = ba.countup(rs1+rs2+rs3,off) : ba.bpf.start(0,L4) : ba.bpf.point(rs1,L1) :
  ba.bpf.point(rs1+rs2,L2) : ba.bpf.end(rs1+rs2+rs3,L3);
  down = _,ba.countup(rs4,on) : ba.bpf.start(0) : ba.bpf.end(rs4,L4);
};
//############################## oscillators.lib ######################################
// This library contains a collection of sound generators. Its official prefix is `os`.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/oscillators.lib>
//########################################################################################

/************************************************************************
************************************************************************
FAUST library file, GRAME section

Except where noted otherwise, Copyright (C) 2003-2017 by GRAME,
Centre National de Creation Musicale.
----------------------------------------------------------------------
GRAME LICENSE

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

ma = library("maths.lib");
ba = library("basics.lib");
fi = library("filters.lib");
si = library("signals.lib");

declare name "Faust Oscillator Library";
declare version "0.3";

// This library contains platform specific constants 
pl = library("platform.lib");

//=========================Wave-Table-Based Oscillators===================================
//========================================================================================


//-----------------------`(os.)sinwaveform`------------------------
// Sine waveform ready to use with a `rdtable`.
//
// #### Usage
//
// ```
// sinwaveform(tablesize) : _
// ```
//
// Where:
//
// * `tablesize`: the table size
//------------------------------------------------------------
sinwaveform(tablesize) = 
    sin(float(ba.period(tablesize)) * (2.0 * ma.PI) / float(tablesize));


//-----------------------`(os.)coswaveform`------------------------
// Cosine waveform ready to use with a `rdtable`.
//
// #### Usage
//
// ```
// coswaveform(tablesize) : _
// ```
//
// Where:
//
// * `tablesize`: the table size
//------------------------------------------------------------
coswaveform(tablesize) = 
    cos(float(ba.period(tablesize)) * (2.0 * ma.PI) / float(tablesize));
    

// Generic phasor with `reset` and `phase` parameters to be specialised in concrete use-cases.
// The `reset` must be 1 on first sample for the `phase` to be properly initialized.
phasor_imp(freq, reset, phase) = (select2(reset, +(freq/ma.SR), phase) : ma.decimal) ~ _;

// Version to be used with tables
phasor_table(tablesize, freq, reset, phase) = phasor_imp(freq, reset, phase) : *(float(tablesize));

//-----------------------`(os.)phasor`------------------------
// A simple phasor to be used with a `rdtable`.
// `phasor` is a standard Faust function.
//
// #### Usage
//
// ```
// phasor(tablesize,freq) : _
// ```
//
// Where:
//
// * `tablesize`: the table size
// * `freq`: the frequency in Hz
//------------------------------------------------------------
phasor(tablesize, freq) = phasor_table(tablesize, freq, 0, 0);


//-----------------------`(os.)hs_phasor`------------------------
// Hardsyncing phasor to be used with a `rdtable`.
//
// #### Usage
//
// ```
// hs_phasor(tablesize,freq,reset) :  _
// ```
//
// Where:
//
// * `tablesize`: the table size
// * `freq`: the frequency in Hz
// * `reset`: a reset signal, reset phase to 0 when equal to 1
//---------------------------------------------------------
// Author: Mike Olsen, revised by Stéphane Letz
hs_phasor(tablesize, freq, reset) = phasor_table(tablesize, freq, reset, 0);


//-----------------------`(os.)hsp_phasor`------------------------
// Hardsyncing phasor with selectable phase to be used with a `rdtable`.
//
// #### Usage
//
// ```
// hsp_phasor(tablesize,freq,reset,phase)
// ```
//
// Where:
//
// * `tablesize`: the table size
// * `freq`: the frequency in Hz
// * `reset`: reset the oscillator to phase when equal to 1
// * `phase`: phase between 0 and 1
//---------------------------------------------------------
// Author: Christophe Lebreton, revised by Stéphane Letz
hsp_phasor(tablesize, freq, reset, phase) = phasor_table(tablesize, freq, reset, phase);


//-----------------------`(os.)oscsin`------------------------
// Sine wave oscillator.
// `oscsin` is a standard Faust function.
//
// #### Usage
//
// ```
// oscsin(freq) : _
// ```
//
// Where:
//
// * `freq`: the frequency in Hz
//------------------------------------------------------------
oscsin(freq) = rdtable(tablesize, sinwaveform(tablesize), int(phasor(tablesize,freq)))
with {
    tablesize = pl.tablesize;
};


//-----------------------`(os.)hs_oscsin`------------------------
// Sin lookup table with hardsyncing phase.
//
// #### Usage
//
// ```
// hs_oscsin(freq,reset) : _
// ```
//
// Where:
//
// * `freq`: the frequency in Hz
// * `reset`: reset the oscillator to 0 when equal to 1
//---------------------------------------------------------
// Author: Mike Olsen
hs_oscsin(freq,reset) = rdtable(tablesize, sinwaveform(tablesize), int(hs_phasor(tablesize,freq,reset)))
with {
    tablesize = pl.tablesize;
};


//-----------------------`(os.)osccos`------------------------
// Cosine wave oscillator.
//
// #### Usage
//
// ```
// osccos(freq) : _
// ```
//
// Where:
//
// * `freq`: the frequency in Hz
//------------------------------------------------------------
osccos(freq) = rdtable(tablesize, coswaveform(tablesize), int(phasor(tablesize,freq)))
with {
    tablesize = pl.tablesize;
};


//-----------------------`(os.)hs_osccos`------------------------
// Cos lookup table with hardsyncing phase.
//
// #### Usage
//
// ```
// hs_osccos(freq,reset) : _
// ```
//
// Where:
//
// * `freq`: the frequency in Hz
// * `reset`: reset the oscillator to 0 when equal to 1
//---------------------------------------------------------
// Author: Stéphane Letz
hs_osccos(freq,reset) = rdtable(tablesize, coswaveform(tablesize), int(hs_phasor(tablesize,freq,reset)))
with {
    tablesize = pl.tablesize;
};


//-----------------------`(os.)oscp`------------------------
// A sine wave generator with controllable phase.
//
// #### Usage
//
// ```
// oscp(freq,phase) : _
// ```
//
// Where:
//
// * `freq`: the frequency in Hz
// * `phase`: the phase in radian
//------------------------------------------------------------
oscp(freq,phase) = oscsin(freq) * cos(phase) + osccos(freq) * sin(phase);


//-----------------------`(os.)osci`------------------------
// Interpolated phase sine wave oscillator.
//
// #### Usage
//
// ```
// osci(freq) : _
// ```
//
// Where:
//
// * `freq`: the frequency in Hz
//------------------------------------------------------------
osci(freq) = s1 + d * (s2 - s1)
with {
    tablesize = pl.tablesize;
    i = int(phasor(tablesize,freq));
    d = ma.decimal(phasor(tablesize,freq));
    s1 = rdtable(tablesize+1,sinwaveform(tablesize),i);
    s2 = rdtable(tablesize+1,sinwaveform(tablesize),i+1);
};


//-----------------------`(os.)osc`------------------------
// Default sine wave oscillator (same as [oscsin](#oscsin)).
// `osc` is a standard Faust function.
//
// #### Usage
//
// ```
// osc(freq) : _
// ```
//
// Where:
//
// * `freq`: the frequency in Hz
//------------------------------------------------------------
osc = oscsin;


// end GRAME section
//########################################################################################
/************************************************************************
FAUST library file, jos section

Except where noted otherwise, The Faust functions below in this
section are Copyright (C) 2003-2017 by Julius O. Smith III <jos@ccrma.stanford.edu>
([jos](http://ccrma.stanford.edu/~jos/)), and released under the
(MIT-style) [STK-4.3](#stk-4.3-license) license.

The MarkDown comments in this section are Copyright 2016-2017 by Romain
Michon and Julius O. Smith III, and are released under the
[CCA4I](https://creativecommons.org/licenses/by/4.0/) license (TODO: if/when Romain agrees)

************************************************************************/

//===============================LFOs===============================
// Low-Frequency Oscillators (LFOs) have prefix `lf_`
// (no aliasing suppression, which is not audible at LF).
//==================================================================

//--------`(os.)lf_imptrain`----------
// Unit-amplitude low-frequency impulse train.
// `lf_imptrain` is a standard Faust function.
//
// #### Usage
//
// ```
// lf_imptrain(freq) : _
// ```
//
// Where:
//
// * `freq`: frequency in Hz
//------------------------------------------------------------
lf_imptrain(freq) = lf_sawpos(freq)<:-(mem)<0; // definition below


//--------`(os.)lf_pulsetrainpos`----------
// Unit-amplitude nonnegative LF pulse train, duty cycle between 0 and 1.
//
//
// #### Usage
//
// ```
// lf_pulsetrainpos(freq, duty) : _
// ```
//
// Where:
//
// * `freq`: frequency in Hz
// * `duty`: duty cycle between 0 and 1
//------------------------------------------------------------
lf_pulsetrainpos(freq,duty) = float(lf_sawpos(freq) <= duty);

//pulsetrainpos = lf_pulsetrainpos; // for backward compatibility


//--------`(os.)lf_pulsetrain`----------
// Unit-amplitude zero-mean LF pulse train, duty cycle between 0 and 1.
//
// #### Usage
//
// ```
// lf_pulsetrain(freq,duty) : _
// ```
//
// Where:
//
// * `freq`: frequency in Hz
// * `duty`: duty cycle between 0 and 1
//------------------------------------------------------------
lf_pulsetrain(freq,duty) = 2.0*lf_pulsetrainpos(freq,duty) - 1.0;


//--------`(os.)lf_squarewavepos`----------
// Positive LF square wave in [0,1]
//
// #### Usage
//
// ```
// lf_squarewavepos(freq) : _
// ```
//
// Where:
//
// * `freq`: frequency in Hz
//------------------------------------------------------------
lf_squarewavepos(freq) = lf_pulsetrainpos(freq,0.5);
// squarewavepos = lf_squarewavepos; // for backward compatibility


//--------`(os.)lf_squarewave`----------
// Zero-mean unit-amplitude LF square wave.
// `lf_squarewave` is a standard Faust function.
//
// #### Usage
//
// ```
// lf_squarewave(freq) : _
// ```
//
// Where:
//
// * `freq`: frequency in Hz
//------------------------------------------------------------
lf_squarewave(freq) = 2.0*lf_squarewavepos(freq) - 1.0;
// squarewave = lf_squarewave; // for backward compatibility


//--------`(os.)lf_trianglepos`----------
// Positive unit-amplitude LF positive triangle wave.
//
// #### Usage
//
// ```
// lf_trianglepos(freq) : _
// ```
//
// Where:
//
// * `freq`: frequency in Hz
//------------------------------------------------------------
lf_trianglepos(freq) = 1.0-abs(saw1(freq)); // saw1 defined below


//----------`(os.)lf_triangle`----------
// Positive unit-amplitude LF triangle wave.
// `lf_triangle` is a standard Faust function.
//
// #### Usage
//
// ```
// lf_triangle(freq) : _
// ```
//
// Where:
//
// * `freq`: frequency in Hz
//------------------------------------------------------------
// Author: Bart Brouns
// License: STK-4.3
lf_triangle(freq) = 2.0*lf_trianglepos(freq) - 1.0;


//================== Low Frequency Sawtooths ====================
// Sawtooth waveform oscillators for virtual analog synthesis et al.
// The 'simple' versions (`lf_rawsaw`, `lf_sawpos` and `saw1`), are mere samplings of
// the ideal continuous-time ("analog") waveforms.  While simple, the
// aliasing due to sampling is quite audible.  The differentiated
// polynomial waveform family (`saw2`, `sawN`, and derived functions)
// do some extra processing to suppress aliasing (not audible for
// very low fundamental frequencies).  According to Lehtonen et al.
// (JASA 2012), the aliasing of `saw2` should be inaudible at fundamental
// frequencies below 2 kHz or so, for a 44.1 kHz sampling rate and 60 dB SPL
// presentation level;  fundamentals 415 and below required no aliasing
// suppression (i.e., `saw1` is ok).
//=====================================================================

//-----------------`(os.)lf_rawsaw`--------------------
// Simple sawtooth waveform oscillator between 0 and period in samples.
//
// #### Usage
//
// ```
// lf_rawsaw(periodsamps) : _
// ```
//
// Where:
//
// * `periodsamps`: number of periods per samples
//---------------------------------------------------------
lf_rawsaw(periodsamps) = (_,periodsamps : fmod) ~ +(1.0);


//-----------------`(os.)lf_sawpos`--------------------
// Simple sawtooth waveform oscillator between 0 and 1.
//
// #### Usage
//
// ```
// lf_sawpos(freq) : _
// ```
//
// Where:
//
// * `freq`: frequency in Hz
//
//---------------------------------------------------------
// Author: Bart Brouns, revised by Stéphane Letz
// License: STK-4.3
lf_sawpos(freq) = phasor_imp(freq, 0, 0);


//-----------------`(os.)lf_sawpos_phase`--------------------
// Simple sawtooth waveform oscillator between 0 and 1
// with phase control.
//
// #### Usage
//
// ```
// lf_sawpos_phase(freq, phase) : _
// ```
//
// Where:
//
// * `freq`: frequency in Hz
// * `phase`: phase between 0 and 1
//---------------------------------------------------------
// Author: Bart Brouns, revised by Stéphane Letz
// License: STK-4.3
// Using an initial '1' to reset to `phase`
lf_sawpos_phase(freq,phase) = phasor_imp(freq, (1-1'), phase);


//-----------------`(os.)lf_sawpos_reset`--------------------
// Simple sawtooth waveform oscillator between 0 and 1
// with reset.
//
// #### Usage
//
// ```
// lf_sawpos_reset(freq,reset) : _
// ```
//
// Where:
//
// * `freq`: frequency in Hz
// * `reset`: reset the oscillator to 0 when equal to 1
//
//---------------------------------------------------------
// Author: Bart Brouns, revised by Stéphane Letz
// License: STK-4.3
lf_sawpos_reset(freq,reset) = phasor_imp(freq, reset, 0);


//-----------------`(os.)lf_sawpos_phase_reset`--------------------
// Simple sawtooth waveform oscillator between 0 and 1
// with phase control and reset.
//
// #### Usage
//
// ```
// lf_sawpos_phase_reset(freq,phase,reset) : _
// ```
//
// Where:
//
// * `freq`: frequency in Hz
// * `phase`: phase between 0 and 1
// * `reset`: reset the oscillator to phase when equal to 1
//
//---------------------------------------------------------
// Author: Bart Brouns, revised by Stéphane Letz
// License: STK-4.3
lf_sawpos_phase_reset(freq,phase,reset) = phasor_imp(freq, reset, phase);


//-----------------`(os.)lf_saw`--------------------
// Simple sawtooth waveform oscillator between -1 and 1.
// `lf_saw` is a standard Faust function.
//
// #### Usage
//
// ```
// lf_saw(freq) : _
// ```
//
// Where:
//
// * `freq`: frequency in Hz
//---------------------------------------------------------
// Author: Bart Brouns
// License: STK-4.3
saw1(freq) = 2.0 * lf_sawpos(freq) - 1.0;
lf_saw(freq) = saw1(freq);

//================== Bandlimited Sawtooth ====================
//-----------------`(os.)sawN`--------------------
// Bandlimited Sawtooth
//
// `sawN(N,freq)`, `sawNp`, `saw2dpw(freq)`, `saw2(freq)`, `saw3(freq)`,
// `saw4(freq)`, `saw5(freq)`, `saw6(freq)`, `sawtooth(freq)`, `saw2f2(freq)`
// `saw2f4(freq)`
//
// #### Method 1 (`saw2`)
//
// Polynomial Transition Regions (PTR) (for aliasing suppression).
//
// ##### References
//
// * Kleimola, J.; Valimaki, V., "Reducing Aliasing from Synthetic Audio
//     Signals Using Polynomial Transition Regions," in Signal Processing
//     Letters, IEEE , vol.19, no.2, pp.67-70, Feb. 2012
// * <https://aaltodoc.aalto.fi/bitstream/handle/123456789/7747/publication6.pdf?sequence=9>
// * <http://research.spa.aalto.fi/publications/papers/spl-ptr/>
//
// #### Method 2 (`sawN`)
//
// Differentiated Polynomial Waves (DPW) (for aliasing suppression).
//
// ##### Reference
//
// "Alias-Suppressed Oscillators based on Differentiated Polynomial Waveforms",
// Vesa Valimaki, Juhan Nam, Julius Smith, and Jonathan Abel,
// IEEE Tr. Acoustics, Speech, and Language Processing (IEEE-ASLP),
// Vol. 18, no. 5, May 2010.
//
// #### Other Cases
//
// Correction-filtered versions of `saw2`: `saw2f2`, `saw2f4`
// The correction filter compensates "droop" near half the sampling rate.
// See reference for sawN.
//
// #### Usage
//
// ```
// sawN(N,freq) : _
// sawNp(N,freq,phase) : _
// saw2dpw(freq) : _
// saw2(freq) : _
// saw3(freq) : _     // based on sawN
// saw4(freq) : _     // based on sawN
// saw5(freq) : _     // based on sawN
// saw6(freq) : _     // based on sawN
// sawtooth(freq) : _ // = saw2
// saw2f2(freq) : _
// saw2f4(freq) : _
// ```
//
// Where:
//
// * `N`: polynomial order, known at compile time
// * `freq`: frequency in Hz
// * `phase`: phase between 0 and 1
//===================================================================
// --- sawN for N = 1 to 6 ---
//We can do 6, but 5 and 6 have noise at low fundamentals: MAX_SAW_ORDER = 6; MAX_SAW_ORDER_NEXTPOW2 = 8;
MAX_SAW_ORDER = 4; MAX_SAW_ORDER_NEXTPOW2 = 8; // par cannot handle the case of 0 elements
sawN(N,freq) = saw1l : poly(Nc) : D(Nc-1) : gate(Nc-1)
with {
  Nc = max(1,min(N,MAX_SAW_ORDER));
  clippedFreq = max(20.0,abs(freq)); // use lf_sawpos(freq) for LFOs (freq < 20 Hz)
  saw1l = 2*lf_sawpos(clippedFreq) - 1; // zero-mean, amplitude +/- 1
  // Also note the availability of lf_sawpos_phase above.
  poly(1,x) = x;
  poly(2,x) = x*x;
  poly(3,x) = x*x*x - x;
  poly(4,x) = x*x*(x*x - 2.0);
  poly(5,x) = x*(7.0/3 + x*x*(-10.0/3.0 + x*x));
  poly(6,x) = x*x*(7.0 + x*x*(-5.0 + x*x));
  p0n = float(ma.SR)/clippedFreq; // period in samples
  diff1(x) = (x - x')/(2.0/p0n);
  diff(N) = seq(n,N,diff1); // N diff1s in series
  factorial(0) = 1;
  factorial(i) = i * factorial(i-1);
  D(0) = _;
  D(i) = diff(i)/factorial(i+1);
  gate(N) = *(1@(N)); // delayed step for blanking startup glitch
};

//------------------`(os.)sawNp`--------------------------------
// TODO: MarkDown doc in comments
//--------------------------------------------------------
// --- sawNp for N = 1 to 6 ---
// Phase offset = delay (max 8191 samples is more than one period of audio):
sawNp(N,freq,phase) = sawN(N,freq) : @(max(0,min(8191,int(phase*ma.SR/freq))));

// Special named cases:

//------------------`(os.)saw2dpw`--------------------------------
// TODO: MarkDown doc in comments
//--------------------------------------------------------
// --- sawN ---
saw2dpw(freq) = saw1(freq) <: * <: -(mem) : *(0.25'*ma.SR/freq); // inferior to saw2 below

//------------------`(os.)saw3`--------------------------------
// TODO: MarkDown doc in comments
//--------------------------------------------------------
saw3 = sawN(3); 
saw4 = sawN(4); 
saw5 = sawN(5); 
saw6 = sawN(6);

//------------------`(os.)sawtooth`--------------------------------
// Alias-free sawtooth wave. 2nd order interpolation (based on `saw2`).
// `sawtooth` is a standard Faust function.
//
// #### Usage
//
// ```
// sawtooth(freq) : _
// ```
//
// Where:
//
// * `freq`: frequency in Hz
//--------------------------------------------------------
saw2(freq) = y with { // newer PTR version (stateless - freq can vary at any speed)
  p0 = float(ma.SR)/float(max(ma.EPSILON,abs(freq))); // period in samples
  t0 = 1.0/p0; // phase increment
  p = ((_<:(-(1)<:_,_),_) <: selector1,selector2) ~(+(t0)):!,_;
  selector1 = select2(<(0)); // for feedback
  selector2 = select2(<(0), (_<:_,(*(1-p0):+(1)):+), _); // for output
  y = 2*p-1;
};

// --- sawtooth ---
sawtooth = saw2; // default choice for sawtooth signal - see also sawN

//------------------`(os.)saw2f2`--------------------------------
// TODO: MarkDown doc in comments
//---------------------------------------------------------------
// --- Correction-filtered versions of saw2: saw2f2, saw2f4 -----
// The correction filter compensates "droop" near half the sampling rate.
// See reference for sawN.
saw2f2 = saw2 : cf2 with {
  cf2 = fi.tf2(1.155704605878911, 0.745184288225518,0.040305967265900,
        0.823765146386639, 0.117420665547108);
};

//------------------`(os.)saw2f4`--------------------------------
// TODO: MarkDown doc in comments
//---------------------------------------------------------------
saw2f4 = saw2 : cf4 with {
  cf4 = fi.iir((1.155727435125014, 2.285861038554662,
        1.430915027294021, 0.290713280893317, 0.008306401748854),
        (2.156834679164532, 1.559532244409321, 0.423036498118354,
        0.032080681130972));
};

//=========Bandlimited Pulse, Square, and Impulse Trains============
// Bandlimited Pulse, Square and Impulse Trains.
//
// `pulsetrainN`, `pulsetrain`, `squareN`, `square`, `imptrain`, `imptrainN`,
// `triangle`, `triangleN`
//
// All are zero-mean and meant to oscillate in the audio frequency range.
// Use simpler sample-rounded lf_* versions above for LFOs.
//
// #### Usage
//
// ```
// pulsetrainN(N,freq,duty) : _
// pulsetrain(freq, duty) : _ // = pulsetrainN(2)
// squareN(N, freq) : _
// square : _ // = squareN(2)
// imptrainN(N,freq) : _
// imptrain : _ // = imptrainN(2)
// triangleN(N,freq) : _
// triangle : _ // = triangleN(2)
// ```
//
// Where:
//
// * `N`: polynomial order
// * `freq`: frequency in Hz
//====================================================================

//------------------`(os.)pulsetrainN`--------------------------------
// TODO: MarkDown doc in comments
//--------------------------------------------------------
pulsetrainN(N,freq,duty) = diffdel(sawN(N,freqC),del) with {
 // non-interpolated-delay version: diffdel(x,del) = x - x@int(del+0.5);
 // linearly interpolated delay version (sounds good to me):
    diffdel(x,del) = x-x@int(del)*(1-ma.frac(del))-x@(int(del)+1)*ma.frac(del);
 // Third-order Lagrange interpolated-delay version (see filters.lib):
 // diffdel(x,del) = x - fdelay3(DELPWR2,max(1,min(DELPWR2-2,ddel)));
 DELPWR2 = 2048; // Needs to be a power of 2 when fdelay*() used above.
 delmax = DELPWR2-1; // arbitrary upper limit on diff delay (duty=0.5)
 SRmax = 96000.0; // assumed upper limit on sampling rate
 fmin = SRmax / float(2.0*delmax); // 23.4 Hz (audio freqs only)
 freqC = max(freq,fmin); // clip frequency at lower limit
 period = (float(ma.SR) / freqC); // actual period
 ddel = duty * period; // desired delay
 del = max(0,min(delmax,ddel));
};

//------------------`(os.)pulsetrain`--------------------------------
// Bandlimited pulse train oscillator. Based on `pulsetrainN(2)`.
// `pulsetrain` is a standard Faust function.
//
// #### Usage
//
// ```
// pulsetrain(freq, duty) : _
// ```
//
// Where:
//
// * `freq`: frequency in Hz
// * `duty`: duty cycle between 0 and 1
//--------------------------------------------------------
pulsetrain = pulsetrainN(2);

//------------------`(os.)squareN`--------------------------------
// TODO: MarkDown doc in comments
//--------------------------------------------------------
squareN(N,freq) = pulsetrainN(N,freq,0.5);

//------------------`(os.)square`--------------------------------
// Bandlimited square wave oscillator. Based on `squareN(2)`.
// `square` is a standard Faust function.
//
// #### Usage
//
// ```
// square(freq) : _
// ```
//
// Where:
//
// * `freq`: frequency in Hz
//--------------------------------------------------------
square = squareN(2);

//------------------`(os.)impulse`--------------------------------
// One-time impulse generated when the Faust process is started.
// `impulse` is a standard Faust function.
//
// #### Usage
//
// ```
// impulse : _
// ```
//--------------------------------------------------------
impulse = 1-1';

//------------------`(os.)imptrainN`--------------------------------
// TODO: MarkDown doc in comments
//--------------------------------------------------------
imptrainN(N,freq) = impulse + 0.5*ma.diffn(sawN(N,freq));


//------------------`(os.)imptrain`--------------------------------
// Bandlimited impulse train generator. Based on `imptrainN(2)`.
// `imptrain` is a standard Faust function.
//
// #### Usage
//
// ```
// imptrain(freq) : _
// ```
//
// Where:
//
// * `freq`: frequency in Hz
//--------------------------------------------------------
imptrain = imptrainN(2); // default based on saw2

//------------------`(os.)triangleN`--------------------------------
// TODO: MarkDown doc in comments
//--------------------------------------------------------
triangleN(N,freq) = squareN(N,freq) : fi.pole(p) : *(gain) with {
  gain = 4.0*freq/ma.SR; // for aproximate unit peak amplitude
  p = 0.999;
};

//------------------`(os.)triangle`--------------------------------
// Bandlimited triangle wave oscillator. Based on `triangleN(2)`.
// `triangle` is a standard Faust function.
//
// #### Usage
//
// ```
// triangle(freq) : _
// ```
//
// Where:
//
// * `freq`: frequency in Hz
//--------------------------------------------------------
triangle = triangleN(2); // default based on saw2

//===============================Filter-Based Oscillators=================================
// Filter-Based Oscillators
//
// #### Usage
//
// ```
// osc[b|r|rs|rc|s|w](f), where f = frequency in Hz.
// ```
//
// #### References
//
// * <http://lac.linuxaudio.org/2012/download/lac12-slides-jos.pdf>
// * <https://ccrma.stanford.edu/~jos/pdf/lac12-paper-jos.pdf>
//========================================================================================

//--------------------------`(os.)oscb`--------------------------------
// Sinusoidal oscillator based on the biquad.
//
// #### Usage
//
// ```
// oscb(freq) : _
// ```
//
// Where:
//
// * `freq`: frequency in Hz
//------------------------------------------------------------
oscb(f) = impulse : fi.tf2(1,0,0,a1,1)
with {
  a1 = -2*cos(2*ma.PI*f/ma.SR);
};


//--------------------------`(os.)oscrq`---------------------------
// Sinusoidal (sine and cosine) oscillator based on 2D vector rotation,
//  = undamped "coupled-form" resonator
//  = lossless 2nd-order normalized ladder filter.
//
// #### Usage
//
// ```
// oscrq(freq) : _,_
// ```
//
// Where:
//
// * `freq`: frequency in Hz
//
// #### Reference
//
// * <https://ccrma.stanford.edu/~jos/pasp/Normalized_Scattering_Junctions.html>
//------------------------------------------------------------
oscrq(f) = impulse : fi.nlf2(f,1); // sine and cosine outputs

//--------------------------`(os.)oscrs`---------------------------
// Sinusoidal (sine) oscillator based on 2D vector rotation,
//  = undamped "coupled-form" resonator
//  = lossless 2nd-order normalized ladder filter.
//
// #### Usage
//
// ```
// oscrs(freq) : _
// ```
//
// Where:
//
// * `freq`: frequency in Hz
//
// #### Reference
//
// * <https://ccrma.stanford.edu/~jos/pasp/Normalized_Scattering_Junctions.html>
//------------------------------------------------------------
oscrs(f) = impulse : fi.nlf2(f,1) : _,!; // sine

//--------------------------`(os.)oscrc`---------------------------
// Sinusoidal (cosine) oscillator based on 2D vector rotation,
//  = undamped "coupled-form" resonator
//  = lossless 2nd-order normalized ladder filter.
//
// #### Usage
//
// ```
// oscrc(freq) : _
// ```
//
// Where:
//
// * `freq`: frequency in Hz
//
// #### Reference
//
// * <https://ccrma.stanford.edu/~jos/pasp/Normalized_Scattering_Junctions.html>
//------------------------------------------------------------
oscrc(f) = impulse : fi.nlf2(f,1) : !,_; // cosine

oscrp(f,p) = oscrq(f) : *(cos(p)), *(sin(p)) : + ; // p=0 for sine, p=PI/2 for cosine, etc.

oscr = oscrs; // default = sine (starts without a pop)

//--------------------------`(os.)oscs`--------------------------------
// Sinusoidal oscillator based on the state variable filter
// = undamped "modified-coupled-form" resonator
// = "magic circle" algorithm used in graphics.
//
// #### Usage
//
// ```
// oscs(freq) : _
// ```
//
// Where:
//
// * `freq`: frequency in Hz
//------------------------------------------------------------
oscs(f) = (*(-1) : sint(wn) : sintp(wn,impulse)) ~ _
with {
  wn = 2*ma.PI*f/ma.SR; // approximate
  // wn = 2*sin(PI*f/SR); // exact
  sint(x) = *(x) : + ~ _ ; // frequency-scaled integrator
  sintp(x,y) = *(x) : +(y): + ~ _; // same + state input
};

//-----------------`(os.)quadosc`--------------------
// Sinusoidal oscillator based on QuadOsc by Martin Vicanek.
//
// #### Usage
//
// ```
// quadosc(freq) : _
// ```
//
// where
//
// * `freq`: frequency in Hz
//
// #### Reference
// * <https://vicanek.de/articles/QuadOsc.pdf>
//------------------------------------------------------------
// Authors:
// Dario Sanfilippo <sanfilippo.dario@gmail.com>
// and Oleg Nesterov (jos ed.)
quadosc(f) = tick ~ (_,_) 
with {
    k1 = tan(f * ma.PI / ma.SR);
    k2 = 2 * k1 / (1 + k1 * k1);
    tick(u_0,v_0) = u_1,v_1 
    with {
        tmp = u_0 - k1 * v_0;
        v_1 = v_0 + k2 * tmp;
        u_1 = tmp - k1 * v_1 : select2(1',1);
    };
};


//================ Waveguide-Resonator-Based Oscillators ================
// Sinusoidal oscillator based on the waveguide resonator `wgr`.
//=======================================================================

//-----------------`(os.)oscwc`--------------------
// Sinusoidal oscillator based on the waveguide resonator `wgr`. Unit-amplitude
// cosine oscillator.
//
// #### Usage
//
// ```
// oscwc(freq) : _
// ```
//
// Where:
//
// * `freq`: frequency in Hz
//
// #### Reference
//
// * <https://ccrma.stanford.edu/~jos/pasp/Digital_Waveguide_Oscillator.html>
//------------------------------------------------------------
oscwc(fr) = impulse : fi.wgr(fr,1) : _,!; // cosine (cheapest at 1 mpy/sample)

//-----------------`(os.)oscws`--------------------
// Sinusoidal oscillator based on the waveguide resonator `wgr`. Unit-amplitude
// sine oscillator.
//
// #### Usage
//
// ```
// oscws(freq) : _
// ```
//
// Where:
//
// * `freq`: frequency in Hz
//
// #### Reference
//
// * <https://ccrma.stanford.edu/~jos/pasp/Digital_Waveguide_Oscillator.html>
//------------------------------------------------------------
oscws(fr) = impulse : fi.wgr(fr,1) : !,_; // sine (needs a 2nd scaling mpy)

//-----------------`(os.)oscwq`--------------------
// Sinusoidal oscillator based on the waveguide resonator `wgr`.
// Unit-amplitude cosine and sine (quadrature) oscillator.
//
// #### Usage
//
// ```
// oscwq(freq) : _
// ```
//
// Where:
//
// * `freq`: frequency in Hz
//
// #### Reference
//
// * <https://ccrma.stanford.edu/~jos/pasp/Digital_Waveguide_Oscillator.html>
//------------------------------------------------------------
oscq(fr) = impulse : fi.wgr(fr,1);       // phase quadrature outputs

//-----------------`(os.)oscw`--------------------
// Sinusoidal oscillator based on the waveguide resonator `wgr`.
// Unit-amplitude cosine oscillator (default).
//
// #### Usage
//
// ```
// oscw(freq) : _
// ```
//
// Where:
//
// * `freq`: frequency in Hz
//
// #### Reference
//
// * <https://ccrma.stanford.edu/~jos/pasp/Digital_Waveguide_Oscillator.html>
//------------------------------------------------------------
oscw = oscwc;

// end jos section
//########################################################################################
/************************************************************************
FAUST library file, further contributions section

All contributions below should indicate both the contributor and terms
of license.  If no such indication is found, "git blame" will say who
last edited each line, and that person can be emailed to inquire about
license disposition, if their license choice is not already indicated
elsewhere among the libraries.  It is expected that all software will be
released under LGPL, STK-4.3, MIT, BSD, or a similar FOSS license.
************************************************************************/

//===================== Casio CZ Oscillators ==========================
// Oscillators that mimic some of the Casio CZ oscillators.
//
// There are two sets:
// - A set with an index parameter
// - A set with a res parameter
//
// The "index oscillators" outputs a sine wave at index=0 and gets brighter with a higher index.
// There are two versions of the "index oscillators":
// - with P appended to the name: is phase aligned with 'fund:sin'
// - without P appended to the name: has the phase of the original CZ oscillators
//
// The "res oscillators" have a resonant frequency.
// "res" is the frequency of resonance as a factor of the fundamental pitch.
//=====================================================================

//----------`(os.)CZsaw`----------
// Oscillator that mimics the Casio CZ saw oscillator.
// `CZsaw` is a standard Faust function.
//
// #### Usage
//
// ```
// CZsaw(fund,index) : _
// ```
//
// Where:
//
// * `fund`: a saw-tooth waveform between 0 and 1 that the oscillator slaves to
// * `index`: the brightness of the oscillator, 0 to 1. 0 = sine-wave, 1 = saw-wave
//------------------------------------------------------------
// Author: Bart Brouns
// License: GPLv3
// CZ oscillators by Mike Moser-Booth:
// <https://forum.pdpatchrepo.info/topic/5992/casio-cz-oscillators>
// Ported from pd to Faust by Bart Brouns

CZsaw(fund, index) = CZ.sawChooseP(fund, index, 0);

//----------`(os.)CZsawP`----------
// Oscillator that mimics the Casio CZ saw oscillator,
// with it's phase aligned to `fund:sin`.
// `CZsawP` is a standard Faust function.
//
// #### Usage
//
// ```
// CZsawP(fund,index) : _
// ```
//
// Where:
//
// * `fund`: a saw-tooth waveform between 0 and 1 that the oscillator slaves to
// * `index`: the brightness of the oscillator, 0 to 1. 0 = sine-wave, 1 = saw-wave
//------------------------------------------------------------
// Author: Bart Brouns
// License: GPLv3
// CZ oscillators by Mike Moser-Booth:
// <https://forum.pdpatchrepo.info/topic/5992/casio-cz-oscillators>
// Ported from pd to Faust by Bart Brouns

CZsawP(fund, index) = CZ.sawChooseP(fund, index, 1);

//----------`(os.)CZsquare`----------
// Oscillator that mimics the Casio CZ square oscillator
// `CZsquare` is a standard Faust function.
//
// #### Usage
//
// ```
// CZsquare(fund,index) : _
// ```
//
// Where:
//
// * `fund`: a saw-tooth waveform between 0 and 1 that the oscillator slaves to
// * `index`: the brightness of the oscillator, 0 to 1. 0 = sine-wave, 1 = square-wave
//------------------------------------------------------------
// Author: Bart Brouns
// License: GPLv3
// CZ oscillators by Mike Moser-Booth:
// <https://forum.pdpatchrepo.info/topic/5992/casio-cz-oscillators>
// Ported from pd to Faust by Bart Brouns

CZsquare(fund, index) = CZ.squareChooseP(fund, index, 0);

//----------`(os.)CZsquareP`----------
// Oscillator that mimics the Casio CZ square oscillator,
// with it's phase aligned to `fund:sin`.
// `CZsquareP` is a standard Faust function.
//
// #### Usage
//
// ```
// CZsquareP(fund,index) : _
// ```
//
// Where:
//
// * `fund`: a saw-tooth waveform between 0 and 1 that the oscillator slaves to
// * `index`: the brightness of the oscillator, 0 to 1. 0 = sine-wave, 1 = square-wave
//------------------------------------------------------------
// Author: Bart Brouns
// License: GPLv3
// CZ oscillators by Mike Moser-Booth:
// <https://forum.pdpatchrepo.info/topic/5992/casio-cz-oscillators>
// Ported from pd to Faust by Bart Brouns

CZsquareP(fund, index) = CZ.squareChooseP(fund, index, 1);

//----------`(os.)CZpulse`----------
// Oscillator that mimics the Casio CZ pulse oscillator.
// `CZpulse` is a standard Faust function.
//
// #### Usage
//
// ```
// CZpulse(fund,index) : _
// ```
//
// Where:
//
// * `fund`: a saw-tooth waveform between 0 and 1 that the oscillator slaves to
// * `index`: the brightness of the oscillator, 0 gives a sine-wave, 1 is closer to a pulse
//------------------------------------------------------------
// Author: Bart Brouns
// License: GPLv3
// CZ oscillators by Mike Moser-Booth:
// <https://forum.pdpatchrepo.info/topic/5992/casio-cz-oscillators>
// Ported from pd to Faust by Bart Brouns

CZpulse(fund, index) = CZ.pulseChooseP(fund, index, 0);

//----------`(os.)CZpulseP`----------
// Oscillator that mimics the Casio CZ pulse oscillator,
// with it's phase aligned to `fund:sin`.
// `CZpulseP` is a standard Faust function.
//
// #### Usage
//
// ```
// CZpulseP(fund,index) : _
// ```
//
// Where:
//
// * `fund`: a saw-tooth waveform between 0 and 1 that the oscillator slaves to
// * `index`: the brightness of the oscillator, 0 gives a sine-wave, 1 is closer to a pulse
//------------------------------------------------------------
// Author: Bart Brouns
// License: GPLv3
// CZ oscillators by Mike Moser-Booth:
// <https://forum.pdpatchrepo.info/topic/5992/casio-cz-oscillators>
// Ported from pd to Faust by Bart Brouns

CZpulseP(fund, index) = CZ.pulseChooseP(fund, index, 1);

//----------`(os.)CZsinePulse`----------
// Oscillator that mimics the Casio CZ sine/pulse oscillator.
// `CZsinePulse` is a standard Faust function.
//
// #### Usage
//
// ```
// CZsinePulse(fund,index) : _
// ```
//
// Where:
//
// * `fund`: a saw-tooth waveform between 0 and 1 that the oscillator slaves to
// * `index`: the brightness of the oscillator, 0 gives a sine-wave, 1 is a sine minus a pulse
//------------------------------------------------------------
// Author: Bart Brouns
// License: GPLv3
// CZ oscillators by Mike Moser-Booth:
// <https://forum.pdpatchrepo.info/topic/5992/casio-cz-oscillators>
// Ported from pd to Faust by Bart Brouns

CZsinePulse(fund, index) = CZ.sinePulseChooseP(fund, index, 0);

//----------`(os.)CZsinePulseP`----------
// Oscillator that mimics the Casio CZ sine/pulse oscillator,
// with it's phase aligned to `fund:sin`.
// `CZsinePulseP` is a standard Faust function.
//
// #### Usage
//
// ```
// CZsinePulseP(fund,index) : _
// ```
//
// Where:
//
// * `fund`: a saw-tooth waveform between 0 and 1 that the oscillator slaves to
// * `index`: the brightness of the oscillator, 0 gives a sine-wave, 1 is a sine minus a pulse
//------------------------------------------------------------
// Author: Bart Brouns
// License: GPLv3
// CZ oscillators by Mike Moser-Booth:
// <https://forum.pdpatchrepo.info/topic/5992/casio-cz-oscillators>
// Ported from pd to Faust by Bart Brouns

CZsinePulseP(fund, index) = CZ.sinePulseChooseP(fund, index, 1);

//----------`(os.)CZhalfSine`----------
// Oscillator that mimics the Casio CZ half sine oscillator.
// `CZhalfSine` is a standard Faust function.
//
// #### Usage
//
// ```
// CZhalfSine(fund,index) : _
// ```
//
// Where:
//
// * `fund`: a saw-tooth waveform between 0 and 1 that the oscillator slaves to
// * `index`: the brightness of the oscillator, 0 gives a sine-wave, 1 is somewhere between a saw and a square
//------------------------------------------------------------
// Author: Bart Brouns
// License: GPLv3
// CZ oscillators by Mike Moser-Booth:
// <https://forum.pdpatchrepo.info/topic/5992/casio-cz-oscillators>
// Ported from pd to Faust by Bart Brouns

CZhalfSine(fund, index) = CZ.halfSineChooseP(fund, index, 0);

//----------`(os.)CZhalfSineP`----------
// Oscillator that mimics the Casio CZ half sine oscillator,
// with it's phase aligned to `fund:sin`.
// `CZhalfSineP` is a standard Faust function.
//
// #### Usage
//
// ```
// CZhalfSineP(fund,index) : _
// ```
//
// Where:
//
// * `fund`: a saw-tooth waveform between 0 and 1 that the oscillator slaves to
// * `index`: the brightness of the oscillator, 0 gives a sine-wave, 1 is somewhere between a saw and a square
//------------------------------------------------------------
// Author: Bart Brouns
// License: GPLv3
// CZ oscillators by Mike Moser-Booth:
// <https://forum.pdpatchrepo.info/topic/5992/casio-cz-oscillators>
// Ported from pd to Faust by Bart Brouns

CZhalfSineP(fund, index) = CZ.halfSineChooseP(fund, index, 1);

//----------`(os.)CZresSaw`----------
// Oscillator that mimics the Casio CZ resonant sawtooth oscillator.
// `CZresSaw` is a standard Faust function.
//
// #### Usage
//
// ```
// CZresSaw(fund,res) : _
// ```
//
// Where:
//
// * `fund`: a saw-tooth waveform between 0 and 1 that the oscillator slaves to
// * `res`: the frequency of resonance as a factor of the fundamental pitch.
//------------------------------------------------------------
// Author: Bart Brouns
// License: GPLv3
// CZ oscillators by Mike Moser-Booth:
// <https://forum.pdpatchrepo.info/topic/5992/casio-cz-oscillators>
// Ported from pd to Faust by Bart Brouns

CZresSaw(fund,res) = CZ.resSaw(fund,res);

//----------`(os.)CZresTriangle`----------
// Oscillator that mimics the Casio CZ resonant triangle oscillator.
// `CZresTriangle` is a standard Faust function.
//
// #### Usage
//
// ```
// CZresTriangle(fund,res) : _
// ```
//
// Where:
//
// * `fund`: a saw-tooth waveform between 0 and 1 that the oscillator slaves to
// * `res`: the frequency of resonance as a factor of the fundamental pitch.
//------------------------------------------------------------
// Author: Bart Brouns
// License: GPLv3
// CZ oscillators by Mike Moser-Booth:
// <https://forum.pdpatchrepo.info/topic/5992/casio-cz-oscillators>
// Ported from pd to Faust by Bart Brouns

CZresTriangle(fund,res) = CZ.resTriangle(fund,res);

//----------`(os.)CZresTrap`----------
// Oscillator that mimics the Casio CZ resonant trapeze oscillator
// `CZresTrap` is a standard Faust function.
//
// #### Usage
//
// ```
// CZresTrap(fund,res) : _
// ```
//
// Where:
//
// * `fund`: a saw-tooth waveform between 0 and 1 that the oscillator slaves to
// * `res`: the frequency of resonance as a factor of the fundamental pitch.
//------------------------------------------------------------
// Author: Bart Brouns
// License: GPLv3
// CZ oscillators by Mike Moser-Booth:
// <https://forum.pdpatchrepo.info/topic/5992/casio-cz-oscillators>
// Ported from pd to Faust by Bart Brouns

CZresTrap(fund, res) = CZ.resTrap(fund, res);

CZ = environment {
  
    saw(fund, index) = sawChooseP(fund, index, 0);
    sawP(fund, index) = sawChooseP(fund, index, 1);
    sawChooseP(fund, index, p) =
      (((FUND(fund,align,p)*((.5-INDEX)/INDEX)),(-1*FUND(fund,align,p)+1)*((.5-INDEX)/(1-INDEX))):min+FUND(fund,align,p))*2*ma.PI:cos
    with {
      INDEX = (.5-(index*.5)):max(0.01):min(0.5);
      align = si.interpolate(index, 0.75, 0.5);
    };
    
    square(fund, index) = squareChooseP(fund, index, 0);
    squareP(fund, index) = squareChooseP(fund, index, 1);
    squareChooseP(fund, index, p) = (FUND(fund,align,p)>=0.5), (ma.decimal((FUND(fund,align,p)*2)+1)<:_-min(_,(-1*_+1)*((INDEX)/(1-INDEX)))) :+ *ma.PI:cos
    with {
      INDEX = (index:pow(0.25)):max(0):min(1);
      align = si.interpolate(INDEX, -0.25, 0);
    };

    pulse(fund, index) = pulseChooseP(fund, index, 0);
    pulseP(fund, index) = pulseChooseP(fund, index, 1);
    pulseChooseP(fund, index, p) = ((FUND(fund,align,p)-min(FUND(fund,align,p),((-1*FUND(fund,align,p)+1)*(INDEX/(1-INDEX)))))*2*ma.PI):cos
    with {
      INDEX = index:min(0.99):max(0);
      align = si.interpolate(index, -0.25, 0.0);
    };

    sinePulse(fund, index) = sinePulseChooseP(fund, index, 0);
    sinePulseP(fund, index) = sinePulseChooseP(fund, index, 1);
    sinePulseChooseP(fund, index, p) = (min(FUND(fund,align,p)*((0.5-INDEX)/INDEX),(-1*FUND(fund,align,p)+1)*((.5-INDEX)/(1-INDEX)))+FUND(fund,align,p))*4*ma.PI:cos
    with {
      INDEX = ((index*-0.49)+0.5);
      align = si.interpolate(index, -0.125, -0.25);
    };

    halfSine(fund, index) = halfSineChooseP(fund, index, 0);
    halfSineP(fund, index) = halfSineChooseP(fund, index, 1);
    halfSineChooseP(fund, index, p) = (select2(FUND(fund,align,p)<.5, .5*(FUND(fund,align,p)-.5)/INDEX+.5, FUND(fund,align,p)):min(1))*2*ma.PI:cos
    with {
      INDEX = (.5-(index*0.5)):min(.5):max(.01);
      align = si.interpolate(index:min(0.975), -0.25, -0.5);
    };
    
    FUND =
      case {
        (fund,align,0) => fund;
        (fund,align,1) => (fund+align) : ma.frac; // align phase with fund
      };
    resSaw(fund,res) = (((-1*(1-fund))*((cos((ma.decimal((max(1,res)*fund)+1))*2*ma.PI)*-.5)+.5))*2)+1;
    resTriangle(fund,res) = select2(fund<.5, 2-(fund*2), fund*2)*INDEX*2-1
    with {
      INDEX = ((fund*(res:max(1)))+1:ma.decimal)*2*ma.PI:cos*.5+.5;
    };
    resTrap(fund, res) = (((1-fund)*2):min(1)*sin(ma.decimal(fund*(res:max(1)))*2*ma.PI));
};

//===============================PolyBLEP-Based Oscillators=================================

//----------`(os.)polyblep`----------
// PolyBLEP residual function, used for smoothing steps in the audio signal.
//
// #### Usage
//
// ```
// polyblep(Q,phase) : _
// ```
//
// Where:
//
// * `Q`: smoothing factor between 0 and 0.5. Determines how far from the ends of the phase interval the quadratic function is used.
// * `phase`: normalised phase (between 0 and 1)
//------------------------------------------------------------
// Author: Jacek Wieczorek
polyblep(Q, phase) = (0, L(phase / Q), R((phase - 1) / Q)) : select3(sel) 
with {
    sel = (phase < Q) + 2*(phase > 1 - Q);
    L(x) = 2*x - x*x - 1; // Used near the left end of the interval
    R(x) = 2*x + x*x + 1; // Used near the right end of the interval
};

//----------`(os.)polyblep_saw`----------
// Sawtooth oscillator with suppressed aliasing (using polyBLEP).
//
// #### Usage
//
// ```
// polyblep_saw(freq) : _
// ```
//
// Where:
//
// * `freq`: frequency in Hz 
//------------------------------------------------------------
// Author: Jacek Wieczorek
polyblep_saw(freq) = naive - polyblep(Q , phase)
with {
    phase = phasor(1, freq);
    naive = 2 * phase - 1;
    Q = freq / ma.SR;
};

//----------`(os.)polyblep_square`----------
// Square wave oscillator with suppressed aliasing (using polyBLEP).
//
// #### Usage
//
// ```
// polyblep_square(freq) : _
// ```
//
// Where:
//
// * `freq`: frequency in Hz 
//------------------------------------------------------------
// Author: Jacek Wieczorek
polyblep_square(freq) = naive - polyblep(Q, phase) + polyblep(Q, ma.modulo(phase + 0.5, 1))
with {
    phase = phasor(1, freq);
    naive = 2 * (phase * 2 : int) - 1;
    Q = freq / ma.SR;
};

//----------`(os.)polyblep_triangle`----------
// Triangle wave oscillator with suppressed aliasing (using polyBLEP).
//
// #### Usage
//
// ```
// polyblep_triangle(freq) : _
// ```
//
// Where:
//
// * `freq`: frequency in Hz 
//------------------------------------------------------------
// Author: Jacek Wieczorek
polyblep_triangle(freq) = polyblep_square(freq) : fi.pole(0.999) : *(4 * freq / ma.SR);

// end further contributions section
//########################################################################################
//############################# mi.lib #########################################
// This ongoing work is the fruit of a collaboration between GRAME-CNCM and
// the ANIS (Arts Numériques et Immersions Sensorielles) research group from
// GIPSA-Lab (Université Grenoble Alpes).
//
// This library implements basic 1-DoF mass-interaction physics algorithms,
// allowing to declare and connect physical elements (masses, springs, non
// linear interactions, etc.) together to form topological networks.
// Models can be assembled by hand, however in more complex scenarios it is
// recommended to use a scripting tool (such as MIMS) to generate the FAUST
// signal routing for a given physical network. Its official prefix is `mi`.
//
// <https://github.com/rmichon/mi_faust>
// <http://mi-creative.eu/tool_miFaust.html>
// <http://mi-creative.eu/paper_lac19.html>
//
//
// ## Sources
//
// The core mass-interaction algorithms implemented in this library are in the public
// domain and are disclosed in the following scientific publications:
//
// * Claude Cadoz, Annie Luciani, Jean-Loup Florens, Curtis Roads and Françoise
// Chabade. Responsive Input Devices and Sound Synthesis by Stimulation of
// Instrumental Mechanisms: The Cordis System. Computer Music Journal, Vol 8.
// No. 3, 1984.
// * Claude Cadoz, Annie Luciani and Jean Loup Florens. CORDIS-ANIMA: A Modeling
// and Simulation System for Sound and Image Synthesis: The General Formalism.
// Computer Music Journal. Vol. 17, No. 1, 1993.
// * Alexandros Kontogeorgakopoulos and Claude Cadoz. Cordis Anima Physical
// Modeling and Simulation System Analysis. In Proceedings of the Sound and Music
// Computing Conference (SMC-07), Lefkada, Greece, 2007.
// * Nicolas Castagne, Claude Cadoz, Ali Allaoui and Olivier Tache. G3: Genesis
// Software Environment Update. In Proceedings of the International Computer
// Music Conference (ICMC-09), Montreal, Canada, 2009.
// * Nicolas Castagné and Claude Cadoz. Genesis 3: Plate-forme pour la création
// musicale à l'aide des modèles physiques Cordis-Anima. In Proceedings of the
// Journée de l'Informatique Musicale, Grenoble, France, 2009.
// * Edgar Berdahl and Julius O. Smith. An Introduction to the Synth-A-Modeler
// Compiler: Modular and Open-Source Sound Synthesis using Physical Models. In
// Proceedings of the Linux Audio Conference (LAC-12), Stanford, USA, 2012.
// * James Leonard and Claude Cadoz. Physical Modelling Concepts for a Collection
// of Multisensory Virtual Musical Instruments. In Proceedings of the New
// Interfaces for Musical Expression (NIME-15) Conference, Baton Rouge, USA, 2015.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/mi.lib>
//##############################################################################

ma = library("maths.lib");
ba = library("basics.lib");

declare name "Faust mass-interaction physical modelling library";
declare version "0.0";
declare author "James Leonard";
declare author "Romain Michon";
declare copyright "2018-2020 GRAME / GIPSA-Lab";


//===============================Utility Functions========================================
// These utility functions are used to help certain operations (e.g. define initial
// positions and velocities for physical elements).
//========================================================================================



//------------------------`(mi.)initState`----------------------
// Used to set initial delayed position values that must be initialised
// at step 0 of the physics simulation.
//
// If you develop any of your own modules, you will need to use this (see
// mass and springDamper algorithm codes for examples).
//
// #### Usage
//
// ```
// x: initState(x0) : _
// ```
//
// Where:
//
// * `x`: position value signal
// * `x0`: initial value for position
//---------------------------------------------------------
initState(init) = R(0,init)
with{
  R(n,(initn,init)) = +(1: ba.impulsify@n * initn) : R(n+1,init);
  R(n,initn) = +(1 : ba.impulsify@n * initn);
};




//=================================Mass Algorithms========================================
// All mass-type physical element functions are declared here. They all expect to receive
// a force input signal and produce a position signal.
// All physical parameters are expressed in sample-rate dependant values.
//========================================================================================



//------------------------`(mi.)mass`----------------------
// Implementation of a punctual mass element.
// Takes an input force and produces output position.
//
// #### Usage
//
// ```
// mass(m, grav, x0, xr0),_ : _
// ```
//
// Where:
//
// * `m`: mass value
// * `grav`: gravity force value
// * `x0`: initial position
// * `xr0`: initial delayed position (inferred from initial velocity)
//---------------------------------------------------------
mass(m, grav, x0, x1) = equation
with{
  A = 2;
  B = -1;
  C = 1/m;
  equation = x 
	letrec{
    'x = A*(x : initState(x0)) + B*(x' : initState((x1,x0))) + (_-grav)*(C);
	};
};



//------------------------`(mi.)oscil`----------------------
// Implementation of a simple linear harmonic oscillator.
// Takes an input force and produces output position.
//
// #### Usage
//
// ```
// oscil(m, k, z, grav, x0, xr0),_ : _
// ```
//
// Where:
//
// * `m`: mass value
// * `k`: stiffness value
// * `z`: damping value
// * `grav`: gravity force value
// * `x0`: initial position
// * `xr0`: initial delayed position (inferred from initial velocity)
//---------------------------------------------------------
oscil(m, k, z, grav, x0, x1) = equation
with{
  A = 2 - (k + z)/m;
  B = z/m - 1;
  C = 1/m;
  equation = x
	letrec{
    'x = A*(x : initState(x0)) + B*(x' : initState((x1, x0))) + (_-grav)*(C);
	};
};



//------------------------`(mi.)ground`----------------------
// Implementation of a fixed point element.
// The position output produced by this module never changes, however
// it still expects a force input signal (for compliance with connection
// rules).
//
// #### Usage
//
// ```
// ground(x0),_ : _
// ```
//
// Where:
//
// * `x0`: initial position
//---------------------------------------------------------
ground(x0) = equation
with{
  // could this term be removed or simlified? Need "unused" input force signal for the routing scheme to work
  C = 0;
  equation = x 
	letrec{
		'x = (x : initState(x0)) + *(C);
	};
};



//------------------------`(mi.)posInput`----------------------
// Implementation of a position input module (driven by an outside
// signal). Takes two signal inputs: incoming force (which doesn't
// affect position) and the driving position signal.
//
// #### Usage
//
// ```
// posInput(x0),_,_ : _
// ```
//
// Where:
//
// * `x0`: initial position
//---------------------------------------------------------
posInput(init) = _,_ : !,_ : initState(init);



//===============================Interaction Algorithms====================================
// All interaction-type physical element functions are declared here. They each expect to
// receive two position signals (coming from the two mass-elements that they connect) and
// produce two equal and opposite force signals that must be routed back to the mass
// elements' inputs.
// All physical parameters are expressed in sample-rate dependant values.
//=========================================================================================



//------------------------`(mi.)spring`----------------------
// Implementation of a linear elastic spring interaction.
//
// #### Usage
//
// ```
// spring(k, x1r, x2r),_,_ : _,_
// ```
//
// Where:
//
// * `k`: stiffness value
// * `x1r`: initial delayed position of mass 1 (unused here)
// * `x2r`: initial delayed position of mass 2 (unused here)
//---------------------------------------------------------
spring(k, x1r0, x2r0, x1, x2) = 
  k*deltapos <: *(-1),_
with{
    deltapos = x1-x2;
};



//------------------------`(mi.)damper`----------------------
// Implementation of a linear damper interaction.
// Beware: in 32bit precision mode, damping forces can become
// truncated if position values are not centered around zero!
//
// #### Usage
//
// ```
// damper(z, x1r, x2r),_,_ : _,_
// ```
//
// Where:
//
// * `z`: damping value
// * `x1r`: initial delayed position of mass 1
// * `x2r`: initial delayed position of mass 2
//---------------------------------------------------------
damper(z, x1r0, x2r0, x1, x2) = 
  z*deltavel <: *(-1),_
with{
    deltavel = (x1 - x1' : initState(x1r0)) - (x2 - x2' : initState(x2r0));
};



//------------------------`(mi.)springDamper`----------------------
// Implementation of a linear viscoelastic spring-damper interaction
// (a combination of the spring and damper modules).
//
// #### Usage
//
// ```
// springDamper(k, z, x1r, x2r),_,_ : _,_
// ```
//
// Where:
//
// * `k`: stiffness value
// * `z`: damping value
// * `x1r`: initial delayed position of mass 1
// * `x2r`: initial delayed position of mass 2
//---------------------------------------------------------
springDamper(k, z, x1r0, x2r0, x1, x2) = 
  k*deltapos + 
  z*deltavel <: *(-1),_
with{
    deltapos = x1-x2;
    deltavel = (x1 - x1' : initState(x1r0)) - (x2 - x2' : initState(x2r0));
};



//------------------------`(mi.)nlSpringDamper2`----------------------
// Implementation of a non-linear viscoelastic spring-damper interaction
// containing a quadratic term (function of squared distance).
// Beware: at high displacements, this interaction will break numerical
// stability conditions ! The nlSpringDamperClipped is a safer option.
//
// #### Usage
//
// ```
// nlSpringDamper2(k, q, z, x1r, x2r),_,_ : _,_
// ```
//
// Where:
//
// * `k`: linear stiffness value
// * `q`: quadratic stiffness value
// * `z`: damping value
// * `x1r`: initial delayed position of mass 1
// * `x2r`: initial delayed position of mass 2
//---------------------------------------------------------
nlSpringDamper2(k, q, z, x1r0, x2r0, x1, x2) =
  k*deltapos + q * ma.signum(deltapos) * pow(deltapos, 2) +
  z*deltavel <: *(-1),_
with{
    deltapos = x1-x2;
    deltavel = (x1 - x1' : initState(x1r0)) - (x2 - x2' : initState(x2r0));
};



//------------------------`(mi.)nlSpringDamper3`----------------------
// Implementation of a non-linear viscoelastic spring-damper interaction
// containing a cubic term (function of distance^3).
// Beware: at high displacements, this interaction will break numerical
// stability conditions ! The nlSpringDamperClipped is a safer option.
//
// #### Usage
//
// ```
// nlSpringDamper3(k, q, z, x1r, x2r),_,_ : _,_
// ```
//
// Where:
//
// * `k`: linear stiffness value
// * `q`: cubic stiffness value
// * `z`: damping value
// * `x1r`: initial delayed position of mass 1
// * `x2r`: initial delayed position of mass 2
//---------------------------------------------------------
nlSpringDamper3(k, q, z, x1r0, x2r0, x1, x2) =
  k*deltapos + q * pow(deltapos, 3) +
  z*deltavel <: *(-1),_
with{
    deltapos = x1-x2;
    deltavel = (x1 - x1' : initState(x1r0)) - (x2 - x2' : initState(x2r0));
};



//------------------------`(mi.)nlSpringDamperClipped`----------------------
// Implementation of a non-linear viscoelastic spring-damper interaction
// containing a cubic term (function of distance^3), bound by an
// upper linear stiffness (hard-clipping).
//
// This bounding means that when faced with strong displacements, the
// interaction profile will "clip" at a given point and never produce
// forces higher than the bounding equivalent linear spring, stopping models
// from becoming unstable.
//
// So far the interaction clips "hard" (with no soft-knee spline
// interpolation, etc.)
//
// #### Usage
//
// ```
// nlSpringDamperClipped(s, c, k, z, x1r, x2r),_,_ : _,_
// ```
//
// Where:
//
// * `s`: linear stiffness value
// * `c`: cubic stiffness value
// * `k`: upper-bound linear stiffness value
// * `z`: (linear) damping value
// * `x1r`: initial delayed position of mass 1
// * `x2r`: initial delayed position of mass 2
//---------------------------------------------------------
nlSpringDamperClipped(s, c, k, z, x1r0, x2r0, x1, x2) =
    select2(c == 0,
        select2(s >= k,
            select2(absdeltapos <= b,
                // Overdamping induced here to prevent "locked" states...
                k * deltapos + (z+0.3*k)*deltavel,
                s * deltapos + c * pow(deltapos, 3) + z*deltavel
            ),
            k * deltapos + z*deltavel
        ),
        s * deltapos + z*deltavel
    )<: *(-1),_
with{
    b = sqrt(k-s)/c;
    deltapos = x1-x2;
    deltavel = (x1 - x1' : initState(x1r0)) - (x2 - x2' : initState(x2r0));
    absdeltapos = abs(deltapos);

};



//------------------------`(mi.)nlPluck`----------------------
// Implementation of a piecewise linear plucking interaction.
// The symmetric function provides a repulsive viscoelastic interaction
// upon contact, until a tipping point is reached (when the plucking occurs).
// The tipping point depends both on the stiffness and the distance scaling
// of the interaction.
//
//
// #### Usage
//
// ```
// nlPluck(knl, scale, z, x1r, x2r),_,_ : _,_
// ```
//
// Where:
//
// * `knl`: stiffness scaling parameter (vertical stretch of the NL function)
// * `scale`: distance scaling parameter (horizontal stretch of the NL function)
// * `z`: (linear) damping value
// * `x1r`: initial delayed position of mass 1
// * `x2r`: initial delayed position of mass 2
//---------------------------------------------------------
nlPluck(k, scale, z, x1r0, x2r0, x1, x2) = 
  select2(absdeltapos < tipdist,
    select2(absdeltapos < scale,
	  		0,
	  		ma.signum(deltapos)* -tipdist * k + Kend * deltapos + 
              z* deltavel
	  		),
	(k - Kend) * -deltapos + z* deltavel
	) <:  *(-1),_
with{
  deltapos = x1 - x2;
  deltavel = (x1 - x1' : initState(x1r0)) - (x2 - x2' : initState(x2r0));

  absdeltapos = abs(deltapos);
  sharpness = 10;
  tipdist = scale / sharpness;
  Kend = k / sharpness;
};



//------------------------`(mi.)nlBow`----------------------
// Implementation of a non-linear friction based interaction
// that allows for stick-slip bowing behaviour.
// Two versions are proposed : a piecewise linear function (very
// similar to the nlPluck) or a mathematical approximation (see
// Stefan Bilbao's book, Numerical Sound Synthesis).
//
//
// #### Usage
//
// ```
// nlBow(znl, scale, type, x1r, x2r),_,_ : _,_
// ```
//
// Where:
//
// * `znl`: friction scaling parameter (vertical stretch of the NL function)
// * `scale`: velocity scaling parameter (horizontal stretch of the NL function)
// * `type`: interaction profile (0 = piecewise linear, 1 = smooth function)
// * `x1r`: initial delayed position of mass 1
// * `x2r`: initial delayed position of mass 2
//---------------------------------------------------------
nlBow(z, scale, type, x1r0, x2r0, x1, x2) =
  select2(type > 0,
    select2(absdeltavel < tipvel,
        select2(absdeltavel < scale,
	  		0,
	  		ma.signum(deltavel)* tipvel * z - Zend * deltavel
	  		),
	    (z - Zend) * deltavel
	),
    0.63 * z * deltavel *exp(-4*pow(deltavel/scale, 2) + 1/2)
  )
   <:  *(-1),_
with{
  deltavel = (x1 - x1' : initState(x1r0)) - (x2 - x2' : initState(x2r0));
  absdeltavel = abs(deltavel);
  sharpness = 3;
  tipvel = scale / sharpness;
  Zend = z / sharpness;
};



//------------------------`(mi.)collision`----------------------
// Implementation of a collision interaction, producing linear visco-elastic
// repulsion forces when two mass elements are interpenetrating.
//
//
// #### Usage
//
// ```
// collision(k, z, thres, x1r, x2r),_,_ : _,_
// ```
//
// Where:
//
// * `k`: collision stiffness parameter
// * `z`: collision damping parameter
// * `thres`: threshold distance for the contact between elements
// * `x1r`: initial delayed position of mass 1
// * `x2r`: initial delayed position of mass 2
//---------------------------------------------------------
collision(k,z,thres,x1r0,x2r0,x1,x2) = 
  springDamper(k,z,x1r0,x2r0,x1+thres,x2) : (select2(comp,0,_),select2(comp,0,_))
with{
  comp = (x2-x1) < thres;
};



//------------------------`(mi.)nlCollisionClipped`----------------------
// Implementation of a collision interaction, producing non-linear
// visco-elastic repulsion forces when two mass elements are interpenetrating.
// Bound by an upper stiffness value to maintain stability.
// This interaction is particularly useful for more realistic contact dynamics
// (greater difference in velocity provides sharper contacts, and reciprocally).
//
// #### Usage
//
// ```
// nlCollisionClipped(s, c, k, z, thres, x1r, x2r),_,_ : _,_
// ```
//
// Where:
//
// * `s`: collision linear stiffness parameter
// * `c`: collision cubic stiffness parameter
// * `k`: collision upper-bounding stiffness parameter
// * `z`: collision damping parameter
// * `thres`: threshold distance for the contact between elements
// * `x1r`: initial delayed position of mass 1
// * `x2r`: initial delayed position of mass 2
//---------------------------------------------------------
nlCollisionClipped(s, c, k, z, thres, x1r0, x2r0, x1, x2) = 
  nlSpringDamperClipped(s,c,k,z,x1r0,x2r0,x1+thres,x2) : (select2(comp,0,_),select2(comp,0,_))
with{
  comp = (x2-x1) < thres;
};
//################################## misceffects.lib ##########################################
// This library contains a collection of audio effects. Its official prefix is `ef`.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/misceffects.lib>
//########################################################################################

/************************************************************************
************************************************************************
FAUST library file
Copyright (C) 2003-2016 GRAME, Centre National de Creation Musicale
----------------------------------------------------------------------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

ma = library("maths.lib");
ba = library("basics.lib");
de = library("delays.lib");
si = library("signals.lib");
an = library("analyzers.lib");
fi = library("filters.lib");
ef = library("misceffects.lib"); // for compatible copy/paste out of this file

declare name "Misc Effects Library";
declare version "2.0"; // TODO to check

//########################################################################################
/************************************************************************
FAUST library file, jos section

Except where noted otherwise, The Faust functions below in this
section are Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>
([jos](http://ccrma.stanford.edu/~jos/)), and released under the
(MIT-style) [STK-4.3](#stk-4.3-license) license.

MarkDown comments in this section are Copyright 2016-2019 by Romain
Michon and Julius O. Smith III, and are released under the
[CCA4I](https://creativecommons.org/licenses/by/4.0/) license (TODO: if/when Romain agrees!)

************************************************************************/

//======================================Dynamic===========================================
//========================================================================================

//---------------------`(ef.)cubicnl`-----------------------
// Cubic nonlinearity distortion.
// `cubicnl` is a standard Faust library.
//
// #### Usage:
//
// ```
// _ : cubicnl(drive,offset) : _
// _ : cubicnl_nodc(drive,offset) : _
// ```
//
// Where:
//
// * `drive`: distortion amount, between 0 and 1
// * `offset`: constant added before nonlinearity to give even harmonics. Note: offset
// 	can introduce a nonzero mean - feed cubicnl output to dcblocker to remove this.
//
// #### References:
//
// * <https://ccrma.stanford.edu/~jos/pasp/Cubic_Soft_Clipper.html>
// * <https://ccrma.stanford.edu/~jos/pasp/Nonlinear_Distortion.html>
//------------------------------------------------------------
cubicnl(drive,offset) = *(pregain) : +(offset) : clip(-1,1) : cubic
with {
    pregain = pow(10.0,2*drive);
    clip(lo,hi) = min(hi) : max(lo);
    cubic(x) = x - x*x*x/3;
    postgain = max(1.0,1.0/pregain);
};

cubicnl_nodc(drive,offset) = cubicnl(drive,offset) : fi.dcblocker;


//-----------------`(ef.)gate_mono`-------------------
// Mono signal gate.
// `gate_mono` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : gate_mono(thresh,att,hold,rel) : _
// ```
//
// Where:
//
// * `thresh`: dB level threshold above which gate opens (e.g., -60 dB)
// * `att`: attack time = time constant (sec) for gate to open (e.g., 0.0001 s = 0.1 ms)
// * `hold`: hold time = time (sec) gate stays open after signal level < thresh (e.g., 0.1 s)
// * `rel`: release time = time constant (sec) for gate to close (e.g., 0.020 s = 20 ms)
//
// #### References
//
// * <http://en.wikipedia.org/wiki/Noise_gate>
// * <http://www.soundonsound.com/sos/apr01/articles/advanced.asp>
// * <http://en.wikipedia.org/wiki/Gating_(sound_engineering)>
//------------------------------------------------------------
gate_mono(thresh,att,hold,rel,x) = x * gate_gain_mono(thresh,att,hold,rel,x);


//-----------------`(ef.)gate_stereo`-------------------
// Stereo signal gates.
// `gate_stereo` is a standard Faust function.
//
// #### Usage
//
// ```
//  _,_ : gate_stereo(thresh,att,hold,rel) : _,_
// ```
//
// Where:
//
// * `thresh`: dB level threshold above which gate opens (e.g., -60 dB)
// * `att`: attack time = time constant (sec) for gate to open (e.g., 0.0001 s = 0.1 ms)
// * `hold`: hold time = time (sec) gate stays open after signal level < thresh (e.g., 0.1 s)
// * `rel`: release time = time constant (sec) for gate to close (e.g., 0.020 s = 20 ms)
//
// #### References
//
// * <http://en.wikipedia.org/wiki/Noise_gate>
// * <http://www.soundonsound.com/sos/apr01/articles/advanced.asp>
// * <http://en.wikipedia.org/wiki/Gating_(sound_engineering)>
//------------------------------------------------------------
gate_stereo(thresh,att,hold,rel,x,y) = ggm*x, ggm*y with {
  ggm = gate_gain_mono(thresh,att,hold,rel,abs(x)+abs(y));
};

gate_gain_mono(thresh,att,hold,rel,x) = x : extendedrawgate : an.amp_follower_ar(att,rel) with {
  extendedrawgate(x) = max(float(rawgatesig(x)),holdsig(x));
  rawgatesig(x) = inlevel(x) > ba.db2linear(thresh);
  minrate = min(att,rel);
  inlevel = an.amp_follower_ar(minrate,minrate);
  holdcounter(x) = (max(holdreset(x) * holdsamps,_) ~-(1));
  holdsig(x) = holdcounter(x) > 0;
  holdreset(x) = rawgatesig(x) < rawgatesig(x)'; // reset hold when raw gate falls
  holdsamps = int(hold*ma.SR);
};


//=====================================Filtering==========================================
//========================================================================================

//-------------------------`(ef.)speakerbp`-------------------------------
// Dirt-simple speaker simulator (overall bandpass eq with observed
// roll-offs above and below the passband).
//
// Low-frequency speaker model = +12 dB/octave slope breaking to
// flat near f1. Implemented using two dc blockers in series.
//
// High-frequency model = -24 dB/octave slope implemented using a
// fourth-order Butterworth lowpass.
//
// Example based on measured Celestion G12 (12" speaker):
//
// `speakerbp` is a standard Faust function.
//
// #### Usage
//
// ```
// speakerbp(f1,f2)
// _ : speakerbp(130,5000) : _
// ```
//------------------------------------------------------------
// TODO: perhaps this should be moved to physmodels.lib
// [JOS: I don't think so because it's merely a bandpass filter tuned to speaker bandwidth]
speakerbp(f1,f2) = fi.dcblockerat(f1) : fi.dcblockerat(f1) : fi.lowpass(4,f2);


//------------`(ef.)piano_dispersion_filter`---------------
// Piano dispersion allpass filter in closed form.
//
// #### Usage
//
// ```
// piano_dispersion_filter(M,B,f0)
// _ : piano_dispersion_filter(1,B,f0) : +(totalDelay),_ : fdelay(maxDelay) : _
// ```
//
// Where:
//
// * `M`: number of first-order allpass sections (compile-time only)
//  	Keep below 20. 8 is typical for medium-sized piano strings.
// * `B`: string inharmonicity coefficient (0.0001 is typical)
// * `f0`: fundamental frequency in Hz
//
// #### Outputs
//
// * MINUS the estimated delay at `f0` of allpass chain in samples,
//     provided in negative form to facilitate subtraction
//     from delay-line length.
// * Output signal from allpass chain
//
// #### Reference
//
// * "Dispersion Modeling in Waveguide Piano Synthesis Using Tunable
// Allpass Filters", by Jukka Rauhala and Vesa Valimaki, DAFX-2006, pp. 71-76
// * <http://lib.tkk.fi/Diss/2007/isbn9789512290666/article2.pdf>
//   An erratum in Eq. (7) is corrected in Dr. Rauhala's encompassing
//   dissertation (and below).
// * <http://www.acoustics.hut.fi/research/asp/piano/>
//------------------------------------------------------------
// TODO: perhaps this should be moved to physmodels.lib?
// [JOS: I vote yes when there is a piano model in physmodels.lib.]
piano_dispersion_filter(M,B,f0) = -Df0*M,seq(i,M,fi.tf1(a1,1,a1))
with {
 a1 = (1-D)/(1+D); // By Eq. 3, have D >= 0, hence a1 >= 0 also
 D = exp(Cd - Ikey(f0)*kd);
 trt = pow(2.0,1.0/12.0); // 12th root of 2
 logb(b,x) = log(x) / log(b); // log-base-b of x
 Ikey(f0) = logb(trt,f0*trt/27.5);
 Bc = max(B,0.000001);
 kd = exp(k1*log(Bc)*log(Bc) + k2*log(Bc)+k3);
 Cd = exp((m1*log(M)+m2)*log(Bc)+m3*log(M)+m4);
 k1 = -0.00179;
 k2 = -0.0233;
 k3 = -2.93;
 m1 = 0.0126;
 m2 = 0.0606;
 m3 = -0.00825;
 m4 = 1.97;
 wT = 2*ma.PI*f0/ma.SR;
 polydel(a) = atan(sin(wT)/(a+cos(wT)))/wT;
 Df0 = polydel(a1) - polydel(1.0/a1);
};

//-------------------------`(ef.)stereo_width`---------------------------
// Stereo Width effect using the Blumlein Shuffler technique.
// `stereo_width` is a standard Faust function.
//
// #### Usage
//
// ```
// _,_ : stereo_width(w) : _,_
// ```
//
// Where:
//
// * `w`: stereo width between 0 and 1
//
// At `w=0`, the output signal is mono ((left+right)/2 in both channels).
// At `w=1`, there is no effect (original stereo image).
// Thus, w between 0 and 1 varies stereo width from 0 to "original".
//
// #### Reference
//
// * "Applications of Blumlein Shuffling to Stereo Microphone Techniques"
// Michael A. Gerzon, JAES vol. 42, no. 6, June 1994
//------------------------------------------------------------
stereo_width(w) = shuffle : *(mgain),*(sgain) : shuffle
with {
     shuffle =  _,_ <: +,-; // normally scaled by 1/sqrt(2) for orthonormality,
     mgain = 1-w/2;  // but we pick up the needed normalization here.
     sgain = w/2;
};

//===========================================Meshes=======================================
//========================================================================================


// TODO: the following should be in physmodels.lib when it will be operational
// [JOS: I think a new "Meshes" section would fit well after Modal Percussions.]
//----------------------------------`(ef.)mesh_square`------------------------------
// Square Rectangular Digital Waveguide Mesh.
//
// #### Usage
//
// ```
// bus(4*N) : mesh_square(N) : bus(4*N)
// ```
//
// Where:
//
// * `N`: number of nodes along each edge - a power of two (1,2,4,8,...)
//
// #### Reference
//
// <https://ccrma.stanford.edu/~jos/pasp/Digital_Waveguide_Mesh.html>
//
// #### Signal Order In and Out
//
// The mesh is constructed recursively using 2x2 embeddings. Thus,
// the top level of `mesh_square(M)` is a block 2x2 mesh, where each
// block is a `mesh(M/2)`. Let these blocks be numbered 1,2,3,4 in the
// geometry NW,NE,SW,SE, i.e., as
//         1 2
//         3 4
// Each block has four vector inputs and four vector outputs, where the
// length of each vector is `M/2`.  Label the input vectors as Ni,Ei,Wi,Si,
// i.e., as the inputs from the North, East South, and West,
// and similarly for the outputs.  Then, for example, the upper
// left input block of M/2 signals is labeled 1Ni.  Most of the
// connections are internal, such as 1Eo -> 2Wi.  The `8*(M/2)` input
// signals are grouped in the order
//        1Ni 2Ni
//        3Si 4Si
//        1Wi 3Wi
//        2Ei 4Ei
// and the output signals are
//        1No 1Wo
//        2No 2Eo
//        3So 3Wo
//        4So 4Eo
// or
//
// In: 1No 1Wo 2No 2Eo 3So 3Wo 4So 4Eo
//
// Out: 1Ni 2Ni 3Si 4Si 1Wi 3Wi 2Ei 4Ei
//
// Thus, the inputs are grouped by direction N,S,W,E, while the
// outputs are grouped by block number 1,2,3,4, which can also be
// interpreted as directions NW, NE, SW, SE.  A simple program
// illustrating these orderings is `process = mesh_square(2);`.
//
// #### Example
//
// Reflectively terminated mesh impulsed at one corner:
//
// ```
// mesh_square_test(N,x) = mesh_square(N)~(busi(4*N,x)) // input to corner
// with { busi(N,x) = bus(N) : par(i,N,*(-1)) : par(i,N-1,_), +(x); };
// process = 1-1' : mesh_square_test(4); // all modes excited forever
// ```
//
// In this simple example, the mesh edges are connected as follows:
//
// 1No -> 1Ni, 1Wo -> 2Ni, 2No -> 3Si, 2Eo -> 4Si,
//
// 3So -> 1Wi, 3Wo -> 3Wi, 4So -> 2Ei, 4Eo -> 4Ei
//
// A routing matrix can be used to obtain other connection geometries.
//------------------------------------------------------------
// four-port scattering junction:
mesh_square(1) =
          si.bus(4) <: par(i,4,*(-1)), (si.bus(4) :> (*(.5)) <: si.bus(4)) :> si.bus(4);

// rectangular NxN square waveguide mesh:
mesh_square(N) = si.bus(4*N) : (route_inputs(N/2) : par(i,4,mesh_square(N/2)))
          ~(prune_feedback(N/2))
          : prune_outputs(N/2) : route_outputs(N/2) : si.bus(4*N)
with {
  // select block i of N, block size = M:
  s(i,N,M) = par(j, M*N, Sv(i, j))
     with { Sv(i,i) = si.bus(N); Sv(i,j) = si.block(N); };

  // prune mesh outputs down to the signals which make it out:
  prune_outputs(N)
    = si.bus(16*N) :
      si.block(N), si.bus(N),   si.block(N), si.bus(N),
      si.block(N), si.bus(N),   si.bus(N),   si.block(N),
      si.bus(N),   si.block(N), si.block(N), si.bus(N),
      si.bus(N),   si.block(N), si.bus(N),   si.block(N)
      : si.bus(8*N);

  // collect mesh outputs into standard order (N,W,E,S):
  route_outputs(N)
    = si.bus(8*N)
      <: s(4,N,8),s(5,N,8), s(0,N,8),s(2,N,8),
         s(3,N,8),s(7,N,8), s(1,N,8),s(6,N,8)
      : si.bus(8*N);

  // collect signals used as feedback:
  prune_feedback(N) = si.bus(16*N) :
      si.bus(N),   si.block(N), si.bus(N),   si.block(N),
      si.bus(N),   si.block(N), si.block(N), si.bus(N),
      si.block(N), si.bus(N),   si.bus(N),   si.block(N),
      si.block(N), si.bus(N),   si.block(N), si.bus(N) :
      si.bus(8*N);

  // route mesh inputs (feedback, external inputs):
  route_inputs(N) = si.bus(8*N), si.bus(8*N)
  <:s(8,N,16),s(4,N,16), s(12,N,16),s(3,N,16),
    s(9,N,16),s(6,N,16), s(1,N,16),s(14,N,16),
    s(0,N,16),s(10,N,16), s(13,N,16),s(7,N,16),
    s(2,N,16),s(11,N,16), s(5,N,16),s(15,N,16)
    : si.bus(16*N);
};

//--------------------`(ef.)reverseEchoN(nChans,delay)`-------------------
// Reverse echo effect.
//
// #### Usage
//
// ```
// _ : ef.reverseEchoN(N,delay) : si.bus(N)
// ```
//
// Where:
//
// *     `N`: Number of output channels desired (1 or more)
// * `delay`: echo delay (integer power of 2)
//
// #### Demo
//
// ```
// _ : dm.reverseEchoN(N) : _,_
// ```
//
// #### Description
//
// The effect uses N instances of reverseDelayRamped at different phases.
//
//------------------------------------------------------------
reverseEchoN(N,delMax) = _<: par(i,N,ef.reverseDelayRamped(delMax,i/N));

//-------------------`(ef.)reverseDelayRamped(delay,phase)`------------------
// Reverse delay with amplitude ramp.
//
// #### Usage
//
// ```
// _ : ef.reverseDelayRamped(delay,phase) : _
// ```
//
// Where:
//
// * `delay`: echo delay (integer power of 2)
// * `phase`: float between 0 and 1 giving ramp delay phase*delay
//
// #### Demo
//
// ```
// _ : dm.reverseEchoN(N) : _,_
// ```
//
//------------------------------------------------------------
reverseDelayRamped(delMax,phs) = rampGain * de.delay(delMax,del) with {
  rampGain = 4 * (del/delMax) * (1 - del/delMax); // suppress click when delay-line wraps around
  delOffset = int(floor(0.5 + delMax * max(0,min(0.999999,phs)))); // starting point in delay line
  startPulse = (1-1') * delOffset;
  del = int(startPulse : + ~ +(2)) & (delMax-1);
};

//-------------------`(ef.)uniformPanToStereo(nChans)`------------------
// Pan nChans channels to the stereo field, spread uniformly left to right.
//
// #### Usage
//
// ```
// si.bus(N) : ef.uniformPanToStereo(N) : _,_
// ```
//
// Where:
//
// * `N`: Number of input channels to pan down to stereo
//
// #### Demo
//
// ```
// _ : dm.reverseEchoN(N) : _,_
// ```
//
//------------------------------------------------------------
uniformPanToStereo(N) = si.bus(N) <: par(i,2*N,_) :
		      (par(i,N,*(i/(N-1))) :> _),
		      (par(i,N,*(1-i/(N-1))) :> _);

// end jos section
/************************************************************************
************************************************************************
FAUST library file, GRAME section

Except where noted otherwise, Copyright (C) 2003-2017 by GRAME,
Centre National de Creation Musicale.
----------------------------------------------------------------------
GRAME LICENSE

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

//========================================Time Based======================================
//========================================================================================

//----------`(ef.)echo`----------
// A simple echo effect.
//
// `echo` is a standard Faust function
//
// #### Usage
//
// ```
// _ : echo(maxDuration,duration,feedback) : _
// ```
//
// Where:
//
// * `maxDuration`: the max echo duration in seconds
// * `duration`: the echo duration in seconds
// * `feedback`: the feedback coefficient
//----------------------------------------------------
// TODO: author RM
echo(maxDuration,duration,feedback) = +~de.delay(maxDel,del)*feedback
with{
  maxDel = ma.SR*maxDuration;
  del = ma.SR*duration;
};

// TODO demo function for echo

//=======================================Pitch Shifting===================================
//========================================================================================

//--------------`(ef.)transpose`----------------
// A simple pitch shifter based on 2 delay lines.
// `transpose` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : transpose(w, x, s) : _
// ```
//
// Where:
//
// * `w`: the window length (samples)
// * `x`: crossfade duration duration (samples)
// * `s`: shift (semitones)
//-----------------------------------------
transpose(w, x, s, sig) = de.fdelay(maxDelay,d,sig)*ma.fmin(d/x,1) +
	de.fdelay(maxDelay,d+w,sig)*(1-ma.fmin(d/x,1))
with {
	maxDelay = 65536;
	i = 1 - pow(2, s/12);
	d = i : (+ : +(w) : fmod(_,w)) ~ _;
};

//////////////////////////////////Deprecated Functions////////////////////////////////////
// This section implements functions that used to be in music.lib but that are now
// considered as "deprecated".
//////////////////////////////////////////////////////////////////////////////////////////

echo1s  = vgroup("echo 1000", +~(de.delay(65536, int(hslider("millisecond", 0, 0, 1000, 0.10)*ba.millisec)-1) * (hslider("feedback", 0, 0, 100, 0.1)/100.0)));
echo2s  = vgroup("echo 2000", +~(de.delay(131072, int(hslider("millisecond", 0, 0, 2000, 0.25)*ba.millisec)-1) * (hslider("feedback", 0, 0, 100, 0.1)/100.0)));
echo5s  = vgroup("echo 5000", +~(de.delay(262144, int(hslider("millisecond", 0, 0, 5000, 0.50)*ba.millisec)-1) * (hslider("feedback", 0, 0, 100, 0.1)/100.0)));
echo10s = vgroup("echo 10000", +~(de.delay(524288, int(hslider("millisecond", 0, 0, 10000, 1.00)*ba.millisec)-1) * (hslider("feedback", 0, 0, 100, 0.1)/100.0)));
echo21s = vgroup("echo 21000", +~(de.delay(1048576, int(hslider("millisecond", 0, 0, 21000, 1.00)*ba.millisec)-1) * (hslider("feedback", 0, 0, 100, 0.1)/100.0)));
echo43s = vgroup("echo 43000", +~(de.delay(2097152, int(hslider("millisecond", 0, 0, 43000, 1.00)*ba.millisec)-1) * (hslider("feedback", 0, 0, 100, 0.1)/100.0)));
//################################ version.lib ##########################################
// Semantic versioning for the Faust libraries. Its official prefix is `vl`.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/version.lib>
//########################################################################################

//---------------------------`(vl.)version`---------------------------
// Return the version number of the Faust standard libraries as a MAJOR, MINOR, PATCH versioning triplet.
//
// #### Usage
//
// ```
// version : _,_,_
// ```
//
//------------------------------------------------------------
version =   2, // MAJOR version when we make incompatible API changes,
            7, // MINOR version when we add functionality in a backwards compatible manner,
            2; // PATCH version when we make backwards compatible bug fixes.

            
//#################################### webaudio.lib ########################################
//An implementation of the WebAudio API filters (https://www.w3.org/TR/webaudio/). Its official prefix is `wa`.
//
// This library implement WebAudio filters, using their C++ version as a starting point, 
// taken from Mozilla Firefox implementation.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/webaudio.lib>
//########################################################################################

/************************************************************************
************************************************************************
FAUST library file
Copyright (C) 2019-2020 GRAME, Centre National de Creation Musicale
---------------------------------------------------------------------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

ma = library("maths.lib");
fi = library("filters.lib");

declare name "Faust WebAudio Filters Library";
declare author "GRAME";
declare copyright "GRAME";
declare version "0.1";
declare license "LGPL with exception";

//---------------------------------------------------
// biquad coeffs for various filters
// usage : BiquadFilter(f0, dBgain, Q, aDetune).xxx
//---------------------------------------------------
	
BiquadFilter(f0, dBgain, Q, aDetune) = environment
{
    lowpass2 = setNormCoeffs(b0, b1, b2, a0, a1, a2)
    with {
        g = pow(10.0, -0.05 * Q);
        w0 = ma.PI * cutoff;
        cos_w0 = cos(w0);
        alpha = 0.5 * sin(w0) * g;

        b1 = 1.0 - cos_w0;
        b0 = 0.5 * b1;
        b2 = b0;
        a0 = 1.0 + alpha;
        a1 = -2.0 * cos_w0;
        a2 = 1.0 - alpha;
    };
 		
    highpass2 = setNormCoeffs(b0, b1, b2, a0, a1, a2)
    with {
        g = pow(10.0, -0.05 * Q);
        w0 = ma.PI * cutoff;
        cos_w0 = cos(w0);
        alpha = 0.5 * sin(w0) * g;

        b1 = -1.0 - cos_w0;
        b0 = -0.5 * b1;
        b2 = b0;
        a0 = 1.0 + alpha;
        a1 = -2.0 * cos_w0;
        a2 = 1.0 - alpha;
    };

    bandpass2 = setNormCoeffs(b0, b1, b2, a0, a1, a2)
    with {
        // Don't let Q go negative, which causes an unstable filter.
        Qaux = max(0.01, Q);

        w0 = ma.PI * cutoff;
        alpha = sin(w0) / (2 * Qaux);
        k = cos(w0);

        b0 = alpha;
        b1 = 0;
        b2 = -alpha;
        a0 = 1 + alpha;
        a1 = -2 * k;
        a2 = 1 - alpha;
    };

    notch2 = setNormCoeffs(b0, b1, b2, a0, a1, a2)
    with {
        // Don't let Q go negative, which causes an unstable filter.
        Qaux = max(0.01, Q);

        w0 = ma.PI * cutoff;
        alpha = sin(w0) / (2 * Qaux);
        k = cos(w0);

        b0 = 1;
        b1 = -2 * k;
        b2 = 1;
        a0 = 1 + alpha;
        a1 = -2 * k;
        a2 = 1 - alpha;
    };

    allpass2 = setNormCoeffs(b0, b1, b2, a0, a1, a2)
    with {
        // Don't let Q go negative, which causes an unstable filter.
        Qaux = max(0.01, Q);
        
        w0 = ma.PI * cutoff;
        alpha = sin(w0) / (2 * Qaux);
        k = cos(w0);

        b0 = 1 - alpha;
        b1 = -2 * k;
        b2 = 1 + alpha;
        a0 = 1 + alpha;
        a1 = -2 * k;
        a2 = 1 - alpha; 
    };
    
    peaking2 = setNormCoeffs(b0, b1, b2, a0, a1, a2)
    with {
        // Don't let Q go negative, which causes an unstable filter.
        Qaux = max(0.01, Q);
        
        A = pow(10.0, dBgain / 40);
        w0 = ma.PI * cutoff;
        alpha = sin(w0) / (2 * Qaux);
        k = cos(w0);

        b0 = 1 + alpha * A;
        b1 = -2 * k;
        b2 = 1 - alpha * A;
        a0 = 1 + alpha / A;
        a1 = -2 * k;
        a2 = 1 - alpha / A;
   };
    
    lowshelf2 = setNormCoeffs(b0, b1, b2, a0, a1, a2)
    with {
        A = pow(10.0, dBgain / 40);

        w0 = ma.PI * cutoff;
        S = 1;  // filter slope (1 is max value)
        alpha = 0.5 * sin(w0) * sqrt((A + 1 / A) * (1 / S - 1) + 2);
        k = cos(w0);
        k2 = 2 * sqrt(A) * alpha;
        aPlusOne = A + 1;
        aMinusOne = A - 1;

        b0 = A * (aPlusOne - aMinusOne * k + k2);
        b1 = 2 * A * (aMinusOne - aPlusOne * k);
        b2 = A * (aPlusOne - aMinusOne * k - k2);
        a0 = aPlusOne + aMinusOne * k + k2;
        a1 = -2 * (aMinusOne + aPlusOne * k);
        a2 = aPlusOne + aMinusOne * k - k2;
    };
    
    highshelf2 = setNormCoeffs(b0, b1, b2, a0, a1, a2)
    with {
        A = pow(10.0, dBgain / 40);

        w0 = ma.PI * cutoff;
        S = 1;  // filter slope (1 is max value)
        alpha = 0.5 * sin(w0) * sqrt((A + 1 / A) * (1 / S - 1) + 2);
        k = cos(w0);
        k2 = 2 * sqrt(A) * alpha;
        aPlusOne = A + 1;
        aMinusOne = A - 1;

        b0 = A * (aPlusOne - aMinusOne * k + k2);
        b1 = 2 * A * (aMinusOne - aPlusOne * k);
        b2 = A * (aPlusOne - aMinusOne * k - k2);
        a0 = aPlusOne + aMinusOne * k + k2;
        a1 = -2 * (aMinusOne + aPlusOne * k);
        a2 = aPlusOne + aMinusOne * k - k2;
    };

    // --------------------- implementation ------------------------------

    // Convert rbj coeffs to fi.tf2 coeffs
    setNormCoeffs(b0,b1,b2,a0,a1,a2) = (b0/a0, b1/a0, b2/a0, a1/a0, a2/a0);

    nyquist = ma.SR * 0.5;
    nFreq = (f0 / nyquist) * pow(2, aDetune / 1200);
  
    // Limit cutoff between 0.01 and 0.99.
    cutoff = max(0.01, min(nFreq, 0.99));

};

//-------------------------------------------------------------------------
// Implementation of filters using BiquadFilter and fi.tf2
//-------------------------------------------------------------------------

//--------------`(wa.)lowpass2`--------------
// Standard second-order resonant lowpass filter with 12dB/octave rolloff.
// Frequencies below the cutoff pass through, frequencies above it are attenuated.
//
// #### Usage
//
// ```
// _ : lowpass2(f0, Q, dtune) : _
// ```
//
// Where:
//
// * `f0`: cutoff frequency in Hz
// * `Q`: the quality factor
// * `dtune`: detuning of the frequency in cents
//
// #### Reference
//
// <https://searchfox.org/mozilla-central/source/dom/media/webaudio/blink/Biquad.cpp#98>
//--------------------------------------

lowpass2(f0, Q, dtune, x) = BiquadFilter(f0, 1, Q, dtune).lowpass2, x : fi.tf2;


//--------------`(wa.)highpass2`--------------
// Standard second-order resonant highpass filter with 12dB/octave rolloff.
// Frequencies below the cutoff are attenuated, frequencies above it pass through.
//
// #### Usage
//
// ```
// _ : highpass2(f0, Q, dtune) : _
// ```
//
// Where:
//
// * `f0`: cutoff frequency in Hz
// * `Q`: the quality factor
// * `dtune`: detuning of the frequency in cents
//
// #### Reference
//
// <https://searchfox.org/mozilla-central/source/dom/media/webaudio/blink/Biquad.cpp#127>
//--------------------------------------

highpass2(f0, Q, dtune, x) = BiquadFilter(f0, 1, Q, dtune).highpass2, x : fi.tf2;


//--------------`(wa.)bandpass2`--------------
// Standard second-order bandpass filter.
// Frequencies outside the given range of frequencies are attenuated, the frequencies inside it pass through.
//
// #### Usage
//
// ```
// _ : bandpass2(f0, Q, dtune) : _
// ```
//
// Where:
//
// * `f0`: cutoff frequency in Hz
// * `Q`: the quality factor
// * `dtune`: detuning of the frequency in cents
//
// #### Reference
//
// <https://searchfox.org/mozilla-central/source/dom/media/webaudio/blink/Biquad.cpp#334>
//--------------------------------------

bandpass2(f0, Q, dtune, x) = BiquadFilter(f0, 1, Q, dtune).bandpass2, x : fi.tf2;


//--------------`(wa.)notch2`--------------
// Standard notch filter, also called a band-stop or band-rejection filter.
// It is the opposite of a bandpass filter: frequencies outside the give range of frequencies 
// pass through, frequencies inside it are attenuated.
//
// #### Usage
//
// ```
// _ : notch2(f0, Q, dtune) : _
// ```
//
// Where:
//
// * `f0`: cutoff frequency in Hz
// * `Q`: the quality factor
// * `dtune`: detuning of the frequency in cents
//
// #### Reference
//
// <https://searchfox.org/mozilla-central/source/dom/media/webaudio/blink/Biquad.cpp#301>
//--------------------------------------

notch2(f0, Q, dtune, x) = BiquadFilter(f0, 1, Q, dtune).notch2, x : fi.tf2;


//--------------`(wa.)allpass2`--------------
// Standard second-order allpass filter. It lets all frequencies through,
// but changes the phase-relationship between the various frequencies.
//
// #### Usage
//
// ```
// _ : allpass2(f0, Q, dtune) : _
// ```
//
// Where:
//
// * `f0`: cutoff frequency in Hz
// * `Q`: the quality factor
// * `dtune`: detuning of the frequency in cents
//
// #### Reference
//
// <https://searchfox.org/mozilla-central/source/dom/media/webaudio/blink/Biquad.cpp#268>
//--------------------------------------

allpass2(f0, Q, dtune, x) = BiquadFilter(f0, 1, Q, dtune).allpass2, x : fi.tf2;


//--------------`(wa.)peaking2`--------------
// Frequencies inside the range get a boost or an attenuation, frequencies outside it are unchanged.
//
// #### Usage
//
// ```
// _ : peaking2(f0, gain, Q, dtune) : _
// ```
//
// Where:
//
// * `f0`: cutoff frequency in Hz
// * `gain`: the gain in dB
// * `Q`: the quality factor
// * `dtune`: detuning of the frequency in cents
//
// #### Reference
//
// <https://searchfox.org/mozilla-central/source/dom/media/webaudio/blink/Biquad.cpp#233>
//--------------------------------------

peaking2(f0, gain, Q, dtune, x) = BiquadFilter(f0, gain, Q, dtune).peaking2, x : fi.tf2;


//--------------`(wa.)lowshelf2`--------------
// Standard second-order lowshelf filter.
// Frequencies lower than the frequency get a boost, or an attenuation, frequencies over it are unchanged.
//
// ```
// _ : lowshelf2(f0, gain, dtune) : _
// ```
//
// Where:
//
// * `f0`: cutoff frequency in Hz
// * `gain`: the gain in dB
// * `dtune`: detuning of the frequency in cents
//
// #### Reference
//
// <https://searchfox.org/mozilla-central/source/dom/media/webaudio/blink/Biquad.cpp#169>
//--------------------------------------

lowshelf2(f0, gain, dtune, x) = BiquadFilter(f0, gain, 1, dtune).lowshelf2, x : fi.tf2;


//--------------`(wa.)highshelf2`--------------
// Standard second-order highshelf filter.
// Frequencies higher than the frequency get a boost or an attenuation, frequencies lower than it are unchanged.
//
// ```
// _ : highshelf2(f0, gain, dtune) : _
// ```
//
// Where:
//
// * `f0`: cutoff frequency in Hz
// * `gain`: the gain in dB
// * `dtune`: detuning of the frequency in cents
//
// #### Reference
//
// <https://searchfox.org/mozilla-central/source/dom/media/webaudio/blink/Biquad.cpp#201>
//--------------------------------------

highshelf2(f0, gain, dtune, x) = BiquadFilter(f0, gain, 1, dtune).highshelf2, x : fi.tf2;

//////////////////////////////////////////////////////////////////////////////////////////
// WARNING: Deprecated Library!!
// Read the README file in /libraries for more information
//////////////////////////////////////////////////////////////////////////////////////////

/************************************************************************
 ************************************************************************
  	FAUST library file
	Copyright (C) 2003-2012 GRAME, Centre National de Creation Musicale
    ----------------------------------------------------------------------
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as
	published by the Free Software Foundation; either version 2.1 of the
	License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
 	License along with the GNU C Library; if not, write to the Free
  	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
  	02111-1307 USA.

  	EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
  	larger FAUST program which directly or indirectly imports this library
  	file and still distribute the compiled code generated by the FAUST
  	compiler, or a modified version of this compiled code, under your own
  	copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
  	grants you the right to freely choose the license for the resulting
  	compiled code. In particular the resulting compiled code has no obligation
  	to be LGPL or GPL. For example you are free to choose a commercial or
  	closed source license or any other license if you decide so.

 ************************************************************************
 ************************************************************************/

declare name "Math Library";
declare author "GRAME";
declare copyright "GRAME";
declare version "1.0";
declare license "LGPL with exception";
declare deprecated "This library is deprecated and is not maintained anymore. It will be removed in August 2017."; 

//----------------------Mathematic library for Faust----------------------------
//
// Implementation as Faust foreign functions of math.h functions that are not
// part of Faust's primitives. Defines also various constants and several utilities
//
// ### History
// + 07/08/2015	[YO]	documentation comments
// + 20/06/2014	[SL]	added FTZ function
// + 20/06/2014	[SL]	added FTZ function
// + 22/06/2013	[YO]	added float|double|quad variants of some foreign functions
// + 28/06/2005	[YO]	postfixed functions with 'f' to force float version instead of double
// + 28/06/2005	[YO]	removed 'modf' because it requires a pointer as argument
//------------------------------------------------------------------------------


//--------------------------------- SR ---------------------------------------
// Current sampling rate (between 1Hz and 192000Hz). Constant during
// program execution.
//
// ### Usage:
//    `SR:_`
//-----------------------------------------------------------------------------
SR 			= min(192000.0, max(1.0, fconstant(int fSamplingFreq, <math.h>)));


//--------------------------------- BS ---------------------------------------
// Current block-size. Can change during the execution
//
// ### Usage:
//    `BS:_`
//-----------------------------------------------------------------------------
BS          = fvariable(int count, <math.h>);


//--------------------------------- PI ---------------------------------------
// Constant PI in double precision
//
// ### Usage:
//    `PI:_`
//-----------------------------------------------------------------------------
PI          = 3.1415926535897932385;


//--------------------------------- FTZ ---------------------------------------
// Flush to zero : force samples under the "maximum subnormal number"
// to be zero. Usually not needed in C++ because the architecture
// file take care of this, but can be useful in JavaScript for instance.
//
// ### Usage:
//    `_:ftz:_`
//
// see : <http://docs.oracle.com/cd/E19957-01/806-3568/ncg_math.html>
//-----------------------------------------------------------------------------
FTZ(x)      = x * (abs(x) > 1.17549435e-38);


//--------------------------------- neg ---------------------------------------
// Invert the sign (-x) of a signal.
//
// ### Usage:
//    `_:neg:_`
//
//-----------------------------------------------------------------------------
neg(x)      = -x;


//--------------------------------- inv ---------------------------------------
// Compute the inverse (1/x) of the input signal
//
// ### Usage:
//    `_:inv:_`
//
//-----------------------------------------------------------------------------
inv(x)      = 1/x;


//--------------------------------- cbrt --------------------------------------
// Computes the cube root of of the input signal.
//
// ### Usage:
//    `_:cbrt:_`
//-----------------------------------------------------------------------------
cbrt 		= ffunction(float cbrtf|cbrt|cbrtl (float), <math.h>,"");


//--------------------------------- hypot(x,y) -------------------------------------
// Computes the euclidian distance of the two input signals
// sqrt(x*x+y*y) without undue overflow or underflow.
//
// ### Usage:
//    `hypot(x,y):_`
//    `_,_:hypot:_`
//-----------------------------------------------------------------------------
hypot 		= ffunction(float hypotf|hypot|hypotl (float, float), <math.h>,"");


//--------------------------------- ldexp -------------------------------------
// Takes two input signals: x and n, and multiplies x by 2 to the power n.
//
// ### Usage:
//    `_,_:ldexp:_`
//-----------------------------------------------------------------------------
ldexp 		= ffunction(float ldexpf|ldexp|ldexpl (float, int), <math.h>,"");


//--------------------------------- scalb -------------------------------------
// Takes two input signals: x and n, and multiplies x by 2 to the power n.
//
// ### Usage:
//    `_,_:scalb:_`
//-----------------------------------------------------------------------------
scalb 		= ffunction(float scalbnf|scalbn|scalbnl (float, int), <math.h>,"");


//--------------------------------- log1p(x) ----------------------------------
// Computes log(1 + x) without undue loss of accuracy when x is nearly zero.
//
// ### Usage:
// +  `log1p(x):_`
// +  `_:log1p:_`
//-----------------------------------------------------------------------------
log1p 		= ffunction(float log1pf|log1p|log1pl (float), <math.h>,"");


//--------------------------------- logb ---------------------------------------
// Return exponent of the input signal as a floating-point number
//
// ### Usage:
//    `_:logb:_`
//-----------------------------------------------------------------------------
logb 		= ffunction(float logbf|logb|logbl (float), <math.h>,"");


//--------------------------------- ilogb -------------------------------------
// Return exponent of the input signal as an integer number
//
// ### Usage:
//    `_:ilogb:_`
//-----------------------------------------------------------------------------
ilogb 		= ffunction(int ilogbf|ilogb|ilogbl (float), <math.h>,"");


//--------------------------------- expm1 -------------------------------------
// Return exponent of the input signal minus 1 with better precision.
//
// ### Usage:
//    `_:expm1:_`
//-----------------------------------------------------------------------------
expm1 		= ffunction(float expm1f|expm1|expm1l (float), <math.h>,"");


//--------------------------------- acosh -------------------------------------
// Computes the principle value of the inverse hyperbolic cosine
// of the input signal.
//
// ### Usage:
//    `_:acosh:_`
//-----------------------------------------------------------------------------
acosh		= ffunction(float acoshf|acosh|acoshl (float), <math.h>, "");


//-------------------------------- asinh(x) -----------------------------------
// Computes the inverse hyperbolic sine of the input signal.
//
// ### Usage:
//    `_:asinh:_`
//-----------------------------------------------------------------------------
asinh		= ffunction(float asinhf|asinh|asinhl (float), <math.h>, "");


//-------------------------------- atanh(x) -----------------------------------
// Computes the inverse hyperbolic tangent of the input signal.
//
// ### Usage:
//    `_:atanh:_`
//-----------------------------------------------------------------------------
atanh		= ffunction(float atanhf|atanh|atanhl (float), <math.h>, "");


//--------------------------------- sinh ---------------------------------------
// Computes the hyperbolic sine of the input signal.
//
// ### Usage:
//    `_:sinh:_`
//-----------------------------------------------------------------------------
sinh		= ffunction(float sinhf|sinh|sinhl (float), <math.h>, "");


//--------------------------------- cosh --------------------------------------
// Computes the hyperbolic cosine of the input signal.
//
// ### Usage:
//    `_:cosh:_`
//-----------------------------------------------------------------------------
cosh		= ffunction(float coshf|cosh|coshl (float), <math.h>, "");


//--------------------------------- tanh --------------------------------------
// Computes the hyperbolic tangent of the input signal.
//
// ### Usage:
//    `_:tanh:_`
//-----------------------------------------------------------------------------
tanh		= ffunction(float tanhf|tanh|tanhl (float), <math.h>,"");


//--------------------------------- erf ---------------------------------------
// Computes the error function of the input signal.
//
// ### Usage:
//    `_:erf:_`
//-----------------------------------------------------------------------------
erf			= ffunction(float erff|erf|erfl(float), <math.h>,"");


//--------------------------------- erf ---------------------------------------
// Computes the complementary error function of the input signal.
//
// ### Usage:
//    `_:erfc:_`
//-----------------------------------------------------------------------------
erfc		= ffunction(float erfcf|erfc|erfcl(float), <math.h>,"");


//--------------------------------- gamma -------------------------------------
// Computes the gamma function of the input signal.
//
// ### Usage:
//    `_:gamma:_`
//-----------------------------------------------------------------------------
gamma		= ffunction(float tgammaf|tgamma|tgammal(float), <math.h>,"");


//--------------------------------- lgamma ------------------------------------
// Calculates the natural logorithm of the absolute value of
// the gamma function of the input signal.
//
// ### Usage:
//    `_:lgamma:_`
//-----------------------------------------------------------------------------
lgamma		= ffunction(float lgammaf|lgamma|lgammal(float), <math.h>,"");


//---------------------------------- J0 ---------------------------------------
// Computes the Bessel function of the first kind of order 0
// of the input signal.
//
// ### Usage:
//    `_:J0:_`
//-----------------------------------------------------------------------------
J0			= ffunction(float j0(float), <math.h>,"");

//---------------------------------- J1 ---------------------------------------
// Computes the Bessel function of the first kind of order 1
// of the input signal.
//
// ### Usage:
//    `_:J1:_`
//-----------------------------------------------------------------------------
J1			= ffunction(float j1(float), <math.h>,"");

//---------------------------------- Jn ---------------------------------------
// Computes the Bessel function of the first kind of order n
// (first input signal) of the second input signal.
//
// ### Usage:
//    `_,_:Jn:_`
//-----------------------------------------------------------------------------
Jn			= ffunction(float jn(int, float), <math.h>,"");


//---------------------------------- Y0 ---------------------------------------
// Computes the linearly independent Bessel function of the second kind
// of order 0 of the input signal.
//
// ### Usage:
//    `_:Y0:_`
//-----------------------------------------------------------------------------
Y0			= ffunction(float y0(float), <math.h>,"");

//---------------------------------- Y1 ---------------------------------------
// Computes the linearly independent Bessel function of the second kind
// of order 1 of the input signal.
//
// ### Usage:
//    `_:Y0:_`
//-----------------------------------------------------------------------------
Y1			= ffunction(float y1(float), <math.h>,"");

//---------------------------------- Yn ---------------------------------------
// Computes the linearly independent Bessel function of the second kind
// of order n (first input signal) of the second input signal.
//
// ### Usage:
//    `_,_:Yn:_`
//-----------------------------------------------------------------------------
Yn			= ffunction(float yn(int, float), <math.h>,"");


// -- Miscellaneous Functions

fabs = abs;
fmax = max;
fmin = min;

//--------------- isnan(x) ----------------
// return non-zero if and only if x is a NaN,
//
// ### Usage:
//    `_:isnan:_`
//
// #### Where:
// + x = signal to analyse
//
//------------------------------------------
isnan 		= ffunction(int isnan (float),<math.h>,"");
nextafter	= ffunction(float nextafter(float, float),<math.h>,"");


//--------------------------------- count(l) ---------------------------------
// Count the number of elements of list l
//
// ### Usage:
//    `count ((10,20,30,40)) 	-> 4`
//
// #### Where:
// + l = list of elements
//
//-----------------------------------------------------------------------------
count ((xs, xxs)) = 1 + count(xxs);
count (xx) = 1;


//------------------------------- take(e,l) -----------------------------------
// Take an element from a list
//
// ### Usage:
//    `take  (3,(10,20,30,40)) -> 30`
//
// #### Where:
// + p = position (starting at 1)
// + l = list of elements
//
//-----------------------------------------------------------------------------
take (1, (xs, xxs)) 	= xs;
take (1, xs) 			= xs;
take (nn, (xs, xxs)) 	= take (nn-1, xxs);


//---------------------------- subseq(l, p, n) --------------------------------
// Extract a part of a list
//
// ### Usage:
// +  `subseq((10,20,30,40,50,60), 1, 3) -> (20,30,40)`
// +  `subseq((10,20,30,40,50,60), 4, 1) -> 50`
//
// #### Where:
// + l = list
// + p = start point (0: begin of list)
// + n = number of elements
//
// #### Note:
// Faust doesn't have proper lists. Lists are simulated with parallel
// compositions and there is no empty list
//
//-----------------------------------------------------------------------------
subseq((head, tail), 0, 1)      = head;
subseq((head, tail), 0, n)      = head, subseq(tail, 0, n-1);
subseq((head, tail), p, n)      = subseq(tail, p-1, n);
subseq(head, 0, n)              = head;


//----------------------------- interpolate(i) -------------------------------
// linear interpolation between two signals
//
// ### Usage:
//    `_,_:interpolate(i):_`
//
// #### Where:
// + i = interpolation control between 0 and 1 (0: first input; 1: second input)
//
//-----------------------------------------------------------------------------
interpolate(i) = *(1.0-i),*(i) : +;


//----------------------------- if(c,t,e)) -----------------------------------
// if-then-else implemented with a select2
//
// ### Usage:
// +   `if(c, then, else):_`
// +   `_,_:if(c):_`
//
// #### Where:
// + c = condition
// + t = signal selected while c is true
// + e = signal selected while c is false
//
//-----------------------------------------------------------------------------
if(cond,thn,els) = select2(cond,els,thn);


//---------------------------- countdown(n,trig) ------------------------------
// Starts counting down from n included to 0. While trig is 1 the output is n.
// The countdown starts with the transition of trig from 1 to 0. At the end
// of the countdown the output value will remain at 0 until the next trig.
//
// ### Usage:
// + `countdown(n,trig):_`
// + `_:countdown(n):_`
// + `_,_:countdown:_`
//
// #### Where
// + n : the starting point of the countdown
// + trig : the trigger signal (1: start at n; 0: decrease until 0)
//-----------------------------------------------------------------------------
countdown(count, trig)	= \(c).(if(trig>0, count, max(0, c-1))) ~_;


//---------------------------- countup(n,trig) --------------------------------
// Starts counting up from 0 to n included. While trig is 1 the output is 0.
// The countup starts with the transition of trig from 1 to 0. At the end
// of the countup the output value will remain at n until the next trig.
//
// ### Usage:
// + `countup(n,trig):_`
// + `_:countup(n):_`
// + `_,_:countup:_`
//
// #### Where
// + n : the starting point of the countup
// + trig : the trigger signal (1: start at 0; 0: increase until n)
//-----------------------------------------------------------------------------
countup(count, trig)	= \(c).(if(trig>0, 0, min(count, c+1))) ~_;


//-------------------------------- bus(n) -------------------------------------
// n parallel cables
//
// ### Usage:
//    `bus(4) -> _,_,_,_`
//
// #### Where:
// + n = is an integer known at compile time that indicates the number of parallel cables.
//
//-----------------------------------------------------------------------------
bus(2) = _,_; // avoids a lot of "bus(1)" labels in block diagrams
bus(n) = par(i, n, _);


//----------------------------- selector(i,n) ---------------------------------
// Selects the ith input among n at compile time
//
// ### Usage:
// `_,_,_,_:selector(2,4):_`  selects the 3rd input among 4
//
// #### Where:
// + i = input to select (int, numbered from 0, known at compile time)
// + n = number of inputs (int, known at compile time, n > i)
//
//-----------------------------------------------------------------------------
selector(i,n) = par(j, n, S(i, j))    with { S(i,i) = _; S(i,j) = !; };


//----------------------------- selectn(N,i) ---------------------------------
// Selects the ith input among N at run time
//
// ### Usage:
// `_,_,_,_:selectn(4,2):_`  selects the 3rd input among 4
//
// #### Where:
// + N = number of inputs (int, known at compile time, N > 0)
// + i = input to select (int, numbered from 0)
//
// #### Example test program:
// `N=64; process = par(n,N, (par(i,N,i) : selectn(N,n)));`
//-----------------------------------------------------------------------------
selectn(N,i) = S(N,0)
    with {
       S(1,offset) = _;
       S(n,offset) = S(left, offset), S(right, offset+left) : select2(i >= offset+left)
            with {
                right = int(n/2);
                left  = n-right;
            };
    };

//-------------------------- interleave(row,col) ------------------------------
// interleave row*col cables from column order to row order.
// input : x(0), x(1), x(2) ..., x(row*col-1)
// output: x(0+0*row), x(0+1*row), x(0+2*row), ..., x(1+0*row), x(1+1*row), x(1+2*row), ...
//
// ### Usage:
//    `_,_,_,_,_,_:interleave(3,2):_,_,_,_,_,_`
//
// #### Where:
// + row = the number of row (int, known at compile time)
// + column = the number of column (int, known at compile time)
//
//-----------------------------------------------------------------------------
interleave(row,col) = bus(row*col) <: par(r, row, par(c, col, selector(r+c*row,row*col)));


//------------------------------- butterfly(n) --------------------------------
// Addition (first half) then substraction (second half) of interleaved signals.
//
// ### Usage:
//    `_,_,_,_:butterfly(4):_,_,_,_`
//
// #### Where:
// + n = size of the butterfly (n is int, even and known at compile time)
//
//-----------------------------------------------------------------------------
butterfly(n) = bus(n) <: interleave(n/2,2), interleave(n/2,2) : par(i, n/2, +), par(i, n/2, -);


//------------------------------ hadamard(n) ----------------------------------
// hadamard matrix function of size n = 2^k
//
// ### Usage:
//    `_,_,_,_:hadamard(4):_,_,_,_`
//
// #### Where:
// + n = 2^k, size of the matrix (int, must be known at compile time)
//
// #### Note:
// Implementation contributed by Remy Muller.
//
//-----------------------------------------------------------------------------
hadamard(2) = butterfly(2);
hadamard(n) = butterfly(n) : (hadamard(n/2) , hadamard(n/2));


//------------------------------- dot(n) --------------------------------------
// Dot product for two vectors of size n
//
// ### Usage:
//    `_,_,_,_,_,_:dot(3):_`
//
// #### Where:
// + n = size of the vectors (int, must be known at compile time)
//
//-----------------------------------------------------------------------------
dot(n) = interleave(n,2) : par(i,n,*) :> _;


//-------------------------------- cross(n) -----------------------------------
// cross n signals : (x1,x2,..,xn) -> (xn,..,x2,x1)
//
// ### Usage:
//    `_,_,_:cross(3):_,_,_`
//
// #### Where:
// + n = number of signals (int, must be known at compile time)
//
//-----------------------------------------------------------------------------
// cross n cables : (x1,x2,..,xn) -> (xn,..,x2,x1)
cross(n) = bus(n) <: par(i,n,selector(n-i-1,n));
//################################ stdfaust.lib ##########################################
// The purpose of this library is to give access to all the Faust standard libraries
// through a series of environments.
//########################################################################################

aa = library("aanl.lib");
sf = library("all.lib");
an = library("analyzers.lib");
ba = library("basics.lib");
co = library("compressors.lib");
de = library("delays.lib");
dm = library("demos.lib");
dx = library("dx7.lib");
en = library("envelopes.lib");
fd = library("fds.lib");
fi = library("filters.lib");
ho = library("hoa.lib");
it = library("interpolators.lib");
ma = library("maths.lib");
mi = library("mi.lib");
ef = library("misceffects.lib");
os = library("oscillators.lib");
no = library("noises.lib");
pf = library("phaflangers.lib");
pl = library("platform.lib");
pm = library("physmodels.lib");
qu = library("quantizers.lib");
rm = library("reducemaps.lib");
re = library("reverbs.lib");
ro = library("routes.lib");
sp = library("spats.lib");
si = library("signals.lib");
so = library("soundfiles.lib");
sy = library("synths.lib");
ve = library("vaeffects.lib");
vl = library("version.lib");
wa = library("webaudio.lib");
wd = library("wdmodels.lib");
//////////////////////////////////////////////////////////////////////////////////////////
// WARNING: Deprecated Library!!
// Read the README file in /libraries for more information
//////////////////////////////////////////////////////////////////////////////////////////

// filter.lib - digital filters of various types useful in audio and beyond

declare name "Faust Filter Library";
declare author "Julius O. Smith (jos at ccrma.stanford.edu)";
declare copyright "Julius O. Smith III";
declare version "1.29";
declare license "STK-4.3"; // Synthesis Tool Kit 4.3 (MIT style license)
declare reference "https://ccrma.stanford.edu/~jos/filters/";
declare deprecated "This library is deprecated and is not maintained anymore. It will be removed in August 2017."; 

import("music.lib"); // delay, frac and, from math.lib, SR and PI

//---------------------- zero(z) --------------------------
// z = location of zero along real axis in z-plane
// Difference equation: y(n) = x(n) - z * x(n-1)
// Reference: https://ccrma.stanford.edu/~jos/filters/One_Zero.html

zero(z) =  _ <: _,mem : _,*(z) : -;

//------------------------ pole(p) ---------------------------
// p = pole location = feedback coefficient
// Could also be called a "leaky integrator".
// Difference equation: y(n) = x(n) + p * y(n-1)
// Reference: https://ccrma.stanford.edu/~jos/filters/One_Pole.html

pole(p) = + ~ *(p);

//---------------------- integrator --------------------------
// pole(1) [implemented separately for block-diagram clarity]

integrator = + ~ _ ;

//------------------ tau2pole, pole2tau ----------------------
// tau2pole(tau) returns a real pole giving exponential decay with
// tau = time-constant in seconds
// Note that t60 (time to decay 60 dB) is ~6.91 time constants.
// pole2tau(pole) returns the time-constant, in seconds, 
// corresponding to the given real, positive pole in (0,1).

tau2pole(tau) = if(tau>0, exp(-1.0/(tau*SR)), 0.0);
pole2tau(pole) = if(pole<1.0, -1.0/(log(pole)*SR), 1.0e10);

//---------------------- smooth(s) --------------------------
// Exponential smoothing by a unity-dc-gain one-pole lowpass
//
// USAGE: smooth(tau2pole(tau)), where 
//   tau = desired smoothing time constant in seconds,
// or
//   smooth(s), where s = smoothness between 0 and 1.
//    s=0 for no smoothing
//    s=0.999 is "very smooth"
// s>1 is unstable, and s=1 yields the zero signal for all inputs.
// The exponential time-constant is approximately 
// 1/(1-s) samples, when s is close to (but less than) 1.
// Reference: 
// https://ccrma.stanford.edu/~jos/mdft/Convolution_Example_2_ADSR.html

smooth(s) = *(1.0 - s) : + ~ *(s);

//------------------- dcblockerat(fb) -----------------------
// fb = "break frequency" in Hz, i.e., -3 dB gain frequency.
// The amplitude response is substantially flat above fb,
// and sloped at about +6 dB/octave below fb.
// Derived from the analog transfer function 
// H(s) = s / (s + 2*PI*fb) 
// by the low-frequency-matching bilinear transform method
// (i.e., the standard frequency-scaling constant 2*SR).
// Reference:
// https://ccrma.stanford.edu/~jos/pasp/Bilinear_Transformation.html

dcblockerat(fb) = *(b0) : zero(1) : pole(p)
with {
  wn = PI*fb/SR;
  b0 = 1.0 / (1 + wn);
  p = (1 - wn) * b0;
};

//---------------------- dcblocker --------------------------
// Default dc blocker has -3dB point near 35 Hz (at 44.1 kHz)
// and high-frequency gain near 1.0025 (due to no scaling)
//
dcblocker = zero(1) : pole(0.995);

//------------ notchw(width,freq), notch(freq) --------------
// width = "notch width" in Hz (approximate)
// freq  = "notch frequency" in Hz
// Reference:
// https://ccrma.stanford.edu/~jos/pasp/Phasing_2nd_Order_Allpass_Filters.html

notchw(width,freq) = tf2(b0,b1,b2,a1,a2)
with {
  fb = 0.5*width; // First design a dcblockerat(width/2)
  wn = PI*fb/SR;
  b0db = 1.0 / (1 + wn);
  p = (1 - wn) * b0db; // This is our pole radius.
  // Now place unit-circle zeros at desired angles:
  tn = 2*PI*freq/SR;
  a2 = p * p;
  a2p1 = 1+a2;
  a1 = -a2p1*cos(tn);
  b1 = a1;
  b0 = 0.5*a2p1;
  b2 = b0;
};

//---------------------------- latch(c) --------------------------------
// Latch input on positive-going transition of "clock" ("sample-and-hold")
//
// USAGE:
//   _ : latch(clocksig) : _

latch(c,x) = x * s : + ~ *(1-s) with { s = ((c'<=0)&(c>0)); };

//========================= Comb Filters ===============================

//----------------------- ff_comb, ff_fcomb ----------------------------
// Feed-Forward Comb Filter
// 
// USAGE:
//   _ : ff_comb(maxdel,intdel,b0,bM) : _
//   _ : ff_fcomb(maxdel,del,b0,bM) : _
// where
//   maxdel = maximum delay (a power of 2)
//   intdel = current (integer) comb-filter delay between 0 and maxdel
//   del = current (float) comb-filter delay between 0 and maxdel
//   b0 = gain applied to delay-line input
//   bM = gain applied to delay-line output and then summed with input
//
// Note that ff_comb requires integer delays  (uses delay()  internally)
// while ff_fcomb takes floating-point delays (uses fdelay() internally).
//
// REFERENCE:
//   https://ccrma.stanford.edu/~jos/pasp/Feedforward_Comb_Filters.html

ff_comb (maxdel,M,b0,bM) = _ <: *(b0), bM *  delay(maxdel,M) : + ;
ff_fcomb(maxdel,M,b0,bM) = _ <: *(b0), bM * fdelay(maxdel,M) : + ;

// Typical special case:
ffcombfilter(maxdel,del,g) = ff_comb(maxdel,del,1,g);

//----------------------- fb_comb, fb_fcomb, rev1 -----------------------
// Feed-Back Comb Filter
//
// USAGE: 
//   _ : fb_comb(maxdel,intdel,b0,aN) : _
//   _ : fb_fcomb(maxdel,del,b0,aN) : _
//   _ : rev1(maxdel,del,-aN) : _
// where
//   maxdel = maximum delay (a power of 2)
//   intdel = current (integer) comb-filter delay between 0 and maxdel
//   del = current (float) comb-filter delay between 0 and maxdel
//   b0 = gain applied to delay-line input and forwarded to output
//   aN = minus the gain applied to delay-line output before
//        summing with the input and feeding to the delay line
//
// Reference: 
//   https://ccrma.stanford.edu/~jos/pasp/Feedback_Comb_Filters.html

fb_comb (maxdel,N,b0,aN) = (+ <:  delay(maxdel,N-1),_) ~ *(-aN) : !,*(b0):mem;
fb_fcomb(maxdel,N,b0,aN) = (+ <: fdelay(maxdel,float(N)-1.0),_) ~ *(-aN) : !,*(b0):mem;

// The "rev1 section" dates back to the 1960s in computer-music reverberation.
// See the jcrev and brassrev in effect.lib for usage examples.
rev1(maxdel,N,g) = fb_comb (maxdel,N,1,-g);

// Typical special case:
fbcombfilter(maxdel,intdel,g) = (+ : delay(maxdel,intdel)) ~ *(g);
ffbcombfilter(maxdel,del,g) = (+ : fdelay(maxdel,del)) ~ *(g);

//------------------- allpass_comb, allpass_fcomb, rev2 -----------------
// Schroeder Allpass Comb Filter
//
// USAGE: 
//   _ : allpass_comb (maxdel,intdel,aN) : _
//   _ : allpass_fcomb(maxdel,del,aN) : _
//   _ : rev2(maxdel,del,-aN) : _
// where
//   maxdel = maximum delay (a power of 2)
//   intdel = current (integer) comb-filter delay between 0 and maxdel
//   del = current (float) comb-filter delay between 0 and maxdel
//   aN = minus the feedback gain
//
// Note that allpass_comb(maxlen,len,aN) = 
//    ff_comb(maxlen,len,aN,1) : 
//    fb_comb(maxlen,len-1,1,aN);
// which is a direct-form-1 implementation, requiring two delay lines.
// The implementation here is direct-form-2 requiring only one delay line.
// 
// REFERENCES:
//   https://ccrma.stanford.edu/~jos/pasp/Allpass_Two_Combs.html
//   https://ccrma.stanford.edu/~jos/pasp/Schroeder_Allpass_Sections.html
//   https://ccrma.stanford.edu/~jos/filters/Four_Direct_Forms.html

allpass_comb(maxdel,N,aN) = (+ <: 
   delay(maxdel,N-1),*(aN)) ~ *(-aN)
   : mem,_ : + ;

allpass_fcomb(maxdel,N,aN) = (+ <: fdelay(maxdel,N-1),*(aN)) ~ *(-aN) : mem,_ : + ;
allpass_fcomb5(maxdel,N,aN) = (+ <: fdelay5(maxdel,N-1),*(aN)) ~ *(-aN) : mem,_ : + ;
allpass_fcomb1a(maxdel,N,aN) = (+ <: fdelay1a(maxdel,N-1),*(aN)) ~ *(-aN) : mem,_ : + ;
// Interpolation helps - look at an fft of faust2octave on
// 1-1' <: allpass_fcomb(1024,10.5,0.95), allpass_fcomb5(1024,10.5,0.95);

// The "rev2 section" dates back to the 1960s in computer-music reverberation:
rev2(maxlen,len,g) = allpass_comb(maxlen,len,-g);

//================ Direct-Form Digital Filter Sections ================

// Specified by transfer-function polynomials B(z)/A(z) as in matlab

//---------------------------- iir (tfN) -------------------------------
// Nth-order Infinite-Impulse-Response (IIR) digital filter,
// implemented in terms of the Transfer-Function (TF) coefficients.
// Such filter structures are termed "direct form".
//
// USAGE:
//   _ : iir(bcoeffs,acoeffs) : _
// where
//   order = filter order (int) = max(#poles,#zeros)
//   bcoeffs = (b0,b1,...,b_order) = TF numerator coefficients
//   acoeffs =    (a1,...,a_order) = TF denominator coeffs (a0=1)
//
// REFERENCE:
//   https://ccrma.stanford.edu/~jos/filters/Four_Direct_Forms.html

iir(bv,av) = sub ~ fir(av) : fir(bv);

//----------------------------- sub ---------------------------------
sub(x,y) = y-x; // move to math.lib?

//----------------------------- fir ---------------------------------
// FIR filter (convolution of FIR filter coefficients with a signal)
//
// USAGE: 
//   _ : fir(bv) : _
// where bv = b0,b1,...,bn is a parallel bank of coefficient signals.
// NOTE: bv is processed using pattern-matching at compile time,
//       so it must have this normal form (parallel signals).
// EXAMPLE: Smoothing white noise with a five-point moving average:
//   bv = .2,.2,.2,.2,.2;
//   process = noise : fir(bv);
// EQUIVALENT (note double parens):
//   process = noise : fir((.2,.2,.2,.2,.2));

//fir(bv) = conv(bv);
fir((b0,bv)) = _ <: *(b0), R(1,bv) :> _ with {
	R(n,(bn,bv)) = (@(n):*(bn)), R(n+1,bv);
	R(n, bn)     = (@(n):*(bn));              };
fir(b0) = *(b0);

//--------------------------- conv, convN -------------------------------
// Convolution of input signal with given coefficients
//
// USAGE:
//  _ : conv((k1,k2,k3,...,kN)) : _; // Argument = one signal bank
//  _ : convN(N,(k1,k2,k3,...)) : _; // Useful when N < count((k1,...))

//convN(N,kv,x) = sum(i,N,take(i+1,kv) * x@i); // take() defined in math.lib
convN(N,kv)     = sum(i,N, @(i)*take(i+1,kv)); // take() defined in math.lib

//conv(kv,x) = sum(i,count(kv),take(i+1,kv) * x@i); // count() from math.lib
conv(kv) = fir(kv);


// Named special cases:
//----------------------------- tf1, tf2 ---------------------------------
// tfN = N'th-order direct-form digital filter
tf1(b0,b1,a1) = _ <: *(b0), (mem : *(b1)) :> + ~ *(0-a1);
tf2(b0,b1,b2,a1,a2) = iir((b0,b1,b2),(a1,a2)); // cf. TF2 in music.lib)
// tf2 is a variant of tf22 below with duplicated mems
tf3(b0,b1,b2,b3,a1,a2,a3) = iir((b0,b1,b2,b3),(a1,a2,a3));

//=============== Direct-Form second-order biquad sections ================
// REFERENCE: https://ccrma.stanford.edu/~jos/filters/Four_Direct_Forms.html

//---------------------- tf21, tf21t, tf22, tf22t ------------------------
tf21(b0,b1,b2,a1,a2) = // tf2, direct-form 1:
    _ <:(mem<:((mem:*(b2)),*(b1))),*(b0) :>_
    : ((_,_,_:>_) ~(_<:*(-a1),(mem:*(-a2))));
tf22(b0,b1,b2,a1,a2) = // tf2, direct-form 2:
    _ : (((_,_,_:>_)~*(-a1)<:mem,*(b0))~*(-a2))
      : (_<:mem,*(b1)),_ : *(b2),_,_ :> _;
tf22t(b0,b1,b2,a1,a2) = // tf2, direct-form 2 transposed:
    _ : (_,_,(_ <: *(b2)',*(b1)',*(b0))
      : _,+',_,_ :> _)~*(-a1)~*(-a2) : _;
tf21t(b0,b1,b2,a1,a2) = // tf2, direct-form 1 transposed:
    tf22t(1,0,0,a1,a2) : tf22t(b0,b1,b2,0,0); // or write it out if you want

//===================== Ladder/Lattice Digital Filters ======================
// Ladder and lattice digital filters generally have superior numerical
// properties relative to direct-form digital filters.  They can be derived
// from digital waveguide filters, which gives them a physical interpretation.

// REFERENCES: 
//  F. Itakura and S. Saito: "Digital Filtering Techniques for Speech Analysis and Synthesis",
//     7th Int. Cong. Acoustics, Budapest, 25 C 1, 1971.
//  J. D. Markel and A. H. Gray: Linear Prediction of Speech, New York: Springer Verlag, 1976.
//  https://ccrma.stanford.edu/~jos/pasp/Conventional_Ladder_Filters.html

//------------------------- block, crossn,crossn1 -----------------------------
// signal block/crossing utilities
// (move to math.lib?)

// block - terminate n signals (goes with bus(n) in math.lib)
block(n) = par(i,n,!);

// crossnn - cross two bus(n)s:
crossnn(n) = bus(n),bus(n) <: block(n),bus(n),bus(n),block(n);

// crossn1 - cross bus(n) and bus(1):
crossn1(n) = bus(n),(bus(1)<:bus(n)) <: block(n),bus(n),bus(n),block(n):bus(1),block(n-1),bus(n);

//------------------------------- av2sv -----------------------------------
// Compute reflection coefficients sv from transfer-function denominator av
//
// USAGE:
//   sv = av2sv(av)
// where
//   av = parallel signal bank a1,...,aN
//   sv = parallel signal bank s1,...,sN
// where si = ith reflection coefficient, and
//       ai = coefficient of z^(-i) in the filter
//          transfer-function denominator A(z).
//
// REFERENCE:
//   https://ccrma.stanford.edu/~jos/filters/Step_Down_Procedure.html
//   (where reflection coefficients are denoted by k rather than s).

av2sv(av) = par(i,M,s(i+1)) with {
  M = count(av);
  s(m) = sr(M-m+1); // m=1..M
  sr(m) = Ari(m,M-m+1); // s_{M-1-m}
  Ari(m,i) = take(i+1,Ar(m-1));
  //step-down recursion for lattice/ladder digital filters:
  Ar(0) = (1,av); // Ar(m) is order M-m (i.e. "reverse-indexed")
  Ar(m) = 1,par(i,M-m, (Ari(m,i+1) - sr(m)*Ari(m,M-m-i))/(1-sr(m)*sr(m)));
};

//---------------------------- bvav2nuv --------------------------------
// Compute lattice tap coefficients from transfer-function coefficients
//
// USAGE:
//   nuv = bvav2nuv(bv,av)
// where
//   av = parallel signal bank    a1,...,aN
//   bv = parallel signal bank b0,b1,...,aN
//  nuv = parallel signal bank   nu1,...,nuN
// where nui is the i'th tap coefficient,
//       bi is the coefficient of z^(-i) in the filter numerator,
//       ai is the coefficient of z^(-i) in the filter denominator

bvav2nuv(bv,av) = par(m,M+1,nu(m)) with {
  M = count(av);
  nu(m) = take(m+1,Pr(M-m)); // m=0..M
  // lattice/ladder tap parameters:
  Pr(0) = bv; // Pr(m) is order M-m, 'r' means "reversed"
  Pr(m) = par(i,M-m+1, (Pri(m,i) - nu(M-m+1)*Ari(m,M-m-i+1)));
  Pri(m,i) = take(i+1,Pr(m-1));
  Ari(m,i) = take(i+1,Ar(m-1));
  //step-down recursion for lattice/ladder digital filters:
  Ar(0) = (1,av); // Ar(m) is order M-m (recursion index must start at constant)
  Ar(m) = 1,par(i,M-m, (Ari(m,i+1) - sr(m)*Ari(m,M-m-i))/(1-sr(m)*sr(m)));
  sr(m) = Ari(m,M-m+1); // s_{M-1-m}
};

//--------------------------- iir_lat2, allpassnt -----------------------

iir_lat2(bv,av) = allpassnt(M,sv) : sum(i,M+1,*(take(M-i+1,tg)))
with {
  M = count(av);
  sv = av2sv(av); // sv = vector of sin(theta) reflection coefficients
  tg = bvav2nuv(bv,av); // tg = vector of tap gains
};

// two-multiply lattice allpass (nested order-1 direct-form-ii allpasses):
allpassnt(0,sv) = _;
allpassnt(n,sv) =
//0:   x <: ((+ <: (allpassnt(n-1,sv)),*(s))~(*(-s))) : _',_ :+
       _ : ((+ <: (allpassnt(n-1,sv),*(s)))~*(-s)) : fsec(n)
with {
  fsec(1) = crossnn(1) : _, (_<:mem,_) : +,_;
  fsec(n) = crossn1(n) : _, (_<:mem,_),par(i,n-1,_) : +, par(i,n,_);
  innertaps(n) = par(i,n,_);
  s = take(n,sv); // reflection coefficient s = sin(theta)
};

//------------------------------- iir_kl, allpassnklt -------------------------
iir_kl(bv,av) = allpassnklt(M,sv) : sum(i,M+1,*(tghr(i)))
with {
  M = count(av);
  sv = av2sv(av); // sv = vector of sin(theta) reflection coefficients
  tg = bvav2nuv(bv,av); // tg = vector of tap gains for 2mul case
  tgr(i) = take(M+1-i,tg);
  tghr(n) = tgr(n)/pi(n);
  pi(0) = 1;
  pi(n) = pi(n-1)*(1+take(M-n+1,sv)); // all sign parameters '+'
};

// Kelly-Lochbaum ladder allpass with tap lines:
allpassnklt(0,sv) = _;
allpassnklt(n,sv) = _ <: *(s),(*(1+s) : (+
                   : allpassnklt(n-1,sv))~(*(-s))) : fsec(n)
with {
  fsec(1) = _, (_<:mem*(1-s),_) : sumandtaps(n);
  fsec(n) = _, (_<:mem*(1-s),_), par(i,n-1,_) : sumandtaps(n);
  s = take(n,sv);
  sumandtaps(n) = +,par(i,n,_);
};


//------------------------------- iir_lat1, allpassn1mt -------------------------
iir_lat1(bv,av) = allpassn1mt(M,sv) : sum(i,M+1,*(tghr(i+1)))
with {
  M = count(av);
  sv = av2sv(av); // sv = vector of sin(theta) reflection coefficients
  tg = bvav2nuv(bv,av); // tg = vector of tap gains
  tgr(i) = take(M+2-i,tg); // i=1..M+1 (for "takability")
  tghr(n)=tgr(n)/pi(n);
  pi(1) = 1;
  pi(n) = pi(n-1)*(1+take(M-n+2,sv)); // all sign parameters '+'
};

// one-multiply lattice allpass with tap lines:
allpassn1mt(0,sv) = _;
allpassn1mt(n,sv)= _ <: _,_ : ((+:*(s) <: _,_),_ : _,+ : crossnn(1)
		  : allpassn1mt(n-1,sv),_)~(*(-1)) : fsec(n)
with {
//0:  fsec(n) = _',_ : +
  fsec(1) = crossnn(1) : _, (_<:mem,_) : +,_;
  fsec(n) = crossn1(n) : _, (_<:mem,_),par(i,n-1,_) : +, par(i,n,_);
  innertaps(n) = par(i,n,_);
  s = take(n,sv); // reflection coefficient s = sin(theta)
};

//------------------------------- iir_nl, allpassnnlt -------------------------
// Normalized ladder filter
//
// REFERENCES:
//   J. D. Markel and A. H. Gray, Linear Prediction of Speech, New York: Springer Verlag, 1976.
//   https://ccrma.stanford.edu/~jos/pasp/Normalized_Scattering_Junctions.html

iir_nl(bv,av) = allpassnnlt(M,sv) : sum(i,M+1,*(tghr(i)))
with {
  M = count(av);
  sv = av2sv(av); // sv = vector of sin(theta) reflection coefficients
  tg = bvav2nuv(bv,av); // tg = vector of tap gains for 2mul case
  tgr(i) = take(M+1-i,tg);
  tghr(n) = tgr(n)/pi(n);
  pi(0) = 1;
  s(n) = take(M-n+1,sv); // reflection coefficient = sin(theta) 
  c(n) = sqrt(max(0,1-s(n)*s(n))); // compiler crashes on sqrt(-)
  pi(n) = pi(n-1)*c(n);
};

// Normalized ladder allpass with tap lines:
allpassnnlt(0,sv) = _;
allpassnnlt(n,scl*(sv)) = allpassnnlt(n,par(i,count(sv),scl*(sv(i))));
allpassnnlt(n,sv) = _ <: *(s),(*(c) : (+
                   : allpassnnlt(n-1,sv))~(*(-s))) : fsec(n)
with {
  fsec(1) = _, (_<:mem*(c),_) : sumandtaps(n);
  fsec(n) = _, (_<:mem*(c),_), par(i,n-1,_) : sumandtaps(n);
  s = take(n,sv);
  c = sqrt(max(0,1-s*s));
  sumandtaps(n) = +,par(i,n,_);
};

//========================= Useful special cases ============================

//-------------------------------- tf2np ------------------------------------
// tf2np - biquad based on a stable second-order Normalized Ladder Filter
// (more robust to modulation than tf2 and protected against instability)
tf2np(b0,b1,b2,a1,a2) = allpassnnlt(M,sv) : sum(i,M+1,*(tghr(i)))
with {
  smax = 0.9999; // maximum reflection-coefficient magnitude allowed
  s2 = max(-smax, min(smax,a2)); // Project both reflection-coefficients
  s1 = max(-smax, min(smax,a1/(1+a2))); // into the defined stability-region.
  sv = (s1,s2); // vector of sin(theta) reflection coefficients
  M = 2;
  nu(2) = b2;
  nu(1) = b1 - b2*a1;
  nu(0) = (b0-b2*a2) - nu(1)*s1;
  tg = (nu(0),nu(1),nu(2));
  tgr(i) = take(M+1-i,tg); // vector of tap gains for 2mul case
  tghr(n) = tgr(n)/pi(n);  // apply pi parameters for NLF case
  pi(0) = 1;
  s(n) = take(M-n+1,sv);
  c(n) = sqrt(1-s(n)*s(n));
  pi(n) = pi(n-1)*c(n);
};

//----------------------------- wgr ---------------------------------
// Second-order transformer-normalized digital waveguide resonator
// USAGE: 
//   _ : wgr(f,r) : _
// where
//   f = resonance frequency (Hz)
//   r = loss factor for exponential decay
//        (set to 1 to make a numerically stable oscillator)
//
// REFERENCES:
//  https://ccrma.stanford.edu/~jos/pasp/Power_Normalized_Waveguide_Filters.html
//  https://ccrma.stanford.edu/~jos/pasp/Digital_Waveguide_Oscillator.html
//
wgr(f,r,x) = (*(G),_<:_,((+:*(C))<:_,_),_:+,_,_:+(x),-) ~ cross : _,*(0-gi)
with { 
  C = cos(2*PI*f/SR);
  gi = sqrt(max(0,(1+C)/(1-C))); // compensate amplitude (only needed when
  G = r*(1-1' + gi')/gi;         //   frequency changes substantially)
  cross = _,_ <: !,_,_,!;
};

//----------------------------- nlf2 --------------------------------
// Second order normalized digital waveguide resonator
// USAGE: 
//   _ : nlf2(f,r) : _
// where
//   f = resonance frequency (Hz)
//   r = loss factor for exponential decay
//        (set to 1 to make a sinusoidal oscillator)
//
// REFERENCE:
// https://ccrma.stanford.edu/~jos/pasp/Power_Normalized_Waveguide_Filters.html
//
nlf2(f,r,x) = ((_<:_,_),(_<:_,_) : (*(s),*(c),*(c),*(0-s)) :> 
              (*(r),+(x))) ~ cross
with { 
  th = 2*PI*f/SR;
  c = cos(th);
  s = sin(th);
  cross = _,_ <: !,_,_,!;
};

//===================== Ladder/Lattice Allpass Filters ======================
// An allpass filter has gain 1 at every frequency, but variable phase.
// Ladder/lattice allpass filters are specified by reflection coefficients.
// They are defined here as nested allpass filters, hence the names allpassn*.
//
// REFERENCES
//   1. https://ccrma.stanford.edu/~jos/pasp/Conventional_Ladder_Filters.html
//      https://ccrma.stanford.edu/~jos/pasp/Nested_Allpass_Filters.html
//   2. Linear Prediction of Speech, Markel and Gray, Springer Verlag, 1976
//
// QUICK GUIDE
//   allpassn   - two-multiply lattice - each section is two multiply-adds
//   allpassnn  - normalized form - four multiplies and two adds per section,
//                but coefficients can be time varying and nonlinear without
//                "parametric amplification" (modulation of signal energy).
//   allpassnkl - Kelly-Lochbaum form - four multiplies and two adds per
//                section, but all signals have an immediate physical
//                interpretation as traveling pressure waves, etc.
//   allpassn1m - One-multiply form - one multiply and three adds per section.
//                Normally the most efficient in special-purpose hardware.
//
// TYPICAL USAGE
//   _ : allpassn(N,sv) : _
// where
//   N  = allpass order (number of ladder or lattice sections)
//   sv = (s1,s2,...,sN) = reflection coefficients (between -1 and 1).
//        For allpassnn only, sv is replaced by tv, where sv(i) = sin(tv(i)),
//        where tv(i) may range between -PI and PI.
//
// two-multiply:
allpassn(0,sv) = _;
allpassn(n,sv) = _ <: ((+ <: (allpassn(n-1,sv)),*(s))~(*(-s))) : _',_ :+
with { s = take(n,sv); };

// power-normalized (reflection coefficients s = sin(t)):
allpassnn(0,tv) = _;
allpassnn(n,tv) = _ <: *(s), (*(c) : (+ 
        : allpassnn(n-1,tv))~(*(-s))) : _, mem*c : +
with { c=cos(take(n,tv));  s=sin(take(n,tv)); };

// power-normalized with sparse delays dv(n)>1:
allpassnns(0,tv,dmax,dv) = _;
allpassnns(n,tv,dmax,dv) = _ <: *(s), (*(c) : (+ : dl
           : allpassnns(n-1,tv,dmax,dv))~(*(-s))) : _, mem*c : +
with { c=cos(take(n,tv));  s=sin(take(n,tv));
       dl=delay(dmax,(take(n,dv)-1)); };

// Kelly-Lochbaum:
allpassnkl(0,sv) = _;
allpassnkl(n,sv) = _ <: *(s),(*(1+s) : (+
                   : allpassnkl(n-1,sv))~(*(-s))) : _, mem*(1-s) : +
with { s = take(n,sv); };

// one-multiply:
allpassn1m(0,sv) = _;
allpassn1m(n,sv)= _ <: _,_ : ((+:*(s) <: _,_),_ : _,+ : cross
		  : allpassn1m(n-1,sv),_)~(*(-1)) : _',_ : +
with {s = take(n,sv); cross = _,_ <: !,_,_,!; };

//===== Digital Filter Sections Specified as Analog Filter Sections =====
//
//------------------------- tf2s, tf2snp --------------------------------
// Second-order direct-form digital filter,
// specified by ANALOG transfer-function polynomials B(s)/A(s),
// and a frequency-scaling parameter.  Digitization via the
// bilinear transform is built in.
//
// USAGE: tf2s(b2,b1,b0,a1,a0,w1), where 
//
//         b2 s^2 + b1 s + b0
// H(s) = --------------------
//            s^2 + a1 s + a0
//
// and w1 is the desired digital frequency (in radians/second)
// corresponding to analog frequency 1 rad/sec (i.e., s = j).
//
// EXAMPLE: A second-order ANALOG Butterworth lowpass filter,
//          normalized to have cutoff frequency at 1 rad/sec,
//          has transfer function
//
//              1
// H(s) = -----------------
//         s^2 + a1 s + 1
//
// where a1 = sqrt(2).  Therefore, a DIGITAL Butterworth lowpass 
// cutting off at SR/4 is specified as tf2s(0,0,1,sqrt(2),1,PI*SR/2);
//
// METHOD: Bilinear transform scaled for exact mapping of w1.
// REFERENCE: 
//   https://ccrma.stanford.edu/~jos/pasp/Bilinear_Transformation.html
//
tf2s(b2,b1,b0,a1,a0,w1) = tf2(b0d,b1d,b2d,a1d,a2d)
with {
  c   = 1/tan(w1*0.5/SR); // bilinear-transform scale-factor
  csq = c*c;
  d   = a0 + a1 * c + csq;
  b0d = (b0 + b1 * c + b2 * csq)/d;
  b1d = 2 * (b0 - b2 * csq)/d;
  b2d = (b0 - b1 * c + b2 * csq)/d;
  a1d = 2 * (a0 - csq)/d;
  a2d = (a0 - a1*c + csq)/d;
};

// tf2snp = tf2s but using a protected normalized ladder filter for tf2:
tf2snp(b2,b1,b0,a1,a0,w1) = tf2np(b0d,b1d,b2d,a1d,a2d)
with {
  c   = 1/tan(w1*0.5/SR); // bilinear-transform scale-factor
  csq = c*c;
  d   = a0 + a1 * c + csq;
  b0d = (b0 + b1 * c + b2 * csq)/d;
  b1d = 2 * (b0 - b2 * csq)/d;
  b2d = (b0 - b1 * c + b2 * csq)/d;
  a1d = 2 * (a0 - csq)/d;
  a2d = (a0 - a1*c + csq)/d;
};

//----------------------------- tf3slf -------------------------------
// Analogous to tf2s above, but third order, and using the typical
// low-frequency-matching bilinear-transform constant 2/T ("lf" series)
// instead of the specific-frequency-matching value used in tf2s and tf1s.
// Note the lack of a "w1" argument.
//
tf3slf(b3,b2,b1,b0,a3,a2,a1,a0) = tf3(b0d,b1d,b2d,b3d,a1d,a2d,a3d) with {
  c   = 2.0 * SR; // bilinear-transform scale-factor ("lf" case)
  csq = c*c;
  cc = csq*c;
  // Thank you maxima:
  b3d = (b3*c^3-b2*c^2+b1*c-b0)/d;
  b2d = (-3*b3*c^3+b2*c^2+b1*c-3*b0)/d;
  b1d = (3*b3*c^3+b2*c^2-b1*c-3*b0)/d;
  b0d = (-b3*c^3-b2*c^2-b1*c-b0)/d;
  a3d = (a3*c^3-a2*c^2+a1*c-a0)/d;
  a2d = (-3*a3*c^3+a2*c^2+a1*c-3*a0)/d;
  a1d = (3*a3*c^3+a2*c^2-a1*c-3*a0)/d;
  d = (-a3*c^3-a2*c^2-a1*c-a0);
};

//----------------------------- tf1s --------------------------------
// First-order direct-form digital filter,
// specified by ANALOG transfer-function polynomials B(s)/A(s),
// and a frequency-scaling parameter.
//
// USAGE: tf1s(b1,b0,a0,w1), where 
//
//        b1 s + b0
// H(s) = ----------
//           s + a0
//
// and w1 is the desired digital frequency (in radians/second)
// corresponding to analog frequency 1 rad/sec (i.e., s = j).
//
// EXAMPLE: A first-order ANALOG Butterworth lowpass filter,
//          normalized to have cutoff frequency at 1 rad/sec,
//          has transfer function
//
//           1
// H(s) = -------
//         s + 1
//
// so b0 = a0 = 1 and b1 = 0.  Therefore, a DIGITAL first-order 
// Butterworth lowpass with gain -3dB at SR/4 is specified as 
//
// tf1s(0,1,1,PI*SR/2); // digital half-band order 1 Butterworth
//
// METHOD: Bilinear transform scaled for exact mapping of w1.
// REFERENCE: 
//   https://ccrma.stanford.edu/~jos/pasp/Bilinear_Transformation.html
//
tf1s(b1,b0,a0,w1) = tf1(b0d,b1d,a1d)
with {
  c   = 1/tan(w1*0.5/SR); // bilinear-transform scale-factor
  d   = a0 + c;
  b1d = (b0 - b1*c) / d;
  b0d = (b0 + b1*c) / d;
  a1d = (a0 - c) / d;
};

//----------------------------- tf2sb --------------------------------
// Bandpass mapping of tf2s: In addition to a frequency-scaling parameter
// w1 (set to HALF the desired passband width in rad/sec),
// there is a desired center-frequency parameter wc (also in rad/s).
// Thus, tf2sb implements a fourth-order digital bandpass filter section
// specified by the coefficients of a second-order analog lowpass prototpe
// section.  Such sections can be combined in series for higher orders.
// The order of mappings is (1) frequency scaling (to set lowpass cutoff w1),
// (2) bandpass mapping to wc, then (3) the bilinear transform, with the 
// usual scale parameter 2*SR.  Algebra carried out in maxima and pasted here.
//
tf2sb(b2,b1,b0,a1,a0,w1,wc) = 
  iir((b0d/a0d,b1d/a0d,b2d/a0d,b3d/a0d,b4d/a0d),(a1d/a0d,a2d/a0d,a3d/a0d,a4d/a0d)) with {
  T = 1.0/float(SR);
  b0d = (4*b0*w1^2+8*b2*wc^2)*T^2+8*b1*w1*T+16*b2;
  b1d = 4*b2*wc^4*T^4+4*b1*wc^2*w1*T^3-16*b1*w1*T-64*b2;
  b2d = 6*b2*wc^4*T^4+(-8*b0*w1^2-16*b2*wc^2)*T^2+96*b2;
  b3d = 4*b2*wc^4*T^4-4*b1*wc^2*w1*T^3+16*b1*w1*T-64*b2;
  b4d = (b2*wc^4*T^4-2*b1*wc^2*w1*T^3+(4*b0*w1^2+8*b2*wc^2)*T^2-8*b1*w1*T +16*b2)
        + b2*wc^4*T^4+2*b1*wc^2*w1*T^3;
  a0d = wc^4*T^4+2*a1*wc^2*w1*T^3+(4*a0*w1^2+8*wc^2)*T^2+8*a1*w1*T+16;
  a1d = 4*wc^4*T^4+4*a1*wc^2*w1*T^3-16*a1*w1*T-64;
  a2d = 6*wc^4*T^4+(-8*a0*w1^2-16*wc^2)*T^2+96;
  a3d = 4*wc^4*T^4-4*a1*wc^2*w1*T^3+16*a1*w1*T-64;
  a4d = wc^4*T^4-2*a1*wc^2*w1*T^3+(4*a0*w1^2+8*wc^2)*T^2-8*a1*w1*T+16;
};

//----------------------------- tf1sb --------------------------------
// First-to-second-order lowpass-to-bandpass section mapping,
// analogous to tf2sb above.
//
tf1sb(b1,b0,a0,w1,wc) = tf2(b0d/a0d,b1d/a0d,b2d/a0d,a1d/a0d,a2d/a0d) with {
  T = 1.0/float(SR);
  a0d = wc^2*T^2+2*a0*w1*T+4;
  b0d = b1*wc^2*T^2 +2*b0*w1*T+4*b1;
  b1d = 2*b1*wc^2*T^2-8*b1;
  b2d = b1*wc^2*T^2-2*b0*w1*T+4*b1;
  a1d = 2*wc^2*T^2-8;
  a2d = wc^2*T^2-2*a0*w1*T+4;
};

//====================== Simple Resonator Filters ======================

// resonlp = 2nd-order lowpass with corner resonance:
resonlp(fc,Q,gain) = tf2s(b2,b1,b0,a1,a0,wc)
with {
     wc = 2*PI*fc;
     a1 = 1/Q;
     a0 = 1;
     b2 = 0;
     b1 = 0;
     b0 = gain;
};

// resonhp = 2nd-order highpass with corner resonance:
resonhp(fc,Q,gain,x) = gain*x-resonlp(fc,Q,gain,x);

// resonbp = 2nd-order bandpass
resonbp(fc,Q,gain) = tf2s(b2,b1,b0,a1,a0,wc) 
with {
     wc = 2*PI*fc;
     a1 = 1/Q;
     a0 = 1;
     b2 = 0;
     b1 = gain;
     b0 = 0;
};

//================ Butterworth Lowpass/Highpass Filters ======================
// Nth-order Butterworth lowpass or highpass filters
//
// USAGE: 
//   _ : lowpass(N,fc) : _
//   _ : highpass(N,fc) : _
// where
//   N = filter order (number of poles) [nonnegative constant integer]
//   fc = desired cut-off frequency (-3dB frequency) in Hz
// REFERENCE: 
//  https://ccrma.stanford.edu/~jos/filters/Butterworth_Lowpass_Design.html
//  'butter' function in Octave ("[z,p,g] = butter(N,1,'s');")
// ACKNOWLEDGMENT
//  Generalized recursive formulation initiated by Yann Orlarey.

lowpass(N,fc) = lowpass0_highpass1(0,N,fc);
highpass(N,fc) = lowpass0_highpass1(1,N,fc);
lowpass0_highpass1(s,N,fc) = lphpr(s,N,N,fc)
with {
  lphpr(s,0,N,fc) = _;
  lphpr(s,1,N,fc) = tf1s(s,1-s,1,2*PI*fc);
  lphpr(s,O,N,fc) = lphpr(s,(O-2),N,fc) : tf2s(s,0,1-s,a1s,1,w1) with {
    parity = N % 2;
    S = (O-parity)/2; // current section number
    a1s = -2*cos(-PI + (1-parity)*PI/(2*N) + (S-1+parity)*PI/N);
    w1 = 2*PI*fc;
  };
};

//========== Special Filter-Bank Delay-Equalizing Allpass Filters ===========
//
// These special allpass filters are needed by filterbank et al. below.
// They are equivalent to (lowpass(N,fc) +|- highpass(N,fc))/2, but with 
// canceling pole-zero pairs removed (which occurs for odd N).

//-------------------- lowpass_plus|minus_highpass ------------------

highpass_plus_lowpass(1,fc) = _;
highpass_plus_lowpass(3,fc) = tf2s(1,-1,1,1,1,w1) with { w1 = 2*PI*fc; };
highpass_minus_lowpass(3,fc) = tf1s(-1,1,1,w1) with { w1 = 2*PI*fc; };
highpass_plus_lowpass(5,fc) = tf2s(1,-a11,1,a11,1,w1)
with { 
  a11 = 1.618033988749895;
  w1 = 2*PI*fc; 
};
highpass_minus_lowpass(5,fc) = tf1s(1,-1,1,w1) : tf2s(1,-a12,1,a12,1,w1)
with { 
  a12 = 0.618033988749895;
  w1 = 2*PI*fc; 
};

// Catch-all definitions for generality - even order is done:

highpass_plus_lowpass(N,fc) = _ <: switch_odd_even(N%2,N,fc) with {
  switch_odd_even(0,N,fc) = highpass_plus_lowpass_even(N,fc);
  switch_odd_even(1,N,fc) = highpass_plus_lowpass_odd(N,fc);
};

highpass_minus_lowpass(N,fc) = _ <: switch_odd_even(N%2,N,fc) with {
  switch_odd_even(0,N,fc) = highpass_minus_lowpass_even(N,fc);
  switch_odd_even(1,N,fc) = highpass_minus_lowpass_odd(N,fc);
};

highpass_plus_lowpass_even(N,fc) = highpass(N,fc) + lowpass(N,fc);
highpass_minus_lowpass_even(N,fc) = highpass(N,fc) - lowpass(N,fc);

// FIXME: Rewrite the following, as for orders 3 and 5 above,
//        to eliminate pole-zero cancellations:
highpass_plus_lowpass_odd(N,fc) = highpass(N,fc) + lowpass(N,fc);
highpass_minus_lowpass_odd(N,fc) = highpass(N,fc) - lowpass(N,fc);

//===================== Elliptic (Cauer) Lowpass Filters ===================
// USAGE: 
//   _ : lowpass3e(fc) : _
//   _ : lowpass6e(fc) : _
// where fc = -3dB frequency in Hz
//
// REFERENCES:
//   http://en.wikipedia.org/wiki/Elliptic_filter
//   functions 'ncauer' and 'ellip' in Octave

//----------------------------- lowpass3e -----------------------------
// Third-order Elliptic (Cauer) lowpass filter
// DESIGN: For spectral band-slice level display (see octave_analyzer3e):
//   [z,p,g] = ncauer(Rp,Rs,3);  % analog zeros, poles, and gain, where
//   Rp = 60  % dB ripple in stopband
//   Rs = 0.2 % dB ripple in passband
//
lowpass3e(fc) = tf2s(b21,b11,b01,a11,a01,w1) : tf1s(0,1,a02,w1)
with { 
  a11 = 0.802636764161030; // format long; poly(p(1:2)) % in octave
  a01 = 1.412270893774204;
  a02 = 0.822445908998816; // poly(p(3)) % in octave
  b21 = 0.019809144837789; // poly(z)
  b11 = 0;
  b01 = 1.161516418982696;
  w1 = 2*PI*fc; 
};

//----------------------------- lowpass6e -----------------------------
// Sixth-order Elliptic/Cauer lowpass filter
// DESIGN: For spectral band-slice level display (see octave_analyzer6e):
//   [z,p,g] = ncauer(Rp,Rs,6);  % analog zeros, poles, and gain, where
//   Rp = 80  % dB ripple in stopband
//   Rs = 0.2 % dB ripple in passband
//
lowpass6e(fc) = 
              tf2s(b21,b11,b01,a11,a01,w1) :
              tf2s(b22,b12,b02,a12,a02,w1) :
              tf2s(b23,b13,b03,a13,a03,w1)
with { 
  b21 = 0.000099999997055;
  a21 = 1;
  b11 = 0;
  a11 = 0.782413046821645;
  b01 = 0.000433227200555;
  a01 = 0.245291508706160;
  b22 = 1;
  a22 = 1;
  b12 = 0;
  a12 = 0.512478641889141;
  b02 = 7.621731298870603;
  a02 = 0.689621364484675;
  b23 = 1;
  a23 = 1;
  b13 = 0;
  a13 = 0.168404871113589;
  b03 = 53.536152954556727;
  a03 = 1.069358407707312;
  w1 = 2*PI*fc; 
};

//===================== Elliptic Highpass Filters =====================
// USAGE: 
//   _ : highpass3e(fc) : _
//   _ : highpass6e(fc) : _
// where fc = -3dB frequency in Hz

//----------------------------- highpass3e -----------------------------
// Third-order Elliptic (Cauer) highpass filter
// DESIGN: Inversion of lowpass3e wrt unit circle in s plane (s <- 1/s)
//
highpass3e(fc) = tf2s(b01/a01,b11/a01,b21/a01,a11/a01,1/a01,w1) : 
                 tf1s(1/a02,0,1/a02,w1)
with { 
  a11 = 0.802636764161030;
  a01 = 1.412270893774204;
  a02 = 0.822445908998816;
  b21 = 0.019809144837789;
  b11 = 0;
  b01 = 1.161516418982696;
  w1 = 2*PI*fc; 
};

//----------------------------- highpass6e -----------------------------
// Sixth-order Elliptic/Cauer highpass filter
// METHOD: Inversion of lowpass3e wrt unit circle in s plane (s <- 1/s)
//
highpass6e(fc) = 
              tf2s(b01/a01,b11/a01,b21/a01,a11/a01,1/a01,w1) :
              tf2s(b02/a02,b12/a02,b22/a02,a12/a02,1/a02,w1) :
              tf2s(b03/a03,b13/a03,b23/a03,a13/a03,1/a03,w1)
with { 
  b21 = 0.000099999997055;
  a21 = 1;
  b11 = 0;
  a11 = 0.782413046821645;
  b01 = 0.000433227200555;
  a01 = 0.245291508706160;
  b22 = 1;
  a22 = 1;
  b12 = 0;
  a12 = 0.512478641889141;
  b02 = 7.621731298870603;
  a02 = 0.689621364484675;
  b23 = 1;
  a23 = 1;
  b13 = 0;
  a13 = 0.168404871113589;
  b03 = 53.536152954556727;
  a03 = 1.069358407707312;
  w1 = 2*PI*fc; 
};

//================== Butterworth Bandpass/Bandstop Filters =====================
// Order 2*Nh Butterworth bandpass filter made using the transformation
// s <- s + wc^2/s on lowpass(Nh), where wc is the desired bandpass center 
// frequency.  The lowpass(Nh) cutoff w1 is half the desired bandpass width.
// A notch-like "bandstop" filter is similarly made from highpass(Nh).
//
// USAGE: 
//   _ : bandpass(Nh,fl,fu) : _
//   _ : bandstop(Nh,fl,fu) : _
// where 
//   Nh = HALF the desired bandpass/bandstop order (which is therefore even)
//   fl = lower -3dB frequency in Hz
//   fu = upper -3dB frequency in Hz
// Thus, the passband (stopband) width is fu-fl, 
//       and its center frequency is (fl+fu)/2.
//
// REFERENCE: 
//   http://cnx.org/content/m16913/latest/
//
bandpass(Nh,fl,fu) = bandpass0_bandstop1(0,Nh,fl,fu);
bandstop(Nh,fl,fu) = bandpass0_bandstop1(1,Nh,fl,fu);
bandpass0_bandstop1(s,Nh,fl,fu) = bpbsr(s,Nh,Nh,fl,fu) 
with {
  wl = 2*PI*fl; // digital (z-plane) lower passband edge
  wu = 2*PI*fu; // digital (z-plane) upper passband edge

  c = 2.0*SR; // bilinear transform scaling used in tf2sb, tf1sb
  wla = c*tan(wl/c); // analog (s-splane) lower cutoff
  wua = c*tan(wu/c); // analog (s-splane) upper cutoff

  wc = sqrt(wla*wua); // s-plane center frequency
  w1 = wua - wc^2/wua; // s-plane lowpass prototype cutoff

  bpbsr(s,0,Nh,fl,fu) = _;
  bpbsr(s,1,Nh,fl,fu) = tf1sb(s,1-s,1,w1,wc);
  bpbsr(s,O,Nh,fl,fu) = bpbsr(s,O-2,Nh,fl,fu) : tf2sb(s,0,(1-s),a1s,1,w1,wc)
  with {
    parity = Nh % 2;
    S = (O-parity)/2; // current section number
    a1s = -2*cos(-PI + (1-parity)*PI/(2*Nh) + (S-1+parity)*PI/Nh);
  };
};

//======================= Elliptic Bandpass Filters ============================

//----------------------------- bandpass6e -----------------------------
// Order 12 elliptic bandpass filter analogous to bandpass(6) above.
//
bandpass6e(fl,fu) = tf2sb(b21,b11,b01,a11,a01,w1,wc) : tf1sb(0,1,a02,w1,wc)
with { 
  a11 = 0.802636764161030; // In octave: format long; poly(p(1:2))
  a01 = 1.412270893774204;
  a02 = 0.822445908998816; // poly(p(3))
  b21 = 0.019809144837789; // poly(z)
  b11 = 0;
  b01 = 1.161516418982696;

  wl = 2*PI*fl; // digital (z-plane) lower passband edge
  wu = 2*PI*fu; // digital (z-plane) upper passband edge

  c = 2.0*SR; // bilinear transform scaling used in tf2sb, tf1sb
  wla = c*tan(wl/c); // analog (s-splane) lower cutoff
  wua = c*tan(wu/c); // analog (s-splane) upper cutoff

  wc = sqrt(wla*wua); // s-plane center frequency
  w1 = wua - wc^2/wua; // s-plane lowpass cutoff
};

//----------------------------- bandpass12e -----------------------------

bandpass12e(fl,fu) = 
              tf2sb(b21,b11,b01,a11,a01,w1,wc) :
              tf2sb(b22,b12,b02,a12,a02,w1,wc) :
              tf2sb(b23,b13,b03,a13,a03,w1,wc)
with { // octave script output:
  b21 = 0.000099999997055;
  a21 = 1;
  b11 = 0;
  a11 = 0.782413046821645;
  b01 = 0.000433227200555;
  a01 = 0.245291508706160;
  b22 = 1;
  a22 = 1;
  b12 = 0;
  a12 = 0.512478641889141;
  b02 = 7.621731298870603;
  a02 = 0.689621364484675;
  b23 = 1;
  a23 = 1;
  b13 = 0;
  a13 = 0.168404871113589;
  b03 = 53.536152954556727;
  a03 = 1.069358407707312;

  wl = 2*PI*fl; // digital (z-plane) lower passband edge
  wu = 2*PI*fu; // digital (z-plane) upper passband edge

  c = 2.0*SR; // bilinear transform scaling used in tf2sb, tf1sb
  wla = c*tan(wl/c); // analog (s-splane) lower cutoff
  wua = c*tan(wu/c); // analog (s-splane) upper cutoff

  wc = sqrt(wla*wua); // s-plane center frequency
  w1 = wua - wc^2/wua; // s-plane lowpass cutoff
};

//================= Parametric Equalizers (Shelf, Peaking)  ==================
// REFERENCES
// - http://en.wikipedia.org/wiki/Equalization
// - filterbank (below, here in filter.lib)
// - http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt
// - Digital Audio Signal Processing, Udo Zolzer, Wiley, 1999, p. 124
// - https://ccrma.stanford.edu/~jos/filters/Low_High_Shelving_Filters.html
// - https://ccrma.stanford.edu/~jos/filters/Peaking_Equalizers.html
// - maxmsp.lib in the Faust distribution
// - bandfilter.dsp in the faust2pd distribution 

//------------------------------ low_shelf -------------------------------------
// First-order "low shelf" filter (gain boost|cut between dc and some frequency)
//
// USAGE: 
//   _ : lowshelf(N,L0,fx) : _
// where
//   N = filter order 1, 3, 5, ... (odd only).
//  L0 = desired level (dB) between dc and fx (boost L0>0 or cut L0<0)
//  fx = -3dB frequency of lowpass band (L0>0) or upper band (L0<0)
//       (see "SHELF SHAPE" below).
//
// The gain at SR/2 is constrained to be 1.
// The generalization to arbitrary odd orders is based on the well known
// fact that odd-order Butterworth band-splits are allpass-complementary
// (see filterbank documentation below for references).
//
// SHELF SHAPE 
//  The magnitude frequency response is approximately piecewise-linear
//  on a log-log plot ("BODE PLOT").  The Bode "stick diagram" approximation
//  L(lf) is easy to state in dB versus dB-frequency lf = dB(f):
// L0 > 0:
//  L(lf) = L0, f between 0 and fx = 1st corner frequency;
//  L(lf) = L0 - N * (lf - lfx), f between fx and f2 = 2nd corner frequency;
//  L(lf) = 0, lf > lf2.
//    lf2 = lfx + L0/N = dB-frequency at which level gets back to 0 dB.
//    See lowshelf_other_freq() below.
// L0 < 0:
//  L(lf) = L0, f between 0 and f1 = 1st corner frequency;
//  L(lf) = - N * (lfx - lf), f between f1 and lfx = 2nd corner frequency;
//  L(lf) = 0, lf > lfx.
//    lf1 = lfx + L0/N = dB-frequency at which level goes up from L0.
//    See lowshelf_other_freq() below.

lowshelf(N,L0,fx) = filterbank(N,(fx)) : _, *(db2linear(L0)) :> _;
// Special cases and optimization:
low_shelf  = lowshelf(3); // default = 3rd order Butterworth
low_shelf1(L0,fx,x) = x + (db2linear(L0)-1)*lowpass(1,fx,x); // optimized
low_shelf1_l(G0,fx,x) = x + (G0-1)*lowpass(1,fx,x); // optimized

lowshelf_other_freq(N, L0, fx) = db2linear(linear2db(fx) + L0/N); // convenience

//------------------------------ high_shelf ------------------------------------
// First-order "high shelf" filter (gain boost|cut above some frequency)
//
// USAGE: 
//   _ : highshelf(N,Lpi,fx) : _
// where
//    N = filter order 1, 3, 5, ... (odd only).
//  Lpi = desired level (dB) between fx and SR/2 (boost Lpi>0 or cut Lpi<0)
//   fx = -3dB frequency of highpass band (L0>0) or lower band (L0<0)
//        (Use highshelf_other_freq() below to find the other one.)
//
// The gain at dc is constrained to be 1.
// See lowshelf documentation above regarding SHELF SHAPE.

highshelf(N,Lpi,fx) = filterbank(N,(fx)) : *(db2linear(Lpi)), _ :> _;
// Special cases and optimization:
high_shelf = highshelf(3); // default = 3rd order Butterworth
high_shelf1(Lpi,fx,x) = x + (db2linear(Lpi)-1)*highpass(1,fx,x); // optimized
high_shelf1_l(Gpi,fx,x) = x + (Gpi-1)*highpass(1,fx,x); //optimized

// shelf transitions between frequency fx and this one:
highshelf_other_freq(N, Lpi, fx) = db2linear(linear2db(fx) - Lpi/N);

//-------------------------------- peak_eq -----------------------------------
// Second order "peaking equalizer" section 
// (gain boost or cut near some frequency)
//   Also called a "parametric equalizer" section
// USAGE: _ : peak_eq(Lfx,fx,B) : _;
// where
//    Lfx = level (dB) at fx (boost Lfx>0 or cut Lfx<0)
//     fx = peak frequency (Hz)
//      B = bandwidth (B) of peak in Hz
//
peak_eq(Lfx,fx,B) = tf2s(1,b1s,1,a1s,1,wx) with {
  T = float(1.0/SR);
  Bw = B*T/sin(wx*T); // prewarp s-bandwidth for more accuracy in z-plane
  a1 = PI*Bw;
  b1 = g*a1;
  g = db2linear(abs(Lfx));
  b1s = select2(Lfx>0,a1,b1); // When Lfx>0, pole dominates bandwidth
  a1s = select2(Lfx>0,b1,a1); // When Lfx<0, zero dominates
  wx = 2*PI*fx;
};  

//------------------------------- peak_eq_cq ---------------------------------
// Constant-Q second order peaking equalizer section 
// USAGE: _ : peak_eq_cq(Lfx,fx,Q) : _;
// where
//    Lfx = level (dB) at fx
//     fx = boost or cut frequency (Hz)
//      Q = "Quality factor" = fx/B where B = bandwidth of peak in Hz
//
peak_eq_cq(Lfx,fx,Q) = peak_eq(Lfx,fx,fx/Q);

//------------------------------- peak_eq_rm ---------------------------------
// Regalia-Mitra second order peaking equalizer section
// USAGE: _ : peak_eq_rm(Lfx,fx,tanPiBT) : _;
// where
//     Lfx = level (dB) at fx
//      fx = boost or cut frequency (Hz)
// tanPiBT = tan(PI*B/SR), where B = -3dB bandwidth (Hz) when 10^(Lfx/20) = 0
//         ~ PI*B/SR for narrow bandwidths B
//
// REFERENCE: 
//   P.A. Regalia, S.K. Mitra, and P.P. Vaidyanathan,
//   "The Digital All-Pass Filter: A Versatile Signal Processing Building Block"
//   Proceedings of the IEEE, 76(1):19-37, Jan. 1988.  (See pp. 29-30.)
//
peak_eq_rm(Lfx,fx,tanPiBT) = _ <: _,A,_ : +,- : *(0.5),*(K/2.0) : + with {
  A = tf2(k2, k1*(1+k2), 1, k1*(1+k2), k2) <: _,_; // allpass
  k1 = 0.0 - cos(2.0*PI*fx/SR);
  k2 = (1.0 - tanPiBT)/(1.0 + tanPiBT);
  K = db2linear(Lfx);
};

//-------------------------- parametric_eq_demo ------------------------------
// USAGE:
//   _ : parametric_eq_demo: _ ;
parametric_eq_demo = // input_signal : 
	low_shelf(LL,FL) :
        peak_eq(LP,FP,BP) :
	high_shelf(LH,FH)
// Recommended: 
//       : mth_octave_spectral_level_demo(2) // half-octave spectrum analyzer
with {
  eq_group(x) = hgroup("[0] PARAMETRIC EQ SECTIONS 
                [tooltip: See Faust's filter.lib for info and pointers]",x);

  ls_group(x) = eq_group(vgroup("[1] Low Shelf",x));
  LL = ls_group(hslider("[0] Low Boost|Cut [unit:dB] [style:knob]
                [tooltip: Amount of low-frequency boost or cut in decibels]",
                0,-40,40,0.1));
  FL = ls_group(hslider("[1] Transition Frequency [unit:Hz] [style:knob] [scale:log]
                [tooltip: Transition-frequency from boost (cut) to unity gain]",
                200,1,5000,1));

  pq_group(x) = eq_group(vgroup("[2] Peaking Equalizer
                [tooltip: Parametric Equalizer sections from filter.lib]",x));
  LP = pq_group(hslider("[0] Peak Boost|Cut [unit:dB] [style:knob]
                [tooltip: Amount of local boost or cut in decibels]",
                0,-40,40,0.1));
  FP = pq_group(hslider("[1] Peak Frequency [unit:PK] [style:knob]
       [tooltip: Peak Frequency in Piano Key (PK) units (A440 = 49PK)]",
                49,1,100,1)) : smooth(0.999) : pianokey2hz 
		with { pianokey2hz(x) = 440.0*pow(2.0, (x-49.0)/12); };

  Q = pq_group(hslider("[2] Peak Q [style:knob] [scale:log]
              [tooltip: Quality factor (Q) of the peak = center-frequency/bandwidth]",
              40,1,1000,0.1));

  BP = FP/Q;

  hs_group(x) = eq_group(vgroup("[3] High Shelf 
                [tooltip: A high shelf provides a boost or cut 
                          above some frequency]",x));
  LH = hs_group(hslider("[0] High Boost|Cut [unit:dB] [style:knob]
                [tooltip: Amount of high-frequency boost or cut in decibels]",
                0,-40,40,.1));
  FH = hs_group(hslider("[1] Transition Frequency [unit:Hz] [style:knob] [scale:log]
                [tooltip: Transition-frequency from boost (cut) to unity gain]",
                8000,20,10000,1));
};

//------------------------- spectral_tilt --------------------------------
// Spectral tilt filter, providing an arbitrary spectral rolloff factor
// alpha in (-1,1), where
//  -1 corresponds to one pole (-6 dB per octave), and
//  +1 corresponds to one zero (+6 dB per octave).
// In other words, alpha is the slope of the ln magnitude versus ln frequency.
// For a "pinking filter" (e.g., to generate 1/f noise from white noise),
// set alpha to -1/2.
//
// USAGE:
//   _ : spectral_tilt(N,f0,bw,alpha) : _
// where
//     N = desired integer filter order (fixed at compile time)
//    f0 = lower frequency limit for desired roll-off band
//    bw = bandwidth of desired roll-off band
// alpha = slope of roll-off desired in nepers per neper
//         (ln mag / ln radian freq)
//
// EXAMPLE:
//    spectral_tilt_demo below
//
// REFERENCE:
//    http://arxiv.org/abs/1606.06154
//
spectral_tilt(N,f0,bw,alpha) = seq(i,N,sec(i)) with {
  sec(i) = g * tf1s(b1,b0,a0,1) with {
    g = a0/b0; // unity dc-gain scaling
    b1 = 1.0;
    b0 = mzh(i);
    a0 = mph(i);
    mzh(i) = prewarp(mz(i),SR,w0); // prewarping for bilinear transform
    mph(i) = prewarp(mp(i),SR,w0);
    prewarp(w,SR,wp) = wp * tan(w*T/2) / tan(wp*T/2) with { T = 1/SR; };
    mz(i) = w0 * r ^ (-alpha+i); // minus zero i in s plane
    mp(i) = w0 * r ^ i; // minus pole i in s plane
    w0 = 2 * PI * f0; // radian frequency of first pole
    f1 = f0 + bw; // upper band limit
    r = (f1/f0)^(1.0/float(N-1)); // pole ratio (2 => octave spacing)
  };
};

//-------------------------- spectral_tilt_demo ------------------------------
// USAGE:
//   _ : spectral_tilt_demo(N) : _ ;
// where
//   N = filter order (integer)
// All other parameters interactive
//
spectral_tilt_demo(N) = spectral_tilt(N,f0,bw,alpha) with {
	alpha = hslider("[1] Slope of Spectral Tilt across Band",-1/2,-1,1,0.001);
	f0 = hslider("[2] Band Start Frequency [unit:Hz]",100,20,10000,1);
	bw = hslider("[3] Band Width [unit:Hz]",5000,100,10000,1);
};

//========================= Lagrange Interpolation ========================

//-------------------------- fdelaylti, fdelayltv -------------------------
// Fractional delay line using Lagrange interpolation
// USAGE: _ : fdelaylt[i|v](order, maxdelay, delay, inputsignal) : _
// where order=1,2,3,... is the order of the Lagrange interpolation polynomial.
// fdelaylti is most efficient, but designed for constant/slowly-varying delay.
// fdelayltv is more expensive and more robust when the delay varies rapidly.
//
// NOTE: The requested delay should not be less than (N-1)/2.
//
// The first-order case (linear interpolation) is equivalent to 
// fdelay in music.lib (delay d in [0,1])
//
// REFERENCES:
//
// https://ccrma.stanford.edu/~jos/pasp/Lagrange_Interpolation.html
//
// Timo I. Laakso et al., "Splitting the Unit Delay - Tools for Fractional
//         Delay Filter Design", IEEE Signal Processing Magazine,
//         vol. 13, no. 1, pp. 30-60, Jan 1996.
//
// Philippe Depalle and Stephan Tassart, "Fractional Delay Lines using
//         Lagrange Interpolators", ICMC Proceedings, pp. 341-343, 1996.

fdelaylti(N,n,d,x)  = delay(n,id,x) <: seq(i,N,section(i)) : !,_
with {
  o = (N-1.00001)/2; // offset to ~center FIR interpolator
  dmo = d - o; // assumed nonnegative [d > (N-1)/2]
  id = int(dmo);
  fd = o + frac(dmo);
  section(i,x,y) = (x-x') * c(i) <: _,+(y);
  c(i) = (i - fd)/(i+1);
};

fdelayltv(N,n,d,x) = sum(i, N+1, delay(n,id+i,x) * h(N,fd,i))
with {
  o = (N-1.00001)/2;  // ~center FIR interpolator
  dmo = d - o; // assumed >=0 [d > (N-1)/2]
  id = int(dmo);
  fd = o + frac(dmo);
  h(N,d,n) = facs1(N,d,n) * facs2(N,d,n);
  facs1(N,d,n) = select2(n,1,prod(k,max(1,n),select2(k<n,1,fac(d,n,k))));
  facs2(N,d,n) = select2(n<N,1,prod(l,max(1,N-n),fac(d,n,l+n+1)));
  fac(d,n,k) = (d-k)/((n-k)+(n==k));
  // Explicit formula for Lagrange interpolation coefficients:
  // h_d(n) = \prod_{\stackrel{k=0}{k\neq n}}^N \frac{d-k}{n-k}, n=0:N
};

// Backward compatibility:
fdelay1 = fdelayltv(1);
fdelay2 = fdelayltv(2);
fdelay3 = fdelayltv(3);
fdelay4 = fdelayltv(4);
fdelay5 = fdelayltv(5);

//====================== Thiran Allpass Interpolation =====================
// Reference:
// https://ccrma.stanford.edu/~jos/pasp/Thiran_Allpass_Interpolators.html
// 
//---------------- fdelay1a, fdelay2a, fdelay3a, fdelay4a -------------
// Delay lines interpolated using Thiran allpass interpolation
// USAGE: fdelayNa(maxdelay, delay, inputsignal) 
//        (exactly like fdelay in music.lib)
// where N=1,2,3, or 4 is the order of the Thiran interpolation filter,
// and the delay argument is at least N - 1/2.
//
// (Move the following and similar notes above to filter-lib-doc.txt?)
//
// NOTE: The interpolated delay should not be less than N - 1/2.
//            (The allpass delay ranges from N - 1/2 to N + 1/2.)
//            This constraint can be alleviated by altering the code,
//            but be aware that allpass filters approach zero delay
//            by means of pole-zero cancellations.
//            The delay range [N-1/2,N+1/2] is not optimal. What is?
//
// NOTE: Delay arguments too small will produce an UNSTABLE allpass!
//
// NOTE: Because allpass interpolation is recursive, it is not as robust
//       as Lagrange interpolation under time-varying conditions.
//       (You may hear clicks when changing the delay rapidly.)
//
// first-order allpass interpolation, delay d in [0.5,1.5]
fdelay1a(n,d,x)  = delay(n,id,x) : tf1(eta,1,eta)
with {
  o = 0.49999; // offset to make life easy for allpass
  dmo = d - o; // assumed nonnegative
  id = int(dmo);
  fd = o + frac(dmo);
  eta = (1-fd)/(1+fd); // allpass coefficient
};

// second-order allpass delay in [1.5,2.5]
fdelay2a(n,d,x) = delay(n,id,x) : tf2(a2,a1,1,a1,a2)
with {
  o = 1.49999;
  dmo = d - o; // delay range is [order-1/2, order+1/2]
  id = int(dmo);
  fd = o + frac(dmo);
  a1o2 = (2-fd)/(1+fd); // share some terms (the compiler does this anyway)
  a1 = 2*a1o2;
  a2 = a1o2*(1-fd)/(2+fd);
};

// third-order allpass delay in [2.5,3.5]
// delay d should be at least 2.5
fdelay3a(n,d,x) = delay(n,id,x) : iir((a3,a2,a1,1),(a1,a2,a3))
with {
  o = 2.49999;
  dmo = d - o;
  id = int(dmo);
  fd = o + frac(dmo);
  a1o3 = (3-fd)/(1+fd);
  a2o3 = a1o3*(2-fd)/(2+fd);
  a1 = 3*a1o3;
  a2 = 3*a2o3;
  a3 = a2o3*(1-fd)/(3+fd);
};

// fourth-order allpass delay in [3.5,4.5]
// delay d should be at least 3.5
fdelay4a(n,d,x) = delay(n,id,x) : iir((a4,a3,a2,a1,1),(a1,a2,a3,a4))
with {
  o = 3.49999;
  dmo = d - o;
  id = int(dmo);
  fd = o + frac(dmo);
  a1o4 = (4-fd)/(1+fd);
  a2o6 = a1o4*(3-fd)/(2+fd);
  a3o4 = a2o6*(2-fd)/(3+fd);
  a1 = 4*a1o4;
  a2 = 6*a2o6;
  a3 = 4*a3o4;
  a4 = a3o4*(1-fd)/(4+fd);
};

//================ Mth-Octave Filter-Banks and Spectrum-Analyzers ============
// Mth-octave filter-banks and spectrum-analyzers split the input signal into a
// bank of parallel signals, one for each spectral band. The parameters are
//
//   M = number of band-slices per octave (>1)
//   N = total number of bands (>2)
//   ftop = upper bandlimit of the Mth-octave bands (<SR/2)
//
// In addition to the Mth-octave output signals, there is a highpass signal
// containing frequencies from ftop to SR/2, and a "dc band" lowpass signal 
// containing frequencies from 0 (dc) up to the start of the Mth-octave bands.
// Thus, the N output signals are
//
//   highpass(ftop), MthOctaveBands(M,N-2,ftop), dcBand(ftop*2^(-M*(N-1)))
//
// A FILTER-BANK is defined here as a signal bandsplitter having the
// property that summing its output signals gives an allpass-filtered
// version of the filter-bank input signal.  A more conventional term for
// this is an "allpass-complementary filter bank".  If the allpass filter
// is a pure delay (and possible scaling), the filter bank is said to be
// a "perfect-reconstruction filter bank" (see Vaidyanathan-1993 cited
// below for details).  A "graphic equalizer", in which band signals
// are scaled by gains and summed, should be based on a filter bank.
//
// A SPECTRUM-ANALYZER is defined here as any band-split whose bands span
// the relevant spectrum, but whose band-signals do not
// necessarily sum to the original signal, either exactly or to within an
// allpass filtering. Spectrum analyzer outputs are normally at least nearly
// "power complementary", i.e., the power spectra of the individual bands
// sum to the original power spectrum (to within some negligible tolerance).
//
// The filter-banks below are implemented as Butterworth or Elliptic
// spectrum-analyzers followed by delay equalizers that make them 
// allpass-complementary.
//
// INCREASING CHANNEL ISOLATION
//   Go to higher filter orders - see Regalia et al. or Vaidyanathan (cited 
//   below) regarding the construction of more aggressive recursive 
//   filter-banks using elliptic or Chebyshev prototype filters.
//   
// REFERENCES
// - "Tree-structured complementary filter banks using all-pass sections",
//   Regalia et al., IEEE Trans. Circuits & Systems, CAS-34:1470-1484, Dec. 1987
// - "Multirate Systems and Filter Banks", P. Vaidyanathan, Prentice-Hall, 1993
// - Elementary filter theory: https://ccrma.stanford.edu/~jos/filters/
//
//------------------------- mth_octave_analyzer ----------------------------
//
// USAGE
//  _ : mth_octave_analyzer(O,M,ftop,N) : par(i,N,_); // Oth-order Butterworth
//  _ : mth_octave_analyzer6e(M,ftop,N) : par(i,N,_); // 6th-order elliptic
//
// where 
//   O = order of filter used to split each frequency band into two
//   M = number of band-slices per octave
//   ftop = highest band-split crossover frequency (e.g., 20 kHz)
//   N = total number of bands (including dc and Nyquist)
//
// ACKNOWLEDGMENT
//  Recursive band-splitting formulation improved by Yann Orlarey.

mth_octave_analyzer6e(M,ftop,N) = _ <: bsplit(N-1) with {
  fc(n) = ftop * 2^(float(n-N+1)/float(M)); // -3dB crossover frequencies
  lp(n) = lowpass6e(fc(n));  // 6th-order elliptic - see other choices above
  hp(n) = highpass6e(fc(n)); //   (search for lowpass* and highpass*)
  bsplit(0)  = _; 
  bsplit(i) = hp(i), (lp(i) <: bsplit(i-1));
};

// Butterworth analyzers may be cascaded with allpass
// delay-equalizers to make (allpass-complementary) filter banks:

mth_octave_analyzer(O,M,ftop,N) = _ <: bsplit(N-1) with {
  fc(n) = ftop * 2^(float(n-N+1)/float(M));
  lp(n) = lowpass(O,fc(n)); // Order O Butterworth
  hp(n) = highpass(O,fc(n));
  bsplit(0)  = _; 
  bsplit(i) = hp(i), (lp(i) <: bsplit(i-1));
};

mth_octave_analyzer3(M,ftop,N) = mth_octave_analyzer(3,M,ftop,N);
mth_octave_analyzer5(M,ftop,N) = mth_octave_analyzer(5,M,ftop,N);
mth_octave_analyzer_default = mth_octave_analyzer6e; // default analyzer

//------------------------ mth_octave_filterbank -------------------------
// Allpass-complementary filter banks based on Butterworth band-splitting.
// For Butterworth band-splits, the needed delay equalizer is easily found.

mth_octave_filterbank(O,M,ftop,N) = 
    mth_octave_analyzer(O,M,ftop,N) : 
    delayeq(N) with {
  fc(n) = ftop * 2^(float(n-N+1)/float(M)); // -3dB crossover frequencies
  ap(n) = highpass_plus_lowpass(O,fc(n));   // delay-equalizing allpass
  delayeq(N) = par(i,N-2,apchain(i+1)), _, _;
  apchain(i) = seq(j,N-1-i,ap(j+1));
};

// dc-inverted version.  This reduces the delay-equalizer order for odd O.
// Negating the input signal makes the dc band noninverting
//   and all higher bands sign-inverted (if preferred).
mth_octave_filterbank_alt(O,M,ftop,N) = 
    mth_octave_analyzer(O,M,ftop,N) : delayeqi(O,N) with {
  fc(n) = ftop * 2^(float(n-N+1)/float(M)); // -3dB crossover frequencies
  ap(n) = highpass_minus_lowpass(O,fc(n)); // half the order of 'plus' case
  delayeqi(N) = par(i,N-2,apchain(i+1)), _, *(-1.0);
  apchain(i) = seq(j,N-1-i,ap(j+1));
};

// Note that even-order cases require complex coefficients.
// See Vaidyanathan 1993 and papers cited there for more info.

mth_octave_filterbank3(M,ftop,N) = mth_octave_filterbank_alt(3,M,ftop,N);
mth_octave_filterbank5(M,ftop,N) = mth_octave_filterbank(5,M,ftop,N);

mth_octave_filterbank_default = mth_octave_filterbank5;

//======================= Mth-Octave Spectral Level =========================
// Spectral Level: Display (in bar graphs) the average signal level in each 
//                 spectral band.
//
//------------------------ mth_octave_spectral_level -------------------------
// USAGE: _ : mth_octave_spectral_level(M,ftop,NBands,tau,dB_offset);
// where 
//    M = bands per octave
//    ftop = lower edge frequency of top band
//    NBands = number of passbands (including highpass and dc bands),
//    tau = spectral display averaging-time (time constant) in seconds,
//    dB_offset = constant dB offset in all band level meters.
//
mth_octave_spectral_level6e(M,ftop,N,tau,dB_offset) = _<:
    _,mth_octave_analyzer6e(M,ftop,N) : 
    _,(display:>_):attach with {
  display = par(i,N,dbmeter(i));
  dbmeter(i) = abs : smooth(tau2pole(tau)) : linear2db : +(dB_offset) : 
     meter(N-i-1);
    meter(i) = speclevel_group(vbargraph("[%2i] [unit:dB] 
     [tooltip: Spectral Band Level in dB]", -50, 10));
  O = int(((N-2)/M)+0.4999);
  speclevel_group(x)  = hgroup("[0] CONSTANT-Q SPECTRUM ANALYZER (6E), %N bands spanning LP, %O octaves below %ftop Hz, HP
     [tooltip: See Faust's filter.lib for documentation and references]", x);
};

mth_octave_spectral_level_default = mth_octave_spectral_level6e;
spectral_level = mth_octave_spectral_level(2,10000,20);  // simple default

//---------------------- mth_octave_spectral_level_demo ----------------------
// Demonstrate mth_octave_spectral_level in a standalone GUI.
//
// USAGE:  _ : mth_octave_spectral_level_demo(BandsPerOctave);

mth_octave_spectral_level_demo(M) = 
  mth_octave_spectral_level_default(M,ftop,N,tau,dB_offset) 
with {
  ftop = 16000;
  Noct = 10; // number of octaves down from ftop
  // Lowest band-edge is at ftop*2^(-Noct+2) = 62.5 Hz when ftop=16 kHz:
  N = int(Noct*M); // without 'int()', segmentation fault observed for M=1.67
  ctl_group(x)  = hgroup("[1] SPECTRUM ANALYZER CONTROLS", x);
  tau = ctl_group(hslider("[0] Level Averaging Time [unit:ms] [scale:log]
        [tooltip: band-level averaging time in milliseconds]",
        100,1,10000,1)) * 0.001; 
  dB_offset = ctl_group(hslider("[1] Level dB Offset [unit:dB]
        [tooltip: Level offset in decibels]",
        50,0,100,1)); 
};

spectral_level_demo = mth_octave_spectral_level_demo(1.5); // 2/3 octave

//---------------- (third|half)_octave_(analyzer|filterbank) -----------------

// Named special cases of mth_octave_* with defaults filled in:

third_octave_analyzer(N) = mth_octave_analyzer_default(3,10000,N);
third_octave_filterbank(N) = mth_octave_filterbank_default(3,10000,N);
// Third-Octave Filter-Banks have been used in audio for over a century.
// See, e.g.,
//   Acoustics [the book], by L. L. Beranek
//   Amer. Inst. Physics for the Acoustical Soc. America,
//   http://asa.aip.org/publications.html, 1986 (1st ed.1954)

// Third-octave bands across the audio spectrum are too wide for current
// typical computer screens, so half-octave bands are the default:
half_octave_analyzer(N) = mth_octave_analyzer_default(2,10000,N);
half_octave_filterbank(N) = mth_octave_filterbank_default(2,10000,N);

octave_filterbank(N) = mth_octave_filterbank_default(1,10000,N);
octave_analyzer(N) = mth_octave_analyzer_default(1,10000,N);

//=========================== Filter-Bank Demos ==============================
// Graphic Equalizer: Each filter-bank output signal routes through a fader.
//
// USAGE: _ : mth_octave_filterbank_demo(M) : _
// where 
//   M = number of bands per octave

mth_octave_filterbank_demo(M) = bp1(bp,mthoctavefilterbankdemo) with {
   bp1 = component("effect.lib").bypass1;
   mofb_group(x)  = vgroup("CONSTANT-Q FILTER BANK (Butterworth dyadic tree)
     [tooltip: See Faust's filter.lib for documentation and references]", x);
   bypass_group(x) = mofb_group(hgroup("[0]", x));
   slider_group(x)  = mofb_group(hgroup("[1]", x));
   N = 10*M; // total number of bands (highpass band, octave-bands, dc band)
   ftop = 10000;
   mthoctavefilterbankdemo = chan;
   chan = mth_octave_filterbank_default(M,ftop,N) : 
          sum(i,N,(*(db2linear(fader(N-i)))));
   fader(i) = slider_group(vslider("[%2i] [unit:dB]
              [tooltip: Bandpass filter gain in dB]", -10, -70, 10, 0.1)) : 
              smooth(0.999);
   bp = bypass_group(checkbox("[0] Bypass  
              [tooltip: When this is checked, the filter-bank has no effect]"));
};

filterbank_demo = mth_octave_filterbank_demo(1); // octave-bands = default

//=========== Arbritary-Crossover Filter-Banks and Spectrum Analyzers ========
// These are similar to the Mth-octave filter-banks above, except that the
// band-split frequencies are passed explicitly as arguments. 
//
// USAGE:
//    _ : filterbank (O,freqs) : par(i,N,_); // Butterworth band-splits
//    _ : filterbanki(O,freqs) : par(i,N,_); // Inverted-dc version 
//    _ : analyzer   (O,freqs) : par(i,N,_); // No delay equalizer
//
// where 
//   O     = band-split filter order (ODD integer required for filterbank[i])
//   freqs = (fc1,fc2,...,fcNs) [in numerically ascending order], where
//           Ns=N-1 is the number of octave band-splits 
//           (total number of bands N=Ns+1). 
// 
// If frequencies are listed explicitly as arguments, enclose them in parens:
//
//    _ : filterbank(3,(fc1,fc2)) : _,_,_
//
// ACKNOWLEDGMENT
//    Technique for processing a variable number of signal arguments due
//    to Yann Orlarey (as is the entire Faust framework!)
//
//------------------------------ analyzer --------------------------------------
analyzer(O,lfreqs) = _ <: bsplit(nb) with
{
   nb = count(lfreqs);
   fc(n) = take(n, lfreqs);
   lp(n) = lowpass(O,fc(n));
   hp(n) = highpass(O,fc(n));
   bsplit(0) = _;
   bsplit(i) = hp(i), (lp(i) <: bsplit(i-1));
};

//----------------------------- filterbank -------------------------------------
filterbank(O,lfreqs) = analyzer(O,lfreqs) : delayeq(nb) with
{
   nb = count(lfreqs);
   fc(n) = take(n, lfreqs);
   ap(n) = highpass_plus_lowpass(O,fc(n));
   delayeq(1) = _,_; // par(i,0,...) does not fly
   delayeq(nb) = par(i,nb-1,apchain(nb-1-i)),_,_;
   apchain(0) = _;
   apchain(i) =  ap(i) : apchain(i-1);
};

//----------------------------- filterbanki ------------------------------------
filterbanki(O,lfreqs) = _ <: bsplit(nb) with
{
   fc(n) = take(n, lfreqs);
   lp(n) = lowpass(O,fc(n));
   hp(n) = highpass(O,fc(n));
   ap(n) = highpass_minus_lowpass(O,fc(n));
   bsplit(0) = *(-1.0);
   bsplit(i) = (hp(i) : delayeq(i-1)), (lp(i) <: bsplit(i-1));
   delayeq(0) = _; // moving the *(-1) here inverts all outputs BUT dc
   delayeq(i) =  ap(i) : delayeq(i-1);
};

//#################################### delays.lib #########################################
// This library contains a collection of delay functions. Its official prefix is `de`.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/delays.lib>
//########################################################################################

/************************************************************************
************************************************************************
FAUST library file
Copyright (C) 2003-2016 GRAME, Centre National de Creation Musicale
----------------------------------------------------------------------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

ma = library("maths.lib");
ba = library("basics.lib");
si = library("signals.lib");
fi = library("filters.lib");

declare name "Faust Delay Library";
declare version "0.1";

//==================================Basic Delay Functions=================================
//========================================================================================

//-------`(de.)delay`----------
// Simple `d` samples delay where `n` is the maximum delay length as a number of
// samples. Unlike the `@` delay operator, here the delay signal `d` is explicitly
// bounded to the interval [0..n]. The consequence is that delay will compile even
// if the interval of d can't be computed by the compiler.
// `delay` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : delay(n,d) : _
// ```
//
// Where:
//
// * `n`: the max delay length in samples
// * `d`: the delay length as a number of samples (integer)
//-----------------------------
// TODO: add MBH np2
delay(n,d,x) = x @ min(n, max(0,d));


//-------`(de.)fdelay`----------
// Simple `d` samples fractional delay based on 2 interpolated delay lines where `n` is
// the maximum delay length as a number of samples.

// `fdelay` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : fdelay(n,d) : _
// ```
//
// Where:
//
// * `n`: the max delay length in samples
// * `d`: the delay length as a number of samples (float)
//-----------------------------
fdelay(n,d,x) = delay(n+1,int(d),x)*(1 - ma.frac(d)) + delay(n+1,int(d)+1,x)*ma.frac(d);


//--------------------------`(de.)sdelay`----------------------------
// s(mooth)delay: a mono delay that doesn't click and doesn't
// transpose when the delay time is changed.
//
// #### Usage
//
// ```
// _ : sdelay(n,it,dt) : _
// ```
//
// Where :
//
// * `n`: the max delay length in samples
// * `it`: interpolation time (in samples) for example 1024
// * `dt`: delay time (in samples)
//--------------------------------------------------------------------------
sdelay(n, it, dt) = ctrl(it,dt),_ : ddi(n)
with {
	// ddi(n,i,d0,d1)
	// DDI (Double Delay with Interpolation) : the input signal is sent to two
	// delay lines. The outputs of these delay lines are crossfaded with
	// an interpolation stage. By acting on this interpolation value one
	// can move smoothly from one delay to another. When <i> is 0 we can
	// freely change the delay time <d1> of line 1, when it is 1 we can freely change
	// the delay time <d0> of line 0.
	//
	// <n>  = maximal delay in samples
	// <i>  = interpolation value between 0 and 1 used to crossfade the outputs of the
	// 		two delay lines (0.0: first delay line, 1.0: second delay line)
	// <d0> = delay time of delay line 0 in samples between 0 and <N>-1
	// <d1> = delay time of delay line 1 in samples between 0 and <N>-1
	// <  > = the input signal we want to delay
	ddi(n, i, d0, d1) = _ <: delay(n,d0), delay(n,d1) : si.interpolate(i);

	// ctrl(it,dt)
	// Control logic for a Double Delay with Interpolation according to two
	//
	// USAGE : ctrl(it,dt)
	// where :
	// <it> an interpolation time (in samples, for example 256)
	// <dt> a delay time (in samples)
	//
	// ctrl produces 3 outputs : an interpolation value <i> and two delay
	// times <d0> and <d1>. These signals are used to control a ddi (Double Delay with Interpolation).
	// The principle is to detect changes in the input delay time dt, then to
	// change the delay time of the delay line currently unused and then by a
	// smooth crossfade to remove the first delay line and activate the second one.
	//
	// The control logic has an internal state controlled by 4 elements
	// <v> : the interpolation variation (0, 1/it, -1/it)
	// <i> : the interpolation value (between 0 and 1)
	// <d0>: the delay time of line 0
	// <d1>: the delay time of line 1
	//
	// Please note that the last stage (!,_,_,_) cut <v> because it is only
	// used internally.
	ctrl(it, dt) = \(v,ip,d0,d1).((nv, nip, nd0, nd1)
	with {
		// interpolation variation
		nv = ba.if (v!=0.0,                         // if variation we are interpolating
			ba.if ((ip>0.0) & (ip<1.0), v, 0),      // should we continue or not ?
			ba.if ((ip==0.0) & (dt!=d0), 1.0/it,    // if true xfade from dl0 to dl1
			ba.if ((ip==1.0) & (dt!=d1), -1.0/it,   // if true xfade from dl1 to dl0
					 0)));                  		// nothing to change
		// interpolation value
		nip = ip+nv : min(1.0) : max(0.0);

		// update delay time of line 0 if needed
		nd0 = ba.if ((ip >= 1.0) & (d1!=dt), dt, d0);

		// update delay time of line 0 if needed
		nd1 = ba.if ((ip <= 0.0) & (d0!=dt), dt, d1);
	}) ~ (_,_,_,_) : (!,_,_,_);
};


// ----------`(de.)prime_power_delays`-----------
// Prime Power Delay Line Lengths.
//
// #### Usage
//
// ```
// si.bus(N) : prime_power_delays(N,pathmin,pathmax) : si.bus(N);
// ```
//
// Where:
//
// * `N`: positive integer up to 16 (for higher powers of 2, extend 'primes' array below)
// * `pathmin`: minimum acoustic ray length in the reverberator (in meters)
// * `pathmax`: maximum acoustic ray length (meters) - think "room size"
//
// #### Reference
//
// <https://ccrma.stanford.edu/~jos/pasp/Prime_Power_Delay_Line.html>
//------------------------------------------------------------
// TODO: author JOS, revised by RM
prime_power_delays(N,pathmin,pathmax) = par(i,N,delayvals(i)) with {
  Np = 16;
  primes = 2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53;
  prime(n) = primes : ba.selector(n,Np); // math.lib

  // Prime Power Bounds [matlab: floor(log(maxdel)./log(primes(53)))]
  maxdel = 8192; // more than 63 meters at 44100 samples/sec & 343 m/s
  ppbs = 13,8,5,4, 3,3,3,3, 2,2,2,2, 2,2,2,2; // 8192 is enough for all
  ppb(i) = ba.take(i+1,ppbs);

  // Approximate desired delay-line lengths using powers of distinct primes:
  c = 343; // soundspeed in m/s at 20 degrees C for dry air
  dmin = ma.SR*pathmin/c;
  dmax = ma.SR*pathmax/c;
  dl(i) = dmin * (dmax/dmin)^(i/float(N-1)); // desired delay in samples
  ppwr(i) = floor(0.5+log(dl(i))/log(prime(i))); // best prime power
  delayvals(i) = prime(i)^ppwr(i); // each delay a power of a distinct prime
};


//===============================Lagrange Interpolation===================================
//========================================================================================

//----------------------`(de.)fdelaylti` and `(de.)fdelayltv`-------------------------
// Fractional delay line using Lagrange interpolation.
//
// #### Usage
//
// ```
// _ : fdelaylt[i|v](order, maxdelay, delay, inputsignal) : _
// ```
//
// Where `order=1,2,3,...` is the order of the Lagrange interpolation polynomial.
//
// `fdelaylti` is most efficient, but designed for constant/slowly-varying delay.
// `fdelayltv` is more expensive and more robust when the delay varies rapidly.
//
// NOTE: The requested delay should not be less than `(order-1)/2`.
//
// #### References
//
// * <https://ccrma.stanford.edu/~jos/pasp/Lagrange_Interpolation.html>
//   - [fixed-delay case](https://ccrma.stanford.edu/~jos/Interpolation/Efficient_Time_Invariant_Lagrange_Interpolation.html)
//   - [variable-delay case](https://ccrma.stanford.edu/~jos/Interpolation/Time_Varying_Lagrange_Interpolation.html)
// * Timo I. Laakso et al., "Splitting the Unit Delay - Tools for Fractional
//         Delay Filter Design", IEEE Signal Processing Magazine,
//         vol. 13, no. 1, pp. 30-60, Jan 1996.
// * Philippe Depalle and Stephan Tassart, "Fractional Delay Lines using
//         Lagrange Interpolators", ICMC Proceedings, pp. 341-343, 1996.
//------------------------------------------------------------
// TODO: author JOS, revised by RM
fdelaylti(N,n,d,x)  = delay(n,id,x) <: seq(i,N,section(i)) : !,_
with {
  o = (N-1.00001)/2; // offset to ~center FIR interpolator
  dmo = d - o; // assumed nonnegative [d > (N-1)/2]
  id = int(dmo);
  fd = o + ma.frac(dmo);
  section(i,x,y) = (x-x') * c(i) <: _,+(y);
  c(i) = (i - fd)/(i+1);
};

fdelayltv(N,n,d,x) = sum(i, N+1, delay(n,id+i,x) * h(N,fd,i))
with {
  o = (N-1.00001)/2;  // ~center FIR interpolator
  dmo = d - o; // assumed nonnegative [d > (N-1)/2]
  id = int(dmo);
  fd = o + ma.frac(dmo);
  h(N,d,n) = facs1(N,d,n) * facs2(N,d,n);
  facs1(N,d,n) = select2(n,1,prod(k,max(1,n),select2(k<n,1,fac(d,n,k))));
  facs2(N,d,n) = select2(n<N,1,prod(l,max(1,N-n),fac(d,n,l+n+1)));
  fac(d,n,k) = (d-k)/((n-k)+(n==k));
  // Explicit formula for Lagrange interpolation coefficients:
  // h_d(n) = \prod_{\stackrel{k=0}{k\neq n}}^N \frac{d-k}{n-k}, n=0:N
};

//------------------`(de.)fdelay[n]`----------------------------
// For convenience, `fdelay1`, `fdelay2`, `fdelay3`, `fdelay4`, `fdelay5`
// are also available where n is the order of the interpolation.
//------------------------------------------------------------
// TODO: author JOS, revised by RM
fdelay1 = fdelayltv(1);
fdelay2 = fdelayltv(2);
fdelay3 = fdelayltv(3);
fdelay4 = fdelayltv(4);
fdelay5 = fdelayltv(5);

//==============================Thiran Allpass Interpolation==============================
// Thiran Allpass Interpolation
//
// #### Reference
//
// <https://ccrma.stanford.edu/~jos/pasp/Thiran_Allpass_Interpolators.html>
//========================================================================================

//----------------`(de.)fdelay[n]a`-------------
// Delay lines interpolated using Thiran allpass interpolation.
//
// #### Usage
//
// ```
// _ : fdelay[N]a(maxdelay, delay, inputsignal) : _
// ```
//
// (exactly like `fdelay`)
//
// Where:
//
// * `N`=1,2,3, or 4 is the order of the Thiran interpolation filter,
// and the delay argument is at least N - 1/2.
//
// #### Note
//
// The interpolated delay should not be less than `N - 1/2`.
// (The allpass delay ranges from `N - 1/2` to `N + 1/2`.)
// This constraint can be alleviated by altering the code,
// but be aware that allpass filters approach zero delay
// by means of pole-zero cancellations.
// The delay range `[N-1/2`,`N+1/2]` is not optimal. What is?
//
// Delay arguments too small will produce an UNSTABLE allpass!
//
// Because allpass interpolation is recursive, it is not as robust
// as Lagrange interpolation under time-varying conditions
// (You may hear clicks when changing the delay rapidly.)
//
// First-order allpass interpolation, delay d in [0.5,1.5]
//------------------------------------------------------------
// TODO: author JOS, revised by RM
fdelay1a(n,d,x)  = delay(n,id,x) : fi.tf1(eta,1,eta)
with {
  o = 0.49999; // offset to make life easy for allpass
  dmo = d - o; // assumed nonnegative
  id = int(dmo);
  fd = o + ma.frac(dmo);
  eta = (1-fd)/(1+fd); // allpass coefficient
};

// second-order allpass delay in [1.5,2.5]
fdelay2a(n,d,x) = delay(n,id,x) : fi.tf2(a2,a1,1,a1,a2)
with {
  o = 1.49999;
  dmo = d - o; // delay range is [order-1/2, order+1/2]
  id = int(dmo);
  fd = o + ma.frac(dmo);
  a1o2 = (2-fd)/(1+fd); // share some terms (the compiler does this anyway)
  a1 = 2*a1o2;
  a2 = a1o2*(1-fd)/(2+fd);
};

// third-order allpass delay in [2.5,3.5]
// delay d should be at least 2.5
fdelay3a(n,d,x) = delay(n,id,x) : fi.iir((a3,a2,a1,1),(a1,a2,a3))
with {
  o = 2.49999;
  dmo = d - o;
  id = int(dmo);
  fd = o + ma.frac(dmo);
  a1o3 = (3-fd)/(1+fd);
  a2o3 = a1o3*(2-fd)/(2+fd);
  a1 = 3*a1o3;
  a2 = 3*a2o3;
  a3 = a2o3*(1-fd)/(3+fd);
};

// fourth-order allpass delay in [3.5,4.5]
// delay d should be at least 3.5
fdelay4a(n,d,x) = delay(n,id,x) : fi.iir((a4,a3,a2,a1,1),(a1,a2,a3,a4))
with {
  o = 3.49999;
  dmo = d - o;
  id = int(dmo);
  fd = o + ma.frac(dmo);
  a1o4 = (4-fd)/(1+fd);
  a2o6 = a1o4*(3-fd)/(2+fd);
  a3o4 = a2o6*(2-fd)/(3+fd);
  a1 = 4*a1o4;
  a2 = 6*a2o6;
  a3 = 4*a3o4;
  a4 = a3o4*(1-fd)/(4+fd);
};

//////////////////////////////////Deprecated Functions////////////////////////////////////
// This section implements functions that used to be in music.lib but that are now
// considered as "deprecated".
//////////////////////////////////////////////////////////////////////////////////////////

delay1s(d) = delay(65536,d);
delay2s(d) = delay(131072,d);
delay5s(d) = delay(262144,d);
delay10s(d) = delay(524288,d);
delay21s(d) = delay(1048576,d);
delay43s(d) = delay(2097152,d);

fdelay1s(d) = fdelay(65536,d);
fdelay2s(d) = fdelay(131072,d);
fdelay5s(d) = fdelay(262144,d);
fdelay10s(d) = fdelay(524288,d);
fdelay21s(d) = fdelay(1048576,d);
fdelay43s(d) = fdelay(2097152,d);
//#################################### routes.lib ########################################
// A library to handle signal routing in Faust. Its official prefix is `ro`.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/routes.lib>
//########################################################################################

/************************************************************************
************************************************************************
FAUST library file
Copyright (C) 2003-2019 GRAME, Centre National de Creation Musicale
----------------------------------------------------------------------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

ba = library("basics.lib");
si = library("signals.lib");
sp = library("spats.lib");

declare name "Faust Signal Routing Library";
declare version "0.2";

//=============================Functions Reference========================================
//========================================================================================

//--------------------------------`(ro.)cross`-----------------------------------
// Cross n signals: `(x1,x2,..,xn) -> (xn,..,x2,x1)`.
// `cross` is a standard Faust function.
//
// #### Usage
//
// ```
// cross(n)
// _,_,_ : cross(3) : _,_,_
// ```
//
// Where:
//
// * `n`: number of signals (int, must be known at compile time)
//
// #### Note
//
// Special case: `cross2`:
//
// ```
// cross2 = _,cross(2),_;
// ```
//-----------------------------------------------------------------------------
// cross n cables : (x1,x2,..,xn) -> (xn,..,x2,x1)
cross(n) = route(n, n, par(i, n, (i+1, n-i)));
cross2 = _,cross(2),_; // for compatibility with some old misceffects.lib functions


//--------------`(ro.)crossnn`--------------
// Cross two `bus(n)`s.
//
// #### Usage
//
// ```
// (si.bus(2*n)) : crossnn(n) : (si.bus(2*n))
// ```
//
// Where:
//
// * `n`: the number of signals in the `bus`
//--------------------------------------
crossnn(n) = crossNM(n,n);


//--------------`(ro.)crossn1`--------------
// Cross bus(n) and bus(1).
//
// #### Usage
//
// ```
// (si.bus(n),_) : crossn1(n) : (_,si.bus(n))
// ```
//
// Where:
//
// * `n`: the number of signals in the first `bus`
//--------------------------------------
crossn1(n) = crossNM(n,1);


//--------------`(ro.)cross1n`--------------
// Cross bus(1) and bus(n).
//
// #### Usage
//
// ```
// (_,si.bus(n)) : crossn1(n) : (si.bus(n),_)
// ```
//
// Where:
//
// * `n`: the number of signals in the second `bus`
//--------------------------------------
cross1n(n) = crossNM(1,n);


//--------------`(ro.)crossNM`--------------
// Cross bus(n) and bus(m).
//
// #### Usage
//
// ```
// (si.bus(n),si.bus(m)) : crossNM(n,m) : (si.bus(m),si.bus(n))
// ```
//
// Where:
//
// * `n`: the number of signals in the first `bus`
// * `m`: the number of signals in the second `bus`
//--------------------------------------
crossNM(n,m) = route(n+m, n+m, par(i, n+m, i+1, ((i+m)%(n+m))+1));


//--------------------------`(ro.)interleave`------------------------------
// Interleave row*col cables from column order to row order.
// input : x(0), x(1), x(2) ..., x(row*col-1)
// output: x(0+0*row), x(0+1*row), x(0+2*row), ..., x(1+0*row), x(1+1*row), x(1+2*row), ...
//
// #### Usage
//
// ```
// _,_,_,_,_,_ : interleave(row,column) : _,_,_,_,_,_
// ```
//
// Where:
//
// * `row`: the number of row (int, known at compile time)
// * `column`: the number of column (int, known at compile time)
//-----------------------------------------------------------------------------
interleave(1,2) = _,_;
interleave(row,col) = route(row*col, row*col, par(i, row*col, (i+1, (i%row)*col + int(i/row) + 1)));

//-------------------------------`(ro.)butterfly`--------------------------------
// Addition (first half) then substraction (second half) of interleaved signals.
//
// #### Usage
//
// ```
// _,_,_,_ : butterfly(n) : _,_,_,_
// ```
//
// Where:
//
// * `n`: size of the butterfly (n is int, even and known at compile time)
//-----------------------------------------------------------------------------
butterfly(2) = si.bus(2) <: +,-;
butterfly(n) = si.bus(n) <: interleave(n/2,2), interleave(n/2,2) : par(i, n/2, +), par(i, n/2, -);


//------------------------------`(ro.)hadamard`----------------------------------
// Hadamard matrix function of size `n = 2^k`.
//
// #### Usage
//
// ```
// _,_,_,_ : hadamard(n) : _,_,_,_
// ```
//
// Where:
//
// * `n`: `2^k`, size of the matrix (int, must be known at compile time)
//
// #### Note:
//
// Implementation contributed by Remy Muller.
//-----------------------------------------------------------------------------
// TODO: author: Remy Muller, revised by RM
hadamard(2) = butterfly(2);
hadamard(n) = butterfly(n) : (hadamard(n/2) , hadamard(n/2));


//---------------`(ro.)recursivize`-------------
// Create a recursion from two arbitrary processors p and q.
//
// #### Usage
//
// ```
// _,_ : recursivize(p,q) : _,_
//
// ```
//
// Where:
//
// * `p`: the forward arbitrary processor
// * `q`: the feedback arbitrary processor
//----------------------------------------
recursivize(p,q) = (_,_,_,_ :> sp.stereoize(p)) ~ sp.stereoize(q);
//#################################### soundfiles.lib ########################################
// A library to handle soundfiles in Faust. Its official prefix is `so`.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/soundfiles.lib>
//########################################################################################

/************************************************************************
************************************************************************
FAUST library file
Copyright (C) 2018-2020 GRAME, Centre National de Creation Musicale
----------------------------------------------------------------------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

ba = library("basics.lib");
ma = library("maths.lib");
si = library("signals.lib");
ro = library("routes.lib");
it = library("interpolators.lib");

declare name "Faust Soundfile Library";
declare version "0.7";

//=======================================================================
// Utility functions added in a 'super' environment (to test the idea...)
//=======================================================================

super = environment {

    length(sf, part) = (part, 0) : sf : (_,si.block(outputs(sf)-1));  
    srate(sf, part) = (part, 0) : sf : (!,_,si.block(outputs(sf)-2)) : float;
    outs(sf, level) = sf : si.block(2), bus(outputs(sf)-2) with { bus(n) = par(i,n,*(level)); };

    // Plays a soundfile
    // 'reader' in a function of type \(sf,part).(body) whih produces the (possibly fractional) read index
    player(sf, part, reader, level) = (part, it.int_part(reader(sf, part))) : outs(sf, level);

    // Plays a soundfile with configurable interpolation
    player_interp(sf, part, reader, level, selector) = it.interpolator_select(gen, idv, selector)
    with {
        // Adapts the (sf, part, reader) parameters as 'idv' and 'gen' types for the generic interpolator
        idv = reader(sf, part);
        gen(idx) = (part, idx) : outs(sf, level);
    };

     // Plays a soundfile with configurable interpolation and a reference frequence 'ref'
    play_interp(sf, part, ref, freq, level, gate, selector) = player_interp(sf, part, reader, level, selector)
    with {
        reader(sf, part) = it.raise(gate, step, length(sf, part)) with { step = freq/ref*srate(sf, part)/ma.SR; };
    };

    // Generic version
    loop_speed_level(sf, part, speed, level) = player(sf, part, reader, level)
    with {
        // A 'reader' which loops the sound with 'speed' and 'level' control
        reader(sf, part) = it.raise_modulo(1, step, length(sf, part)) with { step = speed*srate(sf, part)/ma.SR; };
    };

    // Defines 'loop_speed' as a specialized version of loop_speed_level with level = 1
    loop_speed(sf, part, speed) = loop_speed_level(sf, part, speed, 1);

    // Defines 'loop_speed' as a specialized version of loop_speed_level with speed = 1 and level = 1
    loop(sf, part) = loop_speed_level(sf, part, 1, 1);


}; // End of environment

//=============================Functions Reference========================================
//========================================================================================

//--------------------------------`(so.)loop`-----------------------------------
// Play a soundfile in a loop taking into account its sampling rate.
// `loop` is a standard Faust function.
//
// #### Usage
//
// ```
// loop(sf, part) : si.bus(outputs(sf))
// ```
//
// Where:
//
// * `sf`: the soundfile
// * `part`: the part in the soundfile list of sounds
//
//-----------------------------------------------------------------------------

loop(sf, part) = super.loop(sf, part);

//--------------------------------`(so.)loop_speed`-----------------------------------
// Play a soundfile in a loop taking into account its sampling rate, with speed control.
// `loop_speed` is a standard Faust function.
//
// #### Usage
//
// ```
// loop_speed(sf, part, speed) : si.bus(outputs(sf))
// ```
//
// Where:
//
// * `sf`: the soundfile
// * `part`: the part in the soundfile list of sounds
// * `speed`: the speed between 0 and n
//
//-----------------------------------------------------------------------------

loop_speed(sf, part, speed) = super.loop_speed(sf, part, speed);

//--------------------------------`(so.)loop_speed_level`-----------------------------------
// Play a soundfile in a loop taking into account its sampling rate, with speed and level controls.
// `loop_speed_level` is a standard Faust function.
//
// #### Usage
//
// ```
// loop_speed_level(sf, part, speed, level) : si.bus(outputs(sf))
// ```
//
// Where:
//
// * `sf`: the soundfile
// * `part`: the part in the soundfile list of sounds
// * `speed`: the speed between 0 and n
// * `level`: the volume between 0 and n
//
//-----------------------------------------------------------------------------

loop_speed_level(sf, part, speed, level) = super.loop_speed_level(sf, part, speed, level);

//====================================================
// Environment to handle a given sound in a soundfile
//====================================================

sound(sf, part) = environment {

    // Looping the sound
    loop = super.loop(sf, part);
    loop_speed(speed) = super.loop_speed(sf, part, speed);
    loop_speed_level(speed, level) = super.loop_speed_level(sf, part, speed, level);

    // Play once
    play(level, gate) = super.player(sf, part, reader, level)
    with {
        reader(sf, part) = it.raise(gate, super.srate(sf, part)/ma.SR, super.length(sf, part));
    };

    // Play once in reverse
    play_rev(level, gate) = super.player(sf, part, reader, level)
    with {
        reader(sf, part) = it.decrease(gate, super.srate(sf, part)/ma.SR, super.length(sf, part));
    };

    // Play sound once with configurable interpolation and freq control (using a 'ref' value)
    play_interp(ref, freq, level, gate, selector) = super.play_interp(sf, part, ref, freq, level, gate, selector);

    // Play sound once and alternate between normal play and reverse play
    //play_alt(level, gate, ctrl) = super.player(sf, part, alt2(ramp1, ramp2, ctrl), level)
    play_alt(level, gate, ctrl) = super.player(sf, part, altN(lramp, ctrl), level)
    with {
        // High-order function which alternate between 2 'readers' depending of the 'ctrl' signal
       	alt2(r1, r2, ctrl) = \(sf, part).(ba.selectmulti(ma.SR/100, lr, ctrl) with { lr = r1(sf, part), r2(sf, part); });
        
        altN(lrs, ctrl) = \(sf, part).(ba.selectmulti(ma.SR/100, mapper(lrs), ctrl) 
        with { 
        	mapper((xs, xxs)) = xs(sf, part), mapper(xxs); 
        	mapper(xs) = xs(sf, part); 
        });
        
        step = super.srate(sf, part)/ma.SR;
        
        ramp1(sf, part) = it.raise(gate, step, super.length(sf, part));
        ramp2(sf, part) = it.decrease(gate, step, super.length(sf, part));
        
        lramp = (ramp1, ramp2, ramp2, ramp2, ramp1);
    };

}; // End of environment
							  
/*
// Using the `sound` environment allocated with a given `sf` and `part`

import("soundfiles.lib");

s1 = soundfile("[url:{'piano-C5.ogg';'piano-G5.ogg';'piano-C6.ogg';'piano-G6.ogg'}]",2);
sample1 = so.sound(s1, 0);
sample2 = so.sound(s1, 1);
sample3 = so.sound(s1, 2);

// Plays the sound in various ways
sample1.loop;
sample1.loop_speed(0.5);
sample1.loop_speed_level(0.5, 0.5);

sample2.play(0.5, button("gate"));
sample2.play_rev(0.5, button("gate"));
sample2.play_alt(0.5, button("gate"), checkbox("alt"));

sample3.play_interp(440.0, 600.0, 0.5, button("gate"), it.linear);
sample3.play_interp(440.0, 800.0, en.ar(0.1, 0.8, button("gate")), button("gate"), it.cubic);

play = button("gate");
sample3.play_interp(440.0,
                    hslider("freq", 200, 200, 880, 0.01), 
                    hslider("gain", 0.5, 0, 1, 0.01)*en.ar(0.1, 0.8, play), 
                    play,
                    nentry("interp", 0, 0, 3, 1));

*/
/**
 **  Guitar tone stacks (based on the work from D.T. Yeh)
 **  some values are taken from CAPS plugin tonestack 
 ** 
 **  this tonestacks.library provide the following tonestack models:
 **  bassman, mesa, twin, princeton, jcm800, jcm2000, jtm45, mlead,
 **  m2199, ac30, ac15, soldano, sovtek, peavey, ibanez, roland, 
 **  ampeg, ampeg_rev, bogner, groove, crunch, fender_blues,
 **  fender_default, fender_deville, gibsen
 **  
 **  USAGE :
 **        _:component("tonestacks.lib").model(t,m,l):_
 **  WHERE :
 **       model is on of the models above.
 **       t is treble freq control in range of (0.0 - 1.0)
 **       m is middle freq control in range of (0.0 - 1.0)
 **       l is low freq control in range of (0.0 - 1.0)
 ** 
 **  EXAMPLE :
 **       process = component("tonestacks.lib").jcm2000(t,m,l) 
 **       with {
 **         t = vslider("Treble ", 0.5, 0, 1, 0.01);
 **         m = vslider("Middle ", 0.5, 0, 1, 0.01);
 **         l = vslider("Bass ", 0.5, 0, 1, 0.01);
 **       };
 **/

ma = library("maths.lib");
fi = library("filters.lib");

declare name      "Faust Tonestack Emulation Library";
declare author    "Guitarix project (<http://guitarix.sourceforge.net/>)";
declare copyright "Guitarix project";
declare version   "0.28";
declare license   "LGPL";

/****************************************************************
 **           Equalisation 3 bands
 **                    C1
 **       IN >---------||---------
 **            |                 |
 **            |                 |
 **           | | R4            | | R1 Treble
 **           | |               | |<------<  Out
 **           | |               | | 
 **            |       C2        |
 **            |-------||--------|------
 **            |                 |     |
 **            |                | |    |
 **            |                | |<---- R2 Bass
 **            |                | |
 **            |                 |
 **            |       C3       | |
 **            --------||------>| |  R3 Middle
 **                             | |
 **                              |
 **                             _|_
 **                              -
 **
 ****************************************************************/

tonestack(C1,C2,C3,R1,R2,R3,R4,t,m,L) = 
    1/A0*fi.iir((B0,B1,B2,B3),(A1/A0,A2/A0,A3/A0)) 
    with {
    
    l = L : (_-1)*3.4 : exp;
    
    b1 = t*C1*R1 + m*C3*R3 + l*(C1*R2 + C2*R2) + (C1*R3 + C2*R3);

    b2 = t*(C1*C2*R1*R4 + C1*C3*R1*R4) - m*m*(C1*C3*R3*R3 + C2*C3*R3*R3)
         + m*(C1*C3*R1*R3 + C1*C3*R3*R3 + C2*C3*R3*R3)
         + l*(C1*C2*R1*R2 + C1*C2*R2*R4 + C1*C3*R2*R4)
         + l*m*(C1*C3*R2*R3 + C2*C3*R2*R3)
         + (C1*C2*R1*R3 + C1*C2*R3*R4 + C1*C3*R3*R4);

    b3 = l*m*(C1*C2*C3*R1*R2*R3 + C1*C2*C3*R2*R3*R4)
         - m*m*(C1*C2*C3*R1*R3*R3 + C1*C2*C3*R3*R3*R4)
         + m*(C1*C2*C3*R1*R3*R3 + C1*C2*C3*R3*R3*R4)
         + t*C1*C2*C3*R1*R3*R4 - t*m*C1*C2*C3*R1*R3*R4
         + t*l*C1*C2*C3*R1*R2*R4;

    a0 = 1;

    a1 = (C1*R1 + C1*R3 + C2*R3 + C2*R4 + C3*R4)
         + m*C3*R3 + l*(C1*R2 + C2*R2);

    a2 = m*(C1*C3*R1*R3 - C2*C3*R3*R4 + C1*C3*R3*R3 + C2*C3*R3*R3)
         + l*m*(C1*C3*R2*R3 + C2*C3*R2*R3)
         - m*m*(C1*C3*R3*R3 + C2*C3*R3*R3)
         + l*(C1*C2*R2*R4 + C1*C2*R1*R2 + C1*C3*R2*R4 + C2*C3*R2*R4)
         + (C1*C2*R1*R4 + C1*C3*R1*R4 + C1*C2*R3*R4 + C1*C2*R1*R3 + C1*C3*R3*R4 + C2*C3*R3*R4);

    a3 = l*m*(C1*C2*C3*R1*R2*R3 + C1*C2*C3*R2*R3*R4)
         - m*m*(C1*C2*C3*R1*R3*R3 + C1*C2*C3*R3*R3*R4)
         + m*(C1*C2*C3*R3*R3*R4 + C1*C2*C3*R1*R3*R3 - C1*C2*C3*R1*R3*R4)
         + l*C1*C2*C3*R1*R2*R4
         + C1*C2*C3*R1*R3*R4;

    c = 2*float(ma.SR);

    B0 = -b1*c - b2*pow(c,2) - b3*pow(c,3);
    B1 = -b1*c + b2*pow(c,2) + 3*b3*pow(c,3);
    B2 = b1*c + b2*pow(c,2) - 3*b3*pow(c,3);
    B3 = b1*c - b2*pow(c,2) + b3*pow(c,3);
    A0 = -a0 - a1*c - a2*pow(c,2) - a3*pow(c,3);
    A1 = -3*a0 - a1*c + a2*pow(c,2) + 3*a3*pow(c,3);
    A2 = -3*a0 + a1*c + a2*pow(c,2) - 3*a3*pow(c,3);
    A3 = -a0 + a1*c - a2*pow(c,2) + a3*pow(c,3);
};

ts = environment {
    k = *(1e3);
    M = *(1e6);
    nF = *(1e-9);
    pF = *(1e-12);

    /* Fender */

    bassman = environment { /* 59 Bassman 5F6-A */
        R1 = 250:k;
        R2 = 1:M;
        R3 = 25:k;
        R4 = 56:k;
        C1 = 250:pF;
        C2 = 20:nF;
        C3 = 20:nF;
        };
        
    mesa = environment { /* Mesa Boogie Mark */
        R1 = 250:k;
        R2 = 250:k;
        R3 = 25:k;
        R4 = 100:k;
        C1 = 250:pF;
        C2 = 100:nF;
        C3 = 47:nF;
        };
        
    twin = environment { /* 69 Twin Reverb AA270 */
        R1 = 250:k;
        R2 = 250:k;
        R3 = 10:k;
        R4 = 100:k;
        C1 = 120:pF;
        C2 = 100:nF;
        C3 = 47:nF;
        };

    princeton = environment { /* 64 Princeton AA1164 */
        R1 = 250:k;
        R2 = 250:k;
        R3 = 4.8:k;
        R4 = 100:k;
        C1 = 250:pF;
        C2 = 100:nF;
        C3 = 47:nF;
        };

    /* Marshall */

    jcm800 = environment { /* 59/81 JCM-800 Lead 100 2203 */
        R1 = 220:k;
        R2 = 1:M;
        R3 = 22:k;
        R4 = 33:k;
        C1 = 470:pF;
        C2 = 22:nF;
        C3 = 22:nF;
        };
    /* 90 JCM-900 Master 2100: same as JCM-800 */

    jcm2000 = environment { /* 81 2000 Lead */
        R1 = 250:k;
        R2 = 1:M;
        R3 = 25:k;
        R4 = 56:k; /* a 10 k fixed + 100 k pot in series actually */
        C1 = 500:pF;
        C2 = 22:nF;
        C3 = 22:nF;
        };
        
    jtm45 = environment { /* JTM 45 */
        R1 = 250:k;
        R2 = 1:M;
        R3 = 25:k;
        R4 = 33:k; 
        C1 = 270:pF;
        C2 = 22:nF;
        C3 = 22:nF;
        };

    /* parameter order is R1 - R4, C1 - C3 */
    mlead = environment { /* 67 Major Lead 200 */
        R1 = 250:k;
        R2 = 1:M;
        R3 = 25:k;
        R4 = 33:k;
        C1 = 500:pF;
        C2 = 22:nF;
        C3 = 22:nF;
        };

    m2199 = environment { /* undated M2199 30W solid state */
        R1 = 250:k;
        R2 = 250:k;
        R3 = 25:k;
        R4 = 56:k;
        C1 = 250:pF;
        C2 = 47:nF;
        C3 = 47:nF;
        };

    /* Vox */
    ac30 = environment { /* 59/86 AC-30 */
        /* R3 is fixed (circuit differs anyway) */
        R1 = 1:M;
        R2 = 1:M;
        R3 = 10:k;
        R4 = 100:k;
        C1 = 50:pF;
        C2 = 22:nF;
        C3 = 22:nF;
        };
        
    ac15 = environment { /* VOX AC-15 */
        R1 = 220:k;
        R2 = 220:k;
        R3 = 220:k;
        R4 = 100:k;
        C1 = 470:pF;
        C2 = 100:nF;
        C3 = 47:nF;
        };
        
    soldano = environment { /* Soldano SLO 100 */
        R1 = 250:k;
        R2 = 1:M;
        R3 = 25:k;
        R4 = 47:k;
        C1 = 470:pF;
        C2 = 20:nF;
        C3 = 20:nF;
        };
        
    sovtek = environment { /* MIG 100 H*/
        R1 = 500:k;
        R2 = 1:M;
        R3 = 10:k;
        R4 = 47:k;
        C1 = 470:pF;
        C2 = 22:nF;
        C3 = 22:nF;
        };

    peavey = environment { /* c20*/
        R1 = 250:k;
        R2 = 250:k;
        R3 = 20:k;
        R4 = 68:k;
        C1 = 270:pF;
        C2 = 22:nF;
        C3 = 22:nF;
        };
        
    ibanez = environment { /* gx20 */
        R1 = 250:k;
        R2 = 250:k;
        R3 = 10:k;
        R4 = 100:k;
        C1 = 270:pF;
        C2 = 100:nF;
        C3 = 40:nF;
        };
        
    roland = environment { /* Cube 60 */
        R1 = 250:k;
        R2 = 250:k;
        R3 = 10:k;
        R4 = 41:k;
        C1 = 240:pF;
        C2 = 33:nF;
        C3 = 82:nF;
        };
        
    ampeg = environment { /* VL 501 */
        R1 = 250:k;
        R2 = 1:M;
        R3 = 25:k;
        R4 = 32:k;
        C1 = 470:pF;
        C2 = 22:nF;
        C3 = 22:nF;
        };
    
    ampeg_rev = environment { /* reverbrocket*/
        R1 = 250:k;
        R2 = 250:k;
        R3 = 10:k;
        R4 = 100:k;
        C1 = 100:pF;
        C2 = 100:nF;
        C3 = 47:nF;
        };
        
    bogner = environment { /* Triple Giant Preamp  */
        R1 = 250:k;
        R2 = 1:M;
        R3 = 33:k;
        R4 = 51:k;
        C1 = 220:pF;
        C2 = 15:nF;
        C3 = 47:nF;
        };
        
    groove = environment { /* Trio Preamp  */
        R1 = 220:k;
        R2 = 1:M;
        R3 = 22:k;
        R4 = 68:k;
        C1 = 470:pF;
        C2 = 22:nF;
        C3 = 22:nF;
        };
        
    crunch = environment { /* Hughes&Kettner  */
        R1 = 220:k;
        R2 = 220:k;
        R3 = 10:k;
        R4 = 100:k;
        C1 = 220:pF;
        C2 = 47:nF;
        C3 = 47:nF;
        };
        
    fender_blues = environment { /* Fender blues junior  */
        R1 = 250:k;
        R2 = 250:k;
        R3 = 25:k;
        R4 = 100:k;
        C1 = 250:pF;
        C2 = 22:nF;
        C3 = 22:nF;
        };
        
    fender_default = environment { /* Fender   */
        R1 = 250:k;
        R2 = 250:k;
        R3 = 10:k;
        R4 = 100:k;
        C1 = 250:pF;
        C2 = 100:nF;
        C3 = 47:nF;
        };
        
    fender_deville = environment { /* Fender Hot Rod  */
        R1 = 250:k;
        R2 = 250:k;
        R3 = 25:k;
        R4 = 130:k;
        C1 = 250:pF;
        C2 = 100:nF;
        C3 = 22:nF;
        };
        
    gibsen = environment { /* gs12 reverbrocket   */
        R1 = 1:M;
        R2 = 1:M;
        R3 = 94:k;  // 47k fixed
        R4 = 270:k;
        C1 = 25:pF;
        C2 = 60:nF;
        C3 = 20:nF;
        };

};

bassman(T,M,L) = tonestack(t.C1,t.C2,t.C3,t.R1,t.R2,t.R3,t.R4,T,M,L) 
                    with {t = ts.bassman;};
mesa(T,M,L) = tonestack(t.C1,t.C2,t.C3,t.R1,t.R2,t.R3,t.R4,T,M,L) 
                    with {t = ts.mesa;};
twin(T,M,L) = tonestack(t.C1,t.C2,t.C3,t.R1,t.R2,t.R3,t.R4,T,M,L) 
                    with {t = ts.twin;};
princeton(T,M,L) = tonestack(t.C1,t.C2,t.C3,t.R1,t.R2,t.R3,t.R4,T,M,L) 
                    with {t = ts.princeton;};
jcm800(T,M,L) = tonestack(t.C1,t.C2,t.C3,t.R1,t.R2,t.R3,t.R4,T,M,L) 
                    with {t = ts.jcm800;};
jcm2000(T,M,L) = tonestack(t.C1,t.C2,t.C3,t.R1,t.R2,t.R3,t.R4,T,M,L) 
                    with {t = ts.jcm2000;};
jtm45(T,M,L) = tonestack(t.C1,t.C2,t.C3,t.R1,t.R2,t.R3,t.R4,T,M,L) 
                    with {t = ts.jtm45;};
mlead(T,M,L) = tonestack(t.C1,t.C2,t.C3,t.R1,t.R2,t.R3,t.R4,T,M,L) 
                    with {t = ts.mlead;};
m2199(T,M,L) = tonestack(t.C1,t.C2,t.C3,t.R1,t.R2,t.R3,t.R4,T,M,L) 
                    with {t = ts.m2199;};
ac30(T,M,L) = tonestack(t.C1,t.C2,t.C3,t.R1,t.R2,t.R3,t.R4,T,M,L) 
                    with {t = ts.ac30;};
ac15(T,M,L) = tonestack(t.C1,t.C2,t.C3,t.R1,t.R2,t.R3,t.R4,T,M,L) 
                    with {t = ts.ac15;};
soldano(T,M,L) = tonestack(t.C1,t.C2,t.C3,t.R1,t.R2,t.R3,t.R4,T,M,L) 
                    with {t = ts.soldano;};
sovtek(T,M,L) = tonestack(t.C1,t.C2,t.C3,t.R1,t.R2,t.R3,t.R4,T,M,L) 
                    with {t = ts.sovtek;};
peavey(T,M,L) = tonestack(t.C1,t.C2,t.C3,t.R1,t.R2,t.R3,t.R4,T,M,L) 
                    with {t = ts.peavey;};
ibanez(T,M,L) = tonestack(t.C1,t.C2,t.C3,t.R1,t.R2,t.R3,t.R4,T,M,L) 
                    with {t = ts.ibanez;};
roland(T,M,L) = tonestack(t.C1,t.C2,t.C3,t.R1,t.R2,t.R3,t.R4,T,M,L) 
                    with {t = ts.roland;};
ampeg(T,M,L) = tonestack(t.C1,t.C2,t.C3,t.R1,t.R2,t.R3,t.R4,T,M,L) 
                    with {t = ts.ampeg;};
ampeg_rev(T,M,L) = tonestack(t.C1,t.C2,t.C3,t.R1,t.R2,t.R3,t.R4,T,M,L) 
                    with {t = ts.ampeg_rev;};
bogner(T,M,L) = tonestack(t.C1,t.C2,t.C3,t.R1,t.R2,t.R3,t.R4,T,M,L) 
                    with {t = ts.bogner;};
groove(T,M,L) = tonestack(t.C1,t.C2,t.C3,t.R1,t.R2,t.R3,t.R4,T,M,L) 
                    with {t = ts.groove;};
crunch(T,M,L) = tonestack(t.C1,t.C2,t.C3,t.R1,t.R2,t.R3,t.R4,T,M,L) 
                    with {t = ts.crunch;};
fender_blues(T,M,L) = tonestack(t.C1,t.C2,t.C3,t.R1,t.R2,t.R3,t.R4,T,M,L) 
                    with {t = ts.fender_blues;};
fender_default(T,M,L)= tonestack(t.C1,t.C2,t.C3,t.R1,t.R2,t.R3,t.R4,T,M,L) 
                    with {t = ts.fender_default;};
fender_deville(T,M,L) = tonestack(t.C1,t.C2,t.C3,t.R1,t.R2,t.R3,t.R4,T,M,L) 
                    with {t = ts.fender_deville;};
gibsen(T,M,L) = tonestack(t.C1,t.C2,t.C3,t.R1,t.R2,t.R3,t.R4,T,M,L) 
                    with {t = ts.gibsen;};

//################################ aanl.lib ##########################################
// A library for antialiased nonlinearities. Its official prefix is `aa`. 
//
// This library provides aliasing-suppressed nonlinearities through first-order 
// and second-order approximations of continuous-time signals, functions,
// and convolution based on antiderivatives. This technique is particularly 
// effective if combined with low-factor oversampling, for example, operating
// at 96 kHz or 192 kHz sample-rate.
//
// The library contains trigonometric functions as well as other nonlinear 
// functions such as bounded and unbounded saturators.
//
// Due to their limited domains or ranges, some of these functions may not 
// suitable for audio nonlinear processing or waveshaping, although
// they have been included for completeness. Some other functions,
// for example, tan() and tanh(), are only available with first-order
// antialiasing due to the complexity of the antiderivative of the 
// x * f(x) term, particularly because of the necessity of the dilogarithm 
// function, which requires special implementation.
//
// Future improvements to this library may include an adaptive
// mechanism to set the ill-conditioned cases threshold to improve
// performance in varying cases.
//
// Note that the antialiasing functions introduce a delay in the path,
// respectively half and one-sample delay for first and second-order functions.
//
// Also note that due to division by differences, it is vital to use
// double-precision or more to reduce errors.
//
// The environment identifier for this library is `aa`. After importing
// the standard libraries in Faust, the functions below can be called as `aa.function_name`.
// 
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/aanl.lib>
// * <https://www.dafx.de/paper-archive/2016/dafxpapers/20-DAFx-16_paper_41-PN.pdf>
//########################################################################################

ba = library("basics.lib");
ma = library("maths.lib");

declare name "Faust Antialiased Nonlinearities";
declare version "0.3";

//==============================Auxiliary Functions=======================================
//========================================================================================

//-------`(aa.)clip`----------
// Clipping function.
//-----------------------------
clip(l, h, x) = max(l, min(h, x));


//-------`(aa.)Rsqrt`----------
// Real-valued sqrt().
//-----------------------------
Rsqrt(x) = sqrt(max(0.0, x));


//-------`(aa.)Rlog`----------
// Real-valued log().
//-----------------------------
Rlog(x) = log(max(ma.EPSILON, x));


//-------`(aa.)Rtan`----------
// Real-valued tan().
//-----------------------------
Rtan(x) = tan(clip(-ma.MAX, ma.MAX, x));


//-------`(aa.)Racos`----------
// Real-valued acos().
//-----------------------------
Racos(x) = acos(clip(-1.0, 1.0, x));


//-------`(aa.)Rasin`----------
// Real-valued asin().
//-----------------------------
Rasin(x) = asin(clip(-1.0, 1.0, x));


//-------`(aa.)Racosh`----------
// Real-valued acosh()
//-----------------------------
Racosh(x) = ma.acosh(clip(1.0, ma.MAX, x));


//-------`(aa.)Rcosh`----------
// Real-valued cosh().
//-----------------------------
Rcosh(x) = min(ma.MAX, ma.cosh(x));


//-------`(aa.)Rsinh`----------
// Real-valued sinh().
//------------------------------
Rsinh(x) = clip(-ma.MAX, ma.MAX, ma.sinh(x));


//-------`(aa.)Ratanh`----------
// Real-valued atanh().
//------------------------------
Ratanh(x) = ma.atanh(clip(-1.0 + ma.EPSILON, 1.0 - ma.EPSILON, x));


//-------`(aa.)ADAA1`---------------------
//  Generalised first-order ADAA function.
//----------------------------------------

declare ADAA1 author "Dario Sanfilippo";
declare ADAA1 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare ADAA1 license "LGPL v3.0 license";
ADAA1(EPS, f, F1, x) = D1q 
      with {
           D1q = ba.if(abs(x - x') <= EPS, ill_D1q, safe_D1q)
               with {
                   ill_D1q = f(x_m);
                   safe_D1q = (F1(x) - F1(x')) / (x - x');
                   x_m = .5 * (x + x');
               };
      };


//-------`(aa.)ADAA2`---------------------
//  Generalised second-order ADAA function.
//----------------------------------------

declare ADAA2 author "Dario Sanfilippo";
declare ADAA2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare ADAA2 license "LGPL v3.0 license";
ADAA2(EPS, f, F1, F2, x) = T1 + T2 
      with {
           T1 = ba.if((x - x') ^ 2.0 <= EPS, ill_T1, safe_T1)
               with {
                   ill_T1 = .5 * f((x + 2.0 * x') / 3.0);
                   safe_T1 = (x * (F1(x) - F1(x')) - (F2(x) - F2(x'))) /
                       ((x - x') ^ 2.0);
               };
           T2 = ba.if((x' - x'') ^ 2.0 <= EPS, ill_T2, safe_T2)
               with {
                   ill_T2 = .5 * f((x'' + 2.0 * x') / 3.0);
                   safe_T2 = (x'' * (F1(x'') - F1(x')) - (F2(x'') - F2(x'))) /
                       ((x'' - x') ^ 2.0);
               };
      };


//==============================Main functions============================================
//========================================================================================

//================= Saturators ===============
//
// These antialiased saturators perform best with high-amplitude input
// signals. If the input is only slightly saturated, hence producing
// negligible aliasing, the trivial saturator may result in a better
// overall output, as noise can be introduced by first and second ADAA
// at low amplitudes. 
//
// Once determining the lowest saturation level for which the antialiased 
// functions perform adequately, it might be sensible to cross-fade
// between the trivial and the antialiased saturators according to the
// amplitude profile of the input signal.
//==============================================

//-------`(aa.)hardclip`---------------------
//
// First-order ADAA hard-clip.
//
// The domain of this function is ℝ; its theoretical range is [-1.0; 1.0].
//
// #### Usage
// ```
// _ : aa.hardclip : _
// ```

declare hardclip author "Dario Sanfilippo";
declare hardclip copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare hardclip license "LGPL v3.0 license";
hardclip(x) = ADAA1(EPS, f, F1, x)
      with {
           EPS = 1.0 / ma.SR;
           f(x_f) = clip(-1.0, 1.0, x_f);
           F1(x_F1) = ba.if(   (x_F1 <= 1.0) & (x_F1 >= -1.0), 
                               .5 * x_F1 ^ 2.0, 
                               x_F1 * ma.signum(x_F1) - .5);
      };


//-------`(aa.)hardclip2`---------------------
//
// Second-order ADAA hard-clip.
//
// The domain of this function is ℝ; its theoretical range is [-1.0; 1.0].
//
// #### Usage
// ```
// _ : aa.hardclip2 : _
// ```

declare hardclip2 author "Dario Sanfilippo";
declare hardclip2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare hardclip2 license "LGPL v3.0 license";
hardclip2(x) = ADAA2(EPS, f, F1, F2, x) 
      with {
           EPS = 1.0 / ma.SR;
           f(x_f) = clip(-1.0, 1.0, x_f);
           F1(x_F1) = ba.if(   (x_F1 <= 1.0) & (x_F1 >= -1.0), 
                               .5 * x_F1 ^ 2.0, 
                               x_F1 * ma.signum(x_F1) - .5);
           F2(x_F2) = ba.if(   (x_F2 <= 1.0) & (x_F2 >= -1.0), 
                               (1.0 / 3.0) * x_F2 ^ 3.0, 
                               ((.5 * x_F2 ^ 2.0) - 1.0 / 6.0) * 
                                   ma.signum(x_F2));
      };


//-------`(aa.)cubic1`---------------------
//
// First-order ADAA cubic saturator.
//
// The domain of this function is ℝ; its theoretical range is 
// [-2.0/3.0; 2.0/3.0].
//
// #### Usage
// ```
// _ : aa.cubic1 : _
// ```

declare cubic1 author "Dario Sanfilippo";
declare cubic1 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare cubic1 license "LGPL v3.0 license";
cubic1(x) = ADAA1(EPS, f, F1, x)
      with {
           EPS = 1.0 / ma.SR;
           f(x_f) = ba.if( (x_f < 1.0) & (x_f > -1.0), 
                           x_f - x_f ^ 3.0 / 3.0, 
                           (2.0 / 3.0) * ma.signum(x_f));
           F1(x_F1) = ba.if(   x_F1 <= -1.0,
                               x_F1 * -2.0 / 3.0,
                               ba.if(  x_F1 >= 1.0,
                                       x_F1 * 2.0 / 3.0,
                                       x_F1 ^ 2.0 / 2.0 - x_F1 ^ 4.0 / 12.0));
      };


//-------`(aa.)parabolic`---------------------
//
// First-order ADAA parabolic saturator.
//
// The domain of this function is ℝ; its theoretical range is [-1.0; 1.0].
//
// #### Usage
// ```
// _ : aa.parabolic : _
// ```

declare parabolic author "Dario Sanfilippo";
declare parabolic copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare parabolic license "LGPL v3.0 license";
parabolic(x) = ADAA1(EPS, f, F1, x) 
      with {
           EPS = 1.0 / ma.SR;
           f(x_f) = ba.if( abs(x_f) <= 2.0, 
                           x_f * (1.0 - abs(x_f) / 4.0), 
                           ma.signum(x_f));
           F1(x_F1) = ba.if(   abs(x_F1) <= 2.0, 
                               (-1.0 / 12.0) * x_F1 ^ 2.0 * 
                                   (x_F1 * ma.signum(x_F1) - 6.0),
                               abs(x_F1));
      };


//-------`(aa.)parabolic2`---------------------
//
// Second-order ADAA parabolic saturator.
//
// The domain of this function is ℝ; its theoretical range is [-1.0; 1.0].
//
// #### Usage
// ```
// _ : aa.parabolic : _
// ```

declare parabolic2 author "Dario Sanfilippo";
declare parabolic2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare parabolic2 license "LGPL v3.0 license";
parabolic2(x) = ADAA2(EPS, f, F1, F2, x) 
      with {
           EPS = 1.0 / ma.SR;
           f(x_f) = ba.if( abs(x_f) <= 2.0,
                           x_f * (1.0 - abs(x_f) / 4.0),
                           ma.signum(x_f));
           F1(x_F1) = ba.if(   abs(x_F1) <= 2.0,
                               (-1.0 / 12.0) * x_F1 ^ 2.0 * 
                                   (x_F1 * ma.signum(x_F1) - 6.0),
                               abs(x_F1));
           F2(x_F2) = ba.if(   abs(x_F2) <= 2.0,
                               (1.0 / 48.0) * x_F2 ^ 3.0 * 
                                   (16.0 - 3.0 * x_F2 * ma.signum(x_F2)),
                               .5 * x_F2 ^ 2.0 * ma.signum(x_F2));
      };


//-------`(aa.)hyperbolic`---------------------
//
// First-order ADAA hyperbolic saturator.
//
// The domain of this function is ℝ; its theoretical range is ]-1.0; 1.0[.
//
// #### Usage
// ```
// _ : aa.hyperbolic : _
// ```
declare hyperbolic author "Dario Sanfilippo";
declare hyperbolic copyright "Copyright (C) 2021 Dario Sanfilippo
     <sanfilippo.dario@gmail.com>";
declare hyperbolic license "LGPL v3.0 license";
hyperbolic(x) = ADAA1(EPS, f, F1, x)
    with {
        EPS = 1.0 / ma.SR;
        f(x_f) = x_f / (1.0 + abs(x_f));
        F1(x_F1) = abs(x_F1) - log(1.0 + abs(x_F1));
    };


//-------`(aa.)hyperbolic2`---------------------
//
// Second-order ADAA hyperbolic saturator.
//
// The domain of this function is ℝ; its theoretical range is ]-1.0; 1.0[.
//
// #### Usage
// ```
// _ : aa.hyperbolic2 : _
// ```
declare hyperbolic2 author "Dario Sanfilippo";
declare hyperbolic2 copyright "Copyright (C) 2021 Dario Sanfilippo
     <sanfilippo.dario@gmail.com>";
declare hyperbolic2 license "LGPL v3.0 license";
hyperbolic2(x) = ADAA2(EPS, f, F1, F2, x)
    with {
        EPS = 1.0 / ma.SR;
        f(x_f) = x_f / (1.0 + abs(x_f));
        F1(x_F1) = abs(x_F1) - log(1.0 + abs(x_F1));
        F2(x_F2) = ma.signum(x_F2) * (.5 * (3.0 - 2.0 * abs(x_F2) + x_F2 ^ 2.0 + 
            2.0 * log(1.0 + abs(x_F2))) - 3.0 / 2.0) + 3.0 / 2.0;
    };


//-------`(aa.)sinarctan`---------------------
//
// First-order ADAA sin(atan()) saturator.
//
// The domain of this function is ℝ; its theoretical range is ]-1.0; 1.0[.
//
// #### Usage
// ```
// _ : aa.sinatan : _
// ```
declare sinarctan author "Dario Sanfilippo";
declare sinarctan copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare sinarctan license "LGPL v3.0 license";
sinarctan(x) = ADAA1(EPS, f, F1, x)
      with {
           EPS = 1.0 / ma.SR;
           f(x_f) = x_f / sqrt(1.0 + x_f ^ 2.0);
           F1(x_F1) = sqrt(x_F1 ^ 2.0 + 1.0) + const
               with {
                   const = -1.0; // for F1(0) = 0 to minimise precision loss
               };
      };


//-------`(aa.)sinarctan2`---------------------
//
// Second-order ADAA sin(atan()) saturator.
//
// The domain of this function is ℝ; its theoretical range is ]-1.0; 1.0[.
//
// #### Usage
// ```
// _ : aa.sinarctan2 : _
// ```
declare sinarctan2 author "Dario Sanfilippo";
declare sinarctan2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare sinarctan2 license "LGPL v3.0 license";
sinarctan2(x) = ADAA2(EPS, f, F1, F2, x) 
      with {
           EPS = 1.0 / ma.SR;
           f(x_f) = x_f / sqrt(1.0 + x_f ^ 2.0);
           F1(x_F1) = sqrt(x_F1 ^ 2.0 + 1.0) + const
               with {
                   const = -1.0; // for F1(0) = 0 to minimise precision loss
               };
           F2(x_F2) = .5 * x_F2 * sqrt(x_F2 ^ 2.0 + 1.0) - .5 * ma.asinh(x_F2);
      };


//-------`(aa.)tanh1`---------------------
//
// First-order ADAA tanh() saturator.
//
// The domain of this function is ℝ; its theoretical range is ]-1.0; 1.0[.
//
// #### Usage
// ```
// _ : aa.tanh1 : _
// ```
declare tanh1 author "Dario Sanfilippo";
declare tanh1 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare tanh1 license "LGPL v3.0 license";
tanh1(x) = ADAA1(EPS, f, F1, x) 
      with {
           EPS = 1.0 / ma.SR;
           f(x_f) = ma.tanh(x_f);
           F1(x_F1) = log(Rcosh(x_F1));
      };


//-------`(aa.)arctan`---------------------
//
// First-order ADAA atan().
//
// The domain of this function is ℝ; its theoretical range is ]-π/2.0; π/2.0[.
//
// #### Usage
// ```
// _ : aa.arctan : _
// ```
declare arctan author "Dario Sanfilippo";
declare arctan copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare arctan license "LGPL v3.0 license";
arctan(x) = ADAA1(EPS, f, F1, x)
      with {
           EPS = 1.0 / ma.SR;
           f(x_f) = atan(x_f);
           F1(x_F1) = x_F1 * f(x_F1) - .5 * log(x_F1 ^ 2.0 + 1.0);
      };


//-------`(aa.)arctan2`---------------------
//
// Second-order ADAA atan().
//
// The domain of this function is ℝ; its theoretical range is ]-π/2.0; π/2.0[.
//
// #### Usage
// ```
// _ : aa.arctan2 : _
// ```
declare arctan2 author "Dario Sanfilippo";
declare arctan2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare arctan2 license "LGPL v3.0 license";
arctan2(x) = ADAA2(EPS, f, F1, F2, x)
      with {
           EPS = 1.0 / ma.SR;
           f(x_f) = atan(x_f);
           F1(x_F1) = x_F1 * f(x_F1) - .5 * log(x_F1 ^ 2.0 + 1.0);
           F2(x_F2) = .5 * x_F2 ^ 2.0 * f(x_F2) - x_F2 / 2.0 + .5 * f(x_F2);
      };


//-------`(aa.)asinh1`---------------------
//
// First-order ADAA asinh() saturator (unbounded).
//
// The domain of this function is ℝ; its theoretical range is ℝ.
//
// #### Usage
// ```
// _ : aa.asinh1 : _
// ```
declare asinh1 author "Dario Sanfilippo";
declare asinh1 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare asinh1 license "LGPL v3.0 license";
asinh1(x) = ADAA1(EPS, f, F1, x)
      with {
           EPS = 1.0 / ma.SR;
           f(x_f) = ma.asinh(x_f);
           F1(x_F1) = x_F1 * f(x_F1) - sqrt(1.0 + x_F1 ^ 2.0) + const
               with {
                   const = 1.0; // for F1(0) = 0 to minimise precision loss
               };

      };


//-------`(aa.)asinh2`---------------------
//
// Second-order ADAA asinh() saturator (unbounded).
//
// The domain of this function is ℝ; its theoretical range is ℝ.
//
// #### Usage
// ```
// _ : aa.asinh2 : _
// ```
declare asinh2 author "Dario Sanfilippo";
declare asinh2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare asinh2 license "LGPL v3.0 license";
asinh2(x) = ADAA2(EPS, f, F1, F2, x)
      with {
           EPS = 1.0 / ma.SR;
           f(x_f) = ma.asinh(x_f);
           F1(x_F1) = x_F1 * f(x_F1) - sqrt(1.0 + x_F1 ^ 2.0) + const
               with {
                   const = 1.0; // for F1(0) = 0 to minimise precision loss
               };
           F2(x_F2) = .25 * (2.0 * x_F2 ^ 2.0 * f(x_F2) + f(x_F2) - 
               sqrt(x_F2 ^ 2.0 + 1.0) * x_F2);

      };


//================= Trigonometry ===============
// These functions are reliable if input signals are within their domains.
//============================================


//-------`(aa.)cosine1`---------------------
//
// First-order ADAA cos().
//
// The domain of this function is ℝ; its theoretical range is [-1.0; 1.0].
//
// #### Usage
// ```
// _ : aa.cosine1 : _
// ```
declare cosine1 author "Dario Sanfilippo";
declare cosine1 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare cosine1 license "LGPL v3.0 license";
cosine1(x) = ADAA1(EPS, f, F1, x)
      with {
           EPS = 1.0 / ma.SR;
           f(x_f) = cos(x_f);
           F1(x_F1) = sin(x_F1);
      };


//-------`(aa.)cosine2`---------------------
//
// Second-order ADAA cos().
//
// The domain of this function is ℝ; its theoretical range is [-1.0; 1.0].
//
// #### Usage
// ```
// _ : aa.cosine2 : _
// ```
declare cosine2 author "Dario Sanfilippo";
declare cosine2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare cosine2 license "LGPL v3.0 license";
cosine2(x) = ADAA2(EPS, f, F1, F2, x)
      with {
           EPS = 1.0 / ma.SR;
           f(x_f) = cos(x_f);
           F1(x_F1) = sin(x_F1);
           F2(x_F2) = x_F2 * sin(x_F2) + cos(x_F2);
      };



//-------`(aa.)arccos`---------------------
//
// First-order ADAA acos().
//
// The domain of this function is [-1.0; 1.0]; its theoretical range is
// [π; 0.0].
//
// #### Usage
// ```
// _ : aa.arccos : _
// ```
declare arccos author "Dario Sanfilippo";
declare arccos copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare arccos license "LGPL v3.0 license";
arccos(x) = ADAA1(EPS, f, F1, x)
      with {
           EPS = 1.0 / ma.SR;
           f(x_f) = Racos(x_f);
           F1(x_F1) = x_F1 * f(x_F1) - Rsqrt(1.0 - x_F1 ^ 2.0) + const
               with {
                   const = 1.0; // for F1(0) = 0 to minimise precision loss
               };
      };


//-------`(aa.)arccos2`---------------------
//
// Second-order ADAA acos().
//
// The domain of this function is [-1.0; 1.0]; its theoretical range is 
// [π; 0.0].
//
// Note that this function is not accurate for low-amplitude or low-frequency 
// input signals. In that case, the first-order ADAA arccos() can be used.
//
// #### Usage
// ```
// _ : aa.arccos2 : _
// ```
declare arccos2 author "Dario Sanfilippo";
declare arccos2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare arccos2 license "LGPL v3.0 license";
arccos2(x) = ADAA2(EPS, f, F1, F2, x)
      with {
           EPS = 1.0 / ma.SR;
           f(x_f) = Racos(x_f);
           F1(x_F1) = x_F1 * f(x_F1) - Rsqrt(1.0 - x_F1 ^ 2.0) + const
               with {
                   const = 1.0; // for F1(0) = 0 to minimise precision loss
               };
           F2(x_F2) = .25 * (2.0 * x_F2 ^ 2.0 * f(x_F2) + Rasin(x_F2) -
               Rsqrt(1.0 - x_F2 ^ 2.0));
      };


//-------`(aa.)acosh1`---------------------
//
// First-order ADAA acosh(). 
//
// The domain of this function is ℝ >= 1.0; its theoretical range is ℝ >= 0.0.
//
// #### Usage
// ```
// _ : aa.acosh1 : _
// ```
declare acosh1 author "Dario Sanfilippo";
declare acosh1 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare acosh1 license "LGPL v3.0 license";
acosh1(x) = ADAA1(EPS, f, F1, x)
      with {
           EPS = 1.0 / ma.SR;
           f(x_f) = Racosh(x_f);
           F1(x_F1) = x_F1 * f(x_F1) - Rsqrt(x_F1 - 1.0) * Rsqrt(x_F1 + 1.0);
      };


//-------`(aa.)acosh2`---------------------
//
// Second-order ADAA acosh().
//
// The domain of this function is ℝ >= 1.0; its theoretical range is ℝ >= 0.0.
//
// Note that this function is not accurate for low-frequency input signals. 
// In that case, the first-order ADAA acosh() can be used.
//
// #### Usage
// ```
// _ : aa.acosh2 : _
// ```
declare acosh2 author "Dario Sanfilippo";
declare acosh2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare acosh2 license "LGPL v3.0 license";
acosh2(x) = ADAA2(EPS, f, F1, F2, x)
      with {
           EPS = 1.0 / ma.SR;
           f(x_f) = Racosh(x_f);
           F1(x_F1) = x_F1 * f(x_F1) - Rsqrt(x_F1 - 1.0) * Rsqrt(x_F1 + 1.0);
           F2(x_F2) = .5 * x_F2 ^ 2.0 * f(x_F2) - .25 * 
               Rsqrt(x_F2 - 1.0) * Rsqrt(x_F2 + 1.0) * x_F2 -
                   .25 * Rlog(x_F2 + Rsqrt(x_F2 - 1.0) * Rsqrt(x_F2 + 1.0));
      };


//-------`(aa.)sine`---------------------
//
// First-order ADAA sin().
//
// The domain of this function is ℝ; its theoretical range is ℝ.
//
// #### Usage
// ```
// _ : aa.sine : _
// ```
declare sine author "Dario Sanfilippo";
declare sine copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare sine license "LGPL v3.0 license";
sine(x) = ADAA1(EPS, f, F1, x)
      with {
           EPS = 1.0 / ma.SR;
           f(x_f) = sin(x_f);
           F1(x_F1) = -1.0 * cos(x_F1);
      };


//-------`(aa.)sine2`---------------------
//
// Second-order ADAA sin().
//
// The domain of this function is ℝ; its theoretical range is ℝ.
//
// #### Usage
// ```
// _ : aa.sine2 : _
// ```
declare sine2 author "Dario Sanfilippo";
declare sine2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare sine2 license "LGPL v3.0 license";
sine2(x) = ADAA2(EPS, f, F1, F2, x) 
      with {
           EPS = 1.0 / ma.SR;
           f(x_f) = sin(x_f);
           F1(x_F1) = 1.0 - cos(x_F1);
           F2(x_F2) = sin(x_F2) - x_F2 * cos(x_F2);
      };


//-------`(aa.)arcsin`---------------------
//
// First-order ADAA asin().
//
// The domain of this function is [-1.0, 1.0]; its theoretical range is 
// [-π/2.0; π/2.0].
//
// #### Usage
// ```
// _ : aa.arcsin : _
// ```
declare arcsin author "Dario Sanfilippo";
declare arcsin copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare arcsin license "LGPL v3.0 license";
arcsin(x) = ADAA1(EPS, f, F1, x)
      with {
           EPS = 1.0 / ma.SR;
           f(x_f) = Rasin(x_f);
           F1(x_F1) = x_F1 * f(x_F1) + Rsqrt(1.0 - x_F1 ^ 2.0) + const
               with {
                   const = -1.0; // for F1(0) = 0 to minimise precision loss
               };
      };


//-------`(aa.)arcsin2`---------------------
//
// Second-order ADAA asin().
//
// The domain of this function is [-1.0, 1.0]; its theoretical range is
// [-π/2.0; π/2.0].
//
// Note that this function is not accurate for low-frequency input signals.
// In that case, the first-order ADAA asin() can be used.
//
// #### Usage
// ```
// _ : aa.arcsin2 : _
// ```
declare arcsin2 author "Dario Sanfilippo";
declare arcsin2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare arcsin2 license "LGPL v3.0 license";
arcsin2(x) = ADAA2(EPS, f, F1, F2, x)
      with {
           EPS = 1.0 / ma.SR;
           f(x_f) = Rasin(x_f);
           F1(x_F1) = x_F1 * f(x_F1) + Rsqrt(1.0 - x_F1 ^ 2.0) + const
               with {
                   const = -1.0; // for F1(0) = 0 to minimise precision loss
               };
           F2(x_F2) = .25 * (Rsqrt(1.0 - x_F2 ^ 2.0) * x_F2 + 
               (2.0 * x_F2 ^ 2.0 - 1.0) * f(x_F2));
      };


//-------`(aa.)tangent`---------------------
//
// First-order ADAA tan().
//
// The domain of this function is [-π/2.0; π/2.0]; its theoretical range is ℝ.
//
// #### Usage
// ```
// _ : aa.tangent : _
// ```
declare tangent author "Dario Sanfilippo";
declare tangent copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare tangent license "LGPL v3.0 license";
tangent(x) = ADAA1(EPS, f, F1, x)
      with {
           EPS = 1.0 / ma.SR;
           f(x_f) = Rtan(x_f);
           F1(x_F1) = -1.0 * Rlog(cos(x_F1));
      };


//-------`(aa.)atanh1`---------------------
//
// First-order ADAA atanh(). 
//
// The domain of this function is ]-1.0; 1.0[; its theoretical range is ℝ.
//
// #### Usage
// ```
// _ : aa.atanh1 : _
// ```
declare atanh1 author "Dario Sanfilippo";
declare atanh1 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare atanh1 license "LGPL v3.0 license";
atanh1(x) = ADAA1(EPS, f, F1, x)
      with {
           EPS = 1.0 / ma.SR;
           f(x_f) = Ratanh(x_f);
           F1(x_F1) = .5 * Rlog(1.0 - x_F1 ^ 2.0) + x_F1 * f(x_F1);
      };


//-------`(aa.)atanh2`---------------------
//
// Second-order ADAA atanh().
//
// The domain of this function is ]-1.0; 1.0[; its theoretical range is ℝ.
//
// #### Usage
// ```
// _ : aa.atanh2 : _
// ```
declare atanh2 author "Dario Sanfilippo";
declare atanh2 copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare atanh2 license "LGPL v3.0 license";
atanh2(x) = ADAA2(EPS, f, F1, F2, x)
      with {
           EPS = 1.0 / ma.SR;
           f(x_f) = Ratanh(x_f);
           F1(x_F1) = .5 * Rlog(1.0 - x_F1 ^ 2.0) + x_F1 * f(x_F1);
           F2(x_F2) = .5 * x_F2 ^ 2.0 * f(x_F2) + x_F2 / 2.0 + .25 * 
               Rlog(1.0 - x_F2) - .25 * Rlog(1.0 + x_F2);
      };
//#################################### wdmodels.lib ##############################################################################
// A library of basic adaptors and methods to help construct Wave Digital Filter models in Faust. Its official prefix is `wd`.

// ## Library Readme

// This library is intended for use for creating Wave Digital (WD) based models of audio circuitry for real-time audio processing within the Faust programming language. The goal is to provide a framework to create real-time virtual-analog audio effects and synthesizers using WD models without the use of C++. Furthermore, we seek to provide access to the technique of WD modeling to those without extensive knowledge of advanced digital signal processing techniques. Finally, we hope to provide a library which can integrate with all aspects of Faust, thus creating a platform for virtual circuit bending. 
// The library itself is written in Faust to maintain portability. 
//
// This library is heavily based on Kurt Werner's Dissertation, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters." I have tried to maintain consistent notation between the adaptors appearing within thesis and my adaptor code. The majority of the adaptors found in chapter 1 and chapter 3 are currently supported. 
//
// For inquires about use of this library in a commercial product, please contact dirk [dot] roosenburg [dot] 30 [at] gmail [dot] com.
// This documentation is taken directly from the [readme](https://github.com/droosenb/faust-wdf-library). Please refer to it for a more updated version. 
//
// Many of the more in depth comments within the library include jargon. I plan to create videos detailing the theory of WD models.
// For now I recommend Kurt Werner's PhD, [Virtual analog modeling of Audio circuitry using Wave Digital Filters](https://searchworks.stanford.edu/view/11891203).   
// I have tried to maintain consistent syntax and notation to the thesis. 
// This library currently includes the majority of the adaptors covered in chapter 1 and some from chapter 3. 
//
//
// ## Using this Library
//
// Use of this library expects some level of familiarity with WDF techniques, especially simplification and decomposition of electronic circuits into WDF connection trees. I plan to create video to cover both these techniques and use of the library. 
//
// ### Quick Start
//
// to get a quick overview of the library, start with the `secondOrderFilters.dsp` code found in `examples`. Make sure that the `wdmodels.lib` is within the compile path. This can be achieved within the [online Faust IDE](https://faustide.grame.fr/) by simply downloading and dragging in `wdmodels.lib` in addition to the example code.
//
// ### A Simple RC Filter Model
//
// Creating a model using this library consists fo three steps. First, declare a set of components. Second, model the relationship between them using a tree. Finally, build the tree using the libraries build functions.  
//
// First, a set of components is declared using adaptors from the library. This list of components is created based on analysis of the circuit using WDF techniques, though generally each circuit element (resistor, capacitor, diode, etc.) can be expected to appear within the component set. For example, first order RC lowpass filter would require an unadapted voltage source, a 47k resistor, and a 10nF capacitor which outputs the voltage across itself. These can be declared with: 
//
// ```
// vs1(i) = wd.u_voltage(i, no.noise);
// r1(i) = wd.resistor(i, 47*10^3);
// c1(i) = wd.capacitor_Vout(i, 10*10^-9);
// ```
//
// Note that the first argument, i, is left un-parametrized. Components must be declared in this form, as the build algorithm expects to receive adaptors which have exactly one parameter. 
//
// Also note that we have chosen to declare a white noise function as the input to our voltage source. We could potentially declare this as a direct input to our model, but to do so is more complicated process which cannot be covered within this tutorial. For information on how to do this see Declaring Model Parameters as Inputs or see various implementations in `examples`.
//
// Second, the declared components and interconnection/structural adaptors (i.e. series, parallel, etc) are arranged into the connection tree which is produced from performing WD analysis on the modeled circuit. For example, to produce our first order RC lowpass circuit model, the following tree is declared: 
//
// `tree_lowpass = vs1 : wd.series : (r1, c1);`
//
// For more information on how to represent trees in Faust, see Trees in Faust. 
//
// Finally, the tree is built using the the `buildtree` function. To build and compute our first order RC lowpass circuit model, we use:
//
// `process = wd.buildtree(tree_lowpass);`
//
// More information about build functions, see Build Functions. 
//
// ### Building a Model
//
// After creating a connection tree which consists of WD adaptors, the connection tree must be passed to a build function in order to build the model.
//
// ##### Automatic model building 
//
// `buildtree(connection_tree)`
//
// The simplest build function for use with basic models. This automatically implements `buildup`, `builddown`, and `buildout` to create a working model. However, it gives minimum control to the user and cannot currently be used on trees which have parameters declared as inputs.
//
// ##### Manual model building
//
// Wave Digital Filters are an explicit state-space model, meaning they use a previous system state in order to calculate the current output. This is achieved in Faust by using a single global feedback operator. The models feed-forward terms are generated using `builddown` and the models feedback terms are generated using `buildup`. Thus, the most common model implementation (the method used by `buildtree`) is:
//
// `builddown(connection_tree)~buildup(connection_tree) : buildout(connection_tree)`
//
// Since the `~` operator in Faust will leave feedback terms hanging as outputs, `buildout` is a function provided for convenience. It automatically truncates the hanging outputs by identifying leaf components which have an intended output and generating an output matrix.
//
// Building the model manually allows for greater user control and is often very helpful in testing. Also provided for testing are the `getres` and `parres` functions, which can be used to determine the upward-facing port resistance of an element. 
//
// ### Declaring Model Parameters as Inputs
//
// When possible, parameters of components should be declared explicitly, meaning they are dependent on a function with no inputs. This might be something as simple as integer(declaring a static component), a function dependent on a UI input (declaring a component with variable value), or even a time-dependent function like an oscillator (declaring an audio input or circuit bending). 
//
// However, it is often necessary to declare parameters as input. To achieve this there are two possible methods. The first and recommended option is to create a separate model function and declare parameters which will later be implemented as inputs. This allows inputs to be explicitly declared as component parameters. For example, one might use
//
// ```
// model(in1) = buildtree(tree)
// with {
//    ...
//    vin(i) = wd.u_voltage(i, in1);
//    ...
//    tree = vin : ...; 
// };
// ```
//
// In order to simulate an audio input to the circuit. 
//
// Note that the tree and components must be declared inside a `with {...}` statement, or the model's parameters will not be accessible. 
//
// ##### The Empty Signal Operator
//
// The Empty signal operator, `_` should NEVER be used to declare a parameter as in input in a wave-digital model. 
//
// Using it will result on breaking the internal routing of the model and thus breaks the model. Instead, use explicit declaration as shown directly above. 
//
// ### Trees in Faust
//
// Since WD models use connection trees to represent relationships of elements, a comprehensive way to represent trees is critical. As there is no current convention for creating trees in Faust, I've developed a method using the existing series and parallel/list methods in Faust.
//
// The series operator ` : ` is used to separate parent and child elements. For example the tree
//
// ```
//    A
//    |
//    B
// ```
//
// is represented by `A : B` in Faust. 
//
// To denote a parent element with multiple child elements, simply use a list `(a1, a2, ... an)` of children connected to a single parent. For example the tree:
//
// ```
//    A
//   / \
//  B   C
//
// ```
// is represented by:
//
// `A : (B, C)`
//
// Finally, for a tree with many levels, simply break the tree into subtrees following the above rules and connect the subtree as if it was an individual node. For example the tree:
//
// ```
//       A
//      / \
//     B   C
//    /   / \
//   X   Y   Z
// ```
//
// can be represented by:
//
// ```
// B_sub = B : X; //B subtree
// C_sub = C : (Y, Z); //C subtree
// tree = A : (B_sub, C_sub); //full tree
// ```
//
// or more simply, using parentheses: 
//
// `A : ((B : X), (C : (Y, Z)))`

// ### How Adaptors are Structured

// In wave digital filters, adaptors can be described by the form `b = Sa` where `b` is a vector of output waves `b = (b0, b1, b2, ... bn)`, `a` is a vector of input waves`a = (a0, a1, a2, ... an)`, and `S` is an n x n scattering matrix. `S` is dependent on `R`, a list of port resistances `(R0, R1, R2, ... Rn)`. 
//
// The output wave vector `b` can be divided into downward-going and upward-going waves (downward-going waves travel down the connection tree, upward-going waves travel up). For adapted adaptors, with the zeroth port being  the upward-facing port, the downward-going wave vector is `(b1, b2, ... bn)` and the upward-going wave vector is `(b0)`. For unadapted adaptors, there are no upward-going waves, so the downward-going wave vector is simply `b = (b0, b1, b2, ... bn)`. 
//
// In order for adaptors to be interpretable by the compiler, they must be structured in a specific way. 
// Each adaptor is divided into three cases by their first parameter. This parameter, while accessible by the user, should only be set by the compiler/builder.
//
// All other parameters are value declarations (for components), inputs (for voltage or current ins), or parameter controls (for potentiometers/variable capacitors/variable inductors)
//
// ##### First case - downward going waves
//
// `(0, params) => downward-going(R1, ... Rn, a0, a1, ... an)` 
// outputs: `(b1, b2, ... bn)`
// this function takes any number of port resistances, the downward going wave, and any number of upward going waves as inputs. 
// These values/waves are used to calculate the downward going waves coming from this adaptor.
//
// ##### Second case 
//
// `(1, params) =>  upward-going(R1, ... Rn, a1, ... an)`
// outputs : `(b0)`
// this function takes any number of port resistances and any number of upward going waves as inputs
// these values/waves are used to calculate the upward going wave coming from this adaptor.
//
// ##### Third case  
//
// `(2, params) => port-resistance(R1, ... Rn)` 
// outputs: `(R0)`
// this function takes any number of port resistances as inputs
// these values are used to calculate the upward going port resistance of the element.
//
// ##### Unadapted Adaptors
//
// Unadapted adaptor's names will always begin `u_`
// An unadapted adaptor MUST be used as the root of the WD connection tree.
// Unadapted adaptors can ONLY be used as a root of the WD connection tree. 
// While unadapted adaptors contain all three cases, the second and third are purely structural. 
// Only the first case should contain computational information. 
//
// ### How the Build Functions Work
//
// Expect this section to be added soon! It's currently in progress.
//
// ### Acknowledgements
//
// Many thanks to Kurt Werner for helping me to understand wave digital filter models. Without his publications and consultations, the library would not exist. 
// Thanks also to my advisors, Rob Owen and Eli Stine whose input was critical to the development of the library.
// Finally, thanks to Romain Michon, Stephane Letz, and the Faust slack for contributing to testing, development, and inspiration when creating the library. 
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/wdmodels.lib>
//################################################################################################################################

ba = library("basics.lib");
ro = library("routes.lib");
ma = library("maths.lib");
si = library("signals.lib");

declare name "Faust Wave Digital Model Library";
declare version "0.2.0";


//=============================Algebraic One Port Adaptors=================================
//=========================================================================================

//----------------------`(wd.)resistor`--------------------------
// Adapted Resistor.
//
// A basic node implementing a resistor for use within Wave Digital Filter connection trees.
//
// It should be used as a leaf/terminating element of the connection tree.
//
// #### Usage
//
// ```
// r1(i) = resistor(i, R);
// buildtree( A : r1 );
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `R` : Resistance/Impedance of the resistor being modeled in Ohms. 
//
// Note:
// The adaptor must be declared as a separate function before integration into the connection tree.
// Correct implementation is shown above.
//
// #### Reference
//
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.2.1
//----------------------------------------------------------
declare resistor author "Dirk Roosenburg";
declare resistor copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare resistor license "MIT-style STK-4.3 license";
resistor = 
case{
    (0, R) => !, 0; 
    (1, R) => _; 
    (2, R) => R0 
    with{
        R0 = R; 
    };
};


//----------------------`(wd.)resistor_Vout`--------------------------
// Adapted Resistor + voltage Out.
//
// A basic adaptor implementing a resistor for use within Wave Digital Filter connection trees.
//
// It should be used as a leaf/terminating element of the connection tree.
// The resistor will also pass the voltage across itself as an output of the model.
//
// #### Usage
//
// ```
// rout(i) = resistor_Vout(i, R);
// buildtree( A : rout ) : _
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `R` : Resistance/Impedance of the resistor being modeled in Ohms. 
//
// Note: 
// The adaptor must be declared as a separate function before integration into the connection tree.
// Correct implementation is shown above.
//
// #### Reference
//
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.2.1
//----------------------------------------------------------
declare resistor_Vout author "Dirk Roosenburg";
declare resistor_Vout copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare resistor_Vout license "MIT-style STK-4.3 license";
resistor_Vout = 
case{
    (0, R) => 0, _*.5; 
    (1, R) => _, !; 
    (2, R) => R0 
    with{
        R0 = R; 
    };
}with{
    rho = 1; 
};


//----------------------`(wd.)resistor_Iout`--------------------------
// Resistor + current Out.
//
// A basic adaptor implementing a resistor for use within Wave Digital Filter connection trees.
//
// It should be used as a leaf/terminating element of the connection tree.
// The resistor will also pass the current through itself as an output of the model.
//
// #### Usage
//
// ```
// rout(i) = resistor_Iout(i, R);
// buildtree( A : rout ) : _
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `R` : Resistance/Impedance of the resistor being modeled in Ohms. 
//
// Note: 
// The adaptor must be declared as a separate function before integration into the connection tree.
// Correct implementation is shown above.
//
// #### Reference
//
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.2.1
//----------------------------------------------------------
declare resistor_Iout author "Dirk Roosenburg";
declare resistor_Iout copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare resistor_Iout license "MIT-style STK-4.3 license";
resistor_Iout = 
case{
    (0, R) => 0, _*.5/R; 
    (1, R) => _, !; 
    (2, R) => R0 
    with{
        R0 = R; 
    };
};


//----------------------`(wd.)u_voltage`--------------------------
// Unadapted Ideal Voltage Source.
//
// An adaptor implementing an ideal voltage source within Wave Digital Filter connection trees.
//
// It should be used as the root/top element of the connection tree.
// Can be used for either DC (constant) or AC (signal) voltage sources.
//
// #### Usage
//
// ```
// v1(i) = u_Voltage(i, ein);
// buildtree( v1 : B );
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `ein` : Voltage/Potential across ideal voltage source in Volts
//
// Note: 
// Only usable as the root of a tree
// The adaptor must be declared as a separate function before integration into the connection tree.
// Correct implementation is shown above.
//
// #### Reference
//
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.2.2
//----------------------------------------------------------
declare u_voltage author "Dirk Roosenburg";
declare u_voltage copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare u_voltage license "MIT-style STK-4.3 license";
u_voltage = 
case{
    (0 , ein) => b0
    with{
        b0(R0, a0) = 2*R0^(rho-1)*ein -a0;
    };
    (1, ein) => !, !; 
    (2, ein) => 0; 
}with{
    rho = 1; 
};


//----------------------`(wd.)u_current`--------------------------
// Unadapted Ideal Current Source.
//
// An unadapted adaptor implementing an ideal current source within Wave Digital Filter connection trees.
//
// It should be used as the root/top element of the connection tree.
// Can be used for either DC (constant) or AC (signal) current sources.
//
// #### Usage
//
// ```
// i1(i) = u_current(i, jin);
// buildtree( i1 : B );
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `jin` : Current through the ideal current source in Amps
//
// Note: 
// Only usable as the root of a tree.
// The adaptor must be declared as a separate function before integration into the connection tree.
// Correct implementation is shown above.
//
// #### Reference
//
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.2.3
//----------------------------------------------------------
declare u_current author "Dirk Roosenburg";
declare u_current copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare u_current license "MIT-style STK-4.3 license";
u_current = 
case{
    (0 , jin) => b0
    with{
        b0(R0, a0) = 2*R0^(rho)*jin + a0;
    };
    (1, jin) => !, !; 
    (2, jin) => 0; 
}with{
    rho = 1; 
};

//----------------------`(wd.)resVoltage`--------------------------
// Adapted Resistive Voltage Source.
//
// An adaptor implementing a resistive voltage source within Wave Digital Filter connection trees.
//
// It should be used as a leaf/terminating element of the connection tree.
// It is comprised of an ideal voltage source in series with a resistor.
// Can be used for either DC (constant) or AC (signal) voltage sources.
//
// #### Usage
//
// ```
// v1(i) = resVoltage(i, R, ein);
// buildtree( A : v1 );
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared
// * `R` : Resistance/Impedance of the series resistor in Ohms
// * `ein` : Voltage/Potential of the ideal voltage source in Volts
//
// Note: 
// The adaptor must be declared as a separate function before integration into the connection tree.
// Correct implementation is shown above.
//
// #### Reference
//
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.2.4
//----------------------------------------------------------
declare resVoltage author "Dirk Roosenburg";
declare resVoltage copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare resVoltage license "MIT-style STK-4.3 license";
resVoltage = 
case{
    (0, R, ein) => !, R^(1-rho)*ein;
    (1, R, ein) => _; 
    (2, R, ein) => R0
    with {
        R0 = R; 
    };
}with{
    rho = 1; 
}; 

//----------------------`(wd.)resVoltage_Vout`--------------------------
// Adapted Resistive Voltage Source + voltage output.
//
// An adaptor implementing an adapted resistive voltage source within Wave Digital Filter connection trees.
//
// It should be used as a leaf/terminating element of the connection tree.
// It is comprised of an ideal voltage source in series with a resistor.
// Can be used for either DC (constant) or AC (signal) voltage sources.
// The resistive voltage source will also pass the voltage across it as an output of the model.
//
// #### Usage
//
// ```
// vout(i) = resVoltage_Vout(i, R, ein);
// buildtree( A : vout ) : _
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared
// * `R` : Resistance/Impedance of the series resistor in Ohms
// * `ein` : Voltage/Potential across ideal voltage source in Volts
//
// Note: 
// The adaptor must be declared as a separate function before integration into the connection tree.
// Correct implementation is shown above.
//
// #### Reference
//
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.2.4
//----------------------------------------------------------
declare resVoltage_Vout author "Dirk Roosenburg";
declare resVoltage_Vout copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare resVoltage_Vout license "MIT-style STK-4.3 license";
resVoltage_Vout = 
case{
    (0, R, ein) => R^(1-rho)*ein, _*.5 + R^(1-rho)*ein*.5;
    (1, R, ein) => _, !; 
    (2, R, ein) => R0
    with {
        R0 = R; 
    };
}with{
    rho = 1; 
}; 

//----------------------`(wd.)u_resVoltage`--------------------------
// Unadapted Resistive Voltage Source.
//
// An unadapted adaptor implementing a resistive voltage source within Wave Digital Filter connection trees.
//
// It should be used as the root/top element of the connection tree.
// It is comprised of an ideal voltage source in series with a resistor.
// Can be used for either DC (constant) or AC (signal) voltage sources.
//
// #### Usage
//
// ```
// v1(i) = u_resVoltage(i, R, ein);
// buildtree( v1 : B );
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared
// * `R` : Resistance/Impedance of the series resistor in Ohms
// * `ein` : Voltage/Potential across ideal voltage source in Volts
//
// Note: 
// Only usable as the root of a tree.
// The adaptor must be declared as a separate function before integration into the connection tree.
// Correct implementation is shown above.
//
// #### Reference
//
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.2.4
//----------------------------------------------------------
declare u_resVoltage author "Dirk Roosenburg";
declare u_resVoltage copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare u_resVoltage license "MIT-style STK-4.3 license";
u_resVoltage =
case {
    (0, R, ein) => b0
    with{
        b0(R0, a0) = a0*(R - R0)/(R+R0) + ein*(2*R0^rho)/(R + R0);
    };
    (1, R, ein) => !, !; 
    (2, R, ein) => 0; 

}with{
    rho = 1; 
};


//----------------------`(wd.)resCurrent`--------------------------
// Unadapted Resistive Current Source.
//
// An adaptor implementing a resistive current source within Wave Digital Filter connection trees.
//
// It should be used as a leaf/terminating element of the connection tree.
// It is comprised of an ideal current source in parallel with a resistor.
// Can be used for either DC (constant) or AC (signal) current sources.
//
// #### Usage
//
// ```
// i1(i) = resCurrent(i, R, jin);
// buildtree( A : i1 );
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `R` : Resistance/Impedance of the parallel resistor in Ohms
// * `jin` : Current through the ideal current source in Amps
//
// Note: 
// The adaptor must be declared as a separate function before integration into the connection tree.
// Correct implementation is shown above.
//
// #### Reference
//
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.2.5
//----------------------------------------------------------
declare resCurrent author "Dirk Roosenburg";
declare resCurrent copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare resCurrent license "MIT-style STK-4.3 license";
resCurrent =
case {
    (0, R, jin) => !, 2*R^(rho)*jin;
    (1, R, jin) => _; 
    (2, R, jin) => R0
    with {
        R0 = R; 
    };
}with{
    rho = 1; //assume voltage waves
}; 

//----------------------`(wd.)u_resCurrent`--------------------------
// Unadapted Resistive Current Source.
//
// An unadapted adaptor implementing a resistive current source within Wave Digital Filter connection trees.
//
// It should be used as the root/top element of the connection tree.
// It is comprised of an ideal current source in parallel with a resistor.
// Can be used for either DC (constant) or AC (signal) current sources.
//
// #### Usage
//
// ```
// i1(i) = u_resCurrent(i, R, jin);
// buildtree( i1 : B );
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `R` : Resistance/Impedance of the series resistor in Ohms
// * `jin` : Current through the ideal current source in Amps
//
// Note: 
// Only usable as the root of a tree.
// The adaptor must be declared as a separate function before integration into the connection tree.
// Correct implementation is shown above.
//
// #### Reference
//
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.2.5
//----------------------------------------------------------
declare u_resCurrent author "Dirk Roosenburg";
declare u_resCurrent copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare u_resCurrent license "MIT-style STK-4.3 license";
u_resCurrent =
case {
    (0, R, jin) => b0
    with{
        b0(R0, a0) = a0*(R - R0)/(R + R0) + jin*(2*R*R0^rho)/(R + R0);
    };
    (1, R, jin) => !, !; 
    (2, R, jin) => 0; 

}with{
    rho = 1; //assume voltage waves
};

//TODO
//add short circuit (1.2.6), add open circuit (1.2.7)

//----------------------`(wd.)u_switch`--------------------------
// Unadapted Ideal Switch.
//
// An unadapted adaptor implementing an ideal switch for Wave Digital Filter connection trees.
//
// It should be used as the root/top element of the connection tree
//
// #### Usage
//
// ```
// s1(i) = u_resCurrent(i, lambda);
// buildtree( s1 : B );
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `lambda` : switch state control. -1 for closed switch, 1 for open switch.
//
// Note: 
// Only usable as the root of a tree
// The adaptor must be declared as a separate function before integration into the connection tree.
// Correct implementation is shown above.
//
// #### Reference
//
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.2.8
//----------------------------------------------------------
declare u_switch author "Dirk Roosenburg";
declare u_switch copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare u_switch license "MIT-style STK-4.3 license";
u_switch = 
case {
    (0, lambda) => b0
    with{
        b0(R0, a0) = a0*lambda; 
    };
    (1, lambda) => !, !; 
    (2, lambda) => 0; 
};

//=============================Reactive One Port Adaptors=================================
//========================================================================================
//TODO - add mobius transform and alpha transform digitizations

//----------------------`(wd.)capacitor`--------------------------
// Adapted Capacitor.
//
// A basic adaptor implementing a capacitor for use within Wave Digital Filter connection trees.
//
// It should be used as a leaf/terminating element of the connection tree.
// This capacitor model was digitized using the bi-linear transform.
//
// #### Usage
//
// ```
// c1(i) = capacitor(i, R);
// buildtree( A : c1 ) : _
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared.
// * `R` : Capacitance/Impedance of the capacitor being modeled in Farads. 
//
// Note:
// The adaptor must be declared as a separate function before integration into the connection tree.
// Correct implementation is shown above.
//
// #### Reference
//
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.3.1
//----------------------------------------------------------
declare capacitor author "Dirk Roosenburg";
declare capacitor copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare capacitor license "MIT-style STK-4.3 license";
capacitor =
case{
    (0, R) => _*1; 
    (1, R) => _; 
    (2, R) => R0
    with {
        R0 = t/(2*R); 
    };
}with{
    t = 1/ma.SR; //sampling interval
};

//----------------------`(wd.)capacitor_Vout`--------------------------
// Adapted Capacitor + voltage out.
//
// A basic adaptor implementing a capacitor for use within Wave Digital Filter connection trees.
//
// It should be used as a leaf/terminating element of the connection tree.
// The capacitor will also pass the voltage across itself as an output of the model.
// This capacitor model was digitized using the bi-linear transform.
//
// #### Usage
//
// ```
// cout(i) = capacitor_Vout(i, R);
// buildtree( A : cout ) : _
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared
// * `R` : Capacitance/Impedence of the capacitor being modeled in Farads
//
// Note: 
// The adaptor must be declared as a seperate function before integration into the connection tree.
// Correct implementation is shown above.
//
// #### Reference
//
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.3.1
//----------------------------------------------------------
declare capacitor_Vout author "Dirk Roosenburg";
declare capacitor_Vout copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare capacitor_Vout license "MIT-style STK-4.3 license";
capacitor_Vout = 
case{
    (0, R) => b0
    with{
        b0(a1) = a1*1, a1*.5 + (a1')*.5; 
    };
    (1, R) => _, !; 
    (2, R) => R0
    with {
        R0 = t/(2*R); 
    };
}with{
    t = 1/ma.SR; //sampling interval
};

//----------------------`(wd.)inductor`--------------------------
// Unadapted Inductor.
//
// A basic adaptor implementing an inductor for use within Wave Digital Filter connection trees.
//
// It should be used as a leaf/terminating element of the connection tree.
// This inductor model was digitized using the bi-linear transform.
//
// #### Usage
//
// ```
// l1(i) = inductor(i, R);
// buildtree( A : l1 );
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared
// * `R` : Inductance/Impedance of the inductor being modeled in Henries
//
// Note: 
// The adaptor must be declared as a separate function before integration into the connection tree.
// Correct implementation is shown above.
//
// #### Reference
//
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.3.2
//----------------------------------------------------------
declare inductor author "Dirk Roosenburg";
declare inductor copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare inductor license "MIT-style STK-4.3 license";
inductor =
case{
    (0, R) => _*(-1); 
    (1, R) => _; 
    (2, R) => R0
    with {
        R0 = (2*R)/t; 
    };
}with{
    t = 1/ma.SR; //sampling interval
};

//----------------------`(wd.)inductor_Vout`--------------------------
// Unadapted Inductor + Voltage out.
//
// A basic adaptor implementing an inductor for use within Wave Digital Filter connection trees.
//
// It should be used as a leaf/terminating element of the connection tree.
// The inductor will also pass the voltage across itself as an output of the model.
// This inductor model was digitized using the bi-linear transform.
//
// #### Usage
//
// ```
// lout(i) = inductor_Vout(i, R);
// buildtree( A : lout ) : _
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared
// * `R` : Inductance/Impedance of the inductor being modeled in Henries
//
// Note: 
// The adaptor must be declared as a separate function before integration into the connection tree.
// Correct implementation is shown above.
//
// #### Reference
//
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.3.2
//----------------------------------------------------------
declare inductor_Vout author "Dirk Roosenburg";
declare inductor_Vout copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare inductor_Vout license "MIT-style STK-4.3 license";
inductor_Vout = 
case{
    (0, R) => b0
    with{
        b0(a1) = a1*(-1), a1*.5 - (a1')*.5; 
    };
    (1, R) => _, !; 
    (2, R) => R0
    with {
        R0 = (2*R)/t; 
    };
}with{
    t = 1/ma.SR; //sampling interval
};

//===============================Nonlinear One Port Adaptors==============================
//========================================================================================

//----------------------`(wd.)u_idealDiode`--------------------------
// Unadapted Ideal Diode.
//
// An unadapted adaptor implementing an ideal diode for Wave Digital Filter connection trees.
//
// It should be used as the root/top element of the connection tree.
//
// #### Usage
//
// ```
// buildtree( u_idealDiode : B );
// ```
//
// Note: 
// Only usable as the root of a tree
// Correct implementation is shown above.
//
// #### Reference
//
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 3.2.3
//----------------------------------------------------------
declare u_idealDiode author "Dirk Roosenburg";
declare u_idealDiode copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare u_idealDiode license "MIT-style STK-4.3 license";
u_idealDiode =
case{
    (0) => b1
    with{
        b1(R1, a0) = a0 : abs : *(-1);
    };
    (1) => !, !; 
    (2) => 0; 
};

//----------------------`(wd.)u_chua`--------------------------
// Unadapted Chua Diode.
//
// An adaptor implementing the chua diode / non-linear resistor within Wave Digital Filter connection trees.
//
// It should be used as the root/top element of the connection tree.
//
// #### Usage
//
// ```
// chua1(i) = u_chua(i, G1, G2, V0);
// buildtree( chua1 : B );
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared
// * `G1` : resistance parameter 1 of the chua diode
// * `G2` : resistance parameter 2 of the chua diode
// * `V0` : voltage parameter of the chua diode
//
// Note: 
// Only usable as the root of a tree.
// The adaptor must be declared as a separate function before integration into the connection tree.
// Correct implementation is shown above.
//
// #### Reference
//
// Meerkotter and Scholz, "Digital Simulation of Nonlinear Circuits by Wave Digital Filter Principles"
//----------------------------------------------------------
declare u_chua author "Dirk Roosenburg";
declare u_chua copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare u_chua license "MIT-style STK-4.3 license";
u_chua = 
case{
    (0, G1, G2, V0) => b1
    with{
        b1(R1, a0) = g_1*a0 + 1/2*(g_2 - g_1)*(((a0 + a_0) : abs) - ((a0 - a_0): abs))
        with{
            g_1 = (1-G1*R1)/(1+G1*R1);
            g_2 = (1-G2*R1)/(1+G2*R1);
            a_0 = V0*(1+G2*R1);
        };
    };
    (1, G1, G2, V0) => !, !; 
    (2, G1, G2, V0) => 0; 
};


//----------------------`(wd.)lambert`--------------------------
// An implementation of the lambert function.
// It uses Halley's method of iteration to approximate the output.
// Included in the WD library for use in non-linear diode models.
// Adapted from K M Brigg's c++ lambert function approximation.
//
// #### Usage
//
// ```
// lambert(n, itr) : _
// ```
//
// Where:
// * `n`: value at which the lambert function will be evaluated
// * `itr`: number of iterations before output
//
//----------------------------------------------------------
declare lambert author "Dirk Roosenburg";
declare lambert copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare lambert license "MIT-style STK-4.3 license";
lambert(z, itr) = ba.if((z<(-em1+.0001)), less_approx, greater_approx)
with{
    less_approx = -1.0
     +2.331643981597124203363536062168*r
     -1.812187885639363490240191647568*q
     +1.936631114492359755363277457668*r*q
     -2.353551201881614516821543561516*q2
    with{
        q = z+em1;
        r = sqrt(q);
        q2 = q*q; 
    };
    eps=4.0e-16; 
    em1=0.3678794411714423215955237701614608;
    greater_approx = z : init : seq(i, itr, approx)
    with{
        init(w) = ba.if((z<1), init1, init2)
        with{
            init1 = -1.0+p*(1.0+p*(-0.333333333333333333333+p*0.152777777777777777777777))
            with{
                p = sqrt(2.0*(2.7182818284590452353602874713526625*z+1.0));
            };
            init2 = log(abs(z));
        };
        approx(w) = w-t
        with{
            e = exp(w);
            t = (w*e-z)/(e*p-.5*(p+1.0)*(w*e-z)/p);
            p = w+1; 
        };
    };
};


//----------------------`(wd.)u_diodePair`--------------------------
// Unadapted pair of diodes facing in opposite directions.
//
// An unadapted adaptor implementing two antiparallel diodes for Wave Digital Filter connection trees.
// The behavior is approximated using Schottkey's ideal diode law.
//
// #### Usage
//
// ```
// d1(i) = u_diodePair(i, Is, Vt);
// buildtree( d1 : B );
// ```
//
// Where:
// 
// * `i`: index used by model-building functions. Should never be user declared
// * `Is` : saturation current of the diodes
// * `Vt` : thermal resistances of the diodes
//
// Note: 
// Only usable as the root of a tree.
// Correct implementation is shown above.
//
// #### Reference
//
// K. Werner et al. "An Improved and Generalized Diode Clipper Model for Wave Digital Filters"
//----------------------------------------------------------
declare u_diodePair author "Dirk Roosenburg";
declare u_diodePair copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare u_diodePair license "MIT-style STK-4.3 license";
u_diodePair = 
case{
    (0, Is, Vt) => b1
    with{
        b1(R1, a1) = a1 + 2*R1*Is - 2*Vt*lambert((R1*Is/Vt*(((a1+R1*Is)/Vt), 3) : exp));
    };
    (1, Is, Vt) => !, !; 
    (2, Is, Vt) => 0; 
};


//----------------------`(wd.)u_diodeSingle`--------------------------
// Unadapted single diode.
//
// An unadapted adaptor implementing a single diode for Wave Digital Filter connection trees.
// The behavior is approximated using Schottkey's ideal diode law.
//
// #### Usage
//
// ```
// d1(i) = u_diodeSingle(i, Is, Vt);
// buildtree( d1 : B );
// ```
//
// Where:
// 
// * `i`: index used by model-building functions. Should never be user declared
// * `Is` : saturation current of the diodes
// * `Vt` : thermal resistances of the diodes
//
// Note: 
// Only usable as the root of a tree
// Correct implementation is shown above.
//
// #### Reference
//
// K. Werner et al. "An Improved and Generalized Diode Clipper Model for Wave Digital Filters"
//----------------------------------------------------------
declare u_diodeSingle author "Dirk Roosenburg";
declare u_diodeSingle copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare u_diodeSingle license "MIT-style STK-4.3 license";
u_diodeSingle = 
case{
    (0, Is, Vt) => b1
    with{
        b1(R1, a1) = ma.signum(a1)*((a1 : abs) + 2*R1*Is - 2*Vt*(lambert((R1*Is/Vt*((((a1 : abs)+R1*Is)/Vt) : exp)),3) + lambert((-R1*Is/Vt*(((-1*(a1 : abs)+R1*Is)/Vt) : exp)),3)));
    };
    (1, Is, Vt) => !, !; 
    (2, Is, Vt) => 0; 
};

//----------------------`(wd.)u_diodeAntiparallel`--------------------------
// Unadapted set of antiparallel diodes with M diodes facing forwards and N diodes facing backwards.
//
// An unadapted adaptor implementing antiparallel diodes for Wave Digital Filter connection trees.
// The behavior is approximated using Schottkey's ideal diode law.
//
// #### Usage
//
// ```
// d1(i) = u_diodeAntiparallel(i, Is, Vt);
// buildtree( d1 : B );
// ```
//
// Where:
// 
// * `i`: index used by model-building functions. Should never be user declared
// * `Is` : saturation current of the diodes
// * `Vt` : thermal resistances of the diodes
//
// Note: 
// Only usable as the root of a tree
// Correct implementation is shown above.
//
// #### Reference
//
// K. Werner et al. "An Improved and Generalized Diode Clipper Model for Wave Digital Filters"
//----------------------------------------------------------
declare u_diodeAntiparallel author "Dirk Roosenburg";
declare u_diodeAntiparallel copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare u_diodeAntiparallel license "MIT-style STK-4.3 license";
u_diodeAntiparallel =
case{
    (0, Is, Vt, M, N) => b1
    with{
        b1(R1, a1) = a1 - 2*lam*Vt*(mu0* lambert(((R1*Is)/(mu0*Vt) * exp((lam*a1)/(mu0*Vt))), 3) + 
                                    mu1* lambert(((-R1*Is)/(mu1*Vt) * exp((-lam*a1)/(mu1*Vt))), 3))
        with{
            lam = ma.signum(a1); 
            mu0 = ba.if((a1 < 0), N, M);
            mu1 = ba.if((a1 > 0), M, N);
        };
    };
    (1, Is, Vt, M, N) => !, !; 
    (2, Is, Vt, M, N) => 0; 
};


//=============================Two Port Adaptors==========================================
//========================================================================================


//----------------------`(wd.)u_parallel2Port`--------------------------
// Unadapted 2-port parallel connection.
//
// An unadapted adaptor implementing a 2-port parallel connection between adaptors for Wave Digital Filter connection trees.
// Elements connected to this adaptor will behave as if connected in parallel in circuit.
//
// #### Usage
//
// ```
// buildtree( u_parallel2Port : (A, B) );
// ```
//
// Note: 
// Only usable as the root of a tree.
// This adaptor has no user-accessible parameters. 
// Correct implementation is shown above.
//
// #### Reference
//
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.4.1
//----------------------------------------------------------
declare u_parallel2Port author "Dirk Roosenburg";
declare u_parallel2Port copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare u_parallel2Port license "MIT-style STK-4.3 license";
u_parallel2Port = 
case{
    (0) => u_par
    with{ 
        u_par = si.bus(4) <: b0, b1;
        b0(R0, R1, a0, a1) = (-a0*(R0-R1) + a1*(2*R0^rho*R1^(1-rho)))/(R0+R1);
        b1(R0, R1, a0, a1) = (a1*(R0-R1) + a0*(2*R0^(1-rho)*R1^rho))/(R0+R1);
    };
    (1) => !, !, !, !;
    (2) => 0; 
}with{
    rho = 1; //assume voltage waves
};


//----------------------`(wd.)parallel2Port`--------------------------
// Adapted 2-port parallel connection.
//
// An adaptor implementing a 2-port parallel connection between adaptors for Wave Digital Filter connection trees.
// Elements connected to this adaptor will behave as if connected in parallel in circuit.
//
// #### Usage
//
// ```
// buildtree( A : parallel2Port : B );
// ```
//
// Note: 
// This adaptor has no user-accessible parameters. 
// It should be used within the connection tree with one previous and one forward adaptor.
// Correct implementation is shown above.
//
// #### Reference
//
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.4.1
//----------------------------------------------------------
declare parallel2Port author "Dirk Roosenburg";
declare parallel2Port copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare parallel2Port license "MIT-style STK-4.3 license";
parallel2Port = 
case{
    (0) => par_down
    with{
        par_down = b1; 
        b1(R1, a0, a1) = a0;  
    };
    (1) => par_up
    with{
        par_up = b0; 
        b0(R1, a1) = a1; 
    };
    (2) => R0
    with{
        R0(R1) = R1; 
    };
};

//----------------------`(wd.)u_series2Port`--------------------------
// Unadapted 2-port series connection.
//
// An unadapted adaptor implementing a 2-port series connection between adaptors for Wave Digital Filter connection trees.
// Elements connected to this adaptor will behave as if connected in series in circuit.
//
// #### Usage
//
// ```
// buildtree( u_series2Port : (A, B) );
// ```
//
// Note: 
// Only usable as the root of a tree.
// This adaptor has no user-accessible parameters. 
// Correct implementation is shown above.
//
// #### Reference
//
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.4.1
//----------------------------------------------------------
declare u_series2Port author "Dirk Roosenburg";
declare u_series2Port copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare u_series2Port license "MIT-style STK-4.3 license";
u_series2Port = 
case{
    (0) => u_ser
    with{ 
        u_ser = si.bus(4) <: b0, b1;
        b0(R0, R1, a0, a1) = (-a0*(R0-R1) - a1*(2*R0^rho*R1^(1-rho)))/(R0+R1);
        b1(R0, R1, a0, a1) = (a1*(R0-R1) - a0*(2*R0^(1-rho)*R1^rho))/(R0+R1);
    };
    (1) => !, !, !, !;
    (2) => 0; 
}with{
    rho = 1; //assume voltage waves
};


//----------------------`(wd.)series2Port`--------------------------
// Adapted 2-port series connection.
//
// An adaptor implementing a 2-port series connection between adaptors for Wave Digital Filter connection trees.
// Elements connected to this adaptor will behave as if connected in series in circuit.
//
// #### Usage
//
// ```
// buildtree( A : series2Port : B );
// ```
//
// Note: 
// This adaptor has no user-accessible parameters. 
// It should be used within the connection tree with one previous and one forward adaptor.
// Correct implementation is shown above.
//
// #### Reference
//
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.4.1
//----------------------------------------------------------
declare series2Port author "Dirk Roosenburg";
declare series2Port copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare series2Port license "MIT-style STK-4.3 license";
series2Port = 
case{
    (0) => ser_down
    with{
        ser_down = b1; 
        b1(R1, a0, a1) = -a0;  
    };
    (1) => ser_up
    with{
        ser_up = b0; 
        b0(R1, a1) = -a1; 
    };
    (2) => R0
    with{
        R0(R1) = R1; 
    };
};


//----------------------`(wd.)parallelCurrent`--------------------------
// Adapted 2-port parallel connection + ideal current source.
//
// An adaptor implementing a 2-port series connection and internal idealized current source between adaptors for Wave Digital Filter connection trees.
// This adaptor connects the two connected elements and an additional ideal current source in parallel.
//
// #### Usage
//
// ```
// i1(i) = parallelCurrent(i, jin);
// buildtree(A : i1 : B);
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared
// * `jin` :  Current through the ideal current source in Amps
//
// Note: 
// The adaptor must be declared as a separate function before integration into the connection tree.
// It should be used within a connection tree with one previous and one forward adaptor.
// Correct implementation is shown above.
//
// #### Reference
//
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.4.2
//----------------------------------------------------------
declare parallelCurrent author "Dirk Roosenburg";
declare parallelCurrent copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare parallelCurrent license "MIT-style STK-4.3 license";
parallelCurrent = 
case{
    (0, jin) => par_current_down
    with{
        par_current_down = b1; 
        b1(R1, a0, a1) = a0 + R1^rho*jin;  
    };
    (1, jin) => par_current_up
    with{
        par_current_up = b0; 
        b0(R1, a1) = a1 + R1^rho*jin; 
    };
    (2, jin) => R0
    with{
        R0(R1) = R1; 
    };
}with{
    rho = 1; //assume voltage waves
};


//----------------------`(wd.)seriesVoltage`--------------------------
// Adapted 2-port series connection + ideal voltage source.
//
// An adaptor implementing a 2-port series connection and internal ideal voltage source between adaptors for Wave Digital Filter connection trees.
// This adaptor connects the two connected adaptors and an additional ideal voltage source in series.
//
// #### Usage
//
// ```
// v1(i) = seriesVoltage(i, vin)
// buildtree( A : v1 : B );
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared
// * `vin` :  voltage across the ideal current source in Volts
//
// Note: 
// The adaptor must be declared as a separate function before integration into the connection tree.
// It should be used within the connection tree with one previous and one forward adaptor.
//
// #### Reference
//
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.4.2
//----------------------------------------------------------
declare seriesVoltage author "Dirk Roosenburg";
declare seriesVoltage copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare seriesVoltage license "MIT-style STK-4.3 license";
seriesVoltage = 
case{
    (0, vin) => ser_down
    with{
        ser_down = b1; 
        b1(R1, a0, a1) = -a0 - R1^(rho-1)*vin;  
    };
    (1, vin) => ser_up
    with{
        ser_up = b0; 
        b0(R1, a1) = -a1 - R1^(rho-1)*vin; 
    };
    (2, vin) => R0
    with{
        R0(R1) = R1; 
    };
}with{
    rho = 1; //assume voltage waves
};

//----------------------`(wd.)u_transformer`--------------------------
// Unadapted ideal transformer.
//
// An adaptor implementing an ideal transformer for Wave Digital Filter connection trees.
// The first downward-facing port corresponds to the primary winding connections, and the second downward-facing port to the secondary winding connections
//
// #### Usage
//
// ```
// t1(i) = u_transformer(i, tr);
// buildtree(t1 : (A , B));
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared
// * `tr` :  the turn ratio between the windings on the primary and secondary coils
//
// Note: 
// The adaptor must be declared as a separate function before integration into the connection tree.
// It may only be used as the root of the connection tree with two forward nodes.
//
//
// #### Reference
//
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.4.3
//----------------------------------------------------------
declare u_transformer author "Dirk Roosenburg";
declare u_transformer copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare u_transformer license "MIT-style STK-4.3 license";
u_transformer(i, n) = u_genericNode(i, transformer_scatter)
with{
    matrix(M,N,f) = si.bus(N) <: ro.interleave(N,M) : par(n,N, par(m,M,*(f(m+1,n+1)))) :> si.bus(M);

    transformer_scatter(R0, R1) = matrix(2, 2, s)
    with{
        s(1,1) =-1*(R0-n^2*R1)/(R0+n^2*R1);
        s(1,2) = (2*n*R0^rho*R1^(1-rho))/(R0+n^2*R1);
        s(2,1) = (2*n*R0^(1-rho)*R1^rho)/(R0+n^2*R1);
        s(2,2) = (R0-n^2*R1)/(R0+n^2*R1);
        s(i,j) = 10; 

        rho = 1; //assume voltage waves
    };
};

//----------------------`(wd.)transformer`--------------------------
// Adapted ideal transformer.
//
// An adaptor implementing an ideal transformer for Wave Digital Filter connection trees.
// The upward-facing port corresponds to the primary winding connections, and the downward-facing port to the secondary winding connections
//
// #### Usage
//
// ```
// t1(i) = transformer(i, tr);
// buildtree(A : t1 : B);
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared
// * `tr` :  the turn ratio between the windings on the primary and secondary coils
//
// Note: 
// The adaptor must be declared as a separate function before integration into the connection tree.
// It should be used within the connection tree with one backward and one forward nodes.
//
// #### Reference
//
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.4.3
//----------------------------------------------------------
declare transformer author "Dirk Roosenburg";
declare transformer copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare transformer license "MIT-style STK-4.3 license";
transformer(i, n) = genericNode(i, transformer_scatter, transformer_upPortRes)
with{
    matrix(M,N,f) = si.bus(N) <: ro.interleave(N,M) : par(n,N, par(m,M,*(f(m+1,n+1)))) :> si.bus(M);

    transformer_upPortRes(R1) = n^2*R1; //equation for upward-facing port resistance

    transformer_scatter(R1) = matrix(2, 2, s)
    with{
        s(1,1) =-1*(R0-n^2*R1)/(R0+n^2*R1);
        s(1,2) = (2*n*R0^rho*R1^(1-rho))/(R0+n^2*R1);
        s(2,1) = (2*n*R0^(1-rho)*R1^rho)/(R0+n^2*R1);
        s(2,2) = (R0-n^2*R1)/(R0+n^2*R1);
        s(i,j) = 10; 

        rho = 1; //assume voltage waves

        R0 = n^2*R1; //adapting condition
    };
};


//----------------------`(wd.)u_transformerActive`--------------------------
// Unadapted ideal active transformer.
//
// An adaptor implementing an ideal transformer for Wave Digital Filter connection trees.
// The first downward-facing port corresponds to the primary winding connections, and the second downward-facing port to the secondary winding connections
//
// #### Usage
//
// ```
// t1(i) = u_transformerActive(i, gamma1, gamma2);
// buildtree(t1 : (A , B));
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared
// * `gamma1` :  the turn ratio describing the voltage relationship between the primary and secondary coils
// * `gamma2` :  the turn ratio describing the current relationship between the primary and secondary coils
//
// Note: 
// The adaptor must be declared as a separate function before integration into the connection tree.
// It may only be used as the root of the connection tree with two forward nodes.
//
// #### Reference
//
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.4.3
//----------------------------------------------------------
declare u_transformerActive author "Dirk Roosenburg";
declare u_transformerActive copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare u_transformerActive license "MIT-style STK-4.3 license";
u_transformerActive(i, gamma1, gamma2) = u_genericNode(i, transformerActive_scatter)
with{
    matrix(M,N,f) = si.bus(N) <: ro.interleave(N,M) : par(n,N, par(m,M,*(f(m+1,n+1)))) :> si.bus(M);

    transformerActive_scatter(R0, R1) = matrix(2, 2, s)
    with{
        s(1,1) =-1*(R0-gamma1*gamma2*R1)/(R0+gamma1*gamma2*R1);
        s(1,2) = (2*gamma1*R0^rho*R1^(1-rho))/(R0+gamma1*gamma2*R1);
        s(2,1) = (2*gamma2*R0^(1-rho)*R1^rho)/(R0+gamma1*gamma2*R1);
        s(2,2) = (R0-gamma1*gamma2*R1)/(R0+gamma1*gamma2*R1);
        s(i,j) = 10; 

        rho = 1; //assume voltage waves
    };
};


//----------------------`(wd.)transformerActive`--------------------------
// Adapted ideal active transformer.
//
// An adaptor implementing an ideal active transformer for Wave Digital Filter connection trees.
// The upward-facing port corresponds to the primary winding connections, and the downward-facing port to the secondary winding connections
//
// #### Usage
//
// ```
// t1(i) = transformerActive(i, gamma1, gamma2);
// buildtree(A : t1 : B);
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared
// * `gamma1` :  the turn ratio describing the voltage relationship between the primary and secondary coils
// * `gamma2` :  the turn ratio describing the current relationship between the primary and secondary coils
//
// Note: 
// The adaptor must be declared as a separate function before integration into the connection tree.
// It should be used within the connection tree with two forward nodes.
//
// #### Reference
//
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.4.3
//----------------------------------------------------------
declare transformerActive author "Dirk Roosenburg";
declare transformerActive copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare transformerActive license "MIT-style STK-4.3 license";
transformerActive(i, gamma1, gamma2) = genericNode(i, transformerActive_scatter, transformerActive_upPortRes)
with{
    matrix(M,N,f) = si.bus(N) <: ro.interleave(N,M) : par(n,N, par(m,M,*(f(m+1,n+1)))) :> si.bus(M);

    transformerActive_upPortRes(R1) = gamma1*gamma2*R1; //equation for upward-facing port resistance

    transformerActive_scatter(R1) = matrix(2, 2, s)
    with{
        s(1,1) =-1*(R0-gamma1*gamma2*R1)/(R0+gamma1*gamma2*R1);
        s(1,2) = (2*gamma1*R0^rho*R1^(1-rho))/(R0+gamma1*gamma2*R1);
        s(2,1) = (2*gamma2*R0^(1-rho)*R1^rho)/(R0+gamma1*gamma2*R1);
        s(2,2) = (R0-gamma1*gamma2*R1)/(R0+gamma1*gamma2*R1);
        s(i,j) = 10; 

        rho = 1; //assume voltage waves

        R0 = gamma1*gamma2*R1; //adapting condition
    };
};


//===============================Three Port Adaptors======================================
//========================================================================================


//----------------------`(wd.)parallel`--------------------------
// Adapted 3-port parallel connection.
//
// An adaptor implementing a 3-port parallel connection between adaptors for Wave Digital Filter connection trees.
// This adaptor is used to connect adaptors simulating components connected in parallel in the circuit.
//
// #### Usage
//
// ```
// buildtree( A : parallel : (B, C) );
// ```
//
// Note: 
// This adaptor has no user-accessible parameters. 
// It should be used within the connection tree with one previous and two forward adaptors.
//
// #### Reference
//
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.5.1
//----------------------------------------------------------
declare parallel author "Dirk Roosenburg";
declare parallel copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare parallel license "MIT-style STK-4.3 license";
parallel= 
case{
    (0) => par_down
    with{
        par_down = si.bus(5) <: b1, b2;
        b1(R1, R2, a0, a1, a2) = a0 +  a1 * -R1/(R1 + R2) + a2 * R1/(R1 + R2);
        b2(R1, R2, a0, a1, a2) = a0 +  a1 * R2/(R1 + R2) + a2 * -R2/(R1 + R2);
    };
    (1) => par_up
    with{
        par_up = b0;
        b0(R1, R2, a1, a2) = a1 * R2/(R1 + R2) + a2 * R1/(R1 + R2);
    };
    (2) => R0
    with{
        R0(R1, R2) = 1/(1/R1+1/R2); 
    };

};


//----------------------`(wd.)series`--------------------------
// Adapted 3-port series connection.
//
// An adaptor implementing a 3-port series connection between adaptors for Wave Digital Filter connection trees.
// This adaptor is used to connect adaptors simulating components connected in series in the circuit.
//
// #### Usage
//
// ```
//
// tree =  A : (series : (B, C));
// ```
//
// Note: 
// This adaptor has no user-accessible parameters. 
// It should be used within the connection tree with one previous and two forward adaptors.
//
// #### Reference
//
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 1.5.2
//----------------------------------------------------------
declare series author "Dirk Roosenburg";
declare series copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare series license "MIT-style STK-4.3 license";
series= 
case{

    (0) => ser_down
    with{
        ser_down = si.bus(5)<: b1, b2;
        b1(R1, R2, a0, a1, a2) = a0 * -R1/(R1+R2) + a1 * R2/(R1+R2) +  a2 *-R1/(R1+R2);
        b2(R1, R2, a0, a1, a2) = a0 * -R2/(R1+R2) + a1 * -R2/(R1+R2) + a2 * R1/(R1+R2);
    };
    (1) => ser_up
    with{
        ser_up = b0;
        b0(R1, R2, a1, a2) = -a1 - a2;
    };
    (2) => R0
    with{
        R0(R1, R2) = R1 + R2; 
    };
};

//====================================R-Type Adaptors=====================================
//========================================================================================


//----------------------`(wd.)u_sixportPassive`--------------------------
// Unadapted six-port rigid connection.
//
// An adaptor implementing a six-port passive rigid connection between elements. 
// It implements the simplest possible rigid connection found in the Fender Bassman Tonestack circuit
// 
//
// #### Usage
//
// ```
//
// tree =  u_sixportPassive : (A, B, C, D, E, F));
// ```
//
// Note: 
// This adaptor has no user-accessible parameters. 
// It should be used within the connection tree with six forward adaptors.
//
// #### Reference
//
// K. Werner, "Virtual Analog Modeling of Audio Circuitry Using Wave Digital Filters", 2.1.5
//----------------------------------------------------------
declare u_sixportPassive author "Dirk Roosenburg";
declare u_sixportPassive copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare u_sixportPassive license "MIT-style STK-4.3 license";
u_sixportPassive(i) = genericNode(i, sixport_scatter)
with{
    sixport_scatter(Ra, Rb, Rc, Rd, Re, Rf) =  matrix(6, 6, mtx)
    with{
        mtx  =
        case{
            (1, 1) => ((-Ra)*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) + Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf)))/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf   + Rd*(Re + Rf)) +   Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf)));
            (1, 2) => (2*Ra*((Rc + Re)*Rf + Rd*(Re + Rf)))/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) + Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf)));
            (1, 3) => (2*Ra*(Rb*Rd + Re*Rf + Rd*(Re + Rf)))/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) + Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf)));
            (1, 4) => (-1)*((2*Ra*(Rb*(Rc + Re) + Rc*(Re + Rf)))/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) + Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf))));
            (1, 5) => (2*Ra*(Rb*Rd - Rc*Rf))/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) + Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf)));
            (1, 6) => (-1)*((2*Ra*(Rc*Re + Rb*(Rc + Rd + Re)))/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) + Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf))));
            (2, 1) => (2*Rb*((Rc + Re)*Rf + Rd*(Re + Rf)))/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) + Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf)));
            (2, 2) => (Ra*(Rd*Re - Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) - Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf)))/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) +   Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf)));
            (2, 3) => (-1)*((2*Rb*(Ra*Re + Re*Rf + Rd*(Re + Rf)))/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) + Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf))));
            (2, 4) => (-2*Ra*Rb*Re + 2*Rb*Rc*Rf)/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) + Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf)));
            (2, 5) => (2*Rb*(Ra*(Rc + Rd) + Rc*(Rd + Rf)))/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) + Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf)));
            (2, 6) => (-1)*((2*Rb*(Rc*Rd + Ra*(Rc + Rd + Re)))/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) + Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf))));
            (3, 1) => (2*Rc*(Rb*Rd + Re*Rf + Rd*(Re + Rf)))/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) + Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf)));
            (3, 2) => (-1)*((2*Rc*(Ra*Re + Re*Rf + Rd*(Re + Rf)))/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) + Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf))));
            (3, 3) => 1 - (2*Rc*(Rd*Re + Rd*Rf + Re*Rf + Rb*(Rd + Rf) + Ra*(Rb + Re + Rf)))/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) + Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf)));
            (3, 4) => (-1)*((2*Rc*(Rb*Rf + Ra*(Rb + Re + Rf)))/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) + Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf))));
            (3, 5) => (-1)*((2*Rc*(Ra*(Rb + Rf) + Rb*(Rd + Rf)))/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) + Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf))));
            (3, 6) => (2*Rc*(Rb*Rd - Ra*Re))/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) + Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf)));
            (4, 1) => (-1)*((2*Rd*(Rb*(Rc + Re) + Rc*(Re + Rf)))/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) + Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf))));
            (4, 2) => (-2*Ra*Rd*Re + 2*Rc*Rd*Rf)/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) + Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf)));
            (4, 3) => (-1)*((2*Rd*(Rb*Rf + Ra*(Rb + Re + Rf)))/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) + Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf))));
            (4, 4) => 1 - (2*Rd*(Rc*(Re + Rf) + Ra*(Rb + Re + Rf) + Rb*(Rc + Re + Rf)))/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) + Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf)));
            (4, 5) => (-1)*((2*Rd*((Rb + Rc)*Rf + Ra*(Rb + Rf)))/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) + Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf))));
            (4, 6) => (-1)*((2*Rd*((Ra + Rc)*Re + Rb*(Rc + Re)))/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) + Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf))));
            (5, 1) => (2*Re*(Rb*Rd - Rc*Rf))/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) + Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf)));
            (5, 2) => (2*Re*(Ra*(Rc + Rd) + Rc*(Rd + Rf)))/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) + Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf)));
            (5, 3) => (-1)*((2*Re*(Ra*(Rb + Rf) + Rb*(Rd + Rf)))/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) + Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf))));
            (5, 4) => (-1)*((2*Re*((Rb + Rc)*Rf + Ra*(Rb + Rf)))/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) + Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf))));
            (5, 5) => 1 - (2*Re*((Rb + Rc)*(Rd + Rf) + Ra*(Rb + Rc + Rd + Rf)))/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) + Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf)));
            (5, 6) => (2*((Rb + Rc)*Rd + Ra*(Rc + Rd))*Re)/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) + Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf)));
            (6, 1) => (-1)*((2*(Rc*Re + Rb*(Rc + Rd + Re))*Rf)/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) + Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf))));
            (6, 2) => (-1)*((2*(Rc*Rd + Ra*(Rc + Rd + Re))*Rf)/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) + Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf))));
            (6, 3) => (2*(Rb*Rd - Ra*Re)*Rf)/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) + Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf)));
            (6, 4) => (-1)*((2*((Ra + Rc)*Re + Rb*(Rc + Re))*Rf)/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) + Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf))));
            (6, 5) => (2*((Rb + Rc)*Rd + Ra*(Rc + Rd))*Rf)/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) + Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf)));
            (6, 6) => 1 - (2*(Rc*(Rd + Re) + Ra*(Rc + Rd + Re) + Rb*(Rc + Rd + Re))*Rf)/(Ra*(Rd*Re + Rb*(Rc + Rd + Re) + Rd*Rf + Re*Rf + Rc*(Re + Rf)) + Rc*(Re*Rf + Rd*(Re + Rf)) + Rb*(Re*Rf + Rc*(Rd + Rf) + Rd*(Re + Rf)));
            (i, j) => 10;
        };
        matrix(M,N,f) = si.bus(N) <: ro.interleave(N,M) : par(n,N, par(m,M,*(f(m+1,n+1)))) :> si.bus(M);
    };
};

//===============================Node Creating Functions==================================
//========================================================================================

//----------------------`(wd.)genericNode`--------------------------
// Function for generating an adapted node from another faust function or scattering matrix
//
// This function generates a node which is suitable for use in the connection tree structure. 
// genericNode separates the function that it is passed into upward-going and downward-going waves. 
//
// #### Usage
//
// ```
// n1(i) = genericNode(i, scatter, upRes);
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared
// * `scatter` : the function which describes the the node's scattering behavior
// * `upRes` : the function which describes the node's upward-facing port-resistance
//
// Note: 
// `scatter` must be a function with n inputs, n outputs, and n-1 parameter inputs. 
//  input/output 1 will be used as the adapted upward-facing port of the node, ports 2 to n will all be downward-facing. 
//  the first input/output pair is assumed to already be adapted - i.e. the output 1 is not dependent on input 1. 
//  the parameter inputs will receive the port resistances of the downward-facing ports.
//
// `upRes` must be a function with n-1 parameter inputs and 1 output.
//  the parameter inputs will receive the port resistances of the downward-facing ports.
//  the output should give the upward-facing port resistance of the node based on the upward-facing port resistances of the 
//
//  If used on a leaf element (n=1), the model will automatically introduce a one-sample delay. 
//  Thus, the output of the node at sample t based on the input, a[t], should be the output one sample ahead, b[t+1]. 
//  This may require transformation of the output signal. 
//
//----------------------------------------------------------
declare genericNode author "Dirk Roosenburg";
declare genericNode copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare genericNode license "MIT-style STK-4.3 license";
genericNode =
case{
    (0, scatter, upRes) => down(inputs(scatter))
    with{
        down(1) = scatter; //leaf node case
        down(n) = scatter : !, bus(outputs(scatter)-1); //internal node case
    };
    (1, scatter, upRes) => up(inputs(scatter))
    with{
        up(1) = _; //leaf node case
        up(n) = bus(inputs(upRes)), 0 , bus(outputs(scatter)-1) : scatter : _, block(outputs(scatter)-1); //internal node case
    };
    (2, scatter, upRes) => upRes;
}
with{
    bus(0) = 0:!;
    bus(x) = si.bus(x);
    block(0) = 0:!;
    block(x) = si.block(x);
};


//----------------------`(wd.)genericNode_Vout`--------------------------
// Function for generating a terminating/leaf node which gives the voltage across itself as a model output.
//
// This function generates a node which is suitable for use in the connection tree structure. 
// It also calculates the voltage across the element and gives it as a model output
//
// #### Usage
//
// ```
// n1(i) = genericNode_Vout(i, scatter, upRes);
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared
// * `scatter` : the function which describes the the node's scattering behavior
// * `upRes` : the function which describes the node's upward-facing port-resistance
//
// Note: 
// `scatter` must be a function with 1 input and 1 output. 
//  it should give the output from the node based on the incident wave. 
//  
//  The model will automatically introduce a one-sample delay to the output of the function
//  Thus, the output of the node at sample t based on the input, a[t], should be the output one sample ahead, b[t+1]. 
//  This may require transformation of the output signal. 
//
// `upRes` must be a function with no inputs and 1 output.
//  the output should give the upward-facing port resistance of the node
//
//----------------------------------------------------------
declare genericNode_Vout author "Dirk Roosenburg";
declare genericNode_Vout copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare genericNode_Vout license "MIT-style STK-4.3 license";
genericNode_Vout =
case{
    (0, scatter, upRes) => _ <: b, voltage
    with{
        b(a) = a : scatter;
        voltage(a) = 1/2*(a + b(a)');
    };
    (1, scatter, upRes) => _, !;
    (2, scatter, upRes) => upRes;
};

//----------------------`(wd.)genericNode_Iout`--------------------------
// Function for generating a terminating/leaf node which gives the current through itself as a model output.
//
// This function generates a node which is suitable for use in the connection tree structure. 
// It also calculates the current through the element and gives it as a model output
//
// #### Usage
//
// ```
// n1(i) = genericNode_Iout(i, scatter, upRes);
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared
// * `scatter` : the function which describes the the node's scattering behavior
// * `upRes` : the function which describes the node's upward-facing port-resistance
//
// Note: 
// `scatter` must be a function with 1 input and 1 output. 
//  it should give the output from the node based on the incident wave. 
//  
//  The model will automatically introduce a one-sample delay to the output of the function
//  Thus, the output of the node at sample t based on the input, a[t], should be the output one sample ahead, b[t+1]. 
//  This may require transformation of the output signal. 
//
// `upRes` must be a function with no inputs and 1 output.
//  the output should give the upward-facing port resistance of the node
//
//----------------------------------------------------------
declare genericNode_Iout author "Dirk Roosenburg";
declare genericNode_Iout copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare genericNode_Iout license "MIT-style STK-4.3 license";
genericNode_Iout =
case{
    (0, scatter, upRes) => _ <: b, current
    with{
        b(a) = a : scatter;
        current(a) = 1/2/upRes*(a - b(a)');
    };
    (1, scatter, upRes) => _, !;
    (2, scatter, upRes) => upRes;
};


//----------------------`(wd.)u_genericNode`--------------------------
// Function for generating an unadapted node from another Faust function or scattering matrix.
//
// This function generates a node which is suitable for use as the root of the connection tree structure. 
//
// #### Usage
//
// ```
// n1(i) = u_genericNode(i, scatter);
// ```
//
// Where:
//
// * `i`: index used by model-building functions. Should never be user declared
// * `scatter` : the function which describes the the node's scattering behavior
//
// Note: 
// `scatter` must be a function with n inputs, n outputs, and n parameter inputs. 
//  each input/output pair will be used as a downward-facing port of the node
//  the parameter inputs will receive the port resistances of the downward-facing ports.
//
//----------------------------------------------------------
declare u_genericNode author "Dirk Roosenburg";
declare u_genericNode copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare u_genericNode license "MIT-style STK-4.3 license";
u_genericNode =
case{
    (0, scatter) => scatter;
    (1, scatter) => block(inputs(scatter));
    (2, scatter) => 1234;
}
with{
    block(0) = 0:!;
    block(x) = si.block(x);
};


//===============================Model Building Functions=================================
//========================================================================================


//----------------------`(wd.)builddown`--------------------------
// Function for building the structure for calculating waves traveling down the WD connection tree.
//
// It recursively steps through the given tree, parametrizes the adaptors, and builds an algorithm.
// It is used in conjunction with the buildup() function to create a model.
//
// #### Usage
//
// ```
// builddown(A : B)~buildup(A : B);
// ```
//
// Where: 
//  `(A : B)` : is a connection tree composed of WD adaptors
//----------------------------------------------------------
declare builddown author "Dirk Roosenburg";
declare builddown copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare builddown license "MIT-style STK-4.3 license";
builddown(A : As) = ((upPortRes, addins(inputs(A(0)) - outputs(upPortRes))) :  A(0)) , addins(inputs(pardown(As)) - outputs(A(0))) : route(mtxsum(s_mtx(As)), mtxsum(s_mtx(As)), gencross(0, 0, 0, 0, 0, s_mtx(As))) : pardown(As)
with{

    //substitute for si.bus which can accept an argument of 0
    addins = 
    case{
        (0) => 0 : !; 
        (x) => si.bus(x);
    };
    
    //recursively build in parallel
    pardown = 
    case{
        ((Ax, Axx)) => builddown(Ax), pardown(Axx);
        (Ax) => builddown(Ax);
    };
    
    //generate a list of inputs from the next stage down the tree
    s_mtx = 
    case{
        ((Ax, Axx)) => inputs(builddown(Ax)), s_mtx(Axx);
        (Ax) => inputs(builddown(Ax));
    };

    //take the sum of the list
    mtxsum(t_mtx) = sum(i, ba.count(t_mtx), ba.take(i+1, t_mtx));

    upPortRes = parres(As);

    //generate a crossover matrix for the route object based on a list of i/o dimensions
    gencross = 
    case{
        (0, 0, 0, 0, 0, (1, 1)) => 1, 1, 2, 2; 
        (0, 0, 0, 0, 0, (xs, xxs)) => (1, 1), gencross(2, xs+1, ba.count((xs, xxs))-1, 2, mtxsum((xs, xxs)), xxs);

        (0, 0, 0, 0, 0, 0) => 0 : !;
        (0, 0, 0, 0, 0, x) => par(i, x, i+1, i+1);

        //((out, next, norm_index, spec_index, sum), (xs, xxs))

        (msum, msum, count, fcount, msum, xs) => (fcount, msum);  //output is a special output
        (msum, next, count, fcount, msum, xs) => (msum, msum-count); //escape case, reached end of bus

        (out, out, count, fcount, msum, (xs, xxs)) => (fcount, out), gencross(out+1, xs+out, count-1, fcount+1, msum, xxs);
        (out, out, count, fcount, msum, xs) => (fcount, out), gencross(out+1, xs+out, count-1, fcount+1, msum, 0);  //output is a special output

        (out, next, count, fcount, msum, xs) => ((count+out), out), gencross(out+1, next, count, fcount, msum, xs); //output is not a special output
    };
}; 

builddown(A) = A(0); 


//----------------------`(wd.)buildup`--------------------------
// Function for building the structure for calculating waves traveling up the WD connection tree.
//
// It recursively steps through the given tree, parametrizes the adaptors, and builds an algorithm.
// It is used in conjunction with the builddown() function to create a full structure.
//
// #### Usage
//
// ```
// builddown(A : B)~buildup(A : B);
// ```
//
// Where: 
// `(A : B)` : is a connection tree composed of WD adaptors
//----------------------------------------------------------
declare builddown author "Dirk Roosenburg";
declare builddown copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare builddown license "MIT-style STK-4.3 license";
buildup(A : As) = upPortRes, (parup(As) : route(mtxsum(s_mtx(As)), mtxsum(s_mtx(As)), gencross_up(0, 0, 0, 0, 0, s_mtx(As))) : split(s_mtx(As))) : A(1), addins(outputs(split(s_mtx(As))) + outputs(upPortRes) - inputs(A(1))) 
with{

    //substitute for si.bus which can accept an argument of 0
    addins = 
    case{
        (0) => 0 : !; 
        (x) => si.bus(x);
    };

    //recursively build in parallel
    parup =  //<: crossover(out_list(Ap)) : split(out_list(Ap))
    case{
        ((Ax, Axx)) => buildup(Ax), parup(Axx);
        (Ax) => buildup(Ax);
    };

    //generate a list of outputs from the next stage down the tree
    s_mtx = 
    case{
        ((Ax, Axx)) => outputs(buildup(Ax)), s_mtx(Axx);
        (Ax) => outputs(buildup(Ax));
    };
    
    //take the sum of a list
    mtxsum(t_mtx) = sum(i, ba.count(t_mtx), ba.take(i+1, t_mtx));

    //split based on a list of i/o dimensions
    split(inl) = (si.bus(n) <: si.bus(n), si.bus(n)), (addins(s-n))
    with{
        n = ba.count(inl);
        s = inl :> _; 
    };

    //generate a crossover matrix based for the route object based on a list of i/o dimensions
    gencross_up = 
    case{
        //corner case which must be coded manually
        (0, 0, 0, 0, 0, (1, 1)) => 1, 1, 2, 2; 
        //user access function
        (0, 0, 0, 0, 0, (xs, xxs)) => (1, 1), gencross_up(2, xs+1, ba.count((xs, xxs))-1, 2, mtxsum((xs, xxs)), xxs);

        //more corner cases
        (0, 0, 0, 0, 0, 0) => 0: !;
        (0, 0, 0, 0, 0, x) => par(i, x, i+1, i+1);

        //((out, next, norm_index, spec_index, sum), (xs, xxs))

        (msum, msum, count, fcount, msum, xs) => (msum, fcount);  //output is a special output
        (msum, next, count, fcount, msum, xs) => (msum-count, msum); //escape case, reached end of bus

        (out, out, count, fcount, msum, (xs, xxs)) => (out, fcount), gencross_up(out+1, xs+out, count-1, fcount+1, msum, xxs);
        (out, out, count, fcount, msum, xs) => (out, fcount), gencross_up(out+1, xs+out, count-1, fcount+1, msum, 0);  //output is a special output

        (out, next, count, fcount, msum, xs) => (out, (count+out)), gencross_up(out+1, next, count, fcount, msum, xs); //output is not a special output
    };

    upPortRes = parres(As);
};

buildup(A) = A(1);

//----------------------`(wd.)getres`--------------------------
// Function for determining the upward-facing port resistance of a partial WD connection tree.
//
// It recursively steps through the given tree, parametrizes the adaptors, and builds an algorithm.
// It is used by the buildup and builddown functions but is also helpful in testing.
//
// #### Usage
//
// ```
// getres(A : B)~getres(A : B);
// ```
//
// Where: 
// `(A : B)` : is a partial connection tree composed of WD adaptors
//
// Note:
// This function cannot be used on a complete WD tree. When called on an unadapted adaptor (u_ prefix), it will create errors.
//----------------------------------------------------------
declare getres author "Dirk Roosenburg";
declare getres copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare getres license "MIT-style STK-4.3 license";
getres(A: As) = parres(As) : A(2);
getres(A) = A(2); 


//----------------------`(wd.)parres`--------------------------
// Function for determining the upward-facing port resistance of a partial WD connection tree.
//
// It recursively steps through the given tree, parametrizes the adaptors, and builds an algorithm.
// It is used by the buildup and builddown functions but is also helpful in testing.
// This function is a parallelized version of getres.
//
// #### Usage
//
// ```
// parres((A , B))~parres((A , B));
// ```
//
// Where: 
// `(A , B)` : is a partial connection tree composed of WD adaptors
//
// Note:
// This function cannot be used on a complete WD tree. When called on an unadapted adaptor (u_ prefix), it will create errors.
//----------------------------------------------------------
declare parres author "Dirk Roosenburg";
declare parres copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare parres license "MIT-style STK-4.3 license";
parres((Ap1, Ap2)) = getres(Ap1) , parres(Ap2);
parres(Ap) = getres(Ap);


//----------------------`(wd.)buildout`--------------------------
// Function for creating the output matrix for a WD model from a WD connection tree.
//
// It recursively steps through the given tree and creates an output matrix passing only outputs.
//
// #### Usage
//
// ```
// buildout( A : B );
// ```
//
// Where: 
// `(A : B)` : is a connection tree composed of WD adaptors
//
//----------------------------------------------------------
declare buildout author "Dirk Roosenburg";
declare buildout copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare buildout license "MIT-style STK-4.3 license";
buildout(A: As) = parout(As)
with{
    parout((A, Ap)) = buildout(A), parout(Ap);
    parout(A) = buildout(A);
};
buildout(A) = outmtx(outputs(A(0)))
with{
    outmtx(1) = !; 
    outmtx(2) = !, _; 
};


//----------------------`(wd.)buildtree`--------------------------
// Function for building the DSP model from a WD connection tree structure.
//
// It recursively steps through the given tree, parametrizes the adaptors, and builds the algorithm.
//
// #### Usage
//
// ```
// buildtree(A : B);
// ```
//
// Where: 
// `(A : B)` : a connection tree composed of WD adaptors
//----------------------------------------------------------
declare buildtree author "Dirk Roosenburg";
declare buildtree copyright "Copyright (C) 2020 by Dirk Roosenburg <dirk.roosenburg.30@gmail.com>";
declare buildtree license "MIT-style STK-4.3 license";
buildtree((A : B)) = builddown(A : B)~buildup(A : B) : buildout(A : B);



/*******************************************************************************
# Licenses

## STK 4.3 License

Permission is hereby granted, free of charge, to any person obtaining a copy of 
this software and associated documentation files (the "Software"), to deal in 
the Software without restriction, including without limitation the rights to 
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies 
of the Software, and to permit persons to whom the Software is furnished to do 
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all 
copies or substantial portions of the Software.

Any person wishing to distribute modifications to the Software is asked to send 
the modifications to the original developer so that they can be incorporated 
into the canonical version.  For software copyrighted by Dirk Roosenburg, 
email your modifications to <dirk.roosenburg.30@gmail.com>.  This is, however, not a 
binding provision of this license.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE 
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
SOFTWARE.

--------------------------------------------------------------------------------

## LGPL License

This program is free software; you can redistribute it and/or modify it under 
the terms of the GNU Lesser General Public License as published by the Free 
Software Foundation; either version 2.1 of the License, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along 
with the GNU C Library; if not, write to the Free Software Foundation, Inc., 
59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
*******************************************************************************/
//##################################### all.lib ##########################################
// The purpose of this library is to give access to all the Faust standard libraries
// from a single point.
//########################################################################################

import("aanl.lib");
import("analyzers.lib");
import("basics.lib");
import("compressors.lib");
import("delays.lib");
import("demos.lib");
import("dx7.lib");
import("envelopes.lib");
import("fds.lib");
import("filters.lib");
import("hoa.lib");
import("interpolators.lib");
import("maths.lib");
import("mi.lib");
import("misceffects.lib");
import("oscillators.lib");
import("noises.lib");
import("phaflangers.lib");
import("physmodels.lib");
import("quantizers.lib");
import("reducemaps.lib");
import("reverbs.lib");
import("routes.lib");
import("signals.lib");
import("soundfiles.lib");
import("spats.lib");
import("synths.lib");
import("vaeffects.lib");
import("version.lib");
import("wdmodels.lib");
import("webaudio.lib");
//////////////////////////////////////////////////////////////////////////////////////////
// WARNING: Deprecated Library!!
// Read the README file in /libraries for more information
//////////////////////////////////////////////////////////////////////////////////////////

/************************************************************************
 ************************************************************************
    FAUST library file
    Copyright (C) 2003-2012 GRAME, Centre National de Creation Musicale
    ---------------------------------------------------------------------
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as 
    published by the Free Software Foundation; either version 2.1 of the 
    License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with the GNU C Library; if not, write to the Free
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA. 
        
    EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
    larger FAUST program which directly or indirectly imports this library
    file and still distribute the compiled code generated by the FAUST
    compiler, or a modified version of this compiled code, under your own
    copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
    grants you the right to freely choose the license for the resulting
    compiled code. In particular the resulting compiled code has no obligation
    to be LGPL or GPL. For example you are free to choose a commercial or
    closed source license or any other license if you decide so.

 ************************************************************************
 ************************************************************************/

declare name "Music Library";
declare author "GRAME";
declare copyright "GRAME";
declare version "1.0";
declare license "LGPL with exception";
declare deprecated "This library is deprecated and is not maintained anymore. It will be removed in August 2017."; 

import("math.lib");

//-----------------------------------------------
// 					DELAY LINE
//-----------------------------------------------
frac(n)                 = n-int(n);
index(n)                = &(n-1) ~ +(1);                // n = 2**i
//delay(n,d,x)  = rwtable(n, 0.0, index(n), x, (index(n)-int(d)) & (n-1));
delay(n,d,x)    = x@(int(d)&(n-1));
fdelay(n,d,x)   = delay(n,int(d),x)*(1 - frac(d)) + delay(n,int(d)+1,x)*frac(d);


delay1s(d)		= delay(65536,d);
delay2s(d)		= delay(131072,d);
delay5s(d)		= delay(262144,d);
delay10s(d)		= delay(524288,d);
delay21s(d)		= delay(1048576,d);
delay43s(d)		= delay(2097152,d);

fdelay1s(d)		= fdelay(65536,d);
fdelay2s(d)		= fdelay(131072,d);
fdelay5s(d)		= fdelay(262144,d);
fdelay10s(d)	= fdelay(524288,d);
fdelay21s(d)	= fdelay(1048576,d);
fdelay43s(d)	= fdelay(2097152,d);

millisec	= SR/1000.0;

time1s 	= hslider("time", 0, 0,  1000, 0.1)*millisec;
time2s 	= hslider("time", 0, 0,  2000, 0.1)*millisec;
time5s 	= hslider("time", 0, 0,  5000, 0.1)*millisec;
time10s = hslider("time", 0, 0, 10000, 0.1)*millisec;
time21s = hslider("time", 0, 0, 21000, 0.1)*millisec;
time43s = hslider("time", 0, 0, 43000, 0.1)*millisec;


echo1s  = vgroup("echo  1000", +~(delay(65536,   int(hslider("millisecond", 0, 0,	1000, 0.10)*millisec)-1) * (hslider("feedback", 0, 0,  100, 0.1)/100.0)));
echo2s  = vgroup("echo  2000", +~(delay(131072,  int(hslider("millisecond", 0, 0,	2000, 0.25)*millisec)-1) * (hslider("feedback", 0, 0,  100, 0.1)/100.0)));
echo5s  = vgroup("echo  5000", +~(delay(262144,  int(hslider("millisecond", 0, 0,	5000, 0.50)*millisec)-1) * (hslider("feedback", 0, 0,  100, 0.1)/100.0)));
echo10s = vgroup("echo 10000", +~(delay(524288,  int(hslider("millisecond", 0, 0,  10000, 1.00)*millisec)-1) * (hslider("feedback", 0, 0,  100, 0.1)/100.0)));
echo21s = vgroup("echo 21000", +~(delay(1048576, int(hslider("millisecond", 0, 0,  21000, 1.00)*millisec)-1) * (hslider("feedback", 0, 0,  100, 0.1)/100.0)));
echo43s = vgroup("echo 43000", +~(delay(2097152, int(hslider("millisecond", 0, 0,  43000, 1.00)*millisec)-1) * (hslider("feedback", 0, 0,  100, 0.1)/100.0)));


//--------------------------sdelay(N,it,dt)----------------------------
// s(mooth)delay : a mono delay that doesn't click and doesn't 
// transpose when the delay time is changed. It takes 4 input signals 
// and produces a delayed output signal
//
// USAGE : 	... : sdelay(N,it,dt) : ...
//
// Where :
//	<N>  = maximal delay in samples (must be a constant power of 2, for example 65536)
//	<it> = interpolation time (in samples) for example 1024
//	<dt> = delay time (in samples)
//  <  > = input signal we want to delay
//--------------------------------------------------------------------------

sdelay(N, it, dt) = ctrl(it,dt),_ : ddi(N)

	with {

		//---------------------------ddi(N,i,d0,d1)-------------------------------
		//	DDI (Double Delay with Interpolation) : the input signal is sent to two
		//	delay lines. The outputs of these delay lines are crossfaded with 
		//	an interpolation stage. By acting on this interpolation value one 
		//	can move smoothly from one delay to another. When <i> is 0 we can 
		//	freely change the delay time <d1> of line 1, when it is 1 we can freely change
		//	the delay time <d0> of line 0.
		//
		//	<N>  = maximal delay in samples (must be a power of 2, for example 65536)
		//	<i>  = interpolation value between 0 and 1 used to crossfade the outputs of the 
		//		   two delay lines (0.0: first delay line, 1.0: second delay line)
		//	<d0> = delay time of delay line 0 in samples between 0 and <N>-1
		//	<d1> = delay time of delay line 1 in samples between 0 and <N>-1
		//  <  > = the input signal we want to delay
		//-------------------------------------------------------------------------
		ddi(N, i, d0, d1) = _ <: delay(N,d0), delay(N,d1) : interpolate(i);


		//----------------------------ctrl(it,dt)------------------------------------
		// 	Control logic for a Double Delay with Interpolation according to two 
		//
		//	USAGE : ctrl(it,dt)
		//  where : 
		//	<it> an interpolation time (in samples, for example 256)
		//	<dt> a delay time (in samples)
		//
		//	ctrl produces 3 outputs : an interpolation value <i> and two delay 
		//	times <d0> and <d1>. These signals are used to control a ddi (Double Delay with Interpolation). 
		//	The principle is to detect changes in the input delay time dt, then to 
		//	change the delay time of the delay line currently unused and then by a
		//	smooth crossfade to remove the first delay line and activate the second one.
		//
		//	The control logic has an internal state controlled by 4 elements
		//	<v> : the interpolation variation (0, 1/it, -1/it)
		//	<i> : the interpolation value (between 0 and 1)
		//	<d0>: the delay time of line 0
		//	<d1>: the delay time of line 1
		//
		//	Please note that the last stage (!,_,_,_) cut <v> because it is only 
		//	used internally.
		//-------------------------------------------------------------------------
		ctrl(it, dt) = \(v,ip,d0,d1).( (nv, nip, nd0, nd1) 
			with {

				// interpolation variation
				nv = if (v!=0.0, 							// if variation we are interpolating
						if( (ip>0.0) & (ip<1.0), v , 0),	// 		should we continue or not ?
					 if ((ip==0.0) & (dt!=d0),  1.0/it,		// if true xfade from dl0 to dl1
					 if ((ip==1.0) & (dt!=d1), -1.0/it,		// if true xfade from dl1 to dl0	
					 0)));									// nothing to change
				// interpolation value
				nip = ip+nv : min(1.0) : max(0.0);

				// update delay time of line 0 if needed
				nd0 = if ((ip >= 1.0) & (d1!=dt), dt, d0);

				// update delay time of line 0 if needed
				nd1 = if ((ip <= 0.0) & (d0!=dt), dt, d1);

			} ) ~ (_,_,_,_) : (!,_,_,_);
	};




//-----------------------------------------------
// 			Tempo, beats and pulses
//-----------------------------------------------

tempo(t) 	= (60*SR)/t;			// tempo(t) -> samples

period(p) 	= %(int(p))~+(1);		// signal en dent de scie de periode p
pulse(t) 	= period(t)==0;			// pulse (10000...) de periode p
pulsen(n,t) = period(t)<n;			// pulse (1110000...) de taille n et de periode p
beat(t) 	= pulse(tempo(t));		// pulse au tempo t



//-----------------------------------------------
// 	conversions between db and linear values
//-----------------------------------------------

db2linear(x)	= pow(10, x/20.0);
linear2db(x)	= 20*log10(x);





//===============================================
// 			Random and Noise generators
//===============================================


//-----------------------------------------------
// 			noise : Noise generator
//-----------------------------------------------

random 		= +(12345) ~ *(1103515245); // "linear congruential"
RANDMAX		= 2147483647.0; // = 2^31-1 = MAX_SIGNED_INT in 32 bits

noise 		= random / RANDMAX;


//-----------------------------------------------
// Generates multiple decorrelated random numbers 
// in parallel. Expects n>0.
//-----------------------------------------------

multirandom(n) = randomize(n) ~_
with {
	randomize (1) 	= +(12345) : *(1103515245);
	randomize (n) 	= randomize(1) <: randomize(n-1),_;
};


//-----------------------------------------------
// Generates multiple decorrelated noises
// in parallel. Expects n>0.
//-----------------------------------------------

multinoise(n) = multirandom(n) : par(i,n,/(RANDMAX)) 
with { 
	RANDMAX = 2147483647.0; 
};


//------------------------------------------------

noises(N,i) = multinoise(N) : selector(i,N);
 

//-----------------------------------------------
// 			osc(freq) : Sinusoidal Oscillator
//-----------------------------------------------

tablesize 	= 1 << 16;
samplingfreq	= SR;

time 		= (+(1)~_ ) - 1; 			// 0,1,2,3,...
sinwaveform 	= float(time)*(2.0*PI)/float(tablesize) : sin;
coswaveform 	= float(time)*(2.0*PI)/float(tablesize) : cos;

decimal(x)	= x - floor(x);
phase(freq) 	= freq/float(samplingfreq) : (+ : decimal) ~ _ : *(float(tablesize));
oscsin(freq)	= rdtable(tablesize, sinwaveform, int(phase(freq)) );
osccos(freq)	= rdtable(tablesize, coswaveform, int(phase(freq)) );
oscp(freq,p)	= oscsin(freq) * cos(p) + osccos(freq) * sin(p);
osc		= oscsin;
osci(freq)	= s1 + d * (s2 - s1)
		with {
			i = int(phase(freq));
			d = decimal(phase(freq));
			s1 = rdtable(tablesize+1,sinwaveform,i);
			s2 = rdtable(tablesize+1,sinwaveform,i+1);};


//-----------------------------------------------
// 			ADSR envelop
//-----------------------------------------------

// a,d,s,r = attack (sec), decay (sec), sustain (percentage of t), release (sec)
// t       = trigger signal ( >0 for attack, then release is when t back to 0)

adsr(a,d,s,r,t) = env ~ (_,_) : (!,_) // the 2 'state' signals are fed back
with {
    env (p2,y) =
        (t>0) & (p2|(y>=1)),          // p2 = decay-sustain phase
        (y + p1*u - (p2&(y>s))*v*y - p3*w*y)	// y  = envelop signal
	*((p3==0)|(y>=eps)) // cut off tails to prevent denormals
    with {
	p1 = (p2==0) & (t>0) & (y<1);         // p1 = attack phase
	p3 = (t<=0) & (y>0);                  // p3 = release phase
	// #samples in attack, decay, release, must be >0
	na = SR*a+(a==0.0); nd = SR*d+(d==0.0); nr = SR*r+(r==0.0);
	// correct zero sustain level
	z = s+(s==0.0)*db2linear(-60);
	// attack, decay and (-60dB) release rates
	u = 1/na; v = 1-pow(z, 1/nd); w = 1-1/pow(z*db2linear(60), 1/nr);
	// values below this threshold are considered zero in the release phase
	eps = db2linear(-120);
    };
};


//-----------------------------------------------
// 			Spatialisation
//-----------------------------------------------

panner(c) = _ <: *(1-c), *(c);

bus2 = _,_;
bus3 = _,_,_;
bus4 = _,_,_,_;
bus5 = _,_,_,_,_;
bus6 = _,_,_,_,_,_;
bus7 = _,_,_,_,_,_,_;
bus8 = _,_,_,_,_,_,_,_;

gain2(g) = *(g),*(g);
gain3(g) = *(g),*(g),*(g);
gain4(g) = *(g),*(g),*(g),*(g);
gain5(g) = *(g),*(g),*(g),*(g),*(g);
gain6(g) = *(g),*(g),*(g),*(g),*(g),*(g);
gain7(g) = *(g),*(g),*(g),*(g),*(g),*(g),*(g);
gain8(g) = *(g),*(g),*(g),*(g),*(g),*(g),*(g),*(g);


//------------------------------------------------------
//
// 					    GMEM SPAT
//	n-outputs spatializer
//	implementation of L. Pottier 
//
//------------------------------------------------------
// 
//  n = number of outputs
//	r = rotation (between 0 et 1)
// 	d = distance of the source (between 0 et 1)
//
//------------------------------------------------------
spat(n,a,d)	= _ <: par(i, n, *( scaler(i, n, a, d) : smooth(0.9999) ))
	with {
		scaler(i,n,a,d) = (d/2.0+0.5) 
						* sqrt( max(0.0, 1.0 - abs(fmod(a+0.5+float(n-i)/n, 1.0) - 0.5) * n * d) );
		smooth(c) = *(1-c) : +~*(c);
	};



//--------------- Second Order Generic Transfert Function -------------------------
// TF2(b0,b1,b2,a1,a2)
//
//---------------------------------------------------------------------------------

TF2(b0,b1,b2,a1,a2) = sub ~ conv2(a1,a2) : conv3(b0,b1,b2)
	with {
		conv3(k0,k1,k2,x) 	= k0*x + k1*x' + k2*x'';
		conv2(k0,k1,x) 		= k0*x + k1*x';
		sub(x,y)			= y-x;
	};


/*************************** Break Point Functions ***************************

bpf is an environment (a group of related definitions) that can be used to 
create break-point functions. It contains three functions : 
  - start(x,y) to start a break-point function
  - end(x,y) to end a break-point function
  - point(x,y) to add intermediate points to a break-point function

A minimal break-point function must contain at least a start and an end point :

  f = bpf.start(x0,y0) : bpf.end(x1,y1);

A more involved break-point function can contains any number of intermediate 
points

  f = bpf.start(x0,y0) : bpf.point(x1,y1) : bpf.point(x2,y2) : bpf.end(x3,y3);

In any case the x_{i} must be in increasing order (for all i, x_{i} < x_{i+1})

For example the following definition :

  f = bpf.start(x0,y0) : ... : bpf.point(xi,yi) : ... : bpf.end(xn,yn);

implements a break-point function f such that :

  f(x) = y_{0} when x < x_{0}
  f(x) = y_{n} when x > x_{n}
  f(x) = y_{i} + (y_{i+1}-y_{i})*(x-x_{i})/(x_{i+1}-x_{i}) when x_{i} <= x and x < x_{i+1} 

******************************************************************************/

bpf = environment 
{
  // Start a break-point function
  start(x0,y0) = \(x).(x0,y0,x,y0);

  // Add a break-point
  point(x1,y1) = \(x0,y0,x,y).(x1, y1, x , if (x < x0, y, if (x < x1, y0 + (x-x0)*(y1-y0)/(x1-x0), y1)));

  // End a break-point function
  end  (x1,y1) = \(x0,y0,x,y).(if (x < x0, y, if (x < x1, y0 + (x-x0)*(y1-y0)/(x1-x0), y1)));

  // definition of if
  if (c,t,e) = select2(c,e,t);
};


//----------------------------------Stereoize------------------------------
// Transform an arbitrary processor p into a stereo processor with 2 inputs
// and 2 outputs.
//-----------------------------------------------------------------------
stereoize(p) = S(inputs(p), outputs(p))
	with {
	  // degenerated processor with no outputs
		S(n,0) = !,! : 0,0; 		// just in case, probably a rare case

	  // processors with no inputs
		S(0,1) = !,! : p <: _,_; 	// add two fake inputs and split output
		S(0,2) = !,! : p;
		S(0,n) = !,! : p,p :> _,_;	// we are sure this will work if n is odd
 
	  // processors with one input
		S(1,1) = p,p; 				// add two fake inputs and split output
		S(1,n) = p,p :> _,_;		// we are sure this will work if n is odd
 
	  // processors with two inputs
		S(2,1) = p <: _,_; 			// split the output
		S(2,2) = p; 				// nothing to do, p is already stereo
 
	  // processors with inputs > 2 and outputs > 2
		S(n,m) = _,_ <: p,p :> _,_;	// we are sure this works if n or p are odd
	};


//----------------------------------Recursivize------------------------------
// Create a recursion from two arbitrary processors p and q 
//-----------------------------------------------------------------------
recursivize(p,q) = (_,_,_,_ :> stereoize(p)) ~ stereoize(q);


//----------------------------------Automat------------------------------
// Record and replay to the values the input signal in a loop
//
// USAGE: hslider(...) : automat(360, 15, 0.0)
//-----------------------------------------------------------------------

automat(bps, size, init, input) = rwtable(size+1, init, windex, input, rindex)
	with {
		clock 	= beat(bps);
		rindex 	= int(clock) : (+ : %(size)) ~ _;		// each clock read the next entry of the table
		windex 	= if (timeToRenew, rindex, size);		// we ignore input unless it is time to renew
		if(cond,thn,els) = select2(cond,els,thn);
		timeToRenew 	= int(clock) & (inputHasMoved | (input <= init));	
		inputHasMoved 	= abs(input-input') : countfrom(int(clock)') : >(0);
		countfrom(reset) = (+ : if(reset, 0, _)) ~ _;
	};


//----------------------------------bsmooth------------------------------
// bsmooth : (block smooth) linear interpolation during a block of samples
//
// USAGE: hslider(...) : bsmooth
//-----------------------------------------------------------------------

bsmooth(c) = +(i) ~ _
	with { 
		i = (c-c@n)/n;
		n = min(4096, max(1, fvariable(int count, <math.h>)));
	};


//--------------------------------chebychev-------------------------------
// chebychev(n) : chebychev transformation of order n
// USAGE: _ : chebychev(3) : _
//
//
// Semantics:
//	T[0](x) = 1,
//	T[1](x) = x,
//	T[n](x) = 2x*T[n-1](x) - T[n-2](x)
//
//	see : http://en.wikipedia.org/wiki/Chebyshev_polynomial
//-------------------------------------------------------------------------

chebychev(0) = !:1;
chebychev(1) = _;
chebychev(n) = _ <: *(2)*chebychev(n-1)-chebychev(n-2);



//--------------------------------chebychevpoly-------------------------------
//	chebychevpoly((c0,c1,...,cn)) : linear combination of the first Chebyshev polynomials
// 	USAGE: _ : chebychevpoly((0.1,0.8,0.1)) : _
//
//
// Semantics:
// 	chebychevpoly((c0,c1,...,cn)) = Sum of chebychev(i)*ci
//  see : http://www.csounds.com/manual/html/chebyshevpoly.html
//-------------------------------------------------------------------------

chebychevpoly(lcoef) = _ <: L(0,lcoef) :> _
	with {
		L(n,(c,cs)) = chebychev(n)*c, L(n+1,cs);
		L(n,c)      = chebychev(n)*c;
	};

/******************************************************************************
 **  Guitar(ix) tube amp emulations
 **
 **
 **  this tubes.library provide the following tube models:
 **  T1_12AX7, T2_12AX7, T3_12AX7, T1_12AT7, T2_12AT7, T3_12AT7,
 **  T1_12AU7, T2_12AU7, T3_12AU7, T1_6V6, T2_6V6, T3_6V6,
 **  T1_6DJ8, T2_6DJ8, T3_6DJ8, T1_6C16, T2_6C16, T3_6C16
 **
 **
 **  USAGE:
 **        _ : component("tubes.lib").model : _
 **  where
 **       model is on of the models above.
 **
 **  EXAMPLE 2 STAGE TUBE PREAMP:
 **    process = component("tubes.lib").T1_12AX7 : *(preamp):
 **      lowpass(1,6531.0) : component("tubes.lib").T2_12AX7 : *(preamp):
 **      lowpass(1,6531.0) : component("tubes.lib").T3_12AX7 : *(gain) with {
 **      preamp = vslider("Pregain",-6,-20,20,0.1) : db2linear : smooth(0.999);
 **      gain  = vslider("Gain", -6, -20.0, 20.0, 0.1) : db2linear : smooth(0.999);
 **    };
 **
 ******************************************************************************/

fi = library("filters.lib");

/*******************************************************************************
  * 1-dimensional function tables for linear interpolation
*******************************************************************************/

//-- Rdtable from waveform
rtable(table, r) = (table, int(r)):rdtable;

// Change sign of input signal x;
inverse(x) = abs(x) * invsign(x);

// function that takes f value and x sign
ccopysign(f, x) = abs(f) * sign(x);

//-- Get sign and reversed sign of a signal x
sign(x) = x<0, 1, -1 : select2;
invsign(x) = x<0, -1, 1 : select2;

//-- Interpolate value between i and i+1 in table with coefficient f.
interpolation(table, f, i) = rtable(table, i)*(1-f) + rtable(table,i+1)*f;

//-- Bound Index with table boundaries
boundIndex(size, index) = index : floor: min(size-1) : max(0);

//-- Bound factor of interpolation :
//if index<0 return 0 | if index>size-1 return size-1
boundFactor(size, factor, index) =
  select2(0<index, boundupperFactor(size, factor, index), 0)
with {
  boundupperFactor(size, factor, index) =
    select2(index<size-1, size-1, factor - index);
};

// Linear interpolation of x value in table
tubeF(table, low, high, step, size, x) =
  interpolation(table,getFactor(low, step, size, x),
  linindex(low, step, x) : boundIndex(size));

//--Get interpolation factor
getFactor(low, step, size, x) =
  boundFactor(size, linindex(low, step, x), linindex(low, step, x) :
  boundIndex(size));

 //-- Calculate linear index
 linindex(low, step, x) = (x - low) * step;

 /******************************************************************************
 ******************************************************************************/

tubestageF(tb,vplus,divider,fck,Rk,Vk0) = tube : hpf with {
    lpfk = fi.lowpass(1,fck);
    Rp = 100.0e3;
    VkC = Vk0 * (Rp/Rk);

// Characteristics of the tubes
    low = -5;
    high = 5;
    step = 200;
    size = 2000; // (real size = 2001, set the actual size at 2001-1 for interpolation to work at the last point)

    tube = (+ : -(Vk0) : tubeF(tb, low, high, step, size) : +(VkC-vplus)) ~ (*(Rk/Rp) : lpfk) : /(divider);
    hpf = fi.highpass(1,31.0);
};

tubestage(tb,fck,Rk,Vk0)       = tubestageF(tb,250.0,40.0,fck,Rk,Vk0);
tubestage130_20(tb,fck,Rk,Vk0) = tubestageF(tb,130.0,20.0,fck,Rk,Vk0);

/********************* basic tube settings to model stage 1 - 2 *************************/

T1_12AX7 = tubestage(tubetable_12AX7_0,86.0,2700.0,1.581656);
T2_12AX7 = tubestage(tubetable_12AX7_1,132.0,1500.0,1.204285);
T3_12AX7 = tubestage(tubetable_12AX7_1,194.0,820.0,0.840703);
T1_12AT7 = tubestage(tubetable_12AT7_0,86.0,2700.0,2.617753);
T2_12AT7 = tubestage(tubetable_12AT7_1,132.0,1500.0,1.887332);
T3_12AT7 = tubestage(tubetable_12AT7_1,194.0,820.0,1.256962);
T1_12AU7 = tubestage(tubetable_12AU7_0,86.0,2700.0,3.718962);
T2_12AU7 = tubestage(tubetable_12AU7_1,132.0,1500.0,2.314844);
T3_12AU7 = tubestage(tubetable_12AU7_1,194.0,820.0,1.356567);
T1_6V6   = tubestage(tubetable_6V6_0,86.0,2700.0,2.296150);
T2_6V6   = tubestage(tubetable_6V6_1,132.0,1500.0,1.675587);
T3_6V6   = tubestage(tubetable_6V6_1,194.0,820.0,1.130462);
T1_6DJ8  = tubestage130_20(tubetable_6DJ8_0,86.0,2700.0,1.863946);
T2_6DJ8  = tubestage130_20(tubetable_6DJ8_1,132.0,1500.0,1.271609);
T3_6DJ8  = tubestage130_20(tubetable_6DJ8_0,194.0,820.0,0.799031);
T1_6C16  = tubestage(tubetable_6C16_0,86.0,2700.0,2.921806);
T2_6C16  = tubestage(tubetable_6C16_1,132.0,1500.0,2.097743);
T3_6C16  = tubestage(tubetable_6C16_1,194.0,820.0,1.378742);

/****************************************************************************************
*	declare all the waveforms
****************************************************************************************/

// generated by ../../tools/tube_transfer.py
// tube: 6C16
// plate current function: triode
// mu: 42.2
// kx: 2.21
// kg1: 393
// kp: 629
// kvb: 446

tubetable_6C16_0 = waveform{
	214.806581677,214.650587712,214.494441388,214.338143449,214.181694635,
	214.025095677,213.868347304,213.711450238,213.554405194,213.397212884,
	213.239874013,213.082389282,212.924759385,212.766985013,212.60906685,
	212.451005576,212.292801864,212.134456385,211.975969802,211.817342776,
	211.658575961,211.499670005,211.340625555,211.181443251,211.022123727,
	210.862667614,210.703075539,210.543348122,210.383485982,210.22348973,
	210.063359973,209.903097317,209.742702359,209.582175694,209.421517913,
	209.260729602,209.099811343,208.938763714,208.777587287,208.616282633,
	208.454850316,208.293290899,208.131604938,207.969792986,207.807855593,
	207.645793304,207.483606661,207.321296202,207.15886246,206.996305965,
	206.833627244,206.67082682,206.507905211,206.344862933,206.181700497,
	206.018418412,205.855017182,205.691497309,205.527859289,205.364103618,
	205.200230785,205.036241278,204.872135582,204.707914176,204.543577538,
	204.379126141,204.214560458,204.049880955,203.885088096,203.720182343,
	203.555164155,203.390033984,203.224792285,203.059439505,202.893976089,
	202.728402482,202.562719123,202.396926447,202.23102489,202.065014882,
	201.898896852,201.732671223,201.56633842,201.399898861,201.233352963,
	201.066701141,200.899943805,200.733081363,200.566114223,200.399042787,
	200.231867455,200.064588626,199.897206695,199.729722054,199.562135094,
	199.394446202,199.226655764,199.058764161,198.890771775,198.722678983,
	198.554486159,198.386193678,198.217801909,198.04931122,197.880721977,
	197.712034543,197.54324928,197.374366545,197.205386696,197.036310087,
	196.86713707,196.697867994,196.528503206,196.359043053,196.189487877,
	196.019838019,195.850093818,195.680255611,195.510323732,195.340298515,
	195.170180288,194.999969382,194.829666122,194.659270832,194.488783835,
	194.318205451,194.147535999,193.976775794,193.805925153,193.634984386,
	193.463953805,193.292833719,193.121624434,192.950326255,192.778939486,
	192.607464428,192.43590138,192.264250641,192.092512505,191.920687267,
	191.74877522,191.576776653,191.404691857,191.232521118,191.060264721,
	190.887922951,190.715496088,190.542984415,190.370388209,190.197707747,
	190.024943305,189.852095157,189.679163575,189.50614883,189.33305119,
	189.159870923,188.986608295,188.813263571,188.639837013,188.466328882,
	188.292739439,188.119068941,187.945317645,187.771485807,187.597573681,
	187.423581518,187.249509571,187.075358088,186.901127317,186.726817506,
	186.552428899,186.377961741,186.203416274,186.028792738,185.854091375,
	185.679312422,185.504456116,185.329522693,185.154512388,184.979425434,
	184.804262062,184.629022504,184.453706988,184.278315742,184.102848994,
	183.927306968,183.751689889,183.57599798,183.400231463,183.224390558,
	183.048475484,182.872486461,182.696423704,182.520287429,182.344077852,
	182.167795186,181.991439642,181.815011432,181.638510767,181.461937854,
	181.285292902,181.108576118,180.931787707,180.754927872,180.577996819,
	180.400994749,180.223921863,180.046778361,179.869564443,179.692280306,
	179.514926148,179.337502164,179.16000855,178.982445499,178.804813204,
	178.627111857,178.449341649,178.27150277,178.093595408,177.915619752,
	177.737575989,177.559464305,177.381284884,177.203037911,177.024723568,
	176.846342039,176.667893504,176.489378144,176.310796138,176.132147665,
	175.953432902,175.774652027,175.595805214,175.416892639,175.237914476,
	175.058870898,174.879762077,174.700588185,174.521349393,174.342045871,
	174.162677786,173.983245308,173.803748604,173.624187839,173.444563181,
	173.264874792,173.085122839,172.905307483,172.725428887,172.545487212,
	172.365482621,172.185415271,172.005285324,171.825092937,171.644838268,
	171.464521474,171.284142712,171.103702136,170.923199902,170.742636163,
	170.562011074,170.381324785,170.20057745,170.019769219,169.838900242,
	169.65797067,169.476980651,169.295930334,169.114819866,168.933649395,
	168.752419065,168.571129024,168.389779415,168.208370384,168.026902072,
	167.845374625,167.663788182,167.482142887,167.300438881,167.118676302,
	166.936855292,166.754975989,166.573038531,166.391043057,166.208989703,
	166.026878606,165.844709901,165.662483725,165.480200212,165.297859496,
	165.11546171,164.933006988,164.750495462,164.567927263,164.385302523,
	164.202621372,164.019883941,163.837090358,163.654240754,163.471335255,
	163.288373991,163.105357087,162.922284672,162.739156871,162.555973809,
	162.372735612,162.189442404,162.00609431,161.822691453,161.639233955,
	161.45572194,161.272155529,161.088534844,160.904860005,160.721131134,
	160.537348349,160.353511771,160.169621519,159.98567771,159.801680463,
	159.617629896,159.433526124,159.249369266,159.065159437,158.880896752,
	158.696581327,158.512213277,158.327792715,158.143319755,157.958794511,
	157.774217096,157.589587621,157.4049062,157.220172943,157.035387961,
	156.850551366,156.665663268,156.480723775,156.295732998,156.110691046,
	155.925598028,155.74045405,155.555259222,155.37001365,155.184717441,
	154.999370702,154.813973539,154.628526057,154.443028363,154.25748056,
	154.071882754,153.886235049,153.700537548,153.514790354,153.328993572,
	153.143147302,152.957251649,152.771306713,152.585312596,152.3992694,
	152.213177225,152.027036171,151.840846339,151.654607829,151.46832074,
	151.28198517,151.09560122,150.909168986,150.722688568,150.536160062,
	150.349583566,150.162959178,149.976286994,149.78956711,149.602799623,
	149.415984628,149.22912222,149.042212495,148.855255548,148.668251473,
	148.481200364,148.294102315,148.106957419,147.919765771,147.732527463,
	147.545242587,147.357911237,147.170533503,146.983109479,146.795639255,
	146.608122923,146.420560573,146.232952297,146.045298185,145.857598327,
	145.669852813,145.482061732,145.294225174,145.106343228,144.918415983,
	144.730443527,144.542425949,144.354363336,144.166255777,143.978103358,
	143.789906168,143.601664294,143.413377821,143.225046837,143.036671428,
	142.848251681,142.65978768,142.471279512,142.282727262,142.094131015,
	141.905490856,141.71680687,141.528079142,141.339307755,141.150492794,
	140.961634343,140.772732485,140.583787303,140.394798882,140.205767303,
	140.016692651,139.827575006,139.638414453,139.449211072,139.259964947,
	139.070676158,138.881344788,138.691970919,138.50255463,138.313096004,
	138.123595121,137.934052062,137.744466908,137.554839739,137.365170636,
	137.175459677,136.985706944,136.795912515,136.606076471,136.416198891,
	136.226279854,136.036319439,135.846317724,135.65627479,135.466190714,
	135.276065574,135.08589945,134.895692419,134.70544456,134.515155949,
	134.324826666,134.134456787,133.94404639,133.753595552,133.563104351,
	133.372572864,133.182001167,132.991389337,132.800737452,132.610045587,
	132.41931382,132.228542226,132.037730882,131.846879864,131.655989247,
	131.465059109,131.274089524,131.083080569,130.892032318,130.700944849,
	130.509818235,130.318652552,130.127447876,129.936204281,129.744921843,
	129.553600637,129.362240737,129.170842219,128.979405156,128.787929624,
	128.596415698,128.404863451,128.213272959,128.021644295,127.829977533,
	127.638272749,127.446530017,127.254749409,127.062931001,126.871074867,
	126.679181079,126.487249713,126.295280842,126.103274541,125.911230881,
	125.719149938,125.527031786,125.334876497,125.142684145,124.950454804,
	124.758188548,124.565885449,124.373545582,124.18116902,123.988755837,
	123.796306105,123.603819898,123.41129729,123.218738354,123.026143164,
	122.833511792,122.640844313,122.448140799,122.255401324,122.062625961,
	121.869814784,121.676967866,121.484085281,121.291167101,121.098213401,
	120.905224253,120.712199732,120.51913991,120.326044862,120.132914661,
	119.93974938,119.746549093,119.553313874,119.360043796,119.166738933,
	118.973399359,118.780025148,118.586616373,118.393173109,118.19969543,
	118.006183409,117.81263712,117.619056639,117.425442039,117.231793394,
	117.038110779,116.844394268,116.650643936,116.456859857,116.263042107,
	116.069190759,115.87530589,115.681387573,115.487435884,115.293450898,
	115.09943269,114.905381337,114.711296912,114.517179492,114.323029153,
	114.128845971,113.93463002,113.740381379,113.546100122,113.351786326,
	113.157440068,112.963061424,112.768650472,112.574207287,112.379731948,
	112.185224531,111.990685114,111.796113774,111.601510589,111.406875638,
	111.212208997,111.017510746,110.822780964,110.628019727,110.433227116,
	110.238403209,110.043548087,109.848661827,109.65374451,109.458796215,
	109.263817024,109.068807015,108.87376627,108.678694869,108.483592894,
	108.288460425,108.093297545,107.898104334,107.702880875,107.507627251,
	107.312343543,107.117029835,106.921686209,106.726312749,106.530909539,
	106.335476663,106.140014205,105.944522249,105.749000881,105.553450185,
	105.357870248,105.162261155,104.966622992,104.770955847,104.575259805,
	104.379534954,104.183781382,103.987999177,103.792188428,103.596349222,
	103.40048165,103.204585801,103.008661765,102.812709632,102.616729493,
	102.420721441,102.224685566,102.02862196,101.832530717,101.636411929,
	101.440265691,101.244092096,101.047891239,100.851663216,100.655408121,
	100.459126052,100.262817104,100.066481377,99.8701189658,99.673729971,
	99.477314491,99.2808726256,99.0844044752,98.8879101407,98.6913897236,
	98.4948433264,98.2982710519,98.1016730037,97.9050492862,97.7084000044,
	97.5117252641,97.3150251718,97.1182998349,96.9215493615,96.7247738603,
	96.5279734411,96.3311482144,96.1342982917,95.9374237851,95.7405248079,
	95.5436014741,95.3466538988,95.1496821978,94.9526864881,94.7556668877,
	94.5586235156,94.3615564917,94.1644659371,93.9673519741,93.7702147259,
	93.5730543171,93.3758708733,93.1786645213,92.9814353893,92.7841836066,
	92.5869093039,92.3896126132,92.1922936679,91.9949526028,91.7975895541,
	91.6002046595,91.4027980582,91.205369891,91.0079203002,90.8104494298,
	90.6129574255,90.4154444347,90.2179106065,90.0203560919,89.8227810438,
	89.6251856168,89.4275699678,89.2299342554,89.0322786405,88.8346032859,
	88.636908357,88.4391940209,88.2414604476,88.0437078089,87.8459362796,
	87.6481460367,87.4503372598,87.2525101312,87.0546648361,86.8568015623,
	86.6589205007,86.461021845,86.2631057922,86.0651725422,85.8672222985,
	85.6692552677,85.47127166,85.2732716892,85.0752555725,84.8772235314,
	84.6791757908,84.4811125799,84.2830341322,84.084940685,83.8868324806,
	83.6887097654,83.4905727907,83.2924218127,83.0942570925,82.8960788963,
	82.6978874958,82.499683168,82.3014661959,82.1032368679,81.9049954788,
	81.7067423296,81.5084777275,81.3102019866,81.1119154278,80.9136183791,
	80.7153111759,80.516994161,80.3186676851,80.1203321072,79.9219877944,
	79.7236351224,79.5252744761,79.3269062494,79.1285308459,78.9301486789,
	78.7317601719,78.533365759,78.3349658854,78.1365610071,77.9381515922,
	77.7397381206,77.5413210848,77.34290099,77.1444783551,76.9460537123,
	76.7476276085,76.5492006051,76.350773279,76.1523462226,75.9539200451,
	75.7554953721,75.5570728472,75.3586531317,75.160236906,74.9618248697,
	74.7634177425,74.5650162649,74.3666211991,74.1682333293,73.969853463,
	73.7714824312,73.57312109,73.3747703208,73.1764310315,72.9781041575,
	72.7797906624,72.5814915392,72.3832078112,72.1849405333,71.9866907928,
	71.7884597106,71.5902484426,71.3920581808,71.1938901544,70.9957456312,
	70.7976259192,70.5995323675,70.4014663683,70.203429358,70.0054228187,
	69.8074482801,69.6095073209,69.4116015707,69.2137327114,69.0159024793,
	68.8181126671,68.6203651253,68.4226617647,68.2250045581,68.0273955426,
	67.8298368217,67.6323305676,67.4348790234,67.2374845055,67.0401494061,
	66.8428761956,66.6456674255,66.4485257304,66.2514538315,66.0544545389,
	65.8575307545,65.6606854752,65.4639217957,65.2672429117,65.070652123,
	64.8741528369,64.6777485713,64.4814429582,64.2852397473,64.0891428094,
	63.89315614,63.6972838629,63.5015302341,63.3058996458,63.1103966298,
	62.9150258617,62.7197921649,62.5247005146,62.3297560418,62.1349640375,
	61.9403299569,61.7458594236,61.5515582334,61.3574323592,61.1634879547,
	60.9697313588,60.7761690999,60.5828078998,60.3896546781,60.1967165562,
	60.0040008615,59.811515131,59.6192671154,59.427264783,59.2355163231,
	59.0440301495,58.852814904,58.6618794596,58.4712329231,58.2808846382,
	58.090844188,57.9011213969,57.7117263328,57.5226693086,57.3339608836,
	57.1456118642,56.9576333046,56.7700365068,56.58283302,56.3960346403,
	56.2096534086,56.0237016094,55.8381917678,55.6531366466,55.4685492428,
	55.284442783,55.1008307186,54.9177267197,54.7351446693,54.5530986556,
	54.3716029642,54.1906720696,54.0103206254,53.8305634543,53.6514155368,
	53.4728919991,53.295008101,53.1177792216,52.9412208454,52.7653485472,
	52.5901779759,52.4157248378,52.2420048797,52.0690338701,51.8968275811,
	51.7254017683,51.5547721516,51.3849543941,51.2159640815,51.0478167004,
	50.8805276169,50.7141120546,50.5485850721,50.3839615409,50.220256123,
	50.0574832487,49.895657094,49.7347915589,49.5749002458,49.4159964377,
	49.2580930777,49.1012027484,48.9453376526,48.7905095938,48.6367299582,
	48.4840096974,48.3323593121,48.1817888365,48.0323078239,47.8839253338,
	47.7366499195,47.5904896174,47.4454519373,47.3015438542,47.1587718012,
	47.0171416637,46.876658775,46.7373279131,46.5991532994,46.4621385973,
	46.326286914,46.1916008015,46.0580822608,45.9257327457,45.7945531685,
	45.6645439069,45.5357048113,45.4080352138,45.2815339377,45.1561993078,
	45.032029162,44.9090208631,44.7871713114,44.6664769582,44.5469338196,
	44.4285374906,44.3112831602,44.195165626,44.08017931,43.9663182736,
	43.8535762342,43.7419465802,43.6314223873,43.5219964345,43.4136612197,
	43.3064089756,43.2002316854,43.0951210982,42.9910687444,42.8880659502,
	42.7861038533,42.6851734163,42.5852654418,42.4863705854,42.3884793696,
	42.2915821966,42.1956693612,42.1007310628,42.0067574174,41.913738469,
	41.8216642003,41.7305245439,41.6403093918,41.5510086055,41.4626120252,
	41.3751094786,41.2884907892,41.2027457849,41.1178643049,41.0338362075,
	40.9506513767,40.8682997286,40.7867712177,40.7060558425,40.6261436509,
	40.5470247451,40.4686892867,40.3911275007,40.3143296798,40.238286188,
	40.1629874645,40.0884240263,40.0145864718,39.9414654832,39.869051829,
	39.7973363663,39.7263100428,39.6559638986,39.5862890679,39.5172767805,
	39.4489183628,39.381205239,39.3141289323,39.2476810652,39.1818533604,
	39.1166376415,39.0520258329,38.9880099602,38.9245821507,38.861734633,
	38.799459737,38.7377498939,38.6765976358,38.6159955956,38.5559365061,
	38.4964132002,38.4374186098,38.3789457655,38.3209877958,38.2635379265,
	38.20658948,38.1501358741,38.0941706218,38.03868733,37.9836796987,
	37.9291415199,37.8750666772,37.821449144,37.7682829833,37.7155623461,
	37.6632814707,37.6114346815,37.5600163879,37.5090210835,37.4584433446,
	37.4082778296,37.3585192774,37.3091625068,37.260202415,37.2116339769,
	37.1634522436,37.1156523417,37.0682294717,37.0211789077,36.9744959955,
	36.9281761519,36.882214864,36.8366076874,36.7913502455,36.7464382288,
	36.7018673933,36.6576335597,36.6137326126,36.5701604991,36.5269132281,
	36.4839868692,36.4413775518,36.3990814641,36.3570948521,36.3154140187,
	36.2740353227,36.2329551782,36.1921700533,36.1516764693,36.1114710002,
	36.0715502713,36.0319109585,35.9925497878,35.953463534,35.9146490203,
	35.8761031172,35.8378227417,35.7998048569,35.7620464706,35.7245446353,
	35.6872964468,35.6502990438,35.6135496072,35.5770453592,35.5407835628,
	35.5047615211,35.4689765763,35.4334261096,35.3981075401,35.3630183243,
	35.3281559555,35.2935179634,35.2591019128,35.2249054039,35.190926071,
	35.1571615823,35.1236096394,35.0902679764,35.0571343594,35.0242065864,
	34.9914824864,34.9589599188,34.9266367732,34.8945109687,34.8625804535,
	34.8308432042,34.7992972259,34.7679405508,34.7367712388,34.7057873762,
	34.6749870757,34.6443684758,34.6139297407,34.5836690592,34.553584645,
	34.523674736,34.4939375938,34.4643715034,34.4349747732,34.4057457337,
	34.3766827382,34.3477841616,34.3190484007,34.2904738733,34.2620590183,
	34.2338022949,34.2057021827,34.1777571813,34.1499658098,34.1223266066,
	34.094838129,34.067498953,34.0403076731,34.0132629019,33.9863632696,
	33.9596074241,33.9329940306,33.906521771,33.8801893442,33.8539954655,
	33.8279388664,33.8020182942,33.7762325121,33.7505802987,33.7250604478,
	33.6996717682,33.6744130834,33.6492832315,33.624281065,33.5994054503,
	33.5746552679,33.5500294117,33.5255267892,33.5011463214,33.4768869419,
	33.4527475975,33.4287272476,33.404824864,33.3810394309,33.3573699445,
	33.333815413,33.3103748565,33.2870473064,33.2638318058,33.2407274087,
	33.2177331806,33.1948481976,33.1720715466,33.1494023254,33.1268396418,
	33.1043826143,33.0820303713,33.0597820513,33.0376368026,33.0155937833,
	32.9936521611,32.971811113,32.9500698254,32.928427494,32.9068833234,
	32.885436527,32.8640863273,32.8428319553,32.8216726506,32.8006076611,
	32.7796362431,32.7587576613,32.7379711881,32.7172761042,32.696671698,
	32.6761572657,32.6557321111,32.6353955456,32.615146888,32.5949854646,
	32.5749106086,32.5549216607,32.5350179685,32.5151988864,32.4954637759,
	32.4758120052,32.4562429491,32.4367559889,32.4173505127,32.3980259148,
	32.3787815958,32.3596169627,32.3405314284,32.3215244122,32.3025953392,
	32.2837436404,32.2649687528,32.246270119,32.2276471875,32.2090994121,
	32.1906262525,32.1722271737,32.1539016461,32.1356491454,32.1174691527,
	32.0993611542,32.0813246412,32.0633591103,32.0454640627,32.027639005,
	32.0098834483,31.9921969088,31.9745789073,31.9570289692,31.9395466249,
	31.922131409,31.9047828608,31.8875005241,31.870283947,31.8531326821,
	31.8360462862,31.8190243203,31.8020663499,31.7851719442,31.768340677,
	31.7515721256,31.7348658718,31.7182215011,31.7016386029,31.6851167705,
	31.6686556011,31.6522546954,31.6359136583,31.6196320978,31.603409626,
	31.5872458584,31.571140414,31.5550929153,31.5391029884,31.5231702628,
	31.5072943712,31.49147495,31.4757116385,31.4600040794,31.4443519189,
	31.4287548061,31.4132123933,31.3977243359,31.3822902925,31.3669099247,
	31.3515828971,31.3363088772,31.3210875356,31.3059185458,31.2908015839,
	31.2757363292,31.2607224636,31.245759672,31.2308476417,31.2159860631,
	31.2011746291,31.1864130351,31.1717009795,31.1570381631,31.1424242891,
	31.1278590637,31.1133421951,31.0988733943,31.0844523748,31.0700788523,
	31.0557525451,31.0414731739,31.0272404614,31.0130541332,30.9989139168,
	30.9848195421,30.9707707411,30.9567672485,30.9428088006,30.9288951362,
	30.9150259964,30.9012011241,30.8874202647,30.8736831652,30.8599895751,
	30.8463392459,30.8327319308,30.8191673854,30.805645367,30.7921656351,
	30.778727951,30.7653320779,30.751977781,30.7386648273,30.7253929858,
	30.7121620271,30.6989717239,30.6858218505,30.6727121831,30.6596424997,
	30.64661258,30.6336222053,30.6206711589,30.6077592256,30.5948861919,
	30.582051846,30.5692559778,30.5564983788,30.543778842,30.5310971622,
	30.5184531356,30.5058465602,30.4932772352,30.4807449617,30.4682495421,
	30.4557907804,30.4433684821,30.430982454,30.4186325047,30.4063184439,
	30.394040083,30.3817972346,30.369589713,30.3574173335,30.3452799132,
	30.3331772701,30.3211092241,30.309075596,30.2970762081,30.285110884,
	30.2731794486,30.2612817281,30.24941755,30.237586743,30.2257891371,
	30.2140245634,30.2022928546,30.1905938442,30.1789273672,30.1672932596,
	30.1556913586,30.1441215028,30.1325835317,30.1210772861,30.1096026079,
	30.09815934,30.0867473267,30.0753664132,30.0640164459,30.0526972721,
	30.0414087405,30.0301507006,30.018923003,30.0077254995,29.9965580428,
	29.9854204867,29.974312686,29.9632344964,29.9521857749,29.9411663791,
	29.930176168,29.9192150012,29.9082827395,29.8973792446,29.8865043791,
	29.8756580067,29.8648399918,29.8540501999,29.8432884974,29.8325547515,
	29.8218488304,29.8111706032,29.8005199399,29.7898967112,29.7793007888,
	29.7687320454,29.7581903544,29.74767559,29.7371876273,29.7267263422,
	29.7162916116,29.705883313,29.6955013249,29.6851455263,29.6748157973,
	29.6645120188,29.6542340722,29.64398184,29.6337552052,29.6235540517,
	29.6133782642,29.6032277281,29.5931023295,29.5830019553,29.5729264931,
	29.5628758312,29.5528498587,29.5428484654,29.5328715418,29.5229189789,
	29.5129906688,29.503086504,29.4932063777,29.4833501839,29.4735178172,
	29.4637091728,29.4539241467,29.4441626356,29.4344245366,29.4247097476,
	29.4150181672,29.4053496945,29.3957042294,29.3860816723,29.3764819242,
	29.3669048868,29.3573504624,29.3478185538,29.3383090646,29.3288218988,
	29.3193569611,29.3099141568,29.3004933916,29.2910945721,29.2817176051,
	29.2723623983,29.2630288597,29.2537168981,29.2444264227,29.2351573433,
	29.2259095701,29.2166830142,29.2074775868,29.1982931999,29.189129766,
	29.1799871982,29.1708654098,29.161764315,29.1526838283,29.1436238647,
	29.1345843399,29.1255651698,29.1165662711,29.1075875607,29.0986289563,
	29.0896903759,29.0807717379,29.0718729614,29.0629939658,29.054134671,
	29.0452949975,29.0364748662,29.0276741982,29.0188929155,29.0101309403,
	29.0013881953,28.9926646035,28.9839600886,28.9752745746,28.9666079859,
	28.9579602474,28.9493312845,28.9407210228,28.9321293887,28.9235563085,
	28.9150017094,28.9064655188,28.8979476644,28.8894480746,28.880966678,
	28.8725034037,28.864058181,28.8556309398,28.8472216105,28.8388301235,
	28.8304564099,28.8221004011,28.813762029,28.8054412256,28.7971379235,
	28.7888520556,28.7805835552,28.772332356,28.764098392,28.7558815975,
	28.7476819073,28.7394992566,28.7313335807,28.7231848155,28.7150528972,
	28.7069377621,28.6988393474,28.69075759,28.6826924275,28.6746437979,
	28.6666116394,28.6585958904,28.6505964899,28.6426133771,28.6346464915,
	28.626695773,28.6187611617,28.6108425982,28.6029400232,28.595053378,
	28.5871826039,28.5793276427,28.5714884365,28.5636649277,28.5558570589,
	28.5480647731,28.5402880136,28.532526724,28.5247808482,28.5170503302,
	28.5093351147,28.5016351463,28.4939503701,28.4862807313,28.4786261758,
	28.4709866492,28.4633620978,28.4557524681,28.4481577067,28.4405777608,
	28.4330125775,28.4254621044,28.4179262893,28.4104050804,28.4028984259,
	28.3954062746,28.3879285752,28.3804652769,28.3730163292,28.3655816816,
	28.3581612841,28.3507550868,28.3433630402,28.3359850949,28.3286212019,
	28.3212713123,28.3139353775,28.3066133492,28.2993051793,28.2920108199,
	28.2847302234,28.2774633423,28.2702101296,28.2629705384,28.2557445219,
	28.2485320337,28.2413330275,28.2341474574,28.2269752777,28.2198164427,
	28.2126709072,28.205538626,28.1984195544,28.1913136475,28.1842208611,
	28.1771411508,28.1700744728,28.1630207831,28.1559800382,28.1489521948,
	28.1419372097,28.13493504,28.1279456429,28.1209689759,28.1140049966,
	28.107053663,28.1001149332,28.0931887653,28.0862751179,28.0793739497,
	28.0724852196,28.0656088866,28.0587449099,28.0518932492,28.0450538639,
	28.038226714,28.0314117595,28.0246089606,28.0178182778,28.0110396715,
	28.0042731028,27.9975185324,27.9907759215,27.9840452315,27.9773264239,
	27.9706194605,27.9639243029,27.9572409134,27.9505692542,27.9439092876,
	27.9372609763,27.9306242829,27.9239991704,27.917385602,27.9107835408,
	27.9041929503,27.8976137942,27.8910460361,27.8844896401,27.8779445702,
	27.8714107907,27.8648882661,27.8583769608,27.8518768397,27.8453878678,
	27.8389100099,27.8324432315,27.8259874979,27.8195427746,27.8131090273,
	27.806686222,27.8002743245,27.7938733011,27.7874831181,27.781103742,
	27.7747351393,27.7683772768,27.7620301215,27.7556936405,27.7493678008,
	27.74305257,27.7367479154,27.7304538047,27.7241702058,27.7178970865,
	27.7116344149,27.7053821593,27.6991402879,27.6929087694,27.6866875722,
	27.6804766652,27.6742760174,27.6680855976,27.6619053752,27.6557353194,
	27.6495753996,27.6434255855,27.6372858468,27.6311561533,27.6250364749,
	27.6189267819,27.6128270443,27.6067372327,27.6006573174,27.594587269,
	27.5885270585,27.5824766565,27.5764360341,27.5704051624,27.5643840127,
	27.5583725563,27.5523707647,27.5463786095,27.5403960625,27.5344230955,
	27.5284596804,27.5225057894,27.5165613947,27.5106264685,27.5047009834,
	27.4987849119,27.4928782266,27.4869809004,27.4810929061,27.4752142168,
	27.4693448056,27.4634846457,27.4576337105,27.4517919735,27.4459594082,
	27.4401359884,27.4343216877,27.4285164802,27.4227203398,27.4169332407,
	27.411155157,27.4053860632,27.3996259336,27.3938747428,27.3881324655,
	27.3823990764,27.3766745503,27.3709588622,27.3652519873,27.3595539006,
	27.3538645774,27.3481839931,27.3425121231,27.3368489431,27.3311944287,
	27.3255485556,27.3199112998,27.3142826371,27.3086625437,27.3030509957,
	27.2974479694,27.291853441,27.2862673871,27.2806897842,27.2751206089,
	27.2695598379,27.2640074481,27.2584634164,27.2529277198,27.2474003354,
	27.2418812403,27.2363704118,27.2308678274,27.2253734644,27.2198873005,
	27.2144093132,27.2089394803,27.2034777796,27.1980241889,27.1925786864,
	27.18714125,27.181711858,27.1762904885,27.1708771199,27.1654717306,
	27.1600742991,27.1546848041,27.1493032241,27.1439295379,27.1385637244,
	27.1332057625,27.1278556311,27.1225133094,27.1171787765,27.1118520117,
	27.1065329942,27.1012217036,27.0959181192,27.0906222206,27.0853339875,
	27.0800533996,27.0747804366,27.0695150786,27.0642573053,27.0590070968,
	27.0537644333,27.048529295,27.0433016619,27.0380815146,27.0328688334,
	27.0276635988,27.0224657913,27.0172753915,27.0120923803,27.0069167383,
	27.0017484463,26.9965874854,26.9914338364,26.9862874805,26.9811483988,
	26.9760165725,26.9708919829,26.9657746112,26.960664439,26.9555614477,
	26.9504656189,26.9453769341,26.9402953751,26.9352209236,26.9301535615,
	26.9250932707,26.920040033,26.9149938306,26.9099546455,26.9049224599,
	26.899897256,26.8948790161,26.8898677226,26.8848633578,26.8798659043,
	26.8748753447,26.8698916614,26.8649148373,26.8599448551,26.8549816974,
	26.8500253473,26.8450757877,26.8401330015,26.8351969718,26.8302676817,
	26.8253451143,26.820429253,26.815520081,26.8106175817,26.8057217385,
	26.8008325349,26.7959499543,26.7910739805,26.786204597,26.7813417876,
	26.7764855361,26.7716358262,26.7667926419,26.7619559671,26.7571257859,
	26.7523020822,26.7474848402,26.7426740441,26.737869678,26.7330717264,
	26.7282801735,26.7234950037,26.7187162015,26.7139437514,26.7091776379,
	26.7044178457,26.6996643594,26.6949171638,26.6901762436,26.6854415837,
	26.680713169,26.6759909844,26.6712750148,26.6665652454,26.6618616612,
	26.6571642474,26.6524729891,26.6477878717,26.6431088804,26.6384360006,
	26.6337692177,26.6291085171,26.6244538844,26.6198053051,26.6151627648,
	26.6105262491,26.6058957438,26.6012712347,26.5966527074,26.592040148,
	26.5874335422,26.5828328761,26.5782381356,26.5736493067,26.5690663756,
	26.5644893285,26.5599181514,26.5553528306,26.5507933525,26.5462397032,
	26.5416918693,26.5371498371,26.5326135931,26.5280831239,26.5235584158,
	26.5190394557,26.5145262301,26.5100187257,26.5055169292,26.5010208275,
	26.4965304073,26.4920456556,26.4875665593,26.4830931052,26.4786252805,
	26.4741630721,26.4697064672,26.4652554529,26.4608100163,26.4563701447,
	26.4519358254,26.4475070456,26.4430837927,26.4386660541,26.4342538172,
	26.4298470695,26.4254457985,26.4210499918,26.4166596369,26.4122747215,
	26.4078952332,26.4035211598,26.3991524891,26.3947892088,26.3904313068,
	26.3860787709,26.3817315891,26.3773897493,26.3730532396,26.3687220479,
	26.3643961623,26.360075571,26.3557602621,26.3514502237,26.3471454442,
	26.3428459118,26.3385516148,26.3342625415,26.3299786803,26.3257000197,
	26.3214265481,26.3171582539,26.3128951257,26.3086371522,26.3043843218,
	26.3001366232,26.2958940452,26.2916565763,26.2874242055,26.2831969213,
	26.2789747128,26.2747575687,26.2705454778,26.2663384293,26.2621364119,
	26.2579394148,26.2537474269,26.2495604373,26.2453784351,26.2412014095,
	26.2370293495,26.2328622446,26.2287000837,26.2245428563,26.2203905517,
	26.2162431591,26.212100668,26.2079630678,26.2038303479,26.1997024978,
	26.1955795069,26.1914613649,26.1873480613,26.1832395857,26.1791359278,
	26.1750370772,26.1709430235,26.1668537567,26.1627692664,26.1586895424,
	26.1546145745,26.1505443526,26.1464788667,26.1424181066,26.1383620622,
	26.1343107237,26.1302640809,26.1262221239,26.1221848429,26.1181522279,
	26.114124269,26.1101009565,26.1060822805,26.1020682313,26.098058799,
	26.0940539741,26.0900537468,26.0860581075,26.0820670466,26.0780805544,
	26.0740986214,26.070121238,26.0661483949,26.0621800824,26.0582162911,
	26.0542570117,26.0503022347,26.0463519507,26.0424061505,26.0384648247,
	26.0345279641,26.0305955593,26.0266676012,26.0227440806,26.0188249883,
	26.0149103152,26.0110000522,26.0070941901,26.00319272,25.9992956327,
	25.9954029194,25.9915145709,25.9876305784,25.983750933,25.9798756257,
	25.9760046476,25.97213799,25.9682756441,25.9644176009,25.9605638518,
	25.956714388,25.9528692009,25.9490282816,25.9451916216,25.9413592122,
	25.9375310449,25.9337071109,25.9298874018,25.9260719091,25.9222606242,
	25.9184535386,25.9146506439,25.9108519316,25.9070573933,25.9032670207,
	25.8994808054
	};

tubetable_6C16_1 = waveform{
	214.806581677,214.650587712,214.494441388,214.338143449,214.181694635,
	214.025095677,213.868347304,213.711450238,213.554405194,213.397212884,
	213.239874013,213.082389282,212.924759385,212.766985013,212.60906685,
	212.451005576,212.292801864,212.134456385,211.975969802,211.817342776,
	211.658575961,211.499670005,211.340625555,211.181443251,211.022123727,
	210.862667614,210.703075539,210.543348122,210.383485982,210.22348973,
	210.063359973,209.903097317,209.742702359,209.582175694,209.421517913,
	209.260729602,209.099811343,208.938763714,208.777587287,208.616282633,
	208.454850316,208.293290899,208.131604938,207.969792986,207.807855593,
	207.645793304,207.483606661,207.321296202,207.15886246,206.996305965,
	206.833627244,206.67082682,206.507905211,206.344862933,206.181700497,
	206.018418412,205.855017182,205.691497309,205.527859289,205.364103618,
	205.200230785,205.036241278,204.872135582,204.707914176,204.543577538,
	204.379126141,204.214560458,204.049880955,203.885088096,203.720182343,
	203.555164155,203.390033984,203.224792285,203.059439505,202.893976089,
	202.728402482,202.562719123,202.396926447,202.23102489,202.065014882,
	201.898896852,201.732671223,201.56633842,201.399898861,201.233352963,
	201.066701141,200.899943805,200.733081363,200.566114223,200.399042787,
	200.231867455,200.064588626,199.897206695,199.729722054,199.562135094,
	199.394446202,199.226655764,199.058764161,198.890771775,198.722678983,
	198.554486159,198.386193678,198.217801909,198.04931122,197.880721977,
	197.712034543,197.54324928,197.374366545,197.205386696,197.036310087,
	196.86713707,196.697867994,196.528503206,196.359043053,196.189487877,
	196.019838019,195.850093818,195.680255611,195.510323732,195.340298515,
	195.170180288,194.999969382,194.829666122,194.659270832,194.488783835,
	194.318205451,194.147535999,193.976775794,193.805925153,193.634984386,
	193.463953805,193.292833719,193.121624434,192.950326255,192.778939486,
	192.607464428,192.43590138,192.264250641,192.092512505,191.920687267,
	191.74877522,191.576776653,191.404691857,191.232521118,191.060264721,
	190.887922951,190.715496088,190.542984415,190.370388209,190.197707747,
	190.024943305,189.852095157,189.679163575,189.50614883,189.33305119,
	189.159870923,188.986608295,188.813263571,188.639837013,188.466328882,
	188.292739439,188.119068941,187.945317645,187.771485807,187.597573681,
	187.423581518,187.249509571,187.075358088,186.901127317,186.726817506,
	186.552428899,186.377961741,186.203416274,186.028792738,185.854091375,
	185.679312422,185.504456116,185.329522693,185.154512388,184.979425434,
	184.804262062,184.629022504,184.453706988,184.278315742,184.102848994,
	183.927306968,183.751689889,183.57599798,183.400231463,183.224390558,
	183.048475484,182.872486461,182.696423704,182.520287429,182.344077852,
	182.167795186,181.991439642,181.815011432,181.638510767,181.461937854,
	181.285292902,181.108576118,180.931787707,180.754927872,180.577996819,
	180.400994749,180.223921863,180.046778361,179.869564443,179.692280306,
	179.514926148,179.337502164,179.16000855,178.982445499,178.804813204,
	178.627111857,178.449341649,178.27150277,178.093595408,177.915619752,
	177.737575989,177.559464305,177.381284884,177.203037911,177.024723568,
	176.846342039,176.667893504,176.489378144,176.310796138,176.132147665,
	175.953432902,175.774652027,175.595805214,175.416892639,175.237914476,
	175.058870898,174.879762077,174.700588185,174.521349393,174.342045871,
	174.162677786,173.983245308,173.803748604,173.624187839,173.444563181,
	173.264874793,173.085122839,172.905307483,172.725428887,172.545487212,
	172.365482621,172.185415272,172.005285324,171.825092937,171.644838268,
	171.464521475,171.284142712,171.103702136,170.923199902,170.742636163,
	170.562011074,170.381324785,170.20057745,170.019769219,169.838900242,
	169.65797067,169.476980651,169.295930334,169.114819867,168.933649395,
	168.752419065,168.571129024,168.389779415,168.208370384,168.026902072,
	167.845374625,167.663788183,167.482142888,167.300438881,167.118676302,
	166.936855292,166.754975989,166.573038531,166.391043057,166.208989703,
	166.026878606,165.844709901,165.662483725,165.480200212,165.297859496,
	165.115461711,164.933006988,164.750495462,164.567927263,164.385302523,
	164.202621372,164.019883941,163.837090359,163.654240754,163.471335256,
	163.288373991,163.105357088,162.922284672,162.739156871,162.555973809,
	162.372735612,162.189442405,162.006094311,161.822691453,161.639233956,
	161.455721941,161.27215553,161.088534844,160.904860006,160.721131134,
	160.53734835,160.353511772,160.169621519,159.985677711,159.801680464,
	159.617629896,159.433526125,159.249369267,159.065159438,158.880896753,
	158.696581328,158.512213278,158.327792716,158.143319756,157.958794512,
	157.774217097,157.589587623,157.404906201,157.220172944,157.035387963,
	156.850551368,156.665663269,156.480723777,156.295733,156.110691048,
	155.925598029,155.740454052,155.555259223,155.370013651,155.184717443,
	154.999370704,154.813973541,154.62852606,154.443028365,154.257480563,
	154.071882757,153.886235051,153.70053755,153.514790357,153.328993575,
	153.143147306,152.957251652,152.771306717,152.5853126,152.399269404,
	152.213177229,152.027036175,151.840846344,151.654607834,151.468320744,
	151.281985175,151.095601225,150.909168991,150.722688573,150.536160067,
	150.349583572,150.162959184,149.976287,149.789567117,149.60279963,
	149.415984635,149.229122227,149.042212503,148.855255556,148.668251481,
	148.481200372,148.294102323,148.106957428,147.919765781,147.732527473,
	147.545242597,147.357911247,147.170533514,146.98310949,146.795639267,
	146.608122935,146.420560586,146.232952311,146.045298199,145.857598342,
	145.669852828,145.482061748,145.294225191,145.106343245,144.918416001,
	144.730443545,144.542425968,144.354363356,144.166255797,143.97810338,
	143.789906191,143.601664317,143.413377845,143.225046862,143.036671454,
	142.848251708,142.659787708,142.471279541,142.282727292,142.094131047,
	141.905490889,141.716806905,141.528079178,141.339307792,141.150492833,
	140.961634383,140.772732527,140.583787347,140.394798927,140.20576735,
	140.016692699,139.827575057,139.638414505,139.449211127,139.259965004,
	139.070676217,138.88134485,138.691970983,138.502554697,138.313096073,
	138.123595193,137.934052137,137.744466986,137.55483982,137.36517072,
	137.175459765,136.985707035,136.79591261,136.60607657,136.416198993,
	136.22627996,136.036319549,135.846317839,135.656274909,135.466190838,
	135.276065704,135.085899585,134.895692559,134.705444705,134.5151561,
	134.324826823,134.13445695,133.944046559,133.753595729,133.563104534,
	133.372573054,133.182001365,132.991389543,132.800737666,132.61004581,
	132.419314051,132.228542467,132.037731132,131.846880124,131.655989518,
	131.46505939,131.274089817,131.083080873,130.892032635,130.700945177,
	130.509818577,130.318652908,130.127448245,129.936204665,129.744922243,
	129.553601052,129.362241169,129.170842668,128.979405623,128.78793011,
	128.596416203,128.404863976,128.213273504,128.021644862,127.829978123,
	127.638273363,127.446530654,127.254750072,127.062931691,126.871075583,
	126.679181825,126.487250488,126.295281648,126.103275378,125.911231752,
	125.719150844,125.527032727,125.334877475,125.142685163,124.950455862,
	124.758189648,124.565886593,124.373546772,124.181170257,123.988757122,
	123.796307442,123.603821288,123.411298735,123.218739857,123.026144726,
	122.833513416,122.640846001,122.448142555,122.255403149,122.062627859,
	121.869816757,121.676969918,121.484087414,121.291169319,121.098215706,
	120.90522665,120.712202224,120.519142502,120.326047556,120.132917462,
	119.939752292,119.746552121,119.553317022,119.360047069,119.166742336,
	118.973402897,118.780028826,118.586620198,118.393177086,118.199699564,
	118.006187707,117.81264159,117.619061286,117.42544687,117.231798417,
	117.038116001,116.844399697,116.650649581,116.456865726,116.263048209,
	116.069197103,115.875312486,115.68139443,115.487443014,115.293458311,
	115.099440397,114.905389349,114.711305243,114.517188154,114.323038158,
	114.128855333,113.934639754,113.740391499,113.546110644,113.351797266,
	113.157451442,112.963073249,112.768662766,112.574220069,112.379745237,
	112.185238347,111.990699479,111.796128709,111.601526117,111.406891782,
	111.212225782,111.017528197,110.822799106,110.62803859,110.433246727,
	110.238423599,110.043569285,109.848683866,109.653767423,109.458820038,
	109.263841792,109.068832766,108.873793042,108.678722704,108.483621833,
	108.288490512,108.093328825,107.898136855,107.702914687,107.507662403,
	107.31238009,107.117067832,106.921725713,106.726353821,106.53095224,
	106.335521058,106.14006036,105.944570235,105.749050771,105.553502054,
	105.357924174,105.16231722,104.966681281,104.771016447,104.575322809,
	104.379600457,104.183849483,103.98806998,103.792262038,103.596425752,
	103.400561215,103.204668521,103.008747766,102.812799044,102.616822451,
	102.420818085,102.224786042,102.028726421,101.832639321,101.63652484,
	101.440383079,101.244214139,101.048018121,100.851795129,100.655545265,
	100.459268634,100.26296534,100.06663549,99.8702791895,99.6738965474,
	99.4774876719,99.2810526729,99.0845916608,98.8881047476,98.691592046,
	98.4950536699,98.2984897344,98.1019003557,97.9052856512,97.7086457396,
	97.5119807408,97.315290776,97.1185759679,96.9218364403,96.7250723187,
	96.52828373,96.3314708025,96.1346336663,95.9377724527,95.7408872952,
	95.5439783285,95.3470456894,95.1500895163,94.9531099497,94.7561071318,
	94.5590812068,94.3620323212,94.1649606233,93.9678662638,93.7707493956,
	93.5736101738,93.3764487561,93.1792653025,92.9820599756,92.7848329407,
	92.5875843657,92.3903144214,92.1930232816,91.9957111228,91.7983781248,
	91.6010244707,91.4036503465,91.2062559421,91.0088414506,90.8114070689,
	90.6139529975,90.4164794409,90.2189866076,90.0214747103,89.823943966,
	89.626394596,89.4288268263,89.2312408877,89.0336370159,88.8360154516,
	88.6383764408,88.4407202349,88.243047091,88.045357272,87.8476510469,
	87.6499286907,87.4521904852,87.2544367185,87.0566676858,86.8588836897,
	86.6610850397,86.4632720534,86.2654450561,86.0676043814,85.8697503714,
	85.6718833771,85.4740037586,85.2761118852,85.0782081364,84.8802929016,
	84.6823665808,84.4844295847,84.2864823355,84.0885252669,83.8905588249,
	83.6925834679,83.4945996672,83.2966079077,83.0986086881,82.9006025218,
	82.7025899369,82.504571477,82.3065477019,82.1085191881,81.9104865291,
	81.7124503365,81.5144112404,81.31636989,81.1183269543,80.9202831233,
	80.7222391079,80.5241956415,80.3261534801,80.1281134038,79.9300762172,
	79.7320427503,79.5340138598,79.3359904296,79.1379733722,78.9399636292,
	78.7419621732,78.5439700078,78.3459881699,78.14801773,77.9500597938,
	77.7521155034,77.5541860386,77.3562726184,77.1583765021,76.960498991,
	76.7626414298,76.5648052081,76.3669917621,76.1692025763,75.971439185,
	75.7737031742,75.5759961834,75.3783199075,75.1806760987,74.9830665686,
	74.78549319,74.5879578994,74.3904626989,74.1930096588,73.9956009193,
	73.7982386937,73.6009252702,73.4036630149,73.2064543742,73.0093018775,
	72.8122081401,72.6151758657,72.4182078498,72.2213069825,72.0244762512,
	71.8277187444,71.6310376545,71.4344362812,71.2379180349,71.0414864401,
	70.8451451392,70.6488978956,70.4527485979,70.2567012634,70.0607600418,
	69.8649292195,69.6692132231,69.4736166236,69.2781441408,69.0828006466,
	68.8875911702,68.6925209014,68.4975951954,68.302819577,68.1081997447,
	67.9137415753,67.7194511279,67.5253346485,67.3313985744,67.137649538,
	66.9440943715,66.750740111,66.5575940006,66.3646634965,66.1719562709,
	65.979480216,65.7872434478,65.5952543092,65.4035213744,65.2120534512,
	65.0208595845,64.8299490593,64.6393314028,64.4490163873,64.2590140316,
	64.0693346033,63.8799886194,63.6909868482,63.502340309,63.3140602728,
	63.1261582616,62.9386460478,62.7515356528,62.5648393451,62.3785696378,
	62.1927392856,62.0073612811,61.8224488501,61.6380154473,61.4540747498,
	61.2706406511,61.0877272534,60.9053488602,60.7235199671,60.5422552522,
	60.3615695659,60.1814779194,60.0019954732,59.8231375236,59.6449194893,
	59.467356897,59.290465366,59.1142605922,58.9387583312,58.7639743808,
	58.5899245626,58.4166247035,58.2440906157,58.0723380767,57.9013828089,
	57.7312404584,57.5619265734,57.3934565824,57.2258457724,57.0591092663,
	56.8932620005,56.7283187029,56.5642938699,56.4012017447,56.2390562951,
	56.0778711918,55.9176597869,55.7584350933,55.6002097646,55.442996075,
	55.2868059006,55.1316507015,54.9775415045,54.8244888866,54.67250296,
	54.521593358,54.3717692215,54.2230391876,54.0754113787,53.928893393,
	53.7834922966,53.6392146163,53.4960663344,53.3540528842,53.213179147,
	53.0734494507,52.9348675694,52.7974367242,52.6611595853,52.5260382756,
	52.392074375,52.2592689262,52.1276224411,51.9971349089,51.8678058046,
	51.7396340988,51.6126182678,51.4867563052,51.3620457335,51.2384836172,
	51.1160665754,50.9947907962,50.8746520501,50.7556457053,50.6377667424,
	50.5210097692,50.4053690366,50.2908384541,50.177411605,50.0650817627,
	49.953841906,49.8436847348,49.7346026858,49.626587948,49.5196324774,
	49.4137280128,49.30886609,49.2050380567,49.1022350863,49.0004481925,
	48.899668242,48.7998859685,48.7010919851,48.6032767968,48.5064308127,
	48.4105443574,48.3156076826,48.2216109775,48.1285443795,48.0363979842,
	47.9451618546,47.8548260307,47.7653805379,47.6768153954,47.5891206244,
	47.5022862551,47.4163023342,47.3311589317,47.2468461468,47.1633541147,
	47.0806730113,46.9987930595,46.9177045334,46.8373977633,46.7578631402,
	46.6790911195,46.6010722248,46.5237970519,46.4472562712,46.3714406313,
	46.2963409615,46.2219481742,46.1482532672,46.0752473257,46.0029215242,
	45.9312671284,45.8602754958,45.789938078,45.7202464213,45.6511921675,
	45.582767055,45.5149629195,45.4477716941,45.3811854103,45.3151961979,
	45.249796285,45.1849779988,45.1207337645,45.0570561064,44.9939376466,
	44.9313711053,44.8693493005,44.8078651471,44.746911657,44.686481938,
	44.6265691936,44.567166722,44.5082679158,44.449866261,44.391955336,
	44.3345288112,44.2775804481,44.2211040981,44.1650937017,44.1095432878,
	44.0544469725,43.9997989584,43.9455935331,43.8918250688,43.8384880208,
	43.7855769268,43.7330864057,43.6810111566,43.6293459579,43.5780856658,
	43.5272252138,43.4767596114,43.426683943,43.3769933668,43.3276831139,
	43.2787484874,43.230184861,43.181987678,43.1341524507,43.0866747587,
	43.0395502487,42.9927746327,42.9463436875,42.9002532535,42.8544992337,
	42.8090775929,42.7639843566,42.7192156101,42.6747674974,42.6306362206,
	42.5868180387,42.5433092665,42.5001062744,42.4572054868,42.4146033815,
	42.3722964889,42.3302813911,42.2885547209,42.2471131613,42.2059534443,
	42.1650723503,42.1244667073,42.0841333903,42.0440693199,42.0042714625,
	41.9647368285,41.9254624723,41.8864454915,41.8476830258,41.8091722568,
	41.7709104067,41.7328947382,41.6951225536,41.6575911941,41.6202980392,
	41.5832405061,41.5464160489,41.5098221582,41.4734563605,41.4373162174,
	41.4013993251,41.3657033141,41.3302258481,41.294964624,41.2599173708,
	41.2250818496,41.1904558528,41.1560372035,41.1218237553,41.0878133915,
	41.0540040246,41.0203935961,40.9869800759,40.9537614617,40.9207357786,
	40.8879010787,40.8552554409,40.8227969699,40.7905237962,40.7584340756,
	40.7265259888,40.694797741,40.6632475612,40.6318737025,40.6006744409,
	40.5696480755,40.5387929281,40.5081073423,40.477589684,40.4472383402,
	40.4170517192,40.3870282502,40.3571663827,40.3274645866,40.2979213512,
	40.2685351859,40.2393046187,40.210228197,40.1813044866,40.1525320716,
	40.1239095543,40.0954355544,40.0671087095,40.0389276741,40.0108911199,
	39.982997735,39.955246224,39.9276353079,39.9001637232,39.8728302225,
	39.8456335736,39.8185725594,39.7916459781,39.7648526423,39.7381913793,
	39.7116610306,39.6852604519,39.6589885127,39.6328440961,39.6068260988,
	39.5809334306,39.5551650145,39.5295197862,39.5039966942,39.4785946995,
	39.4533127753,39.4281499069,39.4031050918,39.3781773388,39.3533656688,
	39.3286691137,39.304086717,39.2796175331,39.2552606273,39.2310150758,
	39.2068799653,39.1828543931,39.1589374668,39.1351283041,39.1114260327,
	39.0878297902,39.064338724,39.0409519911,39.0176687579,38.9944882003,
	38.9714095031,38.9484318604,38.9255544753,38.9027765596,38.8800973337,
	38.8575160268,38.8350318765,38.8126441286,38.7903520373,38.7681548648,
	38.7460518814,38.7240423652,38.7021256022,38.6803008859,38.6585675176,
	38.636924806,38.6153720669,38.5939086239,38.5725338073,38.5512469547,
	38.5300474107,38.5089345267,38.4879076609,38.4669661783,38.4461094505,
	38.4253368556,38.4046477781,38.384041609,38.3635177454,38.3430755908,
	38.3227145546,38.3024340525,38.2822335058,38.2621123421,38.2420699944,
	38.2221059018,38.2022195088,38.1824102656,38.1626776278,38.1430210566,
	38.1234400185,38.1039339853,38.0845024341,38.065144847,38.0458607114,
	38.0266495197,38.0075107692,37.9884439622,37.9694486057,37.9505242119,
	37.9316702972,37.912886383,37.8941719953,37.8755266647,37.8569499261,
	37.838441319,37.8200003873,37.8016266793,37.7833197474,37.7650791485,
	37.7469044434,37.7287951972,37.7107509792,37.6927713625,37.6748559244,
	37.6570042459,37.6392159121,37.621490512,37.6038276382,37.5862268871,
	37.568687859,37.5512101577,37.5337933905,37.5164371687,37.4991411068,
	37.4819048228,37.4647279384,37.4476100786,37.4305508715,37.4135499491,
	37.3966069463,37.3797215014,37.3628932558,37.3461218542,37.3294069446,
	37.3127481779,37.296145208,37.2795976922,37.2631052905,37.2466676661,
	37.2302844849,37.2139554159,37.197680131,37.1814583048,37.1652896148,
	37.1491737414,37.1331103675,37.1170991789,37.1011398641,37.0852321142,
	37.069375623,37.0535700867,37.0378152045,37.0221106777,37.0064562103,
	36.990851509,36.9752962825,36.9597902425,36.9443331026,36.9289245791,
	36.9135643906,36.8982522581,36.8829879046,36.8677710558,36.8526014395,
	36.8374787856,36.8224028263,36.8073732962,36.7923899319,36.7774524719,
	36.7625606573,36.747714231,36.7329129381,36.7181565255,36.7034447426,
	36.6887773404,36.6741540721,36.6595746928,36.6450389596,36.6305466316,
	36.6160974695,36.6016912363,36.5873276967,36.5730066171,36.5587277661,
	36.5444909137,36.530295832,36.5161422947,36.5020300775,36.4879589576,
	36.473928714,36.4599391274,36.4459899804,36.4320810569,36.4182121427,
	36.4043830253,36.3905934937,36.3768433384,36.3631323519,36.3494603278,
	36.3358270615,36.32223235,36.3086759918,36.2951577868,36.2816775364,
	36.2682350438,36.2548301133,36.2414625508,36.2281321637,36.2148387608,
	36.2015821522,36.1883621497,36.1751785661,36.1620312159,36.1489199148,
	36.1358444799,36.1228047297,36.1098004839,36.0968315636,36.0838977911,
	36.0709989901,36.0581349856,36.0453056038,36.0325106721,36.0197500193,
	36.0070234752,35.9943308711,35.9816720393,35.9690468132,35.9564550278,
	35.9438965189,35.9313711235,35.9188786799,35.9064190275,35.8939920068,
	35.8815974594,35.869235228,35.8569051565,35.8446070897,35.8323408738,
	35.8201063558,35.8079033838,35.7957318069,35.7835914756,35.771482241,
	35.7594039553,35.747356472,35.7353396454,35.7233533306,35.7113973841,
	35.6994716631,35.6875760259,35.6757103316,35.6638744405,35.6520682136,
	35.640291513,35.6285442016,35.6168261434,35.6051372032,35.5934772466,
	35.5818461403,35.5702437517,35.5586699493,35.5471246023,35.5356075808,
	35.5241187557,35.512657999,35.5012251833,35.489820182,35.4784428696,
	35.4670931211,35.4557708126,35.4444758209,35.4332080234,35.4219672987,
	35.4107535258,35.3995665848,35.3884063562,35.3772727218,35.3661655635,
	35.3550847646,35.3440302088,35.3330017805,35.321999365,35.3110228483,
	35.300072117,35.2891470586,35.2782475612,35.2673735136,35.2565248054,
	35.2457013268,35.2349029688,35.2241296228,35.2133811812,35.2026575371,
	35.1919585838,35.1812842159,35.1706343282,35.1600088162,35.1494075763,
	35.1388305053,35.1282775008,35.1177484608,35.1072432842,35.0967618704,
	35.0863041192,35.0758699315,35.0654592084,35.0550718516,35.0447077637,
	35.0343668477,35.0240490072,35.0137541462,35.0034821697,34.9932329829,
	34.9830064918,34.9728026027,34.9626212228,34.9524622596,34.9423256212,
	34.9322112164,34.9221189543,34.9120487447,34.9020004979,34.8919741248,
	34.8819695366,34.8719866453,34.8620253633,34.8520856033,34.842167279,
	34.8322703041,34.8223945932,34.8125400611,34.8027066232,34.7928941955,
	34.7831026943,34.7733320366,34.7635821397,34.7538529214,34.7441443,
	34.7344561944,34.7247885237,34.7151412076,34.7055141664,34.6959073207,
	34.6863205914,34.6767539002,34.6672071689,34.6576803201,34.6481732765,
	34.6386859615,34.6292182987,34.6197702123,34.6103416268,34.6009324673,
	34.5915426592,34.5821721282,34.5728208006,34.5634886031,34.5541754628,
	34.544881307,34.5356060638,34.5263496612,34.517112028,34.5078930933,
	34.4986927864,34.4895110373,34.4803477761,34.4712029334,34.4620764403,
	34.4529682279,34.4438782282,34.4348063732,34.4257525953,34.4167168273,
	34.4076990026,34.3986990546,34.3897169172,34.3807525248,34.3718058119,
	34.3628767135,34.353965165,34.3450711019,34.3361944604,34.3273351768,
	34.3184931877,34.3096684302,34.3008608417,34.2920703598,34.2832969226,
	34.2745404684,34.2658009359,34.2570782641,34.2483723923,34.2396832601,
	34.2310108075,34.2223549748,34.2137157025,34.2050929316,34.1964866032,
	34.1878966587,34.1793230401,34.1707656894,34.1622245491,34.1536995617,
	34.1451906704,34.1366978184,34.1282209493,34.1197600069,34.1113149355,
	34.1028856794,34.0944721833,34.0860743924,34.0776922518,34.0693257072,
	34.0609747043,34.0526391894,34.0443191087,34.0360144089,34.027725037,
	34.0194509401,34.0111920657,34.0029483616,33.9947197757,33.9865062562,
	33.9783077517,33.970124211,33.9619555829,33.9538018168,33.9456628623,
	33.937538669,33.929429187,33.9213343666,33.9132541583,33.9051885128,
	33.8971373811,33.8891007144,33.8810784643,33.8730705825,33.8650770208,
	33.8570977314,33.8491326669,33.8411817798,33.833245023,33.8253223496,
	33.8174137129,33.8095190666,33.8016383643,33.7937715601,33.7859186082,
	33.7780794631,33.7702540793,33.7624424119,33.7546444159,33.7468600466,
	33.7390892595,33.7313320104,33.7235882552,33.7158579501,33.7081410514,
	33.7004375158,33.6927472999,33.6850703608,33.6774066556,33.6697561417,
	33.6621187768,33.6544945186,33.646883325,33.6392851544,33.6316999649,
	33.6241277153,33.6165683642,33.6090218706,33.6014881937,33.5939672928,
	33.5864591274,33.5789636572,33.5714808422,33.5640106423,33.5565530179,
	33.5491079294,33.5416753374,33.5342552028,33.5268474865,33.5194521497,
	33.5120691538,33.5046984602,33.4973400307,33.489993827,33.4826598114,
	33.475337946,33.4680281931,33.4607305153,33.4534448754,33.4461712362,
	33.4389095608,33.4316598125,33.4244219546,33.4171959506,33.4099817644,
	33.4027793597,33.3955887006,33.3884097513,33.3812424763,33.3740868399,
	33.3669428069,33.3598103421,33.3526894105,33.3455799772,33.3384820076,
	33.3313954671,33.3243203212,33.3172565359,33.3102040768,33.3031629102,
	33.2961330022,33.2891143192,33.2821068276,33.2751104942,33.2681252856,
	33.2611511689,33.254188111,33.2472360793,33.2402950411,33.2333649639,
	33.2264458153,33.2195375632,33.2126401754,33.20575362,33.1988778652,
	33.1920128793,33.1851586308,33.1783150883,33.1714822206,33.1646599965,
	33.157848385,33.1510473553,33.1442568766,33.1374769184,33.1307074501,
	33.1239484414,33.1171998621,33.1104616821,33.1037338714,33.0970164003,
	33.090309239,33.0836123579,33.0769257276,33.0702493187,33.063583102,
	33.0569270484,33.050281129,33.0436453148,33.0370195773,33.0304038877,
	33.0237982176,33.0172025386,33.0106168224,33.004041041,32.9974751662,
	32.9909191702,32.9843730252,32.9778367035,32.9713101775,32.9647934199,
	32.9582864031,32.9517891002,32.9453014838,32.938823527,32.932355203,
	32.9258964848,32.919447346,32.9130077598,32.9065776998,32.9001571398,
	32.8937460533,32.8873444143,32.8809521968,32.8745693748,32.8681959225,
	32.8618318142,32.8554770243,32.8491315272,32.8427952975,32.8364683099,
	32.8301505393,32.8238419604,32.8175425484,32.8112522782,32.8049711251,
	32.7986990644,32.7924360713,32.7861821216,32.7799371906,32.7737012541,
	32.7674742879,32.7612562677,32.7550471697,32.7488469698,32.7426556442,
	32.7364731692,32.730299521,32.7241346761,32.717978611,32.7118313024,
	32.705692727,32.6995628615,32.6934416828,32.6873291679,32.6812252939,
	32.6751300379,32.6690433772,32.6629652891,32.656895751,32.6508347404,
	32.6447822349,32.6387382122,32.6327026501,32.6266755264,32.620656819,
	32.614646506,32.6086445654,32.6026509754,32.5966657144,32.5906887606,
	32.5847200926,32.5787596887,32.5728075277,32.5668635881,32.5609278488,
	32.5550002886,32.5490808863,32.5431696211,32.537266472,32.5313714181,
	32.5254844387,32.519605513,32.5137346206,32.5078717408,32.5020168532,
	32.4961699374,32.4903309731,32.4844999401,32.4786768182,32.4728615874,
	32.4670542276,32.4612547189,32.4554630416,32.4496791757,32.4439031016,
	32.4381347996,32.4323742503,32.426621434,32.4208763314,32.4151389231,
	32.4094091899,32.4036871126,32.3979726719,32.3922658489,32.3865666246,
	32.38087498,32.3751908962,32.3695143546,32.3638453363,32.3581838227,
	32.3525297952,32.3468832354,32.3412441247,32.3356124448,32.3299881773,
	32.3243713041,32.3187618069,32.3131596676,32.3075648682,32.3019773906,
	32.296397217,32.2908243294,32.2852587101,32.2797003414,32.2741492056,
	32.268605285,32.2630685622,32.2575390196,32.2520166399,32.2465014056,
	32.2409932995,32.2354923044,32.229998403,32.2245115783,32.2190318133,
	32.2135590908,32.208093394,32.202634706,32.1971830101,32.1917382894,
	32.1863005272,32.1808697069,32.175445812,32.170028826,32.1646187322,
	32.1592155144,32.1538191563,32.1484296414,32.1430469536,32.1376710768,
	32.1323019947,32.1269396913,32.1215841506,32.1162353567,32.1108932936,
	32.1055579455,32.1002292966,32.0949073313,32.0895920337,32.0842833883,
	32.0789813795,32.0736859917,32.0683972096,32.0631150177,32.0578394006,
	32.052570343,32.0473078297,32.0420518455,32.0368023751,32.0315594036,
	32.0263229158,32.0210928968,32.0158693316,32.0106522053,32.0054415031,
	32.0002372101,31.9950393117,31.989847793,31.9846626396,31.9794838367,
	31.9743113698,31.9691452245,31.9639853862,31.9588318406,31.9536845733,
	31.9485435701,31.9434088165,31.9382802985,31.9331580018,31.9280419124,
	31.9229320162,31.9178282991,31.9127307472,31.9076393466,31.9025540833,
	31.8974749435,31.8924019134,31.8873349793,31.8822741275,31.8772193443,
	31.8721706161,31.8671279293,31.8620912705,31.857060626,31.8520359826,
	31.8470173268,31.8420046452,31.8369979246,31.8319971517,31.8270023133,
	31.8220133962,31.8170303872,31.8120532733,31.8070820415,31.8021166787,
	31.797157172,31.7922035084,31.7872556751,31.7823136593,31.7773774481,
	31.7724470288,31.7675223886,31.762603515,31.7576903953,31.7527830168,
	31.7478813671,31.7429854336,31.7380952039,31.7332106655,31.728331806,
	31.7234586132,31.7185910746,31.713729178,31.7088729112,31.7040222619,
	31.6991772181,31.6943377676,31.6895038984,31.6846755983,31.6798528554,
	31.6750356577,31.6702239933,31.6654178504,31.660617217,31.6558220813,
	31.6510324316,31.6462482561,31.6414695432,31.636696281,31.6319284582,
	31.6271660629,31.6224090837,31.6176575091,31.6129113276,31.6081705277,
	31.6034350979,31.5987050271,31.5939803036,31.5892609164,31.5845468541,
	31.5798381054,31.5751346592,31.5704365043,31.5657436296,31.5610560239,
	31.5563736762,31.5516965754,31.5470247107,31.5423580709,31.5376966452,
	31.5330404227,31.5283893925,31.5237435438,31.5191028657,31.5144673476,
	31.5098369787,31.5052117483,31.5005916457,31.4959766602,31.4913667814,
	31.4867619986,31.4821623013,31.477567679,31.4729781212,31.4683936175,
	31.4638141574,31.4592397306,31.4546703267,31.4501059355,31.4455465465,
	31.4409921497,31.4364427347,31.4318982914,31.4273588096,31.4228242792,
	31.4182946901,31.4137700321,31.4092502953,31.4047354697,31.4002255452,
	31.395720512,31.39122036,31.3867250795,31.3822346605,31.3777490932,
	31.3732683678,31.3687924745,31.3643214037,31.3598551455,31.3553936903,
	31.3509370284,31.3464851502,31.3420380461,31.3375957065,31.3331581218,
	31.3287252826,31.3242971794,31.3198738027,31.315455143,31.311041191,
	31.3066319372,31.3022273724,31.2978274871,31.2934322722,31.2890417183,
	31.2846558161,31.2802745565,31.2758979303,31.2715259284,31.2671585414,
	31.2627957605,31.2584375764,31.2540839802,31.2497349627,31.245390515,
	31.2410506282,31.2367152932,31.2323845011,31.228058243,31.2237365101,
	31.2194192934,31.2151065843,31.2107983738,31.2064946532,31.2021954137,
	31.1979006466,31.1936103433,31.189324495,31.1850430931,31.180766129,
	31.176493594,31.1722254796,31.1679617772,31.1637024784,31.1594475745,
	31.1551970572,31.1509509179,31.1467091483,31.1424717399,31.1382386843,
	31.1340099732,31.1297855982,31.1255655511,31.1213498235,31.1171384071,
	31.1129312938,31.1087284753,31.1045299434,31.1003356899,31.0961457067,
	31.0919599856
	};

tubetable_6C16_rtable_0(r) = (tubetable_6C16_0,r):rdtable;
tubetable_6C16_rtable_1(r) = (tubetable_6C16_1,r):rdtable;

// generated by ../../tools/tube_transfer.py
// tube: 6DJ8
// plate current function: triode
// mu: 28
// kx: 1.3
// kg1: 330
// kp: 320
// kvb: 300

tubetable_6DJ8_0 = waveform{
	137.512728867,137.399223264,137.285690251,137.17212984,137.058542039,
	136.944926859,136.831284308,136.717614396,136.603917133,136.490192528,
	136.37644059,136.262661328,136.148854752,136.035020871,135.921159694,
	135.80727123,135.693355487,135.579412475,135.465442203,135.351444679,
	135.237419911,135.12336791,135.009288682,134.895182238,134.781048584,
	134.66688773,134.552699684,134.438484454,134.324242049,134.209972477,
	134.095675745,133.981351862,133.867000836,133.752622675,133.638217387,
	133.523784979,133.40932546,133.294838836,133.180325116,133.065784308,
	132.951216418,132.836621455,132.721999425,132.607350337,132.492674197,
	132.377971012,132.263240791,132.148483539,132.033699265,131.918887974,
	131.804049675,131.689184374,131.574292077,131.459372792,131.344426526,
	131.229453284,131.114453074,130.999425902,130.884371775,130.769290699,
	130.654182681,130.539047726,130.423885842,130.308697033,130.193481308,
	130.078238671,129.962969128,129.847672686,129.732349351,129.616999128,
	129.501622024,129.386218043,129.270787192,129.155329476,129.039844901,
	128.924333473,128.808795197,128.693230078,128.577638121,128.462019333,
	128.346373717,128.230701281,128.115002027,127.999275963,127.883523091,
	127.767743419,127.65193695,127.536103689,127.420243641,127.304356811,
	127.188443204,127.072502824,126.956535675,126.840541763,126.724521091,
	126.608473664,126.492399486,126.376298562,126.260170896,126.144016492,
	126.027835354,125.911627486,125.795392892,125.679131576,125.562843542,
	125.446528794,125.330187335,125.213819169,125.0974243,124.981002732,
	124.864554467,124.74807951,124.631577864,124.515049532,124.398494517,
	124.281912824,124.165304454,124.048669411,123.932007699,123.815319319,
	123.698604276,123.581862572,123.465094209,123.348299192,123.231477521,
	123.114629201,122.997754234,122.880852622,122.763924367,122.646969473,
	122.529987942,122.412979775,122.295944976,122.178883547,122.061795488,
	121.944680804,121.827539496,121.710371565,121.593177014,121.475955845,
	121.358708059,121.241433658,121.124132644,121.006805019,120.889450784,
	120.772069941,120.654662491,120.537228435,120.419767776,120.302280513,
	120.18476665,120.067226186,119.949659123,119.832065462,119.714445204,
	119.596798349,119.4791249,119.361424857,119.24369822,119.12594499,
	119.008165168,118.890358755,118.772525751,118.654666156,118.536779972,
	118.418867198,118.300927835,118.182961883,118.064969342,117.946950213,
	117.828904495,117.710832189,117.592733295,117.474607812,117.356455741,
	117.238277081,117.120071832,117.001839993,116.883581565,116.765296547,
	116.646984939,116.52864674,116.410281948,116.291890565,116.173472589,
	116.055028019,115.936556854,115.818059094,115.699534738,115.580983784,
	115.462406232,115.343802081,115.225171329,115.106513975,114.987830018,
	114.869119456,114.750382289,114.631618514,114.51282813,114.394011136,
	114.27516753,114.15629731,114.037400475,113.918477022,113.799526951,
	113.680550258,113.561546942,113.442517002,113.323460434,113.204377236,
	113.085267407,112.966130945,112.846967846,112.727778109,112.608561731,
	112.489318709,112.370049041,112.250752725,112.131429757,112.012080135,
	111.892703857,111.773300918,111.653871317,111.53441505,111.414932115,
	111.295422508,111.175886226,111.056323266,110.936733624,110.817117298,
	110.697474283,110.577804577,110.458108176,110.338385076,110.218635274,
	110.098858766,109.979055549,109.859225617,109.739368969,109.619485599,
	109.499575504,109.379638679,109.259675121,109.139684826,109.019667789,
	108.899624005,108.779553471,108.659456182,108.539332134,108.419181322,
	108.299003742,108.178799389,108.058568258,107.938310344,107.818025643,
	107.697714149,107.577375859,107.457010766,107.336618867,107.216200154,
	107.095754624,106.975282272,106.854783091,106.734257077,106.613704224,
	106.493124526,106.372517979,106.251884576,106.131224312,106.010537181,
	105.889823177,105.769082295,105.648314528,105.52751987,105.406698316,
	105.28584986,105.164974495,105.044072215,104.923143013,104.802186884,
	104.681203821,104.560193818,104.439156867,104.318092963,104.197002099,
	104.075884268,103.954739463,103.833567678,103.712368905,103.591143138,
	103.46989037,103.348610593,103.2273038,103.105969985,102.98460914,
	102.863221257,102.74180633,102.62036435,102.498895311,102.377399205,
	102.255876023,102.134325759,102.012748405,101.891143952,101.769512394,
	101.647853721,101.526167926,101.404455002,101.282714939,101.16094773,
	101.039153366,100.917331839,100.795483141,100.673607263,100.551704197,
	100.429773934,100.307816465,100.185831783,100.063819877,99.9417807401,
	99.8197143622,99.6976207349,99.575499849,99.4533516955,99.3311762653,
	99.2089735491,99.0867435378,98.964486222,98.8422015924,98.7198896394,
	98.5975503536,98.4751837255,98.3527897454,98.2303684035,98.1079196902,
	97.9854435957,97.86294011,97.7404092232,97.6178509253,97.4952652063,
	97.3726520559,97.250011464,97.1273434204,97.0046479148,96.8819249367,
	96.7591744756,96.6363965212,96.5135910627,96.3907580897,96.2678975913,
	96.1450095569,96.0220939755,95.8991508364,95.7761801285,95.6531818408,
	95.5301559623,95.4071024818,95.2840213882,95.1609126701,95.0377763163,
	94.9146123152,94.7914206556,94.6682013258,94.5449543144,94.4216796095,
	94.2983771996,94.1750470729,94.0516892175,93.9283036216,93.8048902731,
	93.6814491601,93.5579802705,93.4344835922,93.3109591128,93.1874068203,
	93.0638267021,92.940218746,92.8165829395,92.6929192701,92.5692277251,
	92.4455082919,92.3217609579,92.1979857102,92.0741825361,91.9503514226,
	91.8264923567,91.7026053255,91.5786903159,91.4547473147,91.3307763088,
	91.2067772848,91.0827502295,90.9586951294,90.8346119711,90.7105007411,
	90.5863614258,90.4621940116,90.3379984848,90.2137748316,90.0895230382,
	89.9652430908,89.8409349754,89.7165986779,89.5922341844,89.4678414807,
	89.3434205527,89.218971386,89.0944939665,88.9699882796,88.8454543111,
	88.7208920464,88.596301471,88.4716825703,88.3470353296,88.2223597342,
	88.0976557693,87.9729234202,87.8481626718,87.7233735093,87.5985559176,
	87.4737098817,87.3488353864,87.2239324165,87.0990009569,86.9740409921,
	86.8490525069,86.7240354858,86.5989899134,86.4739157741,86.3488130523,
	86.2236817325,86.0985217988,85.9733332355,85.8481160269,85.7228701571,
	85.5975956101,85.47229237,85.3469604207,85.2215997461,85.0962103302,
	84.9707921567,84.8453452094,84.719869472,84.5943649281,84.4688315614,
	84.3432693553,84.2176782934,84.092058359,83.9664095357,83.8407318067,
	83.7150251553,83.5892895648,83.4635250183,83.337731499,83.2119089899,
	83.0860574742,82.9601769347,82.8342673545,82.7083287164,82.5823610033,
	82.456364198,82.3303382832,82.2042832416,82.078199056,81.9520857088,
	81.8259431828,81.6997714604,81.5735705241,81.4473403564,81.3210809396,
	81.1947922561,81.0684742883,80.9421270183,80.8157504285,80.6893445011,
	80.5629092181,80.4364445617,80.309950514,80.1834270571,80.0568741728,
	79.9302918433,79.8036800504,79.677038776,79.550368002,79.4236677102,
	79.2969378824,79.1701785004,79.0433895459,78.9165710006,78.7897228462,
	78.6628450643,78.5359376366,78.4090005446,78.2820337698,78.1550372939,
	78.0280110983,77.9009551645,77.7738694739,77.6467540081,77.5196087483,
	77.3924336761,77.2652287728,77.1379940197,77.0107293981,76.8834348895,
	76.756110475,76.6287561361,76.5013718539,76.3739576098,76.2465133849,
	76.1190391605,75.9915349179,75.8640006383,75.7364363029,75.6088418928,
	75.4812173894,75.3535627738,75.2258780272,75.0981631308,74.9704180658,
	74.8426428134,74.7148373548,74.5870016713,74.459135744,74.3312395542,
	74.203313083,74.0753563118,73.9473692218,73.8193517943,73.6913040105,
	73.5632258517,73.4351172993,73.3069783346,73.178808939,73.0506090938,
	72.9223787804,72.7941179804,72.6658266751,72.537504846,72.4091524748,
	72.2807695429,72.1523560319,72.0239119235,71.8954371994,71.7669318413,
	71.6383958309,71.5098291501,71.3812317808,71.2526037048,71.1239449041,
	70.9952553608,70.866535057,70.7377839747,70.6090020962,70.4801894039,
	70.3513458799,70.2224715068,70.0935662671,69.9646301433,69.835663118,
	69.706665174,69.5776362942,69.4485764614,69.3194856586,69.190363869,
	69.0612110757,68.932027262,68.8028124113,68.6735665071,68.544289533,
	68.4149814728,68.2856423104,68.1562720296,68.0268706146,67.8974380496,
	67.767974319,67.6384794072,67.508953299,67.379395979,67.2498074323,
	67.1201876439,66.990536599,66.8608542831,66.7311406816,66.6013957805,
	66.4716195655,66.3418120229,66.2119731387,66.0821028996,65.9522012923,
	65.8222683035,65.6923039203,65.5623081301,65.4322809203,65.3022222787,
	65.1721321933,65.0420106521,64.9118576437,64.7816731566,64.65145718,
	64.5212097028,64.3909307146,64.2606202051,64.1302781642,63.9999045824,
	63.86949945,63.7390627581,63.6085944978,63.4780946606,63.3475632383,
	63.2170002231,63.0864056074,62.955779384,62.8251215463,62.6944320876,
	62.563711002,62.4329582837,62.3021739275,62.1713579283,62.0405102818,
	61.9096309838,61.7787200307,61.6477774192,61.5168031466,61.3857972106,
	61.2547596093,61.1236903414,60.9925894061,60.8614568029,60.7302925321,
	60.5990965942,60.4678689907,60.3366097231,60.205318794,60.0739962062,
	59.9426419632,59.8112560693,59.6798385291,59.5483893481,59.4169085323,
	59.2853960884,59.1538520239,59.0222763469,58.8906690661,58.7590301912,
	58.6273597325,58.4956577011,58.3639241087,58.2321589683,58.1003622931,
	57.9685340977,57.8366743971,57.7047832076,57.5728605462,57.4409064308,
	57.3089208804,57.1769039148,57.0448555549,56.9127758226,56.7806647409,
	56.6485223339,56.5163486267,56.3841436456,56.251907418,56.1196399725,
	55.9873413389,55.8550115484,55.7226506333,55.5902586273,55.4578355654,
	55.3253814839,55.1928964206,55.0603804149,54.9278335073,54.7952557401,
	54.6626471571,54.5300078037,54.3973377269,54.2646369754,54.1319055996,
	53.9991436517,53.8663511857,53.7335282574,53.6006749245,53.4677912468,
	53.3348772861,53.2019331059,53.0689587724,52.9359543534,52.8029199192,
	52.6698555425,52.5367612981,52.4036372633,52.2704835179,52.1373001442,
	52.0040872271,51.8708448542,51.7375731158,51.6042721052,51.4709419183,
	51.3375826542,51.204194415,51.070777306,50.9373314355,50.8038569154,
	50.6703538609,50.5368223907,50.4032626271,50.2696746961,50.1360587275,
	50.0024148551,49.8687432167,49.7350439541,49.6013172136,49.4675631456,
	49.3337819053,49.1999736524,49.0661385513,48.9322767715,48.7983884873,
	48.6644738783,48.5305331297,48.3965664318,48.2625739808,48.1285559787,
	47.9945126336,47.8604441597,47.7263507774,47.592232714,47.4580902033,
	47.3239234861,47.1897328106,47.0555184321,46.9212806137,46.7870196261,
	46.6527357484,46.5184292679,46.3841004803,46.2497496903,46.1153772119,
	45.9809833681,45.846568492,45.7121329263,45.5776770243,45.4432011498,
	45.3087056776,45.1741909936,45.0396574956,44.9051055933,44.7705357088,
	44.635948277,44.5013437459,44.3667225771,44.2320852465,44.0974322441,
	43.962764075,43.8280812598,43.6933843349,43.5586738531,43.4239503843,
	43.2892145156,43.1544668524,43.0197080186,42.8849386573,42.7501594316,
	42.6153710249,42.4805741417,42.3457695087,42.2109578746,42.0761400117,
	41.9413167163,41.8064888093,41.6716571374,41.5368225735,41.401986018,
	41.2671483992,41.1323106748,40.9974738322,40.8626388899,40.7278068984,
	40.5929789412,40.4581561358,40.3233396351,40.1885306281,40.0537303414,
	39.9189400403,39.78416103,39.6493946568,39.5146423098,39.3799054219,
	39.2451854712,39.1104839826,38.9758025293,38.8411427342,38.7065062715,
	38.5718948684,38.4373103067,38.3027544245,38.1682291179,38.0337363429,
	37.8992781174,37.7648565227,37.6304737057,37.4961318809,37.3618333323,
	37.2275804158,37.093375561,36.9592212736,36.8251201375,36.6910748171,
	36.55708806,36.4231626987,36.2893016539,36.1555079361,36.0217846488,
	35.8881349906,35.7545622582,35.6210698488,35.4876612628,35.3543401068,
	35.2211100958,35.0879750567,34.9549389303,34.822005775,34.6891797689,
	34.556465213,34.4238665343,34.2913882882,34.1590351614,34.0268119754,
	33.8947236884,33.7627753988,33.6309723478,33.499319922,33.3678236562,
	33.236489236,33.1053225003,32.9743294439,32.8435162196,32.7128891409,
	32.5824546835,32.4522194881,32.3221903615,32.1923742787,32.0627783842,
	31.9334099937,31.8042765947,31.6753858474,31.5467455858,31.4183638174,
	31.2902487238,31.1624086599,31.0348521538,30.9075879057,30.7806247864,
	30.6539718359,30.5276382612,30.4016334335,30.275966886,30.1506483095,
	30.0256875494,29.9010946007,29.7768796032,29.6530528365,29.5296247133,
	29.4066057737,29.2840066773,29.1618381963,29.0401112068,28.9188366802,
	28.7980256739,28.6776893212,28.557838821,28.4384854266,28.3196404341,
	28.2013151706,28.083520981,27.9662692154,27.8495712153,27.7334382994,
	27.6178817497,27.502912796,27.3885426015,27.274782247,27.1616427153,
	27.0491348756,26.9372694673,26.8260570842,26.7155081583,26.605632944,
	26.4964415017,26.3879436828,26.2801491135,26.1730671799,26.066707013,
	25.9610774742,25.8561871411,25.7520442943,25.6486569043,25.5460326191,
	25.4441787527,25.343102274,25.2428097972,25.1433075719,25.0446014749,
	24.9466970027,24.8495992647,24.7533129776,24.6578424604,24.5631916308,
	24.4693640021,24.3763626815,24.284190369,24.1928493573,24.102341533,
	24.0126683781,23.9238309727,23.8358299992,23.7486657456,23.6623381119,
	23.576846615,23.492190396,23.4083682275,23.3253785212,23.2432193369,
	23.1618883911,23.0813830671,23.0017004246,22.9228372103,22.8447898684,
	22.7675545521,22.6911271343,22.6155032194,22.5406781549,22.4666470431,
	22.3934047528,22.3209459315,22.2492650165,22.1783562475,22.1082136777,
	22.0388311858,21.9702024871,21.9023211449,21.8351805819,21.7687740907,
	21.7030948443,21.6381359073,21.573890245,21.5103507342,21.4475101722,
	21.3853612859,21.3238967417,21.2631091529,21.2029910891,21.1435350836,
	21.0847336411,21.0265792455,20.9690643664,20.9121814661,20.8559230061,
	20.800281453,20.7452492842,20.6908189936,20.6369830967,20.5837341354,
	20.5310646827,20.4789673469,20.4274347758,20.3764596604,20.3260347384,
	20.2761527978,20.2268066794,20.1779892802,20.1296935556,20.081912522,
	20.034639259,19.9878669114,19.941588691,19.8957978783,19.8504878237,
	19.8056519493,19.7612837498,19.7173767936,19.6739247233,19.6309212573,
	19.5883601896,19.5462353909,19.5045408084,19.4632704669,19.4224184683,
	19.3819789922,19.3419462957,19.3023147134,19.2630786571,19.2242326162,
	19.1857711566,19.1476889213,19.109980629,19.0726410748,19.0356651289,
	18.9990477362,18.9627839162,18.9268687619,18.8912974396,18.8560651877,
	18.8211673166,18.7865992077,18.7523563125,18.7184341523,18.6848283169,
	18.6515344643,18.6185483195,18.5858656739,18.5534823845,18.5213943728,
	18.4895976244,18.4580881876,18.4268621732,18.3959157529,18.3652451591,
	18.3348466836,18.3047166771,18.2748515479,18.2452477615,18.2159018395,
	18.1868103586,18.1579699502,18.1293772992,18.1010291432,18.0729222719,
	18.0450535259,18.0174197962,17.9900180234,17.9628451967,17.9358983531,
	17.9091745768,17.8826709984,17.856384794,17.8303131846,17.804453435,
	17.7788028537,17.7533587915,17.7281186413,17.7030798369,17.6782398529,
	17.6535962035,17.629146442,17.60488816,17.5808189872,17.5569365901,
	17.5332386719,17.5097229715,17.4863872631,17.4632293556,17.4402470917,
	17.4174383478,17.3948010329,17.3723330884,17.3500324875,17.3278972343,
	17.3059253639,17.2841149411,17.2624640605,17.2409708457,17.2196334488,
	17.19845005,17.177418857,17.1565381047,17.1358060544,17.1152209936,
	17.0947812357,17.0744851191,17.0543310071,17.0343172874,17.0144423714,
	16.9947046944,16.9751027147,16.9556349131,16.9362997931,16.9170958798,
	16.8980217202,16.8790758822,16.8602569547,16.8415635471,16.8229942888,
	16.804547829,16.7862228364,16.7680179988,16.7499320229,16.7319636336,
	16.714111574,16.6963746054,16.6787515061,16.661241072,16.6438421159,
	16.6265534672,16.6093739717,16.5923024914,16.5753379039,16.5584791027,
	16.5417249963,16.5250745085,16.5085265778,16.4920801573,16.4757342144,
	16.4594877306,16.4433397013,16.4272891353,16.4113350551,16.3954764962,
	16.3797125071,16.3640421492,16.3484644962,16.3329786343,16.3175836618,
	16.3022786889,16.2870628377,16.2719352417,16.2568950459,16.2419414064,
	16.2270734904,16.2122904759,16.1975915515,16.1829759164,16.1684427801,
	16.1539913623,16.1396208926,16.1253306106,16.1111197655,16.0969876161,
	16.0829334306,16.0689564863,16.0550560698,16.0412314765,16.0274820108,
	16.0138069857,16.0002057227,15.9866775518,15.9732218113,15.9598378476,
	15.9465250152,15.9332826765,15.9201102017,15.9070069688,15.8939723631,
	15.8810057776,15.8681066125,15.8552742754,15.8425081808,15.8298077503,
	15.8171724125,15.8046016028,15.7920947632,15.7796513423,15.7672707954,
	15.754952584,15.7426961761,15.7305010459,15.7183666735,15.7062925455,
	15.694278154,15.6823229973,15.6704265793,15.6585884097,15.6468080039,
	15.6350848828,15.6234185725,15.611808605,15.6002545171,15.5887558512,
	15.5773121548,15.5659229802,15.5545878851,15.543306432,15.5320781883,
	15.5209027261,15.5097796223,15.4987084586,15.4876888213,15.476720301,
	15.465802493,15.454934997,15.4441174172,15.4333493618,15.4226304434,
	15.4119602788,15.4013384891,15.3907646991,15.3802385379,15.3697596385,
	15.3593276378,15.3489421765,15.3386028993,15.3283094545,15.3180614942,
	15.3078586739,15.2977006532,15.2875870947,15.277517665,15.267492034,
	15.2575098748,15.2475708642,15.2376746822,15.2278210121,15.2180095404,
	15.208239957,15.1985119547,15.1888252296,15.1791794809,15.1695744108,
	15.1600097243,15.1504851298,15.1410003383,15.1315550638,15.1221490232,
	15.1127819361,15.1034535249,15.094163515,15.0849116342,15.0756976132,
	15.0665211851,15.057382086,15.0482800541,15.0392148306,15.030186159,
	15.0211937853,15.012237458,15.003316928,14.9944319486,14.9855822755,
	14.9767676668,14.9679878826,14.9592426857,14.950531841,14.9418551155,
	14.9332122786,14.9246031017,14.9160273584,14.9074848247,14.8989752782,
	14.8904984989,14.8820542689,14.8736423721,14.8652625946,14.8569147243,
	14.8485985512,14.8403138672,14.832060466,14.8238381434,14.8156466968,
	14.8074859258,14.7993556314,14.7912556167,14.7831856865,14.7751456474,
	14.7671353076,14.7591544771,14.7512029678,14.7432805929,14.7353871675,
	14.7275225084,14.7196864338,14.7118787638,14.7040993197,14.6963479248,
	14.6886244037,14.6809285825,14.6732602889,14.6656193522,14.6580056031,
	14.6504188737,14.6428589975,14.6353258098,14.6278191469,14.6203388467,
	14.6128847485,14.6054566928,14.5980545218,14.5906780788,14.5833272083,
	14.5760017565,14.5687015706,14.5614264991,14.554176392,14.5469511003,
	14.5397504764,14.532574374,14.5254226477,14.5182951536,14.511191749,
	14.5041122922,14.4970566428,14.4900246616,14.4830162103,14.476031152,
	14.4690693508,14.4621306719,14.4552149818,14.4483221476,14.4414520381,
	14.4346045227,14.427779472,14.4209767576,14.4141962524,14.4074378298,
	14.4007013648,14.3939867329,14.3872938109,14.3806224764,14.3739726081,
	14.3673440856,14.3607367896,14.3541506013,14.3475854034,14.3410410791,
	14.3345175128,14.3280145895,14.3215321954,14.3150702174,14.3086285433,
	14.3022070619,14.2958056626,14.2894242359,14.283062673,14.276720866,
	14.2703987079,14.2640960923,14.2578129137,14.2515490676,14.24530445,
	14.2390789579,14.232872489,14.2266849416,14.2205162152,14.2143662096,
	14.2082348255,14.2021219646,14.1960275289,14.1899514215,14.1838935459,
	14.1778538067,14.1718321088,14.165828358,14.1598424609,14.1538743246,
	14.1479238569,14.1419909664,14.1360755623,14.1301775544,14.1242968532,
	14.11843337,14.1125870164,14.106757705,14.1009453487,14.0951498615,
	14.0893711574,14.0836091515,14.0778637594,14.0721348971,14.0664224814,
	14.0607264296,14.0550466597,14.0493830902,14.0437356402,14.0381042293,
	14.0324887777,14.0268892062,14.0213054361,14.0157373894,14.0101849885,
	14.0046481563,13.9991268163,13.9936208926,13.9881303098,13.9826549929,
	13.9771948675,13.9717498598,13.9663198964,13.9609049044,13.9555048114,
	13.9501195456,13.9447490356,13.9393932105,13.9340519998,13.9287253336,
	13.9234131425,13.9181153575,13.91283191,13.9075627319,13.9023077557,
	13.8970669141,13.8918401405,13.8866273686,13.8814285326,13.876243567,
	13.871072407,13.865914988,13.860771246,13.8556411172,13.8505245383,
	13.8454214467,13.8403317797,13.8352554755,13.8301924725,13.8251427093,
	13.8201061252,13.8150826598,13.8100722531,13.8050748454,13.8000903775,
	13.7951187905,13.790160026,13.7852140259,13.7802807323,13.775360088,
	13.7704520359,13.7655565194,13.7606734822,13.7558028685,13.7509446227,
	13.7460986895,13.7412650141,13.7364435419,13.7316342189,13.7268369912,
	13.7220518053,13.717278608,13.7125173466,13.7077679684,13.7030304215,
	13.6983046538,13.693590614,13.6888882508,13.6841975133,13.679518351,
	13.6748507136,13.6701945512,13.665549814,13.6609164529,13.6562944187,
	13.6516836627,13.6470841366,13.6424957921,13.6379185813,13.6333524569,
	13.6287973714,13.6242532779,13.6197201297,13.6151978803,13.6106864838,
	13.6061858941,13.6016960656,13.5972169532,13.5927485117,13.5882906964,
	13.5838434627,13.5794067665,13.5749805636,13.5705648106,13.5661594637,
	13.5617644799,13.5573798162,13.5530054299,13.5486412786,13.54428732,
	13.5399435123,13.5356098136,13.5312861826,13.526972578,13.5226689589,
	13.5183752845,13.5140915142,13.5098176079,13.5055535255,13.5012992271,
	13.4970546733,13.4928198245,13.4885946418,13.4843790862,13.4801731191,
	13.4759767019,13.4717897965,13.4676123647,13.4634443689,13.4592857713,
	13.4551365347,13.4509966219,13.4468659959,13.4427446199,13.4386324575,
	13.4345294722,13.4304356279,13.4263508888,13.422275219,13.418208583,
	13.4141509456,13.4101022715,13.4060625259,13.4020316739,13.3980096811,
	13.393996513,13.3899921354,13.3859965145,13.3820096163,13.3780314073,
	13.374061854,13.3701009232,13.3661485818,13.362204797,13.358269536,
	13.3543427662,13.3504244554,13.3465145714,13.3426130821,13.3387199557,
	13.3348351605,13.3309586652,13.3270904383,13.3232304487,13.3193786654,
	13.3155350575,13.3116995946,13.3078722459,13.3040529813,13.3002417706,
	13.2964385836,13.2926433907,13.2888561621,13.2850768682,13.2813054797,
	13.2775419674,13.2737863022,13.2700384552,13.2662983976,13.2625661008,
	13.2588415363,13.2551246758,13.2514154912,13.2477139545,13.2440200377,
	13.2403337131,13.2366549531,13.2329837303,13.2293200174,13.2256637873,
	13.2220150128,13.2183736671,13.2147397235,13.2111131554,13.2074939363,
	13.2038820398,13.2002774397,13.19668011,13.1930900248,13.1895071582,
	13.1859314845,13.1823629783,13.178801614,13.1752473665,13.1717002105,
	13.168160121,13.1646270732,13.1611010422,13.1575820033,13.1540699321,
	13.1505648041,13.1470665951,13.1435752808,13.1400908372,13.1366132404,
	13.1331424666,13.1296784921,13.1262212933,13.1227708467,13.1193271291,
	13.1158901171,13.1124597877,13.1090361179,13.1056190848,13.1022086655,
	13.0988048375,13.0954075782,13.0920168651,13.0886326759,13.0852549884,
	13.0818837805,13.0785190301,13.0751607154,13.0718088145,13.0684633057,
	13.0651241676,13.0617913785,13.0584649171,13.0551447622,13.0518308925,
	13.048523287,13.0452219246,13.0419267846,13.0386378462,13.0353550886,
	13.0320784913,13.0288080338,13.0255436958,13.0222854569,13.019033297,
	13.0157871959,13.0125471336,13.0093130904,13.0060850462,13.0028629815,
	12.9996468766,12.9964367119,12.993232468,12.9900341256,12.9868416654,
	12.9836550682,12.9804743149,12.9772993866,12.9741302643,12.9709669292,
	12.9678093625,12.9646575458,12.9615114602,12.9583710875,12.9552364092,
	12.9521074069,12.9489840625,12.9458663579,12.9427542749,12.9396477957,
	12.9365469022,12.9334515768,12.9303618016,12.9272775591,12.9241988316,
	12.9211256016,12.9180578519,12.9149955649,12.9119387235,12.9088873106,
	12.9058413089,12.9028007015,12.8997654714,12.8967356018,12.8937110759,
	12.8906918769,12.8876779882,12.8846693933,12.8816660756,12.8786680187,
	12.8756752064,12.8726876222,12.86970525,12.8667280736,12.8637560771,
	12.8607892443,12.8578275594,12.8548710066,12.8519195701,12.848973234,
	12.8460319829,12.8430958011,12.8401646731,12.8372385835,12.8343175169,
	12.831401458,12.8284903916,12.8255843025,12.8226831755,12.8197869957,
	12.8168957481,12.8140094178,12.8111279898,12.8082514496,12.8053797822,
	12.8025129731,12.7996510076,12.7967938713,12.7939415497,12.7910940284,
	12.7882512929,12.7854133292,12.7825801228,12.7797516597,12.7769279257,
	12.7741089069,12.7712945892,12.7684849587,12.7656800016,12.762879704,
	12.7600840522,12.7572930325,12.7545066312,12.7517248349,12.74894763,
	12.7461750029,12.7434069404,12.7406434291,12.7378844557,12.7351300068,
	12.7323800695,12.7296346305,12.7268936767,12.7241571952,12.721425173,
	12.7186975971,12.7159744547,12.7132557331,12.7105414194,12.7078315009,
	12.7051259651,12.7024247993,12.699727991,12.6970355276,12.6943473968,
	12.6916635861,12.6889840833,12.6863088759,12.6836379519,12.680971299,
	12.678308905,12.6756507579,12.6729968456,12.6703471562,12.6677016776,
	12.6650603981,12.6624233057,12.6597903887,12.6571616353,12.6545370337,
	12.6519165725,12.6493002398,12.6466880242,12.6440799142,12.6414758982,
	12.6388759649,12.6362801029,12.6336883008,12.6311005473,12.6285168312,
	12.6259371414,12.6233614666,12.6207897957,12.6182221177,12.6156584215,
	12.6130986962,12.6105429308,12.6079911145,12.6054432363,12.6028992855,
	12.6003592512,12.5978231229,12.5952908898,12.5927625412,12.5902380665,
	12.5877174553,12.585200697,12.582687781,12.580178697,12.5776734346,
	12.5751719835,12.5726743332,12.5701804736,12.5676903943,12.5652040853,
	12.5627215363,12.5602427373,12.5577676781,12.5552963487,12.5528287392,
	12.5503648395,12.5479046397,12.54544813,12.5429953005,12.5405461414,
	12.5381006428,12.5356587952,12.5332205887,12.5307860138,12.5283550607,
	12.52592772,12.523503982,12.5210838372,12.5186672762,12.5162542895,
	12.5138448677,12.5114390014,12.5090366814,12.5066378982,12.5042426426,
	12.5018509054,12.4994626774,12.4970779493,12.4946967122,12.4923189569,
	12.4899446743,12.4875738554,12.4852064912,12.4828425728,12.4804820912,
	12.4781250374,12.4757714028,12.4734211784,12.4710743554,12.468730925,
	12.4663908786,12.4640542075,12.4617209029,12.4593909562,12.4570643588,
	12.4547411022,12.4524211778,12.4501045771,12.4477912916,12.4454813129,
	12.4431746326,12.4408712422,12.4385711334,12.4362742979,12.4339807274,
	12.4316904136,12.4294033483,12.4271195232,12.4248389303,12.4225615613,
	12.4202874082,12.4180164628,12.4157487171,12.413484163,12.4112227927,
	12.408964598,12.406709571,12.4044577039,12.4022089887,12.3999634176,
	12.3977209827,12.3954816763,12.3932454906,12.3910124178,12.3887824501,
	12.38655558,12.3843317998,12.3821111017,12.3798934782,12.3776789218,
	12.3754674248,12.3732589797,12.371053579,12.3688512153,12.366651881,
	12.3644555688,12.3622622713,12.3600719811,12.3578846908,12.3557003931,
	12.3535190807,12.3513407464,12.3491653829,12.3469929829,12.3448235394,
	12.342657045,12.3404934928,12.3383328755,12.336175186,12.3340204173,
	12.3318685624,12.3297196142,12.3275735657,12.3254304099,12.3232901399,
	12.3211527488,12.3190182296,12.3168865756,12.3147577797,12.3126318353,
	12.3105087354,12.3083884733,12.3062710423,12.3041564356,12.3020446464,
	12.2999356681,12.2978294941,12.2957261176,12.2936255321,12.2915277309,
	12.2894327075,12.2873404553,12.2852509678,12.2831642384,12.2810802607,
	12.2789990281,12.2769205344,12.2748447729,12.2727717373,12.2707014213,
	12.2686338185,12.2665689225,12.2645067269,12.2624472256,12.2603904123,
	12.2583362806,12.2562848243,12.2542360373,12.2521899133,12.2501464462,
	12.2481056297,12.2460674579,12.2440319245,12.2419990234,12.2399687487,
	12.2379410942,12.2359160539,12.2338936219,12.231873792,12.2298565583,
	12.227841915,12.225829856,12.2238203754,12.2218134674,12.2198091261,
	12.2178073455,12.2158081199,12.2138114435,12.2118173105,12.209825715,
	12.2078366513,12.2058501137,12.2038660965,12.2018845939,12.1999056003,
	12.1979291099,12.1959551172,12.1939836165,12.1920146022,12.1900480687,
	12.1880840104,12.1861224218,12.1841632973,12.1822066314,12.1802524186,
	12.1783006534,12.1763513304,12.174404444,12.1724599888,12.1705179595,
	12.1685783507,12.1666411568,12.1647063727,12.1627739928,12.160844012,
	12.1589164248,12.156991226,12.1550684103,12.1531479725,12.1512299072,
	12.1493142093,12.1474008735,12.1454898947,12.1435812676,12.1416749871,
	12.1397710481,12.1378694453,12.1359701738,12.1340732283,12.1321786038,
	12.1302862953,12.1283962977,12.1265086058,12.1246232148,12.1227401197,
	12.1208593153,12.1189807968,12.1171045592,12.1152305975,12.1133589068,
	12.1114894822,12.1096223189,12.1077574118,12.1058947562,12.1040343472,
	12.1021761799,12.1003202496,12.0984665514,12.0966150806,12.0947658323,
	12.0929188017,12.0910739843,12.0892313751,12.0873909695,12.0855527628,
	12.0837167503,12.0818829273,12.0800512891,12.0782218311,12.0763945487,
	12.0745694373,12.0727464922,12.0709257088,12.0691070826,12.067290609,
	12.0654762834
	};

tubetable_6DJ8_1 = waveform{
	137.512728867,137.399223264,137.285690251,137.17212984,137.058542039,
	136.944926859,136.831284308,136.717614396,136.603917133,136.490192528,
	136.37644059,136.262661328,136.148854752,136.035020871,135.921159694,
	135.80727123,135.693355487,135.579412475,135.465442203,135.351444679,
	135.237419911,135.12336791,135.009288682,134.895182238,134.781048584,
	134.66688773,134.552699684,134.438484454,134.324242049,134.209972477,
	134.095675745,133.981351862,133.867000836,133.752622675,133.638217387,
	133.523784979,133.40932546,133.294838836,133.180325116,133.065784308,
	132.951216418,132.836621455,132.721999425,132.607350337,132.492674197,
	132.377971012,132.263240791,132.148483539,132.033699265,131.918887974,
	131.804049675,131.689184374,131.574292077,131.459372792,131.344426526,
	131.229453284,131.114453074,130.999425902,130.884371775,130.769290699,
	130.654182681,130.539047726,130.423885842,130.308697033,130.193481308,
	130.078238671,129.962969128,129.847672686,129.732349351,129.616999128,
	129.501622024,129.386218043,129.270787192,129.155329476,129.039844901,
	128.924333473,128.808795197,128.693230078,128.577638121,128.462019333,
	128.346373717,128.230701281,128.115002027,127.999275963,127.883523091,
	127.767743419,127.65193695,127.536103689,127.420243641,127.304356811,
	127.188443204,127.072502824,126.956535675,126.840541763,126.724521091,
	126.608473664,126.492399486,126.376298562,126.260170896,126.144016492,
	126.027835354,125.911627486,125.795392892,125.679131576,125.562843542,
	125.446528794,125.330187335,125.213819169,125.0974243,124.981002732,
	124.864554467,124.74807951,124.631577864,124.515049532,124.398494517,
	124.281912824,124.165304454,124.048669411,123.932007699,123.815319319,
	123.698604276,123.581862572,123.465094209,123.348299192,123.231477521,
	123.114629201,122.997754234,122.880852622,122.763924367,122.646969473,
	122.529987942,122.412979775,122.295944976,122.178883547,122.061795488,
	121.944680804,121.827539496,121.710371565,121.593177014,121.475955845,
	121.358708059,121.241433658,121.124132644,121.006805019,120.889450784,
	120.772069941,120.654662491,120.537228435,120.419767776,120.302280513,
	120.18476665,120.067226186,119.949659123,119.832065462,119.714445204,
	119.596798349,119.4791249,119.361424857,119.24369822,119.12594499,
	119.008165168,118.890358755,118.772525751,118.654666156,118.536779972,
	118.418867198,118.300927835,118.182961883,118.064969342,117.946950213,
	117.828904495,117.710832189,117.592733295,117.474607812,117.356455741,
	117.238277081,117.120071832,117.001839993,116.883581565,116.765296548,
	116.646984939,116.52864674,116.410281948,116.291890565,116.173472589,
	116.055028019,115.936556854,115.818059094,115.699534738,115.580983784,
	115.462406232,115.343802081,115.225171329,115.106513975,114.987830018,
	114.869119456,114.750382289,114.631618514,114.51282813,114.394011136,
	114.27516753,114.15629731,114.037400475,113.918477022,113.799526951,
	113.680550258,113.561546942,113.442517002,113.323460434,113.204377236,
	113.085267407,112.966130945,112.846967846,112.727778109,112.608561731,
	112.489318709,112.370049041,112.250752725,112.131429757,112.012080135,
	111.892703857,111.773300918,111.653871317,111.53441505,111.414932115,
	111.295422508,111.175886226,111.056323266,110.936733624,110.817117298,
	110.697474283,110.577804577,110.458108176,110.338385076,110.218635274,
	110.098858766,109.979055549,109.859225618,109.739368969,109.619485599,
	109.499575504,109.379638679,109.259675121,109.139684826,109.019667789,
	108.899624005,108.779553471,108.659456182,108.539332134,108.419181322,
	108.299003742,108.178799389,108.058568258,107.938310344,107.818025643,
	107.69771415,107.577375859,107.457010766,107.336618867,107.216200154,
	107.095754624,106.975282272,106.854783091,106.734257077,106.613704224,
	106.493124526,106.372517979,106.251884576,106.131224312,106.010537181,
	105.889823177,105.769082295,105.648314528,105.52751987,105.406698317,
	105.28584986,105.164974495,105.044072215,104.923143013,104.802186884,
	104.681203821,104.560193818,104.439156867,104.318092963,104.197002099,
	104.075884268,103.954739463,103.833567678,103.712368905,103.591143138,
	103.46989037,103.348610593,103.227303801,103.105969985,102.98460914,
	102.863221258,102.74180633,102.620364351,102.498895311,102.377399205,
	102.255876023,102.134325759,102.012748405,101.891143953,101.769512394,
	101.647853721,101.526167927,101.404455002,101.282714939,101.16094773,
	101.039153366,100.917331839,100.795483141,100.673607263,100.551704197,
	100.429773934,100.307816466,100.185831783,100.063819878,99.9417807406,
	99.8197143628,99.6976207354,99.5754998496,99.4533516961,99.3311762659,
	99.2089735498,99.0867435385,98.9644862227,98.8422015931,98.7198896402,
	98.5975503544,98.4751837263,98.3527897462,98.2303684044,98.1079196912,
	97.9854435967,97.862940111,97.7404092242,97.6178509264,97.4952652074,
	97.3726520571,97.2500114653,97.1273434217,97.0046479161,96.881924938,
	96.759174477,96.6363965227,96.5135910643,96.3907580913,96.267897593,
	96.1450095586,96.0220939773,95.8991508382,95.7761801304,95.6531818428,
	95.5301559644,95.407102484,95.2840213905,95.1609126725,95.0377763187,
	94.9146123178,94.7914206583,94.6682013286,94.5449543172,94.4216796125,
	94.2983772027,94.1750470761,94.0516892209,93.9283036251,93.8048902767,
	93.6814491639,93.5579802744,93.4344835962,93.3109591171,93.1874068247,
	93.0638267067,92.9402187508,92.8165829445,92.6929192752,92.5692277304,
	92.4455082975,92.3217609637,92.1979857163,92.0741825423,91.9503514291,
	91.8264923635,91.7026053326,91.5786903232,91.4547473223,91.3307763167,
	91.206777293,91.082750238,90.9586951383,90.8346119803,90.7105007507,
	90.5863614358,90.462194022,90.3379984956,90.2137748429,90.0895230499,
	89.965243103,89.840934988,89.7165986911,89.5922341981,89.467841495,
	89.3434205675,89.2189714014,89.0944939825,88.9699882963,88.8454543284,
	88.7208920644,88.5963014897,88.4716825897,88.3470353498,88.2223597552,
	88.0976557912,87.9729234429,87.8481626954,87.7233735338,87.5985559431,
	87.4737099082,87.3488354139,87.2239324452,87.0990009867,86.9740410231,
	86.8490525391,86.7240355193,86.5989899482,86.4739158103,86.34881309,
	86.2236817716,86.0985218395,85.9733332779,85.8481160709,85.7228702028,
	85.5975956577,85.4722924194,85.3469604721,85.2215997996,85.0962103858,
	84.9707922146,84.8453452696,84.7198695345,84.5943649931,84.4688316289,
	84.3432694255,84.2176783664,84.092058435,83.9664096147,83.8407318888,
	83.7150252407,83.5892896536,83.4635251106,83.3377315949,83.2119090897,
	83.0860575779,82.9601770426,82.8342674667,82.708328833,82.5823611245,
	82.456364324,82.3303384143,82.2042833779,82.0781991977,81.9520858562,
	81.825943336,81.6997716197,81.5735706898,81.4473405286,81.3210811187,
	81.1947924423,81.0684744819,80.9421272196,80.8157506378,80.6893447187,
	80.5629094444,80.436444797,80.3099507586,80.1834273114,80.0568744373,
	79.9302921182,79.8036803362,79.6770390732,79.550368311,79.4236680315,
	79.2969382165,79.1701788478,79.0433899071,78.9165713762,78.7897232367,
	78.6628454704,78.5359380588,78.4090009835,78.2820342262,78.1550377685,
	78.0280115917,77.9009556775,77.7738700074,77.6467545627,77.519609325,
	77.3924342757,77.2652293962,77.1379946679,77.0107300721,76.8834355903,
	76.7561112037,76.6287568937,76.5013726416,76.3739584288,76.2465142365,
	76.119040046,75.9915358386,75.8640015956,75.7364372982,75.6088429277,
	75.4812184654,75.3535638926,75.2258791905,75.0981643403,74.9704193234,
	74.842644121,74.7148387145,74.587003085,74.4591372139,74.3312410825,
	74.2033146721,74.0753579641,73.9473709398,73.8193535805,73.6913058677,
	73.5632277828,73.4351193072,73.3069804223,73.1788111097,73.0506113508,
	72.9223811272,72.7941204204,72.6658292121,72.537507484,72.4091552176,
	72.2807723947,72.1523589971,72.0239150066,71.8954404051,71.7669351744,
	71.6383992966,71.5098327536,71.3812355275,71.2526076005,71.1239489547,
	70.9952595725,70.8665394361,70.7377885279,70.6090068305,70.4801943263,
	70.3513509981,70.2224768285,70.0935718004,69.9646358965,69.8356691,
	69.7066713939,69.5776427614,69.4485831857,69.3194926503,69.1903711386,
	69.0612186344,68.9320351212,68.802820583,68.6735750037,68.5442983675,
	68.4149906585,68.2856518613,68.1562819603,68.0268809401,67.8974487857,
	67.7679854819,67.638491014,67.5089653673,67.3794085272,67.2498204794,
	67.1202012097,66.9905507042,66.8608689491,66.7311559309,66.601411636,
	66.4716360515,66.3418291643,66.2119909618,66.0821214314,65.9522205608,
	65.8222883382,65.6923247516,65.5623297897,65.4323034412,65.302245695,
	65.1721565406,65.0420359675,64.9118839657,64.7817005253,64.6514856368,
	64.5212392911,64.3909614794,64.2606521931,64.1303114242,63.9999391648,
	63.8695354075,63.7391001453,63.6086333716,63.47813508,63.3476052649,
	63.2170439207,63.0864510425,62.9558266257,62.8251706663,62.6944831608,
	62.5637641059,62.4330134991,62.3022313383,62.1714176218,62.0405723488,
	61.9096955186,61.7787871314,61.6478471879,61.5168756894,61.3858726377,
	61.2548380355,61.1237718859,60.9926741928,60.8615449607,60.730384195,
	60.5991919017,60.4679680876,60.3367127601,60.2054259277,60.0741075994,
	59.9427577854,59.8113764964,59.6799637443,59.5485195417,59.4170439022,
	59.2855368404,59.1539983719,59.0224285133,58.8908272824,58.7591946978,
	58.6275307794,58.4958355482,58.3641090265,58.2323512377,58.1005622064,
	57.9687419586,57.8368905217,57.7050079243,57.5730941965,57.4411493697,
	57.3091734771,57.1771665531,57.0451286339,56.9130597573,56.7809599628,
	56.6488292914,56.5166677863,56.3844754921,56.2522524556,56.1199987253,
	55.9877143521,55.8553993885,55.7230538895,55.5906779121,55.4582715156,
	55.3258347616,55.1933677144,55.0608704404,54.9283430087,54.7957854911,
	54.6631979622,54.5305804991,54.3979331822,54.2652560946,54.1325493226,
	53.9998129557,53.8670470866,53.7342518116,53.6014272301,53.4685734456,
	53.3356905649,53.202778699,53.0698379626,52.9368684747,52.8038703584,
	52.6708437413,52.5377887554,52.4047055373,52.2715942288,52.1384549761,
	52.005287931,51.8720932505,51.7388710969,51.6056216384,51.4723450489,
	51.3390415085,51.2057112034,51.0723543264,50.9389710768,50.8055616609,
	50.6721262922,50.5386651916,50.4051785874,50.271666716,50.1381298218,
	50.0045681577,49.8709819854,49.7373715755,49.6037372078,49.470079172,
	49.3363977676,49.2026933043,49.0689661028,48.9352164944,48.8014448221,
	48.6676514405,48.5338367167,48.40000103,48.2661447731,48.1322683519,
	47.9983721867,47.8644567117,47.7305223766,47.5965696462,47.4625990014,
	47.3286109398,47.1946059759,47.0605846422,46.9265474893,46.792495087,
	46.6584280245,46.5243469117,46.3902523791,46.2561450792,46.122025687,
	45.9878949008,45.853753443,45.7196020608,45.5854415275,45.4512726429,
	45.3170962344,45.1829131581,45.0487242995,44.9145305749,44.7803329321,
	44.6461323516,44.5119298478,44.3777264702,44.2435233043,44.1093214733,
	43.9751221389,43.8409265029,43.7067358086,43.5725513419,43.4383744332,
	43.3042064584,43.1700488409,43.0359030526,42.9017706161,42.7676531062,
	42.6335521515,42.4994694361,42.3654067018,42.2313657496,42.0973484418,
	41.9633567039,41.8293925267,41.6954579684,41.5615551566,41.4276862907,
	41.293853644,41.1600595658,41.0263064842,40.8925969082,40.7589334302,
	40.6253187286,40.4917555701,40.3582468127,40.2247954079,40.0914044039,
	39.9580769478,39.8248162888,39.691625781,39.5585088858,39.4254691754,
	39.2925103354,39.1596361679,39.0268505942,38.8941576581,38.7615615286,
	38.6290665035,38.4966770114,38.3643976159,38.2322330175,38.1001880572,
	37.9682677194,37.8364771346,37.7048215822,37.5733064936,37.4419374545,
	37.3107202079,37.1796606565,37.0487648651,36.9180390628,36.7874896455,
	36.6571231776,36.526946394,36.3969662016,36.2671896813,36.1376240885,
	36.0082768545,35.8791555875,35.7502680727,35.6216222725,35.4932263267,
	35.3650885517,35.23721744,35.1096216587,34.9823100482,34.8552916201,
	34.7285755548,34.6021711986,34.4760880604,34.3503358077,34.2249242626,
	34.0998633968,33.9751633259,33.8508343041,33.7268867171,33.6033310755,
	33.4801780068,33.3574382475,33.2351226341,33.1132420942,32.9918076357,
	32.8708303373,32.7503213367,32.6302918195,32.5107530067,32.3917161423,
	32.2731924804,32.1551932711,32.037729747,31.9208131085,31.8044545095,
	31.6886650419,31.5734557206,31.4588374679,31.3448210978,31.2314173004,
	31.1186366258,31.0064894684,30.8949860509,30.7841364092,30.6739503761,
	30.5644375666,30.455607363,30.3474688999,30.2400310502,30.1333024117,
	30.0272912935,29.9220057037,29.8174533375,29.7136415657,29.6105774244,
	29.5082676055,29.4067184471,29.3059359261,29.2059256507,29.1066928541,
	29.0082423889,28.9105787231,28.8137059359,28.7176277156,28.6223473578,
	28.5278677641,28.4341914432,28.3413205108,28.2492566924,28.1580013255,
	28.0675553634,27.9779193796,27.8890935724,27.8010777713,27.7138714431,
	27.6274736993,27.5418833035,27.4570986796,27.373117921,27.289938799,
	27.2075587732,27.1259750009,27.0451843475,26.965183397,26.8859684628,
	26.8075355984,26.7298806087,26.652999061,26.5768862962,26.5015374399,
	26.426947414,26.3531109471,26.2800225865,26.2076767084,26.1360675291,
	26.0651891153,25.9950353953,25.9256001685,25.8568771158,25.7888598095,
	25.7215417227,25.6549162387,25.5889766601,25.5237162175,25.4591280777,
	25.3952053525,25.331941106,25.2693283624,25.2073601134,25.1460293249,
	25.0853289441,25.0252519052,24.9657911364,24.9069395648,24.8486901225,
	24.7910357516,24.7339694092,24.677484072,24.6215727409,24.5662284448,
	24.5114442449,24.4572132382,24.4035285609,24.3503833915,24.2977709541,
	24.2456845208,24.1941174145,24.1430630113,24.0925147424,24.0424660964,
	23.992910621,23.9438419248,23.8952536784,23.8471396162,23.7994935376,
	23.7523093077,23.7055808586,23.6593021901,23.6134673704,23.5680705368,
	23.5231058959,23.4785677245,23.4344503694,23.3907482481,23.3474558483,
	23.3045677287,23.2620785186,23.2199829176,23.1782756959,23.1369516941,
	23.0960058224,23.055433061,23.0152284591,22.9753871351,22.9359042758,
	22.8967751359,22.8579950378,22.8195593706,22.7814635902,22.743703218,
	22.7062738406,22.6691711094,22.6323907394,22.5959285091,22.5597802593,
	22.5239418928,22.4884093734,22.4531787255,22.4182460329,22.3836074384,
	22.3492591431,22.3151974054,22.2814185405,22.2479189191,22.2146949676,
	22.1817431664,22.1490600496,22.1166422042,22.0844862693,22.0525889354,
	22.0209469434,21.9895570842,21.9584161977,21.9275211724,21.896868944,
	21.8664564954,21.8362808557,21.8063390992,21.7766283451,21.7471457566,
	21.7178885402,21.6888539452,21.6600392626,21.631441825,21.6030590054,
	21.5748882168,21.5469269116,21.5191725808,21.4916227535,21.4642749962,
	21.4371269121,21.4101761408,21.3834203573,21.3568572718,21.3304846287,
	21.3043002064,21.2783018166,21.2524873036,21.2268545441,21.2014014463,
	21.1761259495,21.1510260236,21.1260996686,21.1013449141,21.0767598189,
	21.0523424701,21.0280909831,21.004003501,20.9800781938,20.9563132586,
	20.9327069183,20.9092574221,20.8859630443,20.8628220842,20.8398328657,
	20.8169937368,20.7943030693,20.7717592581,20.7493607214,20.7271058996,
	20.7049932554,20.6830212735,20.6611884598,20.6394933414,20.617934466,
	20.5965104018,20.5752197372,20.5540610799,20.5330330574,20.512134316,
	20.491363521,20.4707193559,20.4502005225,20.4298057403,20.4095337464,
	20.3893832953,20.3693531584,20.3494421236,20.3296489955,20.3099725947,
	20.2904117577,20.2709653368,20.2516321995,20.2324112284,20.2133013213,
	20.1943013902,20.1754103619,20.1566271772,20.1379507909,20.1193801714,
	20.1009143009,20.0825521747,20.0642928011,20.0461352015,20.0280784098,
	20.0101214725,19.9922634483,19.9745034079,19.9568404342,19.9392736215,
	19.9218020757,19.9044249141,19.8871412651,19.8699502683,19.8528510738,
	19.8358428425,19.818924746,19.8020959659,19.7853556942,19.7687031328,
	19.7521374934,19.7356579977,19.7192638768,19.702954371,19.6867287302,
	19.6705862133,19.6545260883,19.6385476318,19.6226501296,19.6068328756,
	19.5910951724,19.5754363311,19.5598556707,19.5443525186,19.5289262099,
	19.5135760879,19.4983015033,19.4831018147,19.4679763881,19.4529245969,
	19.4379458218,19.4230394509,19.4082048791,19.3934415084,19.3787487479,
	19.3641260131,19.3495727265,19.3350883172,19.3206722206,19.3063238786,
	19.2920427395,19.2778282577,19.263679894,19.2495971149,19.2355793932,
	19.2216262073,19.2077370416,19.1939113861,19.1801487367,19.1664485945,
	19.1528104664,19.1392338645,19.1257183064,19.1122633148,19.0988684177,
	19.0855331483,19.0722570446,19.0590396499,19.0458805122,19.0327791844,
	19.0197352243,19.0067481941,18.993817661,18.9809431967,18.9681243774,
	18.9553607836,18.9426520006,18.9299976177,18.9173972287,18.9048504315,
	18.8923568283,18.8799160254,18.8675276332,18.855191266,18.8429065421,
	18.8306730839,18.8184905175,18.8063584728,18.7942765836,18.7822444873,
	18.7702618249,18.7583282413,18.7464433847,18.734606907,18.7228184636,
	18.7110777131,18.6993843177,18.6877379431,18.6761382579,18.6645849344,
	18.6530776479,18.6416160769,18.6301999032,18.6188288114,18.6075024895,
	18.5962206284,18.5849829221,18.5737890673,18.5626387639,18.5515317145,
	18.5404676247,18.5294462029,18.5184671601,18.5075302104,18.4966350702,
	18.4857814588,18.4749690983,18.4641977132,18.4534670307,18.4427767803,
	18.4321266945,18.4215165079,18.4109459577,18.4004147836,18.3899227277,
	18.3794695343,18.3690549502,18.3586787246,18.3483406089,18.3380403567,
	18.327777724,18.3175524689,18.3073643518,18.2972131352,18.2870985837,
	18.2770204641,18.2669785453,18.2569725982,18.2470023957,18.2370677129,
	18.2271683268,18.2173040164,18.2074745625,18.1976797481,18.187919358,
	18.1781931787,18.1685009989,18.1588426089,18.149217801,18.1396263691,
	18.1300681091,18.1205428184,18.1110502966,18.1015903445,18.0921627649,
	18.0827673623,18.0734039429,18.0640723142,18.0547722859,18.0455036688,
	18.0362662756,18.0270599206,18.0178844194,18.0087395894,17.9996252494,
	17.9905412198,17.9814873225,17.9724633808,17.9634692195,17.9545046649,
	17.9455695447,17.9366636879,17.9277869252,17.9189390885,17.9101200109,
	17.9013295273,17.8925674735,17.883833687,17.8751280064,17.8664502716,
	17.857800324,17.849178006,17.8405831614,17.8320156354,17.8234752741,
	17.8149619251,17.8064754372,17.7980156603,17.7895824455,17.7811756451,
	17.7727951126,17.7644407026,17.7561122709,17.7478096744,17.7395327711,
	17.7312814201,17.7230554816,17.714854817,17.7066792887,17.69852876,
	17.6904030955,17.6823021608,17.6742258224,17.6661739479,17.6581464059,
	17.6501430661,17.642163799,17.6342084763,17.6262769706,17.6183691553,
	17.6104849049,17.6026240949,17.5947866017,17.5869723025,17.5791810756,
	17.5714128001,17.5636673559,17.5559446241,17.5482444865,17.5405668256,
	17.5329115251,17.5252784694,17.5176675436,17.510078634,17.5025116274,
	17.4949664116,17.4874428751,17.4799409074,17.4724603986,17.4650012398,
	17.4575633227,17.4501465398,17.4427507845,17.4353759509,17.4280219338,
	17.4206886288,17.4133759324,17.4060837415,17.3988119541,17.3915604686,
	17.3843291844,17.3771180014,17.3699268203,17.3627555424,17.35560407,
	17.3484723057,17.341360153,17.3342675159,17.3271942994,17.3201404088,
	17.3131057502,17.3060902305,17.2990937569,17.2921162377,17.2851575813,
	17.2782176971,17.2712964951,17.2643938858,17.2575097803,17.2506440905,
	17.2437967285,17.2369676075,17.2301566409,17.2233637429,17.2165888281,
	17.2098318119,17.2030926101,17.1963711391,17.189667316,17.1829810581,
	17.1763122836,17.1696609112,17.1630268599,17.1564100495,17.1498104003,
	17.1432278329,17.1366622687,17.1301136294,17.1235818374,17.1170668156,
	17.1105684871,17.1040867758,17.0976216062,17.0911729029,17.0847405913,
	17.0783245972,17.0719248468,17.0655412669,17.0591737847,17.0528223279,
	17.0464868247,17.0401672035,17.0338633936,17.0275753244,17.0213029259,
	17.0150461285,17.008804863,17.0025790607,16.9963686535,16.9901735733,
	16.9839937528,16.9778291251,16.9716796235,16.9655451818,16.9594257344,
	16.9533212159,16.9472315614,16.9411567063,16.9350965866,16.9290511385,
	16.9230202986,16.9170040041,16.9110021924,16.9050148013,16.8990417691,
	16.8930830343,16.8871385358,16.8812082131,16.8752920059,16.8693898542,
	16.8635016985,16.8576274795,16.8517671385,16.8459206169,16.8400878566,
	16.8342687999,16.8284633893,16.8226715677,16.8168932783,16.8111284648,
	16.8053770711,16.7996390414,16.7939143204,16.7882028529,16.7825045842,
	16.7768194599,16.7711474258,16.7654884282,16.7598424137,16.7542093289,
	16.7485891212,16.7429817379,16.7373871268,16.731805236,16.7262360139,
	16.7206794092,16.7151353708,16.7096038479,16.7040847902,16.6985781476,
	16.69308387,16.687601908,16.6821322124,16.676674734,16.6712294241,
	16.6657962344,16.6603751165,16.6549660228,16.6495689054,16.6441837172,
	16.6388104109,16.6334489397,16.6280992572,16.6227613169,16.617435073,
	16.6121204796,16.6068174911,16.6015260624,16.5962461483,16.5909777043,
	16.5857206857,16.5804750482,16.575240748,16.5700177411,16.5648059841,
	16.5596054337,16.5544160468,16.5492377806,16.5440705926,16.5389144403,
	16.5337692817,16.5286350749,16.5235117782,16.5183993502,16.5132977498,
	16.5082069358,16.5031268677,16.4980575048,16.4929988068,16.4879507336,
	16.4829132453,16.4778863024,16.4728698652,16.4678638946,16.4628683516,
	16.4578831973,16.4529083931,16.4479439006,16.4429896815,16.438045698,
	16.4331119121,16.4281882863,16.4232747832,16.4183713655,16.4134779963,
	16.4085946388,16.4037212562,16.3988578123,16.3940042707,16.3891605954,
	16.3843267505,16.3795027004,16.3746884096,16.3698838428,16.3650889649,
	16.3603037408,16.3555281359,16.3507621156,16.3460056454,16.3412586913,
	16.336521219,16.3317931948,16.3270745849,16.3223653558,16.3176654741,
	16.3129749068,16.3082936207,16.303621583,16.298958761,16.2943051222,
	16.2896606343,16.285025265,16.2803989824,16.2757817546,16.2711735499,
	16.2665743366,16.2619840836,16.2574027594,16.2528303331,16.2482667737,
	16.2437120505,16.2391661329,16.2346289903,16.2301005925,16.2255809094,
	16.2210699108,16.2165675671,16.2120738484,16.2075887252,16.203112168,
	16.1986441477,16.194184635,16.189733601,16.1852910168,16.1808568537,
	16.1764310832,16.1720136768,16.1676046063,16.1632038434,16.1588113602,
	16.1544271288,16.1500511214,16.1456833105,16.1413236685,16.1369721682,
	16.1326287822,16.1282934836,16.1239662453,16.1196470405,16.1153358426,
	16.1110326249,16.1067373611,16.1024500248,16.0981705898,16.0938990301,
	16.0896353196,16.0853794327,16.0811313435,16.0768910266,16.0726584563,
	16.0684336075,16.0642164549,16.0600069734,16.055805138,16.0516109239,
	16.0474243062,16.0432452604,16.0390737619,16.0349097864,16.0307533095,
	16.026604307,16.022462755,16.0183286294,16.0142019064,16.0100825622,
	16.0059705733,16.0018659161,15.9977685672,15.9936785032,15.9895957011,
	15.9855201377,15.98145179,15.9773906352,15.9733366504,15.9692898131,
	15.9652501006,15.9612174904,15.9571919603,15.9531734879,15.949162051,
	15.9451576277,15.941160196,15.9371697339,15.9331862197,15.9292096318,
	15.9252399486,15.9212771486,15.9173212104,15.9133721128,15.9094298345,
	15.9054943544,15.9015656517,15.8976437053,15.8937284944,15.8898199983,
	15.8859181964,15.8820230682,15.8781345932,15.874252751,15.8703775214,
	15.8665088841,15.8626468192,15.8587913065,15.8549423262,15.8510998585,
	15.8472638835,15.8434343817,15.8396113335,15.8357947194,15.8319845199,
	15.8281807158,15.8243832879,15.8205922169,15.8168074838,15.8130290697,
	15.8092569556,15.8054911227,15.8017315522,15.7979782256,15.7942311241,
	15.7904902294,15.7867555229,15.7830269864,15.7793046016,15.7755883502,
	15.7718782142,15.7681741756,15.7644762164,15.7607843186,15.7570984646,
	15.7534186365,15.7497448167,15.7460769876,15.7424151318,15.7387592317,
	15.7351092701,15.7314652295,15.7278270929,15.7241948431,15.720568463,
	15.7169479355,15.7133332439,15.7097243711,15.7061213004,15.7025240152,
	15.6989324987,15.6953467343,15.6917667056,15.6881923961,15.6846237894,
	15.6810608692,15.6775036193,15.6739520235,15.6704060657,15.6668657298,
	15.6633309998,15.6598018599,15.6562782942,15.652760287,15.6492478224,
	15.6457408848,15.6422394587,15.6387435286,15.6352530788,15.6317680941,
	15.6282885592,15.6248144586,15.6213457773,15.6178825,15.6144246117,
	15.6109720973,15.6075249419,15.6040831305,15.6006466483,15.5972154805,
	15.5937896123,15.5903690291,15.5869537163,15.5835436592,15.5801388435,
	15.5767392546,15.5733448782,15.5699556999,15.5665717054,15.5631928806,
	15.5598192113,15.5564506833,15.5530872827,15.5497289954,15.5463758074,
	15.543027705,15.5396846742,15.5363467014,15.5330137727,15.5296858744,
	15.5263629931,15.5230451151,15.5197322269,15.5164243151,15.5131213662,
	15.5098233669,15.5065303039,15.5032421639,15.4999589337,15.4966806003,
	15.4934071504,15.4901385711,15.4868748494,15.4836159722,15.4803619267,
	15.4771127001,15.4738682796,15.4706286523,15.4673938057,15.464163727,
	15.4609384036,15.457717823,15.4545019727,15.4512908402,15.4480844132,
	15.4448826791,15.4416856258,15.4384932409,15.4353055122,15.4321224276,
	15.4289439748,15.4257701418,15.4226009166,15.4194362872,15.4162762415,
	15.4131207678,15.409969854,15.4068234885,15.4036816594,15.400544355,
	15.3974115636,15.3942832736,15.3911594733,15.3880401512,15.3849252958,
	15.3818148956,15.3787089391,15.3756074151,15.3725103121,15.3694176188,
	15.366329324,15.3632454164,15.3601658849,15.3570907183,15.3540199055,
	15.3509534355,15.3478912972,15.3448334797,15.341779972,15.3387307632,
	15.3356858425,15.3326451991,15.3296088221,15.3265767009,15.3235488246,
	15.3205251828,15.3175057647,15.3144905597,15.3114795573,15.308472747,
	15.3054701184,15.3024716609,15.2994773642,15.2964872179,15.2935012118,
	15.2905193354,15.2875415787,15.2845679312,15.281598383,15.2786329238,
	15.2756715436,15.2727142322,15.2697609796,15.2668117759,15.2638666111,
	15.2609254752,15.2579883584,15.2550552508,15.2521261426,15.249201024,
	15.2462798852,15.2433627166,15.2404495084,15.2375402511,15.2346349349,
	15.2317335503,15.2288360878,15.2259425378,15.2230528908,15.2201671375,
	15.2172852684,15.2144072741,15.2115331453,15.2086628726,15.2057964467,
	15.2029338585,15.2000750986,15.197220158,15.1943690274,15.1915216977,
	15.1886781598,15.1858384047,15.1830024233,15.1801702066,15.1773417457,
	15.1745170316,15.1716960554,15.1688788083,15.1660652813,15.1632554657,
	15.1604493526,15.1576469334,15.1548481993,15.1520531416,15.1492617516,
	15.1464740206,15.1436899402,15.1409095017,15.1381326965,15.1353595161,
	15.1325899521,15.1298239959,15.1270616392,15.1243028735,15.1215476904,
	15.1187960816,15.1160480388,15.1133035537,15.1105626179,15.1078252234,
	15.1050913618,15.1023610249,15.0996342047,15.0969108929,15.0941910815,
	15.0914747624,15.0887619276,15.086052569,15.0833466786,15.0806442485,
	15.0779452707,15.0752497372,15.0725576403,15.0698689721,15.0671837246,
	15.0645018902,15.0618234609,15.0591484291,15.0564767869,15.0538085268,
	15.051143641,15.0484821218,15.0458239617,15.0431691529,15.0405176879,
	15.0378695592,15.0352247593,15.0325832805,15.0299451154,15.0273102566,
	15.0246786966,15.022050428,15.0194254434,15.0168037355,15.0141852968,
	15.0115701201,15.0089581981,15.0063495236,15.0037440891,15.0011418876,
	14.9985429119,14.9959471547,14.9933546088,14.9907652673,14.9881791229,
	14.9855961686,14.9830163972,14.9804398018,14.9778663754,14.9752961109,
	14.9727290013,14.9701650398,14.9676042193,14.965046533,14.962491974,
	14.9599405354,14.9573922104,14.9548469921,14.9523048738,14.9497658486,
	14.9472299098,14.9446970507,14.9421672646,14.9396405447,14.9371168844,
	14.9345962771,14.932078716,14.9295641947,14.9270527064,14.9245442447,
	14.9220388029,14.9195363747,14.9170369533,14.9145405324,14.9120471055,
	14.9095566662,14.9070692079,14.9045847244,14.9021032092,14.8996246559,
	14.8971490582,14.8946764098,14.8922067044,14.8897399356,14.8872760973,
	14.884815183,14.8823571867,14.8799021021,14.877449923,14.8750006433,
	14.8725542567,14.8701107571,14.8676701385,14.8652323947,14.8627975196,
	14.8603655072,14.8579363515,14.8555100463,14.8530865858,14.8506659638,
	14.8482481745,14.8458332119,14.84342107,14.841011743,14.8386052248,
	14.8362015098,14.8338005919,14.8314024654,14.8290071244,14.8266145631,
	14.8242247756,14.8218377564,14.8194534995,14.8170719992,14.8146932498,
	14.8123172457,14.809943981,14.8075734502,14.8052056476,14.8028405675,
	14.8004782043,14.7981185525,14.7957616063,14.7934073604,14.791055809,
	14.7887069467,14.7863607679,14.7840172671,14.7816764389,14.7793382777,
	14.7770027781,14.7746699347,14.7723397421,14.7700121947,14.7676872873,
	14.7653650145,14.7630453708,14.760728351,14.7584139497,14.7561021616,
	14.7537929814,14.7514864038,14.7491824235,14.7468810354,14.7445822341,
	14.7422860144,14.7399923711,14.7377012991,14.7354127931,14.733126848,
	14.7308434587,14.72856262,14.7262843267,14.7240085739,14.7217353563,
	14.719464669,14.7171965068,14.7149308648,14.7126677378,14.7104071209,
	14.7081490091
	};


tubetable_6DJ8_rtable_0(r) = (tubetable_6DJ8_0,r):rdtable;
tubetable_6DJ8_rtable_1(r) = (tubetable_6DJ8_1,r):rdtable;


/*
 * tube: 6V6
 * */

 tubetable_6V6_0 = waveform{
	239.919843376,239.854937108,239.789738489,239.724247218,239.658462996,
	239.592385535,239.526014546,239.459349752,239.392390878,239.325137654,
	239.257589818,239.189747112,239.121609284,239.053176087,238.984447281,
	238.91542263,238.846101903,238.776484877,238.706571332,238.636361055,
	238.565853836,238.495049475,238.423947772,238.352548536,238.280851579,
	238.208856722,238.136563787,238.063972604,237.991083007,237.917894835,
	237.844407935,237.770622155,237.696537352,237.622153385,237.54747012,
	237.472487429,237.397205186,237.321623273,237.245741575,237.169559984,
	237.093078396,237.016296711,236.939214835,236.86183268,236.78415016,
	236.706167196,236.627883714,236.549299644,236.470414921,236.391229484,
	236.311743279,236.231956253,236.151868362,236.071479563,235.99078982,
	235.9097991,235.828507376,235.746914624,235.665020826,235.582825967,
	235.500330038,235.417533033,235.334434951,235.251035796,235.167335575,
	235.083334301,234.999031988,234.914428659,234.829524337,234.744319051,
	234.658812834,234.573005723,234.48689776,234.400488988,234.313779459,
	234.226769224,234.13945834,234.05184687,233.963934876,233.875722429,
	233.7872096,233.698396466,233.609283107,233.519869606,233.430156051,
	233.340142534,233.249829147,233.159215991,233.068303166,232.977090779,
	232.885578937,232.793767753,232.701657342,232.609247824,232.516539321,
	232.423531959,232.330225867,232.236621177,232.142718023,232.048516546,
	231.954016887,231.85921919,231.764123605,231.66873028,231.573039372,
	231.477051037,231.380765434,231.284182727,231.187303082,231.090126667,
	230.992653654,230.894884217,230.796818534,230.698456783,230.599799147,
	230.500845813,230.401596966,230.302052798,230.202213502,230.102079273,
	230.001650309,229.900926811,229.799908981,229.698597024,229.596991149,
	229.495091566,229.392898486,229.290412124,229.187632698,229.084560426,
	228.98119553,228.877538233,228.77358876,228.66934734,228.564814202,
	228.459989578,228.354873701,228.249466808,228.143769136,228.037780925,
	227.931502416,227.824933853,227.718075481,227.610927548,227.503490301,
	227.395763992,227.287748873,227.179445197,227.070853221,226.961973202,
	226.852805398,226.743350071,226.633607482,226.523577894,226.413261574,
	226.302658786,226.1917698,226.080594885,225.969134311,225.857388351,
	225.745357278,225.633041366,225.520440893,225.407556135,225.294387371,
	225.180934881,225.067198945,224.953179846,224.838877868,224.724293293,
	224.609426409,224.494277501,224.378846857,224.263134765,224.147141516,
	224.030867399,223.914312706,223.79747773,223.680362764,223.562968102,
	223.445294038,223.32734087,223.209108892,223.090598404,222.971809703,
	222.852743088,222.733398858,222.613777314,222.493878757,222.373703489,
	222.253251812,222.132524028,222.011520442,221.890241357,221.768687078,
	221.64685791,221.524754159,221.402376131,221.279724132,221.15679847,
	221.033599452,220.910127386,220.78638258,220.662365343,220.538075983,
	220.413514811,220.288682136,220.163578268,220.038203517,219.912558193,
	219.786642608,219.660457072,219.534001897,219.407277394,219.280283874,
	219.15302165,219.025491033,218.897692335,218.769625868,218.641291945,
	218.512690877,218.383822977,218.254688558,218.125287932,217.995621411,
	217.865689308,217.735491935,217.605029605,217.47430263,217.343311321,
	217.212055993,217.080536955,216.948754521,216.816709003,216.684400712,
	216.551829959,216.418997057,216.285902317,216.152546049,216.018928564,
	215.885050174,215.750911189,215.616511919,215.481852673,215.346933762,
	215.211755495,215.076318182,214.94062213,214.804667649,214.668455047,
	214.531984632,214.395256711,214.258271591,214.121029579,213.983530982,
	213.845776106,213.707765256,213.569498737,213.430976855,213.292199913,
	213.153168215,213.013882065,212.874341767,212.734547621,212.594499931,
	212.454198998,212.313645122,212.172838605,212.031779746,211.890468845,
	211.748906201,211.607092111,211.465026874,211.322710786,211.180144145,
	211.037327247,210.894260386,210.750943858,210.607377956,210.463562975,
	210.319499207,210.175186945,210.03062648,209.885818102,209.740762104,
	209.595458773,209.449908399,209.30411127,209.158067675,209.011777899,
	208.865242228,208.718460949,208.571434346,208.424162703,208.276646303,
	208.128885428,207.980880361,207.832631382,207.684138772,207.53540281,
	207.386423774,207.237201943,207.087737593,206.938031001,206.788082442,
	206.637892191,206.487460522,206.336787708,206.185874021,206.034719731,
	205.883325111,205.73169043,205.579815955,205.427701956,205.275348699,
	205.122756451,204.969925477,204.816856041,204.663548407,204.510002838,
	204.356219595,204.20219894,204.047941132,203.893446431,203.738715095,
	203.583747381,203.428543545,203.273103843,203.117428529,202.961517858,
	202.80537208,202.648991449,202.492376215,202.335526628,202.178442936,
	202.021125388,201.86357423,201.705789708,201.547772068,201.389521553,
	201.231038406,201.072322869,200.913375184,200.75419559,200.594784326,
	200.435141631,200.275267741,200.115162893,199.954827322,199.794261261,
	199.633464944,199.472438602,199.311182467,199.149696769,198.987981736,
	198.826037597,198.663864578,198.501462905,198.338832802,198.175974495,
	198.012888205,197.849574154,197.686032562,197.52226365,197.358267635,
	197.194044735,197.029595166,196.864919145,196.700016884,196.534888597,
	196.369534496,196.203954793,196.038149697,195.872119417,195.70586416,
	195.539384134,195.372679544,195.205750595,195.03859749,194.871220431,
	194.703619619,194.535795255,194.367747539,194.199476666,194.030982836,
	193.862266242,193.69332708,193.524165544,193.354781825,193.185176116,
	193.015348605,192.845299483,192.675028937,192.504537154,192.333824319,
	192.162890617,191.991736232,191.820361346,191.648766139,191.476950793,
	191.304915485,191.132660394,190.960185696,190.787491567,190.61457818,
	190.44144571,190.268094328,190.094524205,189.92073551,189.746728413,
	189.572503081,189.398059679,189.223398374,189.048519329,188.873422706,
	188.698108668,188.522577375,188.346828986,188.17086366,187.994681553,
	187.818282821,187.641667619,187.4648361,187.287788416,187.110524719,
	186.933045159,186.755349884,186.577439042,186.399312779,186.220971241,
	186.042414571,185.863642913,185.684656407,185.505455195,185.326039416,
	185.146409208,184.966564707,184.78650605,184.606233371,184.425746802,
	184.245046478,184.064132527,183.88300508,183.701664266,183.520110212,
	183.338343043,183.156362885,182.974169862,182.791764095,182.609145707,
	182.426314816,182.243271543,182.060016004,181.876548316,181.692868595,
	181.508976953,181.324873504,181.14055836,180.95603163,180.771293424,
	180.58634385,180.401183013,180.215811021,180.030227975,179.844433981,
	179.658429138,179.472213549,179.285787311,179.099150523,178.912303282,
	178.725245682,178.537977819,178.350499785,178.162811672,177.974913571,
	177.78680557,177.598487758,177.409960222,177.221223046,177.032276316,
	176.843120113,176.653754521,176.464179619,176.274395486,176.084402201,
	175.894199839,175.703788477,175.513168189,175.322339047,175.131301123,
	174.940054487,174.748599208,174.556935354,174.365062992,174.172982186,
	173.980693001,173.788195499,173.595489741,173.402575787,173.209453697,
	173.016123528,172.822585335,172.628839174,172.434885098,172.240723159,
	172.046353409,171.851775896,171.65699067,171.461997778,171.266797264,
	171.071389174,170.87577355,170.679950435,170.483919869,170.28768189,
	170.091236537,169.894583847,169.697723853,169.500656591,169.303382093,
	169.105900389,168.90821151,168.710315484,168.512212338,168.313902098,
	168.115384789,167.916660433,167.717729053,167.518590668,167.319245298,
	167.11969296,166.919933671,166.719967446,166.519794298,166.31941424,
	166.118827282,165.918033434,165.717032704,165.515825098,165.314410622,
	165.112789281,164.910961076,164.708926008,164.506684078,164.304235284,
	164.101579623,163.898717091,163.695647681,163.492371386,163.288888199,
	163.085198108,162.881301103,162.67719717,162.472886295,162.268368463,
	162.063643656,161.858711857,161.653573044,161.448227196,161.242674291,
	161.036914304,160.83094721,160.62477298,160.418391588,160.211803002,
	160.005007191,159.798004121,159.590793759,159.383376069,159.175751012,
	158.967918551,158.759878644,158.551631251,158.343176326,158.134513827,
	157.925643705,157.716565915,157.507280405,157.297787126,157.088086025,
	156.878177048,156.66806014,156.457735244,156.247202301,156.036461253,
	155.825512036,155.614354589,155.402988847,155.191414744,154.979632212,
	154.767641183,154.555441585,154.343033346,154.130416393,153.91759065,
	153.704556041,153.491312486,153.277859907,153.064198221,152.850327345,
	152.636247195,152.421957684,152.207458725,151.992750227,151.7778321,
	151.562704251,151.347366586,151.131819009,150.916061423,150.700093728,
	150.483915823,150.267527608,150.050928976,149.834119824,149.617100043,
	149.399869526,149.182428161,148.964775837,148.746912439,148.528837853,
	148.310551961,148.092054646,147.873345786,147.65442526,147.435292944,
	147.215948713,146.99639244,146.776623997,146.556643254,146.336450078,
	146.116044336,145.895425893,145.674594613,145.453550356,145.232292983,
	145.010822352,144.789138319,144.567240739,144.345129466,144.122804351,
	143.900265243,143.677511992,143.454544443,143.231362442,143.007965832,
	142.784354453,142.560528148,142.336486752,142.112230104,141.887758038,
	141.663070388,141.438166985,141.213047659,140.987712238,140.762160551,
	140.536392421,140.310407672,140.084206127,139.857787605,139.631151926,
	139.404298906,139.177228362,138.949940108,138.722433955,138.494709716,
	138.266767199,138.038606213,137.810226563,137.581628056,137.352810494,
	137.12377368,136.894517415,136.665041496,136.435345723,136.205429892,
	135.975293798,135.744937235,135.514359995,135.283561869,135.052542648,
	134.82130212,134.589840073,134.358156292,134.126250564,133.894122672,
	133.661772399,133.429199528,133.19640384,132.963385115,132.730143131,
	132.496677668,132.262988503,132.029075413,131.794938175,131.560576562,
	131.325990352,131.091179317,130.856143233,130.620881872,130.385395008,
	130.149682414,129.913743863,129.677579128,129.441187981,129.204570195,
	128.967725544,128.730653801,128.493354739,128.255828133,128.018073758,
	127.780091388,127.541880801,127.303441774,127.064774085,126.825877513,
	126.58675184,126.347396848,126.107812322,125.867998046,125.627953809,
	125.387679402,125.147174616,124.906439246,124.665473091,124.424275951,
	124.18284763,123.941187934,123.699296676,123.457173669,123.214818733,
	122.97223169,122.729412369,122.486360602,122.243076228,121.99955909,
	121.755809038,121.511825927,121.26760962,121.023159987,120.778476904,
	120.533560256,120.288409935,120.043025842,119.797407887,119.551555992,
	119.305470084,119.059150105,118.812596006,118.565807749,118.318785311,
	118.071528678,117.824037853,117.57631285,117.328353699,117.080160446,
	116.831733152,116.583071896,116.334176775,116.085047901,115.835685411,
	115.586089457,115.336260215,115.086197883,114.835902681,114.585374855,
	114.334614673,114.083622432,113.832398456,113.580943098,113.329256739,
	113.077339793,112.825192708,112.572815961,112.320210071,112.067375588,
	111.814313105,111.561023251,111.307506702,111.053764172,110.799796425,
	110.545604269,110.291188564,110.036550219,109.781690197,109.526609517,
	109.271309257,109.015790552,108.760054603,108.504102673,108.247936094,
	107.99155627,107.734964676,107.478162863,107.221152462,106.963935187,
	106.706512834,106.448887292,106.191060538,105.933034646,105.674811791,
	105.416394248,105.157784399,104.89898474,104.639997879,104.380826542,
	104.121473582,103.861941977,103.602234839,103.342355417,103.082307103,
	102.822093435,102.561718104,102.30118496,102.040498015,101.779661449,
	101.518679619,101.25755706,100.996298495,100.734908838,100.473393204,
	100.211756913,99.9500054931,99.6881446953,99.4261804934,99.1641190935,
	98.9019669409,98.6397307266,98.3774173951,98.115034151,97.8525884667,
	97.5900880897,97.32754105,97.0649556675,96.8023405592,96.5397046474,
	96.2770571663,96.01440767,95.7517660395,95.4891424902,95.226547579,
	94.9639922112,94.7014876479,94.4390455122,94.1766777957,93.9143968652,
	93.6522154685,93.39014674,93.1282042061,92.8664017902,92.6047538171,
	92.3432750174,92.0819805307,91.820885909,91.5600071186,91.2993605427,
	91.0389629817,90.7788316539,90.5189841954,90.2594386585,90.0002135096,
	89.7413276266,89.4828002945,89.2246512005,88.9669004284,88.709568451,
	88.4526761221,88.196244667,87.940295672,87.6848510727,87.4299331406,
	87.1755644693,86.9217679583,86.6685667964,86.4159844438,86.1640446119,
	85.9127712432,85.6621884888,85.4123206855,85.163192331,84.914828058,
	84.6672526082,84.4204908033,84.1745675171,83.9295076449,83.6853360732,
	83.4420776478,83.1997571419,82.9583992232,82.7180284205,82.4786690901,
	82.2403453816,82.0030812043,81.7669001925,81.5318256718,81.2978806254,
	81.0650876604,80.8334689751,80.6030463265,80.373840999,80.1458737738,
	79.9191648987,79.6937340602,79.469600356,79.2467822688,79.025297642,
	78.8051636567,78.5863968102,78.3690128963,78.1530269874,77.9384534185,
	77.7253057722,77.5135968673,77.3033387471,77.0945426718,76.8872191109,
	76.6813777391,76.4770274327,76.274176269,76.0728315269,75.8729996892,
	75.674686447,75.4778967059,75.2826345928,75.0889034655,74.896705923,
	74.7060438173,74.5169182664,74.3293296689,74.1432777192,73.958761424,
	73.7757791196,73.5943284902,73.4144065864,73.2360098455,73.0591341108,
	72.8837746527,72.7099261894,72.5375829084,72.3667384877,72.1973861174,
	72.0295185219,71.8631279807,71.698206351,71.5347450886,71.3727352695,
	71.2121676108,71.0530324916,70.895319974,70.7390198224,70.5841215239,
	70.4306143075,70.2784871629,70.127728859,69.9783279618,69.8302728517,
	69.6835517406,69.5381526878,69.3940636164,69.251272328,69.1097665175,
	68.9695337873,68.8305616607,68.692837595,68.556348994,68.4210832195,
	68.2870276031,68.1541694565,68.0224960825,67.8919947839,67.7626528733,
	67.6344576819,67.5073965675,67.3814569225,67.2566261813,67.132891827,
	67.0102413984,66.8886624955,66.7681427857,66.6486700089,66.5302319826,
	66.4128166063,66.2964118658,66.1810058376,66.0665866919,65.9531426963,
	65.8406622188,65.7291337307,65.6185458088,65.5088871381,65.4001465135,
	65.2923128418,65.1853751436,65.0793225539,64.9741443241,64.869829823,
	64.7663685372,64.6637500722,64.5619641527,64.4610006235,64.3608494493,
	64.261500715,64.1629446261,64.0651715079,63.9681718061,63.8719360861,
	63.776455033,63.6817194506,63.5877202614,63.4944485058,63.4018953417,
	63.3100520431,63.2189100002,63.1284607182,63.038695816,62.9496070262,
	62.8611861931,62.7734252727,62.6863163309,62.5998515428,62.5140231916,
	62.4288236674,62.344245466,62.2602811881,62.1769235376,62.094165321,
	62.0119994454,61.9304189184,61.8494168459,61.7689864313,61.6891209743,
	61.6098138696,61.5310586057,61.4528487634,61.3751780152,61.2980401233,
	61.2214289391,61.1453384013,61.0697625353,60.9946954515,60.9201313444,
	60.8460644913,60.772489251,60.699400063,60.6267914458,60.554657996,
	60.4829943874,60.4117953693,60.3410557658,60.2707704748,60.2009344661,
	60.1315427815,60.0625905326,59.9940729003,59.9259851339,59.8583225495,
	59.7910805294,59.724254521,59.6578400356,59.5918326476,59.5262279936,
	59.4610217712,59.3962097382,59.3317877115,59.2677515663,59.2040972355,
	59.140820708,59.0779180285,59.0153852966,58.9532186654,58.8914143412,
	58.8299685825,58.768877699,58.708138051,58.6477460488,58.5876981511,
	58.5279908653,58.4686207459,58.4095843943,58.3508784577,58.2924996285,
	58.2344446436,58.1767102838,58.119293373,58.0621907773,58.005399405,
	57.948916205,57.892738167,57.8368623204,57.7812857339,57.7260055146,
	57.6710188078,57.616322796,57.5619146987,57.5077917713,57.4539513053,
	57.4003906269,57.3471070972,57.2940981111,57.241361097,57.1888935166,
	57.1366928636,57.084756664,57.0330824751,56.9816678854,56.9305105136,
	56.8796080089,56.8289580495,56.7785583433,56.7284066266,56.6785006639,
	56.6288382478,56.5794171979,56.5302353612,56.4812906111,56.432580847,
	56.3841039945,56.3358580041,56.2878408518,56.2400505378,56.1924850868,
	56.1451425476,56.0980209921,56.0511185157,56.0044332366,55.9579632956,
	55.9117068555,55.8656621011,55.8198272387,55.7742004958,55.7287801209,
	55.6835643831,55.6385515716,55.5937399958,55.5491279849,55.5047138872,
	55.4604960706,55.4164729216,55.3726428452,55.3290042651,55.2855556227,
	55.2422953775,55.1992220065,55.1563340038,55.1136298808,55.0711081657,
	55.0287674032,54.9866061544,54.9446229966,54.9028165229,54.8611853421,
	54.8197280785,54.7784433715,54.7373298757,54.6963862605,54.6556112098,
	54.6150034221,54.5745616098,54.5342844997,54.4941708323,54.4542193616,
	54.4144288551,54.3747980937,54.3353258713,54.2960109948,54.2568522837,
	54.2178485702,54.1789986988,54.1403015262,54.1017559213,54.0633607649,
	54.0251149495,53.9870173791,53.9490669694,53.9112626471,53.8736033501,
	53.8360880275,53.7987156391,53.7614851554,53.7243955574,53.6874458368,
	53.6506349953,53.6139620448,53.5774260075,53.5410259151,53.5047608095,
	53.4686297419,53.4326317732,53.3967659736,53.3610314227,53.3254272092,
	53.2899524309,53.2546061945,53.2193876154,53.184295818,53.149329935,
	53.1144891078,53.079772486,53.0451792278,53.0107084993,52.9763594747,
	52.9421313363,52.9080232742,52.8740344864,52.8401641783,52.8064115633,
	52.772775862,52.7392563025,52.7058521203,52.672562558,52.6393868653,
	52.6063242993,52.5733741236,52.5405356091,52.5078080332,52.4751906802,
	52.442682841,52.4102838131,52.3779929004,52.3458094133,52.3137326685,
	52.281761989,52.2498967038,52.2181361484,52.1864796639,52.1549265977,
	52.123476303,52.0921281387,52.0608814697,52.0297356664,51.998690105,
	51.9677441672,51.9368972401,51.9061487165,51.8754979942,51.8449444767,
	51.8144875727,51.7841266957,51.7538612649,51.7236907043,51.6936144428,
	51.6636319146,51.6337425585,51.6039458184,51.5742411427,51.544627985,
	51.5151058032,51.4856740601,51.4563322228,51.4270797633,51.3979161578,
	51.3688408872,51.3398534365,51.3109532954,51.2821399576,51.2534129212,
	51.2247716884,51.1962157658,51.1677446638,51.1393578971,51.1110549843,
	51.0828354481,51.0546988151,51.0266446158,50.9986723845,50.9707816593,
	50.9429719823,50.9152428991,50.8875939591,50.8600247153,50.8325347244,
	50.8051235466,50.7777907458,50.7505358892,50.7233585476,50.6962582952,
	50.6692347097,50.6422873719,50.6154158663,50.5886197804,50.5618987051,
	50.5352522345,50.5086799659,50.4821814997,50.4557564396,50.4294043921,
	50.4031249672,50.3769177775,50.3507824389,50.3247185701,50.2987257929,
	50.2728037319,50.2469520147,50.2211702716,50.1954581358,50.1698152434,
	50.1442412332,50.1187357466,50.0932984281,50.0679289244,50.0426268854,
	50.0173919631,49.9922238125,49.967122091,49.9420864588,49.9171165783,
	49.8922121146,49.8673727353,49.8425981105,49.8178879127,49.7932418167,
	49.7686594998,49.7441406417,49.7196849244,49.6952920323,49.670961652,
	49.6466934725,49.622487185,49.5983424828,49.5742590617,49.5502366195,
	49.5262748563,49.5023734741,49.4785321775,49.4547506727,49.4310286684,
	49.4073658752,49.3837620058,49.3602167748,49.336729899,49.3133010971,
	49.28993009,49.2666166002,49.2433603524,49.2201610732,49.197018491,
	49.1739323363,49.1509023413,49.12792824,49.1050097686,49.0821466646,
	49.0593386678,49.0365855194,49.0138869628,48.9912427428,48.968652606,
	48.9461163009,48.9236335776,48.901204188,48.8788278855,48.8565044252,
	48.8342335641,48.8120150606,48.7898486748,48.7677341684,48.7456713047,
	48.7236598486,48.7016995666,48.6797902266,48.6579315983,48.6361234527,
	48.6143655624,48.5926577015,48.5709996457,48.5493911719,48.5278320588,
	48.5063220864,48.484861036,48.4634486905,48.4420848342,48.4207692528,
	48.3995017333,48.3782820642,48.3571100353,48.3359854377,48.314908064,
	48.2938777081,48.272894165,48.2519572313,48.2310667048,48.2102223845,
	48.1894240707,48.1686715652,48.1479646707,48.1273031914,48.1066869326,
	48.0861157009,48.0655893041,48.0451075513,48.0246702526,48.0042772194,
	47.9839282643,47.963623201,47.9433618444,47.9231440105,47.9029695165,
	47.8828381808,47.8627498227,47.8427042628,47.8227013227,47.8027408252,
	47.7828225941,47.7629464542,47.7431122316,47.7233197533,47.7035688473,
	47.6838593428,47.6641910699,47.6445638598,47.6249775446,47.6054319576,
	47.5859269331,47.5664623061,47.5470379129,47.5276535906,47.5083091774,
	47.4890045124,47.4697394356,47.450513788,47.4313274116,47.4121801493,
	47.3930718448,47.3740023428,47.3549714891,47.3359791301,47.3170251133,
	47.2981092869,47.2792315003,47.2603916035,47.2415894475,47.2228248841,
	47.2040977659,47.1854079466,47.1667552804,47.1481396226,47.1295608293,
	47.1110187573,47.0925132644,47.0740442089,47.0556114503,47.0372148487,
	47.0188542649,47.0005295607,46.9822405986,46.9639872418,46.9457693543,
	46.9275868009,46.9094394473,46.8913271597,46.8732498052,46.8552072516,
	46.8371993674,46.8192260219,46.8012870852,46.7833824279,46.7655119216,
	46.7476754383,46.7298728509,46.712104033,46.6943688588,46.6766672034,
	46.6589989423,46.6413639518,46.6237621091,46.6061932917,46.5886573779,
	46.5711542468,46.5536837781,46.5362458519,46.5188403494,46.501467152,
	46.4841261421,46.4668172024,46.4495402166,46.4322950687,46.4150816434,
	46.3978998262,46.3807495031,46.3636305605,46.3465428857,46.3294863665,
	46.3124608912,46.2954663489,46.2785026291,46.261569622,46.2446672182,
	46.2277953091,46.2109537865,46.1941425428,46.1773614712,46.1606104651,
	46.1438894186,46.1271982264,46.1105367837,46.0939049864,46.0773027305,
	46.0607299131,46.0441864315,46.0276721836,46.0111870677,45.9947309829,
	45.9783038286,45.9619055047,45.9455359118,45.9291949509,45.9128825234,
	45.8965985314,45.8803428774,45.8641154643,45.8479161957,45.8317449755,
	45.8156017082,45.7994862988,45.7833986526,45.7673386755,45.751306274,
	45.7353013548,45.7193238253,45.7033735933,45.6874505668,45.6715546547,
	45.6556857661,45.6398438106,45.6240286981,45.6082403393,45.5924786449,
	45.5767435264,45.5610348956,45.5453526646,45.5296967462,45.5140670535,
	45.4984635,45.4828859995,45.4673344665,45.4518088158,45.4363089625,
	45.4208348222,45.4053863109,45.3899633451,45.3745658416,45.3591937176,
	45.3438468908,45.328525279,45.3132288009,45.297957375,45.2827109208,
	45.2674893576,45.2522926056,45.2371205849,45.2219732164,45.2068504212,
	45.1917521207,45.1766782368,45.1616286916,45.1466034078,45.1316023084,
	45.1166253165,45.101672356,45.0867433507,45.0718382252,45.0569569041,
	45.0420993126,45.027265376,45.0124550203,44.9976681714,44.9829047559,
	44.9681647005,44.9534479326,44.9387543794,44.924083969,44.9094366294,
	44.8948122891,44.8802108769,44.865632322,44.8510765539,44.8365435024,
	44.8220330976,44.8075452698,44.7930799499,44.778637069,44.7642165583,
	44.7498183497,44.735442375,44.7210885667,44.7067568573,44.6924471798,
	44.6781594673,44.6638936534,44.6496496719,44.6354274569,44.6212269429,
	44.6070480645,44.5928907568,44.578754955,44.5646405947,44.5505476118,
	44.5364759423,44.5224255228,44.50839629,44.4943881808,44.4804011325,
	44.4664350827,44.4524899692,44.43856573,44.4246623036,44.4107796285,
	44.3969176438,44.3830762885,44.369255502,44.3554552242,44.341675395,
	44.3279159545,44.3141768433,44.3004580021,44.2867593719,44.2730808939,
	44.2594225098,44.2457841612,44.2321657901,44.2185673388,44.2049887499,
	44.191429966,44.1778909302,44.1643715857,44.150871876,44.1373917448,
	44.1239311362,44.1104899942,44.0970682634,44.0836658884,44.0702828141,
	44.0569189857,44.0435743485,44.0302488482,44.0169424307,44.0036550418,
	43.990386628,43.9771371358,43.9639065119,43.9506947033,43.9375016571,
	43.9243273208,43.911171642,43.8980345685,43.8849160484,43.8718160299,
	43.8587344616,43.8456712922,43.8326264705,43.8195999457,43.8065916671,
	43.7936015843,43.780629647,43.7676758052,43.7547400091,43.7418222089,
	43.7289223553,43.7160403991,43.7031762912,43.6903299827,43.6775014252,
	43.66469057,43.6518973691,43.6391217743,43.6263637378,43.613623212,
	43.6009001494,43.5881945027,43.5755062248,43.5628352689,43.5501815883,
	43.5375451365,43.524925867,43.5123237339,43.499738691,43.4871706927,
	43.4746196934,43.4620856476,43.4495685102,43.437068236,43.4245847802,
	43.4121180981,43.3996681453,43.3872348772,43.3748182499,43.3624182192,
	43.3500347414,43.3376677729,43.32531727,43.3129831897,43.3006654886,
	43.2883641239,43.2760790527,43.2638102324,43.2515576206,43.2393211749,
	43.2271008533,43.2148966136,43.2027084142,43.1905362133,43.1783799696,
	43.1662396416,43.1541151882,43.1420065683,43.1299137412,43.1178366661,
	43.1057753025,43.0937296101,43.0816995485,43.0696850777,43.0576861577,
	43.0457027489,43.0337348116,43.0217823063,43.0098451938,42.9979234347,
	42.9860169902,42.9741258213,42.9622498893,42.9503891557,42.938543582,
	42.9267131299,42.9148977612,42.9030974381,42.8913121225,42.8795417768,
	42.8677863635,42.856045845,42.8443201841,42.8326093436,42.8209132865,
	42.809231976,42.7975653752,42.7859134476,42.7742761567,42.7626534662,
	42.7510453398,42.7394517416,42.7278726355,42.7163079857,42.7047577566,
	42.6932219127,42.6817004185,42.6701932388,42.6587003383,42.6472216822,
	42.6357572354,42.6243069633,42.6128708311,42.6014488044,42.5900408488,
	42.57864693,42.5672670139,42.5559010665,42.5445490538,42.5332109421,
	42.5218866978,42.5105762873,42.4992796772,42.4879968343,42.4767277253,
	42.4654723173,42.4542305773,42.4430024724,42.4317879701,42.4205870377,
	42.4093996427,42.3982257529,42.3870653359,42.3759183598,42.3647847924,
	42.3536646019,42.3425577565,42.3314642245,42.3203839745,42.309316975,
	42.2982631946,42.2872226021,42.2761951665,42.2651808567,42.2541796418,
	42.2431914911,42.2322163739,42.2212542596,42.2103051178,42.1993689181,
	42.1884456302,42.1775352242,42.1666376698,42.1557529372,42.1448809965,
	42.1340218181,42.1231753722,42.1123416295,42.1015205604,42.0907121357,
	42.0799163261,42.0691331025,42.058362436,42.0476042976,42.0368586585,
	42.0261254899,42.0154047634,42.0046964503,41.9940005222,41.9833169508,
	41.972645708,41.9619867655,41.9513400953,41.9407056694,41.9300834602,
	41.9194734397,41.9088755803,41.8982898545,41.8877162349,41.8771546939,
	41.8666052044,41.8560677391,41.845542271,41.8350287731,41.8245272183,
	41.81403758,41.8035598313,41.7930939457,41.7826398964,41.7721976572,
	41.7617672016,41.7513485032,41.740941536,41.7305462738,41.7201626905,
	41.7097907601,41.699430457,41.6890817552,41.6787446291,41.668419053,
	41.6581050015,41.6478024491,41.6375113705,41.6272317404,41.6169635335,
	41.6067067249,41.5964612895,41.5862272023,41.5760044385,41.5657929734,
	41.5555927821,41.5454038401,41.535226123,41.5250596061,41.5149042652,
	41.5047600759,41.4946270141,41.4845050556,41.4743941762,41.4642943522,
	41.4542055595,41.4441277743,41.4340609729,41.4240051315,41.4139602267,
	41.4039262349,41.3939031326,41.3838908964,41.3738895031,41.3638989294,
	41.3539191523,41.3439501485,41.3339918952,41.3240443693,41.3141075481,
	41.3041814088,41.2942659286,41.2843610849,41.2744668552,41.2645832169,
	41.2547101477,41.2448476251,41.234995627,41.225154131,41.2153231151,
	41.2055025572,41.1956924352,41.1858927273,41.1761034116,41.1663244663,
	41.1565558696,41.1467976,41.1370496357,41.1273119554,41.1175845375,
	41.1078673606,41.0981604035,41.0884636448,41.0787770634,41.0691006382,
	41.059434348,41.049778172,41.0401320891,41.0304960786,41.0208701195,
	41.0112541912,41.0016482731,40.9920523444,40.9824663846,40.9728903734,
	40.9633242901,40.9537681146,40.9442218265,40.9346854055,40.9251588316,
	40.9156420845,40.9061351443,40.8966379909,40.8871506045,40.8776729651,
	40.868205053,40.8587468484,40.8492983317,40.8398594831,40.8304302833,
	40.8210107125,40.8116007515,40.8022003807,40.792809581,40.7834283329,
	40.7740566174,40.7646944152,40.7553417072,40.7459984744,40.7366646979,
	40.7273403586,40.7180254378,40.7087199165,40.6994237762,40.6901369979,
	40.6808595632,40.6715914533,40.6623326499,40.6530831343,40.6438428882,
	40.6346118932,40.625390131,40.6161775833,40.6069742319,40.5977800587,
	40.5885950455,40.5794191744,40.5702524272,40.5610947862,40.5519462333,
	40.5428067507,40.5336763208,40.5245549257,40.5154425477,40.5063391692,
	40.4972447727,40.4881593407,40.4790828555,40.4700152999,40.4609566565,
	40.4519069079,40.4428660369,40.4338340262,40.4248108587,40.4157965172,
	40.4067909847,40.3977942441,40.3888062786,40.3798270711,40.3708566047,
	40.3618948628,40.3529418284,40.3439974848,40.3350618154,40.3261348035,
	40.3172164326,40.3083066861,40.2994055475,40.2905130003,40.2816290283,
	40.2727536149,40.2638867439,40.2550283991,40.2461785643,40.2373372232,
	40.2285043598,40.219679958,40.2108640017,40.202056475,40.1932573619,
	40.1844666466,40.1756843131,40.1669103458,40.1581447288,40.1493874464,
	40.1406384829,40.1318978228,40.1231654504,40.1144413503,40.1057255068,
	40.0970179046
	};
 tubetable_6V6_1 = waveform{
	239.919843376,239.854937108,239.789738489,239.724247218,239.658462996,
	239.592385535,239.526014546,239.459349752,239.392390878,239.325137654,
	239.257589818,239.189747112,239.121609284,239.053176087,238.984447281,
	238.91542263,238.846101903,238.776484877,238.706571332,238.636361055,
	238.565853836,238.495049475,238.423947772,238.352548536,238.280851579,
	238.208856722,238.136563787,238.063972604,237.991083007,237.917894835,
	237.844407935,237.770622155,237.696537352,237.622153385,237.54747012,
	237.472487429,237.397205186,237.321623273,237.245741575,237.169559984,
	237.093078396,237.016296711,236.939214835,236.86183268,236.78415016,
	236.706167196,236.627883714,236.549299644,236.470414921,236.391229484,
	236.311743279,236.231956253,236.151868362,236.071479563,235.99078982,
	235.9097991,235.828507376,235.746914624,235.665020826,235.582825967,
	235.500330038,235.417533033,235.334434951,235.251035796,235.167335575,
	235.083334301,234.999031988,234.914428659,234.829524337,234.744319051,
	234.658812834,234.573005723,234.48689776,234.400488988,234.313779459,
	234.226769224,234.13945834,234.05184687,233.963934876,233.875722429,
	233.7872096,233.698396466,233.609283107,233.519869606,233.430156051,
	233.340142534,233.249829147,233.159215991,233.068303166,232.977090779,
	232.885578937,232.793767753,232.701657342,232.609247824,232.516539321,
	232.423531959,232.330225867,232.236621177,232.142718023,232.048516546,
	231.954016887,231.85921919,231.764123605,231.66873028,231.573039372,
	231.477051037,231.380765434,231.284182727,231.187303082,231.090126667,
	230.992653654,230.894884217,230.796818534,230.698456783,230.599799147,
	230.500845813,230.401596966,230.302052798,230.202213502,230.102079273,
	230.001650309,229.900926811,229.799908981,229.698597024,229.596991149,
	229.495091566,229.392898486,229.290412124,229.187632698,229.084560426,
	228.98119553,228.877538233,228.77358876,228.66934734,228.564814202,
	228.459989578,228.354873701,228.249466808,228.143769136,228.037780925,
	227.931502416,227.824933853,227.718075481,227.610927548,227.503490301,
	227.395763992,227.287748873,227.179445197,227.070853221,226.961973202,
	226.852805398,226.743350071,226.633607482,226.523577894,226.413261574,
	226.302658786,226.1917698,226.080594885,225.969134311,225.857388351,
	225.745357278,225.633041366,225.520440893,225.407556135,225.294387371,
	225.180934881,225.067198945,224.953179846,224.838877868,224.724293293,
	224.609426409,224.494277501,224.378846857,224.263134765,224.147141516,
	224.030867399,223.914312706,223.79747773,223.680362764,223.562968102,
	223.445294038,223.32734087,223.209108892,223.090598404,222.971809703,
	222.852743088,222.733398858,222.613777314,222.493878757,222.373703489,
	222.253251812,222.132524028,222.011520442,221.890241357,221.768687078,
	221.64685791,221.524754159,221.402376131,221.279724132,221.15679847,
	221.033599452,220.910127386,220.78638258,220.662365343,220.538075983,
	220.413514811,220.288682136,220.163578268,220.038203517,219.912558193,
	219.786642608,219.660457072,219.534001897,219.407277394,219.280283874,
	219.15302165,219.025491033,218.897692335,218.769625868,218.641291945,
	218.512690877,218.383822977,218.254688558,218.125287932,217.995621411,
	217.865689308,217.735491935,217.605029605,217.47430263,217.343311321,
	217.212055993,217.080536955,216.948754521,216.816709003,216.684400712,
	216.551829959,216.418997057,216.285902317,216.152546049,216.018928564,
	215.885050174,215.750911189,215.616511919,215.481852673,215.346933762,
	215.211755495,215.076318182,214.94062213,214.804667649,214.668455047,
	214.531984632,214.395256711,214.258271591,214.121029579,213.983530982,
	213.845776106,213.707765256,213.569498737,213.430976855,213.292199913,
	213.153168215,213.013882066,212.874341767,212.734547621,212.594499931,
	212.454198998,212.313645123,212.172838605,212.031779747,211.890468845,
	211.748906201,211.607092111,211.465026874,211.322710786,211.180144146,
	211.037327247,210.894260386,210.750943858,210.607377956,210.463562975,
	210.319499207,210.175186945,210.03062648,209.885818102,209.740762104,
	209.595458773,209.449908399,209.304111271,209.158067675,209.011777899,
	208.865242229,208.71846095,208.571434346,208.424162703,208.276646303,
	208.128885429,207.980880362,207.832631383,207.684138772,207.53540281,
	207.386423774,207.237201943,207.087737593,206.938031001,206.788082442,
	206.637892192,206.487460523,206.336787708,206.185874021,206.034719732,
	205.883325112,205.73169043,205.579815956,205.427701956,205.2753487,
	205.122756451,204.969925477,204.816856041,204.663548407,204.510002838,
	204.356219596,204.202198941,204.047941133,203.893446432,203.738715096,
	203.583747382,203.428543546,203.273103844,203.11742853,202.961517859,
	202.805372081,202.64899145,202.492376216,202.335526629,202.178442938,
	202.021125389,201.863574231,201.70578971,201.547772069,201.389521554,
	201.231038407,201.072322871,200.913375185,200.754195591,200.594784328,
	200.435141633,200.275267743,200.115162895,199.954827324,199.794261263,
	199.633464946,199.472438604,199.31118247,199.149696771,198.987981739,
	198.826037599,198.66386458,198.501462908,198.338832806,198.175974498,
	198.012888208,197.849574157,197.686032566,197.522263653,197.358267639,
	197.194044739,197.029595171,196.864919149,196.700016888,196.534888602,
	196.369534501,196.203954798,196.038149702,195.872119422,195.705864166,
	195.53938414,195.372679551,195.205750602,195.038597496,194.871220438,
	194.703619627,194.535795263,194.367747547,194.199476675,194.030982844,
	193.862266251,193.69332709,193.524165554,193.354781836,193.185176127,
	193.015348617,192.845299495,192.675028949,192.504537166,192.333824332,
	192.162890631,191.991736246,191.820361361,191.648766155,191.476950809,
	191.304915502,191.132660411,190.960185714,190.787491586,190.6145782,
	190.441445731,190.268094349,190.094524227,189.920735533,189.746728437,
	189.572503106,189.398059705,189.223398401,189.048519357,188.873422736,
	188.698108699,188.522577407,188.34682902,188.170863695,187.994681589,
	187.818282858,187.641667658,187.46483614,187.287788459,187.110524763,
	186.933045205,186.755349932,186.577439092,186.399312831,186.220971295,
	186.042414627,185.863642971,185.684656468,185.505455258,185.326039482,
	185.146409276,184.966564778,184.786506124,184.606233447,184.425746882,
	184.245046561,184.064132614,183.883005171,183.70166436,183.52011031,
	183.338343145,183.156362991,182.974169972,182.79176421,182.609145826,
	182.426314941,182.243271672,182.060016139,181.876548456,181.69286874,
	181.508977105,181.324873662,181.140558524,180.956031801,180.771293602,
	180.586344035,180.401183206,180.215811221,180.030228184,179.844434198,
	179.658429365,179.472213784,179.285787556,179.099150778,178.912303547,
	178.725245958,178.537978106,178.350500084,178.162811983,177.974913895,
	177.786805907,177.598488109,177.409960587,177.221223426,177.032276711,
	176.843120525,176.653754949,176.464180064,176.274395949,176.084402683,
	175.894200341,175.703788999,175.513168732,175.322339612,175.131301711,
	174.940055099,174.748599845,174.556936017,174.365063682,174.172982904,
	173.980693748,173.788196276,173.59549055,173.402576629,173.209454574,
	173.01612444,172.822586284,172.628840161,172.434886125,172.240724228,
	172.046354521,171.851777054,171.656991875,171.461999032,171.266798569,
	171.071390532,170.875774963,170.679951906,170.483921399,170.287683483,
	170.091238194,169.894585571,169.697725648,169.500658458,169.303384036,
	169.105902411,168.908213614,168.710317673,168.512214616,168.313904469,
	168.115387256,167.916663,167.717731724,167.518593448,167.31924819,
	167.11969597,166.919936804,166.719970706,166.51979769,166.319417769,
	166.118830954,165.918037255,165.71703668,165.515829236,165.314414928,
	165.112793761,164.910965738,164.70893086,164.506689127,164.304240538,
	164.10158509,163.898722779,163.6956536,163.492377545,163.288894608,
	163.085204777,162.881308042,162.677204391,162.472893809,162.268376282,
	162.063651792,161.858720322,161.653581853,161.448236362,161.242683829,
	161.036924229,160.830957537,160.624783727,160.41840277,160.211814637,
	160.005019298,159.79801672,159.590806869,159.38338971,159.175765206,
	158.967933321,158.759894013,158.551647242,158.343192966,158.134531141,
	157.925661722,157.716584662,157.507299912,157.297807424,157.088107145,
	156.878199025,156.668083008,156.457759039,156.247227061,156.036487016,
	155.825538844,155.614382484,155.403017872,155.191444946,154.979663638,
	154.767673882,154.55547561,154.34306875,154.130453232,153.917628982,
	153.704595926,153.491353989,153.277903091,153.064243155,152.850374101,
	152.636295846,152.422008306,152.207511398,151.992805035,151.777889129,
	151.562763591,151.347428331,151.131883256,150.916128273,150.700163287,
	150.483988202,150.267602919,150.051007339,149.834201362,149.617184885,
	149.399957805,149.182520017,148.964871415,148.74701189,148.528941333,
	148.310659634,148.092166681,147.873462361,147.654546557,147.435419156,
	147.216080038,146.996529086,146.776766179,146.556791196,146.336604013,
	146.116204508,145.895592554,145.674768025,145.453730794,145.23248073,
	145.011017705,144.789341586,144.56745224,144.345349535,144.123033334,
	143.900503503,143.677759903,143.454802397,143.231630845,143.008245106,
	142.784645041,142.560830506,142.336801358,142.112557454,141.888098647,
	141.663424793,141.438535745,141.213431356,140.988111477,140.76257596,
	140.536824656,140.310857414,140.084674085,139.858274517,139.631658559,
	139.40482606,139.177776866,138.950510827,138.72302779,138.495327601,
	138.267410109,138.039275161,137.810922605,137.582352287,137.353564057,
	137.124557761,136.89533325,136.665890372,136.436228977,136.206348916,
	135.976250041,135.745932202,135.515395255,135.284639054,135.053663455,
	134.822468314,134.591053492,134.359418849,134.127564247,133.895489551,
	133.663194629,133.430679348,133.197943581,132.964987203,132.73181009,
	132.498412124,132.264793187,132.030953168,131.796891958,131.562609451,
	131.328105548,131.093380151,130.85843317,130.623264518,130.387874115,
	130.152261884,129.916427758,129.680371672,129.444093571,129.207593404,
	128.970871129,128.733926713,128.496760129,128.259371358,128.021760393,
	127.783927234,127.545871891,127.307594385,127.069094748,126.830373023,
	126.591429265,126.352263542,126.112875935,125.873266537,125.633435457,
	125.393382821,125.153108766,124.91261345,124.671897045,124.430959742,
	124.189801752,123.948423304,123.706824648,123.465006057,123.222967823,
	122.980710263,122.738233721,122.495538562,122.252625181,122.009493998,
	121.766145463,121.522580057,121.278798292,121.034800711,120.790587894,
	120.546160453,120.30151904,120.056664344,119.811597095,119.566318064,
	119.320828067,119.075127963,118.82921866,118.583101115,118.336776335,
	118.090245381,117.84350937,117.596569475,117.349426929,117.102083029,
	116.854539134,116.606796673,116.358857143,116.110722114,115.862393231,
	115.613872218,115.365160881,115.116261108,114.867174879,114.61790426,
	114.368451414,114.118818604,113.86900819,113.619022642,113.368864537,
	113.118536565,112.868041535,112.617382378,112.366562149,112.115584036,
	111.864451361,111.613167587,111.361736321,111.11016132,110.858446499,
	110.60659593,110.354613852,110.102504677,109.850272992,109.597923569,
	109.345461366,109.09289154,108.840219447,108.587450649,108.334590925,
	108.081646272,107.828622915,107.575527312,107.322366164,107.069146415,
	106.815875267,106.562560181,106.309208889,106.055829395,105.802429989,
	105.549019247,105.295606044,105.042199559,104.78880928,104.535445014,
	104.282116893,104.028835379,103.775611272,103.522455718,103.26938021,
	103.016396602,102.763517107,102.510754307,102.258121157,102.00563099,
	101.75329752,101.501134848,101.249157464,100.997380252,100.74581849,
	100.494487852,100.243404412,99.9925846399,99.7420454065,99.4918039784,
	99.2418780182,98.992285581,98.7430451111,98.4941754376,98.2456957684,
	97.9976256841,97.7499851301,97.5027944079,97.2560741654,97.0098453854,
	96.764129374,96.5189477467,96.2743224139,96.030275565,95.7868296514,
	95.5440073677,95.3018316327,95.0603255681,94.8195124769,94.5794158196,
	94.3400591904,94.1014662917,93.8636609074,93.6266668754,93.3905080596,
	93.1552083202,92.9207914838,92.687281313,92.4547014744,92.2230755076,
	91.9924267924,91.7627785162,91.5341536421,91.3065748752,91.0800646308,
	90.8546450013,90.6303377244,90.4071641513,90.1851452154,89.9643014023,
	89.7446527197,89.5262186689,89.309018217,89.0930697707,88.8783911506,
	88.6649995678,88.452911601,88.2421431758,88.0327095454,87.8246252726,
	87.6179042144,87.4125595073,87.2086035549,87.0060480178,86.8049038042,
	86.6051810635,86.4068891809,86.2100367742,86.0146316924,85.820681016,
	85.6281910588,85.4371673718,85.2476147483,85.059537231,84.8729381203,
	84.6878199835,84.5041846669,84.3220333071,84.1413663453,83.9621835415,
	83.78448399,83.6082661365,83.4335277947,83.2602661648,83.088477852,
	82.918158886,82.7493047404,82.581910353,82.4159701465,82.2514780484,
	82.0884275127,81.9268115401,81.7666226995,81.6078531484,81.450494654,
	81.2945386136,81.1399760753,80.9867977578,80.8349940706,80.6845551334,
	80.5354707951,80.387730653,80.2413240706,80.0962401958,79.9524679782,
	79.8099961858,79.668813422,79.5289081407,79.3902686621,79.2528831875,
	79.1167398133,78.9818265451,78.8481313104,78.7156419717,78.5843463383,
	78.4542321781,78.3252872283,78.1974992063,78.0708558196,77.9453447751,
	77.8209537885,77.6976705926,77.5754829453,77.4543786377,77.3343455008,
	77.2153714125,77.097444304,76.9805521656,76.8646830525,76.7498250897,
	76.6359664772,76.5230954944,76.411200504,76.3002699564,76.1902923926,
	76.081256448,75.9731508553,75.865964447,75.7596861581,75.6543050282,
	75.5498102036,75.446190939,75.3434365993,75.2415366608,75.1404807122,
	75.0402584562,74.94085971,74.8422744057,74.7444925918,74.6475044324,
	74.5513002088,74.4558703183,74.3612052756,74.2672957116,74.1741323741,
	74.0817061269,73.9900079501,73.8990289392,73.8087603045,73.7191933711,
	73.630319578,73.542130477,73.4546177327,73.3677731209,73.2815885286,
	73.1960559524,73.1111674979,73.0269153786,72.943291915,72.8602895336,
	72.7779007657,72.6961182464,72.6149347136,72.5343430066,72.4543360653,
	72.3749069287,72.296048734,72.2177547155,72.140018203,72.062832621,
	71.9861914875,71.9100884125,71.834517097,71.7594713319,71.6849449967,
	71.6109320582,71.5374265695,71.4644226687,71.3919145776,71.3198966008,
	71.2483631244,71.1773086147,71.1067276173,71.0366147558,70.9669647305,
	70.8977723176,70.829032368,70.7607398058,70.692889628,70.6254769025,
	70.5584967677,70.491944431,70.4258151681,70.3601043217,70.2948073007,
	70.2299195789,70.1654366943,70.1013542477,70.0376679022,69.974373382,
	69.9114664714,69.848943014,69.7867989115,69.7250301233,69.663632665,
	69.6026026079,69.5419360781,69.4816292553,69.4216783727,69.3620797151,
	69.302829619,69.2439244713,69.1853607088,69.127134817,69.0692433298,
	69.0116828285,68.9544499408,68.8975413407,68.8409537471,68.7846839236,
	68.7287286773,68.6730848588,68.6177493608,68.5627191177,68.5079911053,
	68.4535623394,68.399429876,68.3455908099,68.2920422747,68.238781442,
	68.1858055204,68.1331117557,68.0806974294,68.0285598591,67.9766963971,
	67.9251044304,67.8737813799,67.8227247,67.7719318779,67.7214004334,
	67.671127918,67.6211119148,67.5713500377,67.521839931,67.4725792692,
	67.4235657562,67.3747971248,67.3262711367,67.2779855816,67.2299382769,
	67.1821270675,67.1345498251,67.0872044479,67.0400888603,66.9932010121,
	66.9465388788,66.9001004606,66.8538837821,66.8078868926,66.7621078646,
	66.7165447945,66.6711958016,66.626059028,66.5811326384,66.5364148192,
	66.491903779,66.4475977476,66.4034949759,66.3595937358,66.3158923195,
	66.2723890395,66.2290822282,66.1859702377,66.1430514394,66.1003242235,
	66.0577869994,66.0154381946,65.9732762552,65.9312996451,65.8895068457,
	65.8478963563,65.806466693,65.7652163892,65.7241439947,65.6832480761,
	65.642527216,65.6019800131,65.5616050819,65.5214010526,65.4813665705,
	65.4415002962,65.4018009052,65.3622670877,65.3228975484,65.2836910063,
	65.2446461946,65.2057618602,65.1670367641,65.1284696804,65.0900593968,
	65.0518047142,65.0137044463,64.9757574197,64.9379624738,64.9003184602,
	64.8628242429,64.825478698,64.7882807137,64.7512291898,64.7143230378,
	64.6775611809,64.6409425534,64.6044661009,64.5681307798,64.5319355578,
	64.4958794131,64.4599613344,64.4241803212,64.388535383,64.3530255396,
	64.317649821,64.282407267,64.2472969272,64.2123178609,64.1774691369,
	64.1427498335,64.1081590383,64.0736958481,64.0393593686,64.0051487146,
	63.9710630098,63.9371013865,63.9032629857,63.8695469568,63.8359524576,
	63.8024786545,63.7691247216,63.7358898415,63.7027732045,63.669774009,
	63.636891461,63.6041247743,63.5714731704,63.5389358781,63.5065121337,
	63.4742011808,63.4420022703,63.4099146602,63.3779376154,63.3460704081,
	63.3143123171,63.2826626281,63.2511206336,63.2196856325,63.1883569306,
	63.1571338399,63.1260156789,63.0950017724,63.0640914515,63.0332840535,
	63.0025789217,62.9719754055,62.9414728602,62.9110706472,62.8807681334,
	62.8505646917,62.8204597006,62.7904525442,62.7605426122,62.7307292997,
	62.7010120074,62.6713901411,62.6418631122,62.6124303372,62.5830912378,
	62.5538452407,62.5246917779,62.4956302862,62.4666602075,62.4377809884,
	62.4089920806,62.3802929404,62.3516830289,62.3231618119,62.2947287596,
	62.2663833472,62.238125054,62.2099533641,62.1818677657,62.1538677518,
	62.1259528192,62.0981224695,62.0703762081,62.0427135449,62.0151339937,
	61.9876370727,61.9602223038,61.9328892131,61.9056373307,61.8784661904,
	61.8513753301,61.8243642916,61.7974326202,61.7705798651,61.7438055793,
	61.7171093194,61.6904906456,61.6639491218,61.6374843153,61.6110957971,
	61.5847831416,61.5585459265,61.5323837333,61.5062961465,61.4802827541,
	61.4543431474,61.4284769208,61.4026836724,61.376963003,61.3513145168,
	61.3257378211,61.3002325264,61.2747982461,61.2494345967,61.2241411979,
	61.1989176721,61.1737636448,61.1486787445,61.1236626024,61.0987148526,
	61.0738351323,61.049023081,61.0242783416,60.9996005592,60.9749893819,
	60.9504444605,60.9259654483,60.9015520014,60.8772037785,60.8529204409,
	60.8287016523,60.8045470791,60.7804563903,60.7564292571,60.7324653534,
	60.7085643554,60.6847259419,60.660949794,60.637235595,60.6135830308,
	60.5899917896,60.5664615617,60.5429920399,60.5195829191,60.4962338965,
	60.4729446717,60.4497149461,60.4265444237,60.4034328102,60.3803798139,
	60.357385145,60.3344485156,60.3115696402,60.2887482352,60.2659840191,
	60.2432767122,60.2206260372,60.1980317183,60.1754934821,60.1530110568,
	60.1305841728,60.1082125622,60.0858959592,60.0636340995,60.041426721,
	60.0192735634,59.9971743681,59.9751288783,59.9531368392,59.9311979974,
	59.9093121016,59.8874789021,59.865698151,59.8439696018,59.8222930102,
	59.8006681332,59.7790947295,59.7575725597,59.7361013857,59.7146809713,
	59.6933110816,59.6719914837,59.6507219459,59.6295022382,59.6083321322,
	59.587211401,59.5661398192,59.5451171629,59.5241432098,59.5032177389,
	59.4823405308,59.4615113675,59.4407300325,59.4199963107,59.3993099884,
	59.3786708534,59.3580786947,59.3375333029,59.3170344698,59.2965819887,
	59.2761756541,59.2558152619,59.2355006095,59.2152314953,59.1950077192,
	59.1748290824,59.1546953873,59.1346064375,59.1145620381,59.0945619952,
	59.0746061163,59.05469421,59.0348260863,59.0150015562,58.9952204321,
	58.9754825273,58.9557876566,58.9361356358,58.9165262819,58.896959413,
	58.8774348483,58.8579524084,58.8385119146,58.8191131897,58.7997560573,
	58.7804403424,58.7611658707,58.7419324694,58.7227399664,58.7035881909,
	58.684476973,58.665406144,58.6463755361,58.6273849825,58.6084343176,
	58.5895233766,58.5706519958,58.5518200125,58.533027265,58.5142735925,
	58.4955588353,58.4768828345,58.4582454322,58.4396464715,58.4210857965,
	58.402563252,58.384078684,58.3656319393,58.3472228655,58.3288513112,
	58.310517126,58.2922201602,58.2739602651,58.2557372929,58.2375510965,
	58.2194015299,58.2012884478,58.1832117056,58.16517116,58.1471666681,
	58.129198088,58.1112652786,58.0933680997,58.0755064118,58.0576800761,
	58.039888955,58.0221329113,58.0044118086,57.9867255116,57.9690738855,
	57.9514567963,57.9338741109,57.9163256968,57.8988114223,57.8813311564,
	57.8638847691,57.8464721308,57.8290931127,57.8117475869,57.7944354261,
	57.7771565037,57.7599106939,57.7426978714,57.7255179118,57.7083706914,
	57.691256087,57.6741739762,57.6571242374,57.6401067494,57.6231213918,
	57.6061680451,57.58924659,57.5723569081,57.5554988818,57.5386723939,
	57.5218773279,57.505113568,57.488380999,57.4716795062,57.4550089757,
	57.4383692942,57.4217603489,57.4051820278,57.3886342192,57.3721168123,
	57.3556296967,57.3391727627,57.3227459011,57.3063490034,57.2899819617,
	57.2736446684,57.2573370167,57.2410589004,57.2248102138,57.2085908517,
	57.1924007095,57.1762396831,57.1601076691,57.1440045645,57.127930267,
	57.1118846745,57.0958676858,57.0798792,57.063919117,57.0479873368,
	57.0320837602,57.0162082886,57.0003608236,56.9845412676,56.9687495233,
	56.952985494,56.9372490836,56.9215401962,56.9058587367,56.8902046103,
	56.8745777228,56.8589779803,56.8434052895,56.8278595578,56.8123406926,
	56.796848602,56.7813831948,56.7659443798,56.7505320667,56.7351461652,
	56.719786586,56.7044532397,56.6891460378,56.6738648919,56.6586097143,
	56.6433804175,56.6281769146,56.6129991191,56.597846945,56.5827203065,
	56.5676191185,56.5525432961,56.537492755,56.5224674112,56.507467181,
	56.4924919814,56.4775417297,56.4626163434,56.4477157406,56.4328398399,
	56.41798856,56.4031618202,56.3883595402,56.37358164,56.35882804,
	56.3440986611,56.3293934243,56.3147122514,56.3000550642,56.2854217851,
	56.2708123367,56.2562266421,56.2416646249,56.2271262086,56.2126113176,
	56.1981198764,56.1836518097,56.1692070429,56.1547855016,56.1403871117,
	56.1260117995,56.1116594916,56.097330115,56.0830235971,56.0687398656,
	56.0544788483,56.0402404738,56.0260246706,56.0118313678,55.9976604948,
	55.9835119812,55.969385757,55.9552817525,55.9411998985,55.9271401258,
	55.9131023657,55.89908655,55.8850926104,55.8711204792,55.8571700891,
	55.8432413727,55.8293342633,55.8154486945,55.8015845998,55.7877419134,
	55.7739205698,55.7601205035,55.7463416495,55.7325839431,55.7188473199,
	55.7051317156,55.6914370665,55.677763309,55.6641103798,55.6504782158,
	55.6368667544,55.6232759331,55.6097056897,55.5961559624,55.5826266896,
	55.5691178099,55.5556292623,55.542160986,55.5287129205,55.5152850055,
	55.501877181,55.4884893873,55.475121565,55.4617736549,55.448445598,
	55.4351373357,55.4218488095,55.4085799613,55.3953307332,55.3821010675,
	55.3688909069,55.3557001941,55.3425288723,55.3293768848,55.3162441752,
	55.3031306873,55.2900363653,55.2769611534,55.2639049962,55.2508678385,
	55.2378496253,55.2248503018,55.2118698137,55.1989081067,55.1859651266,
	55.1730408198,55.1601351326,55.1472480117,55.134379404,55.1215292566,
	55.1086975168,55.0958841322,55.0830890507,55.0703122201,55.0575535887,
	55.0448131049,55.0320907175,55.0193863752,55.0067000272,54.9940316227,
	54.9813811114,54.9687484428,54.956133567,54.943536434,54.9309569943,
	54.9183951983,54.9058509969,54.893324341,54.8808151818,54.8683234706,
	54.8558491591,54.8433921989,54.8309525421,54.8185301409,54.8061249475,
	54.7937369146,54.7813659949,54.7690121413,54.7566753071,54.7443554455,
	54.73205251,54.7197664544,54.7074972325,54.6952447985,54.6830091066,
	54.6707901112,54.6585877671,54.646402029,54.634232852,54.6220801911,
	54.6099440019,54.5978242398,54.5857208606,54.5736338202,54.5615630746,
	54.5495085801,54.5374702932,54.5254481704,54.5134421685,54.5014522444,
	54.4894783554,54.4775204586,54.4655785116,54.4536524719,54.4417422974,
	54.429847946,54.4179693758,54.4061065451,54.3942594124,54.3824279364,
	54.3706120757,54.3588117893,54.3470270364,54.3352577761,54.323503968,
	54.3117655715,54.3000425465,54.2883348527,54.2766424504,54.2649652996,
	54.2533033607,54.2416565943,54.2300249609,54.2184084215,54.206806937,
	54.1952204684,54.1836489771,54.1720924245,54.1605507722,54.1490239817,
	54.1375120151,54.1260148343,54.1145324014,54.1030646788,54.0916116288,
	54.0801732141,54.0687493974,54.0573401415,54.0459454094,54.0345651643,
	54.0231993694,54.0118479883,54.0005109843,53.9891883213,53.977879963,
	53.9665858734,53.9553060167,53.944040357,53.9327888587,53.9215514863,
	53.9103282045,53.8991189781,53.8879237718,53.8767425508,53.8655752802,
	53.8544219253,53.8432824515,53.8321568244,53.8210450096,53.8099469729,
	53.7988626803,53.7877920977,53.7767351915,53.7656919278,53.7546622731,
	53.7436461939,53.7326436569,53.721654629,53.7106790769,53.6997169678,
	53.6887682688,53.6778329471,53.6669109702,53.6560023055,53.6451069207,
	53.6342247836,53.6233558619,53.6125001237,53.6016575371,53.5908280702,
	53.5800116914,53.5692083692,53.558418072,53.5476407686,53.5368764276,
	53.5261250181,53.5153865089,53.5046608693,53.4939480683,53.4832480754,
	53.47256086,53.4618863916,53.4512246399,53.4405755746,53.4299391657,
	53.419315383,53.4087041967,53.398105577,53.3875194941,53.3769459184,
	53.3663848205,53.355836171,53.3452999404,53.3347760998,53.3242646199,
	53.3137654719,53.3032786267,53.2928040557,53.2823417301,53.2718916214,
	53.261453701,53.2510279406,53.240614312,53.2302127868,53.2198233371,
	53.2094459348,53.1990805521,53.1887271611,53.1783857341,53.1680562435,
	53.1577386619,53.1474329617,53.1371391157,53.1268570966,53.1165868773,
	53.1063284308,53.09608173,53.0858467482,53.0756234586,53.0654118344,
	53.0552118491,53.0450234762,53.0348466893,53.0246814621,53.0145277683,
	53.0043855819,52.9942548766,52.9841356267,52.9740278062,52.9639313893,
	52.9538463503,52.9437726636,52.9337103037,52.9236592451,52.9136194624,
	52.9035909305,52.8935736241,52.883567518,52.8735725874,52.8635888072,
	52.8536161525,52.8436545987,52.833704121,52.8237646948,52.8138362956,
	52.8039188989,52.7940124804,52.7841170158,52.7742324808,52.7643588514,
	52.7544961035,52.7446442132,52.7348031565,52.7249729097,52.7151534489,
	52.7053447507,52.6955467913,52.6857595473,52.6759829952,52.6662171118,
	52.6564618738,52.6467172578,52.636983241,52.6272598001,52.6175469122,
	52.6078445544,52.598152704,52.5884713381,52.5788004341,52.5691399694,
	52.5594899214,52.5498502678,52.5402209861,52.5306020539,52.5209934492,
	52.5113951496,52.5018071332,52.4922293778,52.4826618616,52.4731045626,
	52.463557459,52.4540205291,52.4444937512,52.4349771037,52.425470565,
	52.4159741138,52.4064877284,52.3970113878,52.3875450705,52.3780887554,
	52.3686424213,52.3592060472,52.3497796121,52.340363095,52.3309564751,
	52.3215597316,52.3121728436,52.3027957907,52.293428552,52.2840711072,
	52.2747234357,52.2653855171,52.2560573311,52.2467388573,52.2374300756,
	52.2281309658,52.2188415077,52.2095616814,52.2002914668,52.1910308441,
	52.1817797934,52.1725382949,52.1633063289,52.1540838757,52.1448709156,
	52.1356674293,52.1264733971,52.1172887997,52.1081136176,52.0989478315,
	52.0897914223,52.0806443707,52.0715066576,52.0623782639,52.0532591707,
	52.0441493588,52.0350488095,52.0259575039,52.0168754232,52.0078025486,
	51.9987388616,51.9896843435,51.9806389757,51.9716027398,51.9625756172,
	51.9535575896,51.9445486387,51.9355487462,51.9265578938,51.9175760635,
	51.908603237,51.8996393962,51.8906845233,51.8817386003,51.8728016091,
	51.8638735321,51.8549543514,51.8460440492,51.8371426079,51.8282500099,
	51.8193662375,51.8104912732,51.8016250996,51.7927676992,51.7839190547,
	51.7750791486,51.7662479639,51.7574254831,51.7486116892,51.7398065651,
	51.7310100936,51.7222222578,51.7134430406,51.7046724253,51.6959103948,
	51.6871569323,51.6784120212,51.6696756447,51.660947786,51.6522284287,
	51.643517556,51.6348151515,51.6261211987,51.6174356812,51.6087585825,
	51.6000898864,51.5914295766,51.5827776367,51.5741340507,51.5654988023,
	51.5568718755,51.5482532542,51.5396429225,51.5310408642,51.5224470636,
	51.5138615047,51.5052841718,51.496715049,51.4881541206,51.4796013709,
	51.4710567843,51.4625203452,51.453992038,51.4454718472,51.4369597573,
	51.428455753,51.4199598188,51.4114719394,51.4029920995,51.3945202839,
	51.3860564773,51.3776006646,51.3691528308,51.3607129606,51.352281039,
	51.3438570512,51.3354409821,51.3270328167,51.3186325404,51.3102401382,
	51.3018555953,51.293478897,51.2851100286,51.2767489755,51.268395723,
	51.2600502566,51.2517125617,51.2433826238,51.2350604285,51.2267459613,
	51.218439208,51.210140154,51.2018487853,51.1935650874,51.1852890462,
	51.1770206476,51.1687598773,51.1605067213,51.1522611655,51.1440231959,
	51.1357927985,51.1275699594,51.1193546647,51.1111469005,51.1029466529,
	51.0947539083,51.0865686527,51.0783908726,51.0702205543,51.062057684,
	51.0539022483,51.0457542335,51.0376136261,51.0294804127,51.0213545797,
	51.0132361137
	};


tubetable_6V6_rtable_0(r) = (tubetable_6V6_0,r):rdtable;
tubetable_6V6_rtable_1(r) = (tubetable_6V6_1,r):rdtable;

// generated by ../../tools/tube_transfer.py
// tube: 12AT7
// plate current function: triode
// mu: 60
// kx: 1.35
// kg1: 460
// kp: 300
// kvb: 300

tubetable_12AT7_0 = waveform{
	223.484971051,223.38189846,223.278606859,223.175096438,223.071367386,
	222.967419894,222.863254153,222.758870355,222.654268692,222.549449358,
	222.444412546,222.339158451,222.233687268,222.127999193,222.022094421,
	221.915973151,221.809635579,221.703081904,221.596312324,221.489327039,
	221.382126248,221.274710152,221.167078951,221.059232846,220.951172041,
	220.842896736,220.734407134,220.62570344,220.516785857,220.407654588,
	220.298309839,220.188751814,220.078980719,219.96899676,219.858800143,
	219.748391075,219.637769762,219.526936413,219.415891235,219.304634436,
	219.193166225,219.081486809,218.9695964,218.857495205,218.745183435,
	218.6326613,218.519929009,218.406986775,218.293834807,218.180473316,
	218.066902515,217.953122614,217.839133825,217.724936362,217.610530435,
	217.495916257,217.381094042,217.266064002,217.150826349,217.035381299,
	216.919729063,216.803869855,216.68780389,216.571531381,216.455052541,
	216.338367587,216.22147673,216.104380187,215.987078171,215.869570897,
	215.75185858,215.633941434,215.515819675,215.397493517,215.278963175,
	215.160228865,215.041290801,214.922149198,214.802804272,214.683256238,
	214.563505311,214.443551707,214.32339564,214.203037325,214.082476979,
	213.961714816,213.840751051,213.719585899,213.598219576,213.476652297,
	213.354884277,213.232915731,213.110746873,212.988377919,212.865809083,
	212.74304058,212.620072625,212.496905433,212.373539217,212.249974193,
	212.126210573,212.002248574,211.878088408,211.75373029,211.629174433,
	211.504421051,211.379470357,211.254322565,211.128977889,211.003436541,
	210.877698734,210.751764681,210.625634594,210.499308686,210.37278717,
	210.246070256,210.119158158,209.992051086,209.864749253,209.737252869,
	209.609562146,209.481677294,209.353598524,209.225326046,209.096860071,
	208.968200809,208.839348469,208.710303261,208.581065394,208.451635077,
	208.322012519,208.192197928,208.062191513,207.931993481,207.801604041,
	207.671023398,207.540251762,207.409289338,207.278136334,207.146792955,
	207.015259407,206.883535897,206.75162263,206.61951981,206.487227642,
	206.354746332,206.222076083,206.089217099,205.956169583,205.82293374,
	205.689509771,205.555897879,205.422098267,205.288111136,205.153936688,
	205.019575125,204.885026646,204.750291453,204.615369746,204.480261724,
	204.344967587,204.209487534,204.073821763,203.937970474,203.801933864,
	203.66571213,203.52930547,203.392714081,203.255938159,203.1189779,
	202.9818335,202.844505154,202.706993058,202.569297405,202.43141839,
	202.293356206,202.155111047,202.016683105,201.878072574,201.739279645,
	201.60030451,201.46114736,201.321808386,201.182287779,201.042585728,
	200.902702422,200.762638052,200.622392806,200.481966872,200.341360438,
	200.200573691,200.059606819,199.918460008,199.777133444,199.635627312,
	199.493941798,199.352077087,199.210033363,199.067810809,198.92540961,
	198.782829948,198.640072006,198.497135966,198.354022009,198.210730316,
	198.067261068,197.923614446,197.779790629,197.635789796,197.491612126,
	197.347257797,197.202726987,197.058019875,196.913136635,196.768077446,
	196.622842482,196.477431919,196.331845933,196.186084697,196.040148386,
	195.894037174,195.747751232,195.601290734,195.454655852,195.307846758,
	195.160863622,195.013706614,194.866375906,194.718871667,194.571194065,
	194.423343269,194.275319448,194.127122768,193.978753398,193.830211503,
	193.681497249,193.532610803,193.383552329,193.234321992,193.084919955,
	192.935346382,192.785601437,192.635685281,192.485598078,192.335339987,
	192.18491117,192.034311788,191.883542,191.732601966,191.581491845,
	191.430211795,191.278761974,191.127142539,190.975353646,190.823395453,
	190.671268115,190.518971788,190.366506625,190.213872781,190.061070409,
	189.908099664,189.754960697,189.60165366,189.448178705,189.294535983,
	189.140725644,188.986747838,188.832602715,188.678290424,188.523811112,
	188.369164928,188.214352019,188.059372531,187.904226611,187.748914404,
	187.593436056,187.43779171,187.281981512,187.126005604,186.96986413,
	186.813557231,186.65708505,186.500447728,186.343645406,186.186678223,
	186.029546321,185.872249837,185.71478891,185.55716368,185.399374282,
	185.241420854,185.083303532,184.925022452,184.766577751,184.607969561,
	184.449198018,184.290263255,184.131165406,183.971904602,183.812480977,
	183.652894661,183.493145785,183.33323448,183.173160876,183.012925102,
	182.852527286,182.691967557,182.531246043,182.37036287,182.209318165,
	182.048112054,181.886744663,181.725216116,181.563526537,181.401676051,
	181.239664781,181.077492849,180.915160377,180.752667487,180.590014299,
	180.427200936,180.264227515,180.101094157,179.93780098,179.774348102,
	179.610735642,179.446963716,179.283032441,179.118941932,178.954692305,
	178.790283676,178.625716158,178.460989865,178.29610491,178.131061407,
	177.965859466,177.8004992,177.634980719,177.469304135,177.303469556,
	177.137477092,176.971326852,176.805018943,176.638553475,176.471930553,
	176.305150284,176.138212774,175.971118129,175.803866452,175.63645785,
	175.468892424,175.301170279,175.133291517,174.965256239,174.797064548,
	174.628716544,174.460212328,174.291551999,174.122735656,173.953763399,
	173.784635325,173.615351532,173.445912117,173.276317175,173.106566804,
	172.936661098,172.766600153,172.596384061,172.426012917,172.255486814,
	172.084805844,171.9139701,171.742979672,171.571834651,171.400535128,
	171.229081192,171.057472933,170.885710438,170.713793796,170.541723094,
	170.36949842,170.197119859,170.024587497,169.851901419,169.679061711,
	169.506068455,169.332921736,169.159621635,168.986168237,168.812561622,
	168.638801872,168.464889067,168.290823288,168.116604613,167.942233123,
	167.767708895,167.593032007,167.418202536,167.24322056,167.068086154,
	166.892799395,166.717360356,166.541769112,166.366025738,166.190130307,
	166.014082891,165.837883563,165.661532395,165.485029456,165.308374819,
	165.131568552,164.954610726,164.777501409,164.60024067,164.422828575,
	164.245265193,164.06755059,163.889684831,163.711667983,163.533500109,
	163.355181276,163.176711545,162.998090981,162.819319646,162.640397602,
	162.46132491,162.282101632,162.102727828,161.923203558,161.743528881,
	161.563703855,161.383728539,161.20360299,161.023327265,160.842901421,
	160.662325513,160.481599598,160.300723728,160.11969796,159.938522345,
	159.757196938,159.57572179,159.394096954,159.212322481,159.030398422,
	158.848324827,158.666101745,158.483729225,158.301207317,158.118536068,
	157.935715525,157.752745735,157.569626745,157.3863586,157.202941345,
	157.019375024,156.835659683,156.651795363,156.467782109,156.283619962,
	156.099308963,155.914849155,155.730240578,155.545483271,155.360577274,
	155.175522626,154.990319366,154.80496753,154.619467157,154.433818283,
	154.248020943,154.062075174,153.87598101,153.689738486,153.503347636,
	153.316808491,153.130121087,152.943285453,152.756301622,152.569169625,
	152.381889493,152.194461254,152.006884938,151.819160575,151.631288191,
	151.443267815,151.255099474,151.066783193,150.878318999,150.689706918,
	150.500946973,150.312039189,150.122983589,149.933780197,149.744429035,
	149.554930124,149.365283487,149.175489143,148.985547114,148.795457417,
	148.605220074,148.414835102,148.224302518,148.033622341,147.842794587,
	147.651819272,147.460696413,147.269426023,147.078008117,146.88644271,
	146.694729815,146.502869444,146.31086161,146.118706324,145.926403598,
	145.733953442,145.541355866,145.348610879,145.15571849,144.962678708,
	144.76949154,144.576156994,144.382675075,144.18904579,143.995269144,
	143.801345143,143.60727379,143.413055089,143.218689043,143.024175656,
	142.829514928,142.634706862,142.439751458,142.244648717,142.049398638,
	141.854001221,141.658456465,141.462764367,141.266924924,141.070938135,
	140.874803995,140.678522501,140.482093647,140.285517428,140.088793838,
	139.891922871,139.694904521,139.497738779,139.300425637,139.102965087,
	138.905357119,138.707601724,138.509698892,138.311648611,138.113450871,
	137.915105658,137.716612961,137.517972767,137.319185062,137.120249831,
	136.921167061,136.721936735,136.522558838,136.323033353,136.123360263,
	135.923539552,135.7235712,135.52345519,135.323191502,135.122780116,
	134.922221012,134.72151417,134.520659568,134.319657184,134.118506996,
	133.917208981,133.715763115,133.514169375,133.312427735,133.110538172,
	132.908500658,132.706315168,132.503981676,132.301500154,132.098870574,
	131.896092908,131.693167128,131.490093204,131.286871106,131.083500803,
	130.879982266,130.676315463,130.472500361,130.268536929,130.064425133,
	129.860164941,129.655756317,129.451199229,129.24649364,129.041639516,
	128.836636821,128.631485518,128.426185571,128.220736941,128.015139592,
	127.809393485,127.603498581,127.397454841,127.191262225,126.984920693,
	126.778430205,126.57179072,126.365002195,126.158064589,125.950977859,
	125.743741963,125.536356858,125.328822499,125.121138842,124.913305843,
	124.705323458,124.497191639,124.288910343,124.080479522,123.87189913,
	123.66316912,123.454289445,123.245260057,123.036080908,122.82675195,
	122.617273133,122.407644409,122.197865728,121.987937041,121.777858298,
	121.567629447,121.357250439,121.146721222,120.936041745,120.725211957,
	120.514231806,120.30310124,120.091820207,119.880388654,119.668806528,
	119.457073777,119.245190347,119.033156186,118.82097124,118.608635455,
	118.396148777,118.183511154,117.970722531,117.757782854,117.544692069,
	117.331450122,117.118056958,116.904512525,116.690816767,116.476969631,
	116.262971063,116.048821008,115.834519413,115.620066224,115.405461388,
	115.19070485,114.975796559,114.76073646,114.545524502,114.330160631,
	114.114644796,113.898976945,113.683157025,113.467184988,113.25106078,
	113.034784354,112.818355658,112.601774644,112.385041264,112.168155469,
	111.951117213,111.733926449,111.516583131,111.299087215,111.081438657,
	110.863637413,110.645683442,110.427576702,110.209317154,109.990904759,
	109.772339479,109.553621277,109.334750119,109.115725972,108.896548803,
	108.677218581,108.457735278,108.238098866,108.01830932,107.798366617,
	107.578270734,107.358021653,107.137619356,106.917063827,106.696355055,
	106.475493028,106.25447774,106.033309184,105.81198736,105.590512267,
	105.36888391,105.147102295,104.925167434,104.703079339,104.480838028,
	104.258443522,104.035895848,103.813195034,103.590341113,103.367334124,
	103.14417411,102.920861118,102.697395202,102.473776418,102.250004831,
	102.02608051,101.802003529,101.577773971,101.353391923,101.128857479,
	100.904170741,100.679331818,100.454340825,100.229197888,100.003903138,
	99.778456717,99.5528587734,99.3271094667,99.1012089653,98.8751574477,
	98.6489551024,98.4226021292,98.1960987386,97.969445153,97.7426416069,
	97.5156883471,97.2885856338,97.0613337405,96.833932955,96.6063835797,
	96.3786859321,96.1508403457,95.9228471705,95.6947067733,95.4664195391,
	95.2379858709,95.0094061912,94.7806809423,94.5518105871,94.3227956102,
	94.0936365183,93.8643338415,93.6348881337,93.405299974,93.1755699676,
	92.9456987464,92.7156869704,92.4855353287,92.2552445406,92.0248153569,
	91.7942485605,91.5635449686,91.3327054332,91.1017308426,90.8706221232,
	90.6393802404,90.4080062002,90.1765010512,89.9448658855,89.7131018408,
	89.4812101019,89.2491919027,89.0170485276,88.784781314,88.5523916537,
	88.3198809952,88.0872508458,87.8545027735,87.6216384098,87.3886594513,
	87.1555676628,86.9223648793,86.6890530085,86.4556340339,86.2221100172,
	85.9884831011,85.7547555124,85.5209295646,85.2870076616,85.0529923004,
	84.8188860745,84.5846916773,84.3504119056,84.1160496633,83.8816079647,
	83.647089939,83.4124988332,83.1778380171,82.9431109867,82.7083213689,
	82.4734729256,82.2385695581,82.0036153116,81.7686143804,81.5335711119,
	81.2984900118,81.0633757495,80.8282331624,80.5930672616,80.3578832372,
	80.1226864634,79.8874825043,79.6522771191,79.417076268,79.1818861179,
	78.946713048,78.7115636561,78.4764447639,78.2413634234,78.0063269226,
	77.7713427919,77.5364188098,77.3015630089,77.0667836823,76.832089389,
	76.5974889606,76.3629915064,76.1286064198,75.8943433838,75.6602123765,
	75.4262236766,75.1923878688,74.9587158488,74.7252188281,74.4919083386,
	74.2587962373,74.0258947099,73.7932162747,73.5607737859,73.3285804366,
	73.0966497613,72.8649956377,72.6336322885,72.4025742822,72.1718365333,
	71.9414343025,71.7113831952,71.4816991604,71.2523984878,71.0234978052,
	70.7950140739,70.5669645844,70.3393669505,70.1122391024,69.8855992793,
	69.659466021,69.4338581579,69.2087948004,68.9842953275,68.7603793738,
	68.5370668156,68.3143777559,68.0923325085,67.8709515808,67.6502556556,
	67.4302655713,67.2110023025,66.9924869376,66.7747406569,66.5577847094,
	66.341640388,66.1263290049,65.9118718655,65.6982902415,65.485605344,
	65.2738382953,65.0630101007,64.8531416195,64.644253536,64.4363663304,
	64.2295002488,64.0236752742,63.8189110973,63.6152270868,63.4126422611,
	63.2111752599,63.0108443162,62.8116672294,62.613661339,62.4168434988,
	62.2212300529,62.026836812,61.8336790312,61.6417713894,61.4511279693,
	61.2617622392,61.0736870367,60.8869145531,60.7014563202,60.5173231979,
	60.3345253642,60.1530723064,59.9729728143,59.7942349746,59.6168661678,
	59.4408730656,59.2662616311,59.0930371202,58.9212040837,58.7507663728,
	58.5817271438,58.4140888665,58.2478533317,58.0830216621,57.9195943226,
	57.757571133,57.5969512811,57.437733337,57.2799152681,57.1234944552,
	56.9684677091,56.8148312878,56.6625809145,56.5117117958,56.3622186407,
	56.2140956792,56.0673366819,55.9219349798,55.777883483,55.6351747015,
	55.4938007636,55.3537534367,55.2150241456,55.0776039925,54.9414837759,
	54.8066540091,54.6731049389,54.5408265635,54.4098086506,54.2800407545,
	54.1515122329,54.0242122639,53.8981298612,53.7732538906,53.6495730842,
	53.5270760555,53.4057513131,53.2855872745,53.166572279,53.0486945999,
	52.9319424571,52.816304028,52.7017674586,52.5883208741,52.4759523889,
	52.3646501157,52.2544021747,52.1451967025,52.0370218595,51.9298658379,
	51.8237168688,51.718563229,51.6143932475,51.5111953109,51.4089578697,
	51.3076694432,51.2073186239,51.1078940829,51.0093845734,50.9117789348,
	50.815066096,50.7192350793,50.6242750025,50.5301750825,50.4369246372,
	50.3445130879,50.2529299611,50.1621648909,50.0722076197,49.9830480004,
	49.894675997,49.8070816859,49.7202552566,49.6341870125,49.5488673716,
	49.4642868666,49.3804361451,49.2973059702,49.2148872203,49.1331708887,
	49.052148084,48.9718100296,48.892148063,48.8131536359,48.7348183134,
	48.6571337734,48.5800918059,48.5036843125,48.4279033056,48.3527409073,
	48.2781893488,48.2042409693,48.1308882153,48.0581236393,47.9859398991,
	47.9143297565,47.8432860762,47.772801825,47.7028700705,47.6334839797,
	47.5646368183,47.4963219495,47.4285328322,47.3612630208,47.2945061629,
	47.2282559993,47.1625063616,47.0972511721,47.0324844415,46.9682002687,
	46.9043928391,46.8410564231,46.7781853756,46.7157741343,46.6538172188,
	46.5923092291,46.5312448446,46.4706188231,46.4104259995,46.3506612843,
	46.2913196632,46.2323961953,46.1738860123,46.1157843173,46.0580863839,
	46.0007875547,45.9438832405,45.8873689195,45.8312401357,45.7754924981,
	45.7201216798,45.665123417,45.6104935076,45.5562278108,45.5023222456,
	45.4487727904,45.3955754813,45.3427264119,45.2902217321,45.238057647,
	45.1862304162,45.1347363532,45.0835718238,45.0327332461,44.982217089,
	44.9320198716,44.8821381626,44.8325685792,44.7833077865,44.7343524964,
	44.6856994674,44.6373455033,44.5892874528,44.5415222087,44.4940467071,
	44.4468579267,44.3999528883,44.3533286537,44.3069823257,44.2609110467,
	44.2151119985,44.1695824018,44.124319515,44.0793206341,44.034583092,
	43.9901042576,43.9458815358,43.9019123661,43.8581942231,43.8147246147,
	43.7715010829,43.728521202,43.6857825789,43.6432828524,43.6010196926,
	43.5589908004,43.5171939069,43.4756267733,43.4342871901,43.3931729766,
	43.3522819807,43.3116120784,43.2711611731,43.2309271955,43.1909081027,
	43.1511018785,43.1115065323,43.0721200993,43.0329406393,42.9939662373,
	42.9551950023,42.9166250673,42.878254589,42.8400817471,42.8021047443,
	42.7643218057,42.7267311786,42.6893311322,42.6521199569,42.6150959646,
	42.5782574877,42.5416028795,42.5051305131,42.4688387817,42.4327260982,
	42.3967908945,42.3610316219,42.32544675,42.2900347672,42.2547941799,
	42.2197235125,42.184821307,42.1500861227,42.1155165361,42.0811111406,
	42.0468685461,42.0127873789,41.9788662816,41.9451039126,41.9114989459,
	41.8780500709,41.8447559925,41.8116154303,41.7786271187,41.7457898069,
	41.7131022583,41.6805632504,41.6481715748,41.6159260367,41.5838254549,
	41.5518686617,41.5200545023,41.4883818353,41.4568495316,41.4254564751,
	41.394201562,41.3630837008,41.3321018122,41.3012548286,41.2705416944,
	41.2399613655,41.2095128092,41.1791950042,41.1490069403,41.1189476183,
	41.0890160496,41.0592112567,41.0295322723,40.9999781396,40.970547912,
	40.9412406531,40.9120554366,40.8829913457,40.8540474735,40.8252229228,
	40.7965168056,40.7679282435,40.7394563671,40.7111003161,40.6828592393,
	40.6547322942,40.626718647,40.5988174728,40.5710279548,40.5433492849,
	40.5157806631,40.4883212976,40.4609704049,40.433727209,40.4065909422,
	40.3795608443,40.3526361629,40.3258161531,40.2991000774,40.2724872058,
	40.2459768155,40.2195681909,40.1932606236,40.1670534118,40.1409458612,
	40.114937284,40.089026999,40.063214332,40.0374986152,40.0118791874,
	39.9863553935,39.9609265851,39.9355921199,39.9103513619,39.8852036809,
	39.8601484532,39.8351850605,39.8103128908,39.7855313379,39.7608398011,
	39.7362376854,39.7117244017,39.6872993662,39.6629620004,39.6387117317,
	39.6145479924,39.5904702202,39.5664778582,39.5425703542,39.5187471617,
	39.4950077387,39.4713515484,39.447778059,39.4242867434,39.4008770793,
	39.3775485493,39.3543006404,39.3311328446,39.3080446582,39.2850355821,
	39.2621051218,39.2392527869,39.2164780918,39.193780555,39.1711596991,
	39.1486150512,39.1261461426,39.1037525085,39.0814336882,39.0591892253,
	39.0370186672,39.0149215651,38.9928974745,38.9709459543,38.9490665676,
	38.9272588811,38.9055224652,38.883856894,38.8622617454,38.8407366006,
	38.8192810448,38.7978946663,38.7765770572,38.7553278128,38.7341465321,
	38.7130328173,38.6919862739,38.6710065108,38.6500931402,38.6292457774,
	38.608464041,38.5877475528,38.5670959377,38.5465088236,38.5259858415,
	38.5055266257,38.485130813,38.4647980436,38.4445279604,38.4243202094,
	38.4041744393,38.3840903017,38.3640674511,38.3441055447,38.3242042424,
	38.3043632069,38.2845821037,38.2648606009,38.2451983691,38.2255950817,
	38.2060504147,38.1865640465,38.1671356581,38.1477649333,38.1284515578,
	38.1091952204,38.0899956119,38.0708524256,38.0517653574,38.0327341052,
	38.0137583696,37.9948378534,37.9759722615,37.9571613012,37.9384046823,
	37.9197021164,37.9010533177,37.8824580021,37.8639158882,37.8454266964,
	37.8269901493,37.8086059716,37.7902738901,37.7719936336,37.753764933,
	37.7355875212,37.717461133,37.6993855054,37.6813603772,37.6633854891,
	37.6454605838,37.6275854059,37.6097597018,37.59198322,37.5742557106,
	37.5565769256,37.5389466189,37.521364546,37.5038304645,37.4863441334,
	37.4689053137,37.4515137681,37.4341692609,37.4168715581,37.3996204275,
	37.3824156386,37.3652569623,37.3481441714,37.3310770401,37.3140553445,
	37.297078862,37.2801473717,37.2632606542,37.2464184918,37.2296206681,
	37.2128669684,37.1961571795,37.1794910896,37.1628684884,37.1462891671,
	37.1297529184,37.1132595362,37.0968088162,37.0804005552,37.0640345515,
	37.0477106048,37.0314285162,37.0151880881,36.9989891244,36.9828314301,
	36.9667148116,36.9506390768,36.9346040347,36.9186094956,36.9026552713,
	36.8867411745,36.8708670195,36.8550326217,36.8392377978,36.8234823655,
	36.807766144,36.7920889536,36.7764506158,36.7608509532,36.7452897896,
	36.7297669502,36.714282261,36.6988355493,36.6834266436,36.6680553734,
	36.6527215694,36.6374250634,36.6221656883,36.606943278,36.5917576675,
	36.5766086929,36.5614961915,36.5464200014,36.5313799619,36.5163759132,
	36.5014076967,36.4864751547,36.4715781305,36.4567164685,36.4418900139,
	36.4270986131,36.4123421134,36.3976203629,36.382933211,36.3682805076,
	36.353662104,36.3390778522,36.324527605,36.3100112165,36.2955285412,
	36.2810794351,36.2666637545,36.252281357,36.237932101,36.2236158457,
	36.2093324512,36.1950817784,36.1808636892,36.1666780462,36.152524713,
	36.1384035538,36.1243144338,36.1102572191,36.0962317763,36.0822379733,
	36.0682756782,36.0543447604,36.0404450898,36.0265765373,36.0127389743,
	35.9989322732,35.9851563071,35.9714109499,35.957696076,35.944011561,
	35.9303572808,35.9167331123,35.903138933,35.8895746213,35.8760400561,
	35.8625351171,35.8490596847,35.8356136401,35.822196865,35.808809242,
	35.7954506543,35.7821209857,35.7688201207,35.7555479447,35.7423043434,
	35.7290892035,35.715902412,35.7027438569,35.6896134267,35.6765110104,
	35.663436498,35.6503897796,35.6373707465,35.6243792901,35.6114153029,
	35.5984786777,35.5855693079,35.5726870876,35.5598319116,35.5470036751,
	35.534202274,35.5214276048,35.5086795644,35.4959580506,35.4832629614,
	35.4705941957,35.4579516528,35.4453352325,35.4327448353,35.4201803622,
	35.4076417148,35.3951287951,35.3826415057,35.3701797498,35.3577434311,
	35.3453324539,35.3329467228,35.3205861432,35.3082506207,35.2959400619,
	35.2836543733,35.2713934625,35.2591572371,35.2469456055,35.2347584766,
	35.2225957595,35.2104573643,35.198343201,35.1862531805,35.174187214,
	35.1621452133,35.1501270905,35.1381327583,35.1261621298,35.1142151186,
	35.1022916388,35.0903916048,35.0785149317,35.0666615348,35.0548313299,
	35.0430242335,35.0312401621,35.0194790329,35.0077407637,34.9960252724,
	34.9843324774,34.9726622977,34.9610146526,34.9493894618,34.9377866455,
	34.9262061242,34.9146478189,34.903111651,34.8915975423,34.880105415,
	34.8686351915,34.8571867951,34.845760149,34.8343551769,34.8229718032,
	34.8116099522,34.800269549,34.7889505189,34.7776527876,34.7663762811,
	34.7551209259,34.7438866488,34.732673377,34.7214810381,34.7103095599,
	34.6991588708,34.6880288994,34.6769195746,34.665830826,34.654762583,
	34.6437147759,34.632687335,34.6216801911,34.6106932752,34.5997265188,
	34.5887798536,34.5778532119,34.5669465259,34.5560597285,34.5451927529,
	34.5343455323,34.5235180007,34.5127100921,34.5019217408,34.4911528817,
	34.4804034497,34.4696733802,34.458962609,34.4482710719,34.4375987053,
	34.4269454458,34.4163112303,34.405695996,34.3950996804,34.3845222213,
	34.373963557,34.3634236256,34.3529023661,34.3423997173,34.3319156186,
	34.3214500095,34.3110028299,34.30057402,34.2901635202,34.2797712711,
	34.2693972139,34.2590412897,34.2487034402,34.2383836071,34.2280817325,
	34.2177977589,34.2075316288,34.1972832853,34.1870526713,34.1768397305,
	34.1666444064,34.1564666431,34.1463063848,34.1361635759,34.1260381613,
	34.1159300859,34.1058392949,34.0957657339,34.0857093486,34.075670085,
	34.0656478894,34.0556427083,34.0456544884,34.0356831767,34.0257287205,
	34.0157910671,34.0058701643,33.9959659601,33.9860784026,33.9762074403,
	33.9663530217,33.9565150959,33.9466936118,33.9368885189,33.9270997666,
	33.9173273049,33.9075710837,33.8978310533,33.8881071641,33.8783993668,
	33.8687076124,33.8590318519,33.8493720367,33.8397281184,33.8301000487,
	33.8204877797,33.8108912635,33.8013104526,33.7917452996,33.7821957572,
	33.7726617786,33.763143317,33.7536403258,33.7441527588,33.7346805697,
	33.7252237126,33.7157821418,33.7063558118,33.6969446771,33.6875486927,
	33.6781678136,33.6688019951,33.6594511925,33.6501153616,33.6407944581,
	33.631488438,33.6221972577,33.6129208733,33.6036592416,33.5944123194,
	33.5851800634,33.575962431,33.5667593793,33.5575708659,33.5483968486,
	33.539237285,33.5300921334,33.5209613518,33.5118448987,33.5027427327,
	33.4936548125,33.484581097,33.4755215454,33.4664761168,33.4574447707,
	33.4484274668,33.4394241647,33.4304348245,33.4214594063,33.4124978703,
	33.403550177,33.3946162869,33.3856961609,33.3767897599,33.367897045,
	33.3590179775,33.3501525187,33.3413006302,33.3324622739,33.3236374115,
	33.3148260051,33.3060280169,33.2972434094,33.2884721449,33.2797141863,
	33.2709694962,33.2622380377,33.2535197739,33.2448146681,33.2361226837,
	33.2274437842,33.2187779335,33.2101250953,33.2014852337,33.1928583128,
	33.184244297,33.1756431507,33.1670548384,33.158479325,33.1499165753,
	33.1413665542,33.1328292271,33.124304559,33.1157925156,33.1072930624,
	33.098806165,33.0903317894,33.0818699015,33.0734204674,33.0649834534,
	33.0565588258,33.0481465513,33.0397465963,33.0313589278,33.0229835126,
	33.0146203178,33.0062693106,32.9979304582,32.989603728,32.9812890877,
	32.972986505,32.9646959476,32.9564173834,32.9481507806,32.9398961073,
	32.9316533318,32.9234224226,32.9152033482,32.9069960773,32.8988005787,
	32.8906168214,32.8824447742,32.8742844065,32.8661356875,32.8579985866,
	32.8498730732,32.8417591171,32.833656688,32.8255657557,32.8174862902,
	32.8094182617,32.8013616402,32.7933163962,32.7852825001,32.7772599223,
	32.7692486337,32.7612486048,32.7532598067,32.7452822103,32.7373157867,
	32.7293605071,32.7214163428,32.7134832652,32.705561246,32.6976502567,
	32.689750269,32.6818612548,32.6739831862,32.666116035,32.6582597736,
	32.6504143741,32.6425798089,32.6347560506,32.6269430716,32.6191408447,
	32.6113493427,32.6035685384,32.5957984048,32.588038915,32.5802900421,
	32.5725517595,32.5648240406,32.5571068587,32.5494001875,32.5417040007,
	32.5340182719,32.5263429752,32.5186780844,32.5110235735,32.5033794168,
	32.4957455885,32.4881220628,32.4805088143,32.4729058175,32.4653130469,
	32.4577304774,32.4501580835,32.4425958404,32.4350437229,32.4275017061,
	32.4199697652,32.4124478754,32.404936012,32.3974341505,32.3899422665,
	32.3824603354,32.374988333,32.3675262351,32.3600740175,32.3526316561,
	32.3451991271,32.3377764065,32.3303634705,32.3229602955,32.3155668577,
	32.3081831337,32.3008091,32.2934447331,32.2860900099,32.2787449071,
	32.2714094015,32.2640834702,32.2567670901,32.2494602383,32.2421628922,
	32.2348750288,32.2275966256,32.22032766,32.2130681096,32.2058179518,
	32.1985771644,32.1913457251,32.1841236118,32.1769108022,32.1697072745,
	32.1625130066,32.1553279767,32.148152163,32.1409855437,32.1338280972,
	32.126679802,32.1195406365,32.1124105793,32.1052896091,32.0981777045,
	32.0910748445,32.0839810077,32.0768961733,32.0698203201,32.0627534273,
	32.0556954741,32.0486464396,32.0416063031,32.0345750441,32.0275526419,
	32.020539076,32.0135343261,32.0065383718,31.9995511928,31.9925727688,
	31.9856030797,31.9786421055,31.9716898261,31.9647462215,31.957811272,
	31.9508849576,31.9439672587,31.9370581555,31.9301576284,31.9232656579,
	31.9163822245,31.9095073088,31.9026408914,31.895782953,31.8889334744,
	31.8820924364,31.87525982,31.8684356061,31.8616197757,31.8548123099,
	31.8480131899,31.8412223968,31.834439912,31.8276657168,31.8208997926,
	31.8141421208,31.8073926829,31.8006514606,31.7939184355,31.7871935893,
	31.7804769038,31.7737683607,31.7670679419,31.7603756294,31.7536914052,
	31.7470152514,31.74034715,31.7336870832,31.7270350332,31.7203909824,
	31.7137549131,31.7071268077,31.7005066486,31.6938944183,31.6872900995,
	31.6806936748,31.6741051267,31.6675244382,31.6609515919,31.6543865707,
	31.6478293576,31.6412799354,31.6347382873,31.6282043961,31.6216782452,
	31.6151598176,31.6086490966,31.6021460655,31.5956507075,31.5891630062,
	31.5826829449,31.576210507,31.5697456763,31.5632884362,31.5568387704,
	31.5503966626,31.5439620966,31.5375350561,31.5311155251,31.5247034874,
	31.5182989269,31.5119018277,31.5055121739,31.4991299494,31.4927551386,
	31.4863877255,31.4800276945,31.4736750299,31.4673297159,31.4609917371,
	31.4546610778,31.4483377225,31.4420216558,31.4357128623,31.4294113266,
	31.4231170334,31.4168299674,31.4105501135,31.4042774564,31.398011981,
	31.3917536723,31.3855025152,31.3792584947,31.3730215959,31.3667918039,
	31.3605691038,31.3543534809,31.3481449203,31.3419434074,31.3357489276,
	31.329561466,31.3233810083,31.3172075399,31.3110410462,31.3048815128,
	31.2987289254,31.2925832695,31.2864445309,31.2803126952,31.2741877483,
	31.2680696759,31.261958464,31.2558540983,31.249756565,31.2436658498,
	31.2375819389,31.2315048184,31.2254344742,31.2193708927,31.2133140599,
	31.2072639622,31.2012205857,31.1951839169,31.189153942,31.1831306474,
	31.1771140197,31.1711040452,31.1651007105,31.1591040022,31.1531139068,
	31.1471304109,31.1411535014,31.1351831648,31.1292193879,31.1232621575,
	31.1173114605,31.1113672838,31.1054296141,31.0994984385,31.0935737441,
	31.0876555177,31.0817437464,31.0758384175,31.0699395179,31.0640470349,
	31.0581609557,31.0522812675,31.0464079577,31.0405410135,31.0346804223,
	31.0288261716,31.0229782487,31.0171366411,31.0113013363,31.0054723219,
	30.9996495855,30.9938331146,30.988022897,30.9822189203,30.9764211722,
	30.9706296405,30.9648443129,30.9590651774,30.9532922218,30.9475254339,
	30.9417648017
	};

tubetable_12AT7_1 = waveform{
	223.484971051,223.38189846,223.278606859,223.175096438,223.071367386,
	222.967419894,222.863254153,222.758870355,222.654268692,222.549449358,
	222.444412546,222.339158451,222.233687268,222.127999193,222.022094421,
	221.915973151,221.809635579,221.703081904,221.596312324,221.489327039,
	221.382126248,221.274710152,221.167078951,221.059232846,220.951172041,
	220.842896736,220.734407134,220.62570344,220.516785857,220.407654588,
	220.298309839,220.188751814,220.078980719,219.96899676,219.858800143,
	219.748391075,219.637769762,219.526936413,219.415891235,219.304634436,
	219.193166225,219.081486809,218.9695964,218.857495205,218.745183435,
	218.6326613,218.519929009,218.406986775,218.293834807,218.180473316,
	218.066902515,217.953122614,217.839133825,217.724936362,217.610530435,
	217.495916257,217.381094042,217.266064002,217.150826349,217.035381299,
	216.919729063,216.803869855,216.68780389,216.571531381,216.455052541,
	216.338367587,216.22147673,216.104380187,215.987078171,215.869570897,
	215.75185858,215.633941434,215.515819675,215.397493517,215.278963175,
	215.160228865,215.041290801,214.922149198,214.802804272,214.683256238,
	214.563505311,214.443551707,214.32339564,214.203037325,214.082476979,
	213.961714816,213.840751051,213.719585899,213.598219576,213.476652297,
	213.354884277,213.232915731,213.110746873,212.988377919,212.865809083,
	212.74304058,212.620072625,212.496905433,212.373539217,212.249974193,
	212.126210573,212.002248574,211.878088408,211.75373029,211.629174433,
	211.504421051,211.379470357,211.254322565,211.128977889,211.003436541,
	210.877698734,210.751764681,210.625634594,210.499308686,210.37278717,
	210.246070256,210.119158158,209.992051086,209.864749253,209.737252869,
	209.609562146,209.481677294,209.353598524,209.225326046,209.096860071,
	208.968200809,208.839348469,208.710303261,208.581065394,208.451635077,
	208.322012519,208.192197928,208.062191513,207.931993481,207.801604041,
	207.671023398,207.540251762,207.409289338,207.278136334,207.146792955,
	207.015259407,206.883535897,206.75162263,206.61951981,206.487227642,
	206.354746332,206.222076083,206.089217099,205.956169583,205.82293374,
	205.689509771,205.555897879,205.422098267,205.288111136,205.153936688,
	205.019575125,204.885026646,204.750291453,204.615369746,204.480261724,
	204.344967587,204.209487534,204.073821763,203.937970474,203.801933864,
	203.66571213,203.52930547,203.392714081,203.255938159,203.1189779,
	202.9818335,202.844505154,202.706993058,202.569297405,202.43141839,
	202.293356206,202.155111047,202.016683105,201.878072574,201.739279645,
	201.60030451,201.46114736,201.321808386,201.182287779,201.042585728,
	200.902702422,200.762638052,200.622392806,200.481966872,200.341360438,
	200.200573692,200.059606819,199.918460008,199.777133444,199.635627312,
	199.493941798,199.352077087,199.210033363,199.067810809,198.92540961,
	198.782829948,198.640072006,198.497135966,198.354022009,198.210730316,
	198.067261068,197.923614446,197.779790629,197.635789796,197.491612126,
	197.347257797,197.202726987,197.058019875,196.913136635,196.768077446,
	196.622842482,196.477431919,196.331845933,196.186084697,196.040148386,
	195.894037174,195.747751232,195.601290734,195.454655852,195.307846758,
	195.160863622,195.013706614,194.866375906,194.718871667,194.571194065,
	194.423343269,194.275319448,194.127122768,193.978753398,193.830211503,
	193.681497249,193.532610803,193.383552329,193.234321992,193.084919955,
	192.935346382,192.785601437,192.635685281,192.485598078,192.335339987,
	192.18491117,192.034311788,191.883542,191.732601966,191.581491845,
	191.430211795,191.278761974,191.127142539,190.975353646,190.823395454,
	190.671268116,190.518971788,190.366506625,190.213872781,190.06107041,
	189.908099664,189.754960697,189.60165366,189.448178705,189.294535983,
	189.140725644,188.986747838,188.832602716,188.678290424,188.523811112,
	188.369164928,188.214352019,188.059372531,187.904226611,187.748914404,
	187.593436056,187.43779171,187.281981512,187.126005604,186.96986413,
	186.813557231,186.65708505,186.500447728,186.343645406,186.186678223,
	186.029546321,185.872249837,185.714788911,185.55716368,185.399374282,
	185.241420854,185.083303532,184.925022453,184.766577751,184.607969561,
	184.449198018,184.290263255,184.131165406,183.971904603,183.812480977,
	183.652894661,183.493145785,183.333234481,183.173160876,183.012925102,
	182.852527286,182.691967558,182.531246043,182.37036287,182.209318165,
	182.048112055,181.886744663,181.725216116,181.563526538,181.401676052,
	181.239664781,181.077492849,180.915160377,180.752667487,180.5900143,
	180.427200936,180.264227516,180.101094157,179.937800981,179.774348103,
	179.610735643,179.446963717,179.283032441,179.118941933,178.954692306,
	178.790283677,178.625716159,178.460989866,178.296104912,178.131061408,
	177.965859467,177.800499201,177.634980721,177.469304136,177.303469557,
	177.137477093,176.971326853,176.805018945,176.638553477,176.471930555,
	176.305150286,176.138212776,175.971118131,175.803866455,175.636457852,
	175.468892427,175.301170281,175.133291519,174.965256242,174.797064551,
	174.628716547,174.460212331,174.291552002,174.12273566,173.953763402,
	173.784635329,173.615351536,173.44591212,173.276317179,173.106566808,
	172.936661103,172.766600157,172.596384066,172.426012922,172.255486819,
	172.084805849,171.913970105,171.742979677,171.571834657,171.400535134,
	171.229081198,171.057472939,170.885710445,170.713793803,170.541723102,
	170.369498428,170.197119867,170.024587505,169.851901428,169.67906172,
	169.506068464,169.332921745,169.159621646,168.986168248,168.812561633,
	168.638801884,168.464889079,168.2908233,168.116604626,167.942233136,
	167.767708909,167.593032021,167.418202552,167.243220576,167.068086171,
	166.892799412,166.717360374,166.541769131,166.366025758,166.190130327,
	166.014082912,165.837883585,165.661532417,165.48502948,165.308374843,
	165.131568578,164.954610753,164.777501437,164.600240698,164.422828605,
	164.245265224,164.067550622,163.889684865,163.711668018,163.533500146,
	163.355181313,163.176711584,162.998091022,162.819319688,162.640397646,
	162.461324957,162.28210168,162.102727878,161.92320361,161.743528935,
	161.563703911,161.383728597,161.203603051,161.023327328,160.842901487,
	160.662325582,160.481599669,160.300723803,160.119698037,159.938522426,
	159.757197022,159.575721877,159.394097045,159.212322576,159.03039852,
	158.848324929,158.666101851,158.483729336,158.301207432,158.118536187,
	157.935715649,157.752745864,157.569626879,157.38635874,157.20294149,
	157.019375176,156.83565984,156.651795527,156.467782279,156.283620139,
	156.099309148,155.914849347,155.730240777,155.545483478,155.36057749,
	155.175522851,154.9903196,154.804967774,154.61946741,154.433818546,
	154.248021217,154.062075459,153.875981307,153.689738795,153.503347956,
	153.316808825,153.130121434,152.943285814,152.756301998,152.569170017,
	152.3818899,152.194461677,152.006885379,151.819161033,151.631288668,
	151.443268311,151.25509999,151.06678373,150.878319558,150.689707498,
	150.500947577,150.312039817,150.122984243,149.933780877,149.744429742,
	149.55493086,149.365284253,149.17548994,148.985547943,148.79545828,
	148.605220971,148.414836035,148.224303489,148.033623351,147.842795638,
	147.651820366,147.46069755,147.269427206,147.078009348,146.886443991,
	146.694731147,146.50287083,146.310863051,146.118707824,145.926405158,
	145.733955065,145.541357554,145.348612635,145.155720318,144.962680609,
	144.769493518,144.576159051,144.382677215,144.189048016,143.995271461,
	143.801347552,143.607276296,143.413057696,143.218691756,143.024178478,
	142.829517864,142.634709916,142.439754635,142.244652022,142.049402077,
	141.854004798,141.658460186,141.462768238,141.266928951,141.070942324,
	140.874808353,140.678527034,140.482098363,140.285522334,140.088798942,
	139.891928181,139.694910044,139.497744525,139.300431614,139.102971305,
	138.905363588,138.707608454,138.509705892,138.311655894,138.113458446,
	137.915113539,137.71662116,137.517981296,137.319193934,137.120259061,
	136.921176662,136.721946723,136.522569228,136.323044162,136.123371508,
	135.923551249,135.723583369,135.523467849,135.32320467,135.122793815,
	134.922235263,134.721528995,134.52067499,134.319673227,134.118523685,
	133.917226342,133.715781176,133.514188163,133.31244728,133.110558503,
	132.908521808,132.70633717,132.504004564,132.301523963,132.098895342,
	131.896118674,131.693193931,131.490121086,131.286900111,131.083530977,
	130.880013655,130.676348115,130.472534329,130.268572264,130.064461891,
	129.860203179,129.655796095,129.451240608,129.246536686,129.041684295,
	128.836683403,128.631533975,128.426235979,128.220789379,128.015194141,
	127.80945023,127.603557611,127.397516247,127.191326104,126.984987144,
	126.778499331,126.571862629,126.365076999,126.158142404,125.951058808,
	125.74382617,125.536444455,125.328913622,125.121233634,124.913404451,
	124.705426035,124.497298346,124.289021346,124.080594993,123.87201925,
	123.663294075,123.45441943,123.245395274,123.036221568,122.826898272,
	122.617425345,122.407802748,122.198030441,121.988108384,121.778036537,
	121.567814861,121.357443316,121.146921862,120.936250462,120.725429075,
	120.514457662,120.303336187,120.09206461,119.880642893,119.669071,
	119.457348893,119.245476537,119.033453894,118.821280929,118.608957608,
	118.396483896,118.18385976,117.971085166,117.758160083,117.545084479,
	117.331858324,117.118481589,116.904954244,116.691276262,116.477447617,
	116.263468283,116.049338237,115.835057456,115.620625918,115.406043603,
	115.191310494,114.976426573,114.761391825,114.546206237,114.330869797,
	114.115382497,113.899744328,113.683955284,113.468015365,113.251924567,
	113.035682894,112.819290349,112.60274694,112.386052677,112.169207573,
	111.952211643,111.735064908,111.517767389,111.300319114,111.082720112,
	110.864970417,110.647070067,110.429019104,110.210817576,109.992465532,
	109.77396303,109.55531013,109.336506899,109.117553408,108.898449735,
	108.679195963,108.459792182,108.240238489,108.020534985,107.800681781,
	107.580678994,107.360526749,107.140225178,106.919774422,106.69917463,
	106.478425962,106.257528585,106.036482676,105.815288423,105.593946025,
	105.372455689,105.150817638,104.929032102,104.707099327,104.48501957,
	104.262793102,104.040420207,103.817901185,103.595236351,103.372426033,
	103.149470578,102.926370349,102.703125726,102.479737108,102.256204914,
	102.032529581,101.808711566,101.58475135,101.360649435,101.136406344,
	100.912022628,100.687498859,100.462835637,100.23803359,100.013093371,
	99.7880156641,99.5628011832,99.3374506734,99.1119649126,98.8863447123,
	98.6605909195,98.4347044173,98.2086861271,97.9825370096,97.7562580661,
	97.5298503407,97.3033149214,97.076652942,96.8498655839,96.6229540776,
	96.3959197048,96.1687638004,95.9414877543,95.7140930135,95.4865810843,
	95.2589535346,95.0312119958,94.8033581658,94.5753938109,94.3473207683,
	94.1191409492,93.8908563411,93.6624690106,93.4339811063,93.205394862,
	92.9767125993,92.7479367311,92.5190697648,92.2901143054,92.0610730592,
	91.8319488373,91.602744559,91.373463256,91.1441080758,90.9146822859,
	90.6851892779,90.4556325714,90.2260158187,89.9963428088,89.7666174721,
	89.536843885,89.3070262745,89.0771690233,88.8472766741,88.6173539356,
	88.3874056866,88.1574369818,87.9274530572,87.697459335,87.4674614297,
	87.237465153,87.0074765201,86.7775017551,86.5475472965,86.3176198036,
	86.087726162,85.8578734896,85.6280691424,85.3983207206,85.1686360744,
	84.9390233102,84.7094907959,84.4800471675,84.2507013342,84.0214624844,
	83.7923400915,83.5633439187,83.334484025,83.1057707701,82.8772148192,
	82.6488271479,82.4206190466,82.1926021248,81.9647883147,81.7371898752,
	81.5098193947,81.282689794,81.0558143286,80.8292065906,80.6028805099,
	80.3768503551,80.1511307336,79.9257365914,79.7006832114,79.4759862124,
	79.2516615459,79.0277254929,78.80419466,78.5810859742,78.3584166771,
	78.1362043179,77.914466746,77.6932221017,77.4724888073,77.2522855555,
	77.0326312982,76.8135452334,76.5950467914,76.3771556195,76.1598915665,
	75.943274665,75.7273251137,75.5120632578,75.297509569,75.0836846242,
	74.8706090831,74.6583036656,74.4467891271,74.2360862344,74.0262157397,
	73.8171983546,73.609054723,73.4018053941,73.195470794,72.9900711983,
	72.7856267028,72.5821571954,72.3796823271,72.1782214839,71.9777937575,
	71.7784179177,71.5801123841,71.3828951991,71.1867840008,70.9917959968,
	70.7979479394,70.6052561006,70.413736249,70.2234036275,70.0342729319,
	69.8463582915,69.6596732499,69.4742307486,69.2900431108,69.1071220272,
	68.925478544,68.7451230512,68.5660652733,68.3883142621,68.2118783899,
	68.0367653452,67.8629821298,67.6905350579,67.5194297558,67.349671164,
	67.1812635406,67.0142104662,66.8485148499,66.6841789368,66.5212043171,
	66.359591936,66.1993421046,66.0404545127,65.8829282415,65.7267617781,
	65.5719530301,65.4184993417,65.2663975098,65.1156438011,64.9662339694,
	64.8181632736,64.6714264963,64.5260179616,64.3819315545,64.2391607398,
	64.0976985804,63.9575377573,63.8186705879,63.6810890449,63.5447847755,
	63.4097491195,63.2759731279,63.1434475806,63.0121630047,62.8821096914,
	62.7532777134,62.6256569412,62.4992370596,62.3740075834,62.2499578725,
	62.1270771474,62.0053545027,61.8847789218,61.7653392897,61.6470244065,
	61.5298229991,61.4137237339,61.2987152275,61.1847860581,61.0719247757,
	60.9601199122,60.8493599906,60.7396335345,60.630929076,60.5232351645,
	60.4165403737,60.3108333094,60.2061026159,60.1023369826,59.9995251502,
	59.8976559158,59.7967181389,59.6967007458,59.5975927344,59.4993831786,
	59.4020612319,59.3056161312,59.2100372005,59.1153138535,59.0214355966,
	58.9283920315,58.8361728577,58.7447678742,58.6541669817,58.5643601843,
	58.4753375907,58.3870894158,58.2996059815,58.2128777181,58.1268951645,
	58.0416489694,57.9571298914,57.8733287998,57.7902366743,57.7078446055,
	57.6261437948,57.5451255545,57.4647813073,57.3851025863,57.3060810344,
	57.2277084041,57.1499765569,57.0728774627,56.9964031993,56.9205459515,
	56.8452980105,56.7706517731,56.6965997408,56.6231345189,56.5502488157,
	56.4779354416,56.4061873078,56.3349974256,56.2643589053,56.1942649551,
	56.12470888,56.0556840808,55.9871840529,55.9192023854,55.8517327594,
	55.7847689478,55.7183048131,55.6523343072,55.5868514695,55.5218504263,
	55.4573253892,55.3932706543,55.3296806009,55.2665496903,55.2038724646,
	55.1416435458,55.0798576345,55.0185095087,54.9575940229,54.8971061066,
	54.8370407637,54.7773930709,54.718158177,54.6593313016,54.6009077341,
	54.5428828326,54.4852520229,54.4280107972,54.3711547138,54.3146793951,
	54.2585805273,54.2028538591,54.147495201,54.092500424,54.0378654587,
	53.9835862945,53.9296589787,53.8760796154,53.8228443647,53.7699494418,
	53.7173911161,53.6651657104,53.6132695999,53.5616992114,53.5104510228,
	53.4595215617,53.408907405,53.358605178,53.3086115536,53.2589232516,
	53.2095370379,53.1604497237,53.1116581648,53.0631592611,53.0149499554,
	52.9670272332,52.9193881217,52.8720296893,52.8249490449,52.7781433372,
	52.7316097539,52.6853455215,52.6393479043,52.5936142039,52.5481417587,
	52.5029279432,52.4579701673,52.4132658761,52.3688125489,52.3246076991,
	52.2806488732,52.2369336506,52.193459643,52.1502244938,52.1072258777,
	52.0644615,52.0219290964,51.9796264325,51.9375513029,51.8957015313,
	51.8540749699,51.8126694984,51.7714830245,51.7305134827,51.6897588342,
	51.6492170664,51.6088861928,51.568764252,51.5288493078,51.4891394485,
	51.4496327869,51.4103274594,51.3712216261,51.3323134703,51.2936011979,
	51.2550830374,51.2167572394,51.1786220761,51.1406758414,51.1029168502,
	51.065343438,51.0279539611,50.9907467956,50.9537203379,50.9168730035,
	50.8802032274,50.8437094637,50.8073901849,50.7712438821,50.7352690645,
	50.6994642591,50.6638280107,50.6283588811,50.5930554497,50.5579163121,
	50.522940081,50.4881253853,50.4534708698,50.4189751955,50.3846370388,
	50.3504550916,50.3164280609,50.2825546688,50.2488336522,50.2152637622,
	50.1818437647,50.1485724393,50.1154485799,50.0824709937,50.0496385019,
	50.0169499386,49.9844041515,49.9520000008,49.9197363597,49.8876121142,
	49.8556261623,49.8237774146,49.7920647936,49.7604872338,49.7290436813,
	49.6977330941,49.6665544412,49.6355067033,49.6045888718,49.5737999493,
	49.5431389491,49.5126048954,49.4821968226,49.4519137756,49.4217548096,
	49.3917189898,49.3618053914,49.3320130994,49.3023412085,49.2727888229,
	49.2433550565,49.2140390322,49.1848398821,49.1557567476,49.1267887789,
	49.0979351349,49.0691949835,49.040567501,49.0120518721,48.9836472901,
	48.9553529564,48.9271680807,48.8990918806,48.8711235817,48.8432624174,
	48.815507629,48.7878584653,48.7603141827,48.732874045,48.7055373233,
	48.6783032962,48.6511712493,48.6241404752,48.5972102736,48.5703799512,
	48.5436488213,48.517016204,48.4904814261,48.464043821,48.4377027285,
	48.4114574948,48.3853074723,48.35925202,48.3332905028,48.3074222917,
	48.2816467637,48.2559633019,48.2303712951,48.204870138,48.179459231,
	48.1541379801,48.1289057971,48.103762099,48.0787063085,48.0537378537,
	48.0288561678,48.0040606896,47.9793508627,47.9547261362,47.9301859641,
	47.9057298055,47.8813571243,47.8570673896,47.832860075,47.8087346591,
	47.7846906251,47.7607274611,47.7368446597,47.7130417179,47.6893181375,
	47.6656734245,47.6421070895,47.6186186475,47.5952076176,47.5718735233,
	47.5486158923,47.5254342566,47.5023281519,47.4792971185,47.4563407004,
	47.4334584457,47.4106499063,47.3879146382,47.3652522011,47.3426621586,
	47.3201440779,47.2976975301,47.27532209,47.2530173358,47.2307828496,
	47.2086182168,47.1865230265,47.1644968713,47.142539347,47.1206500531,
	47.0988285923,47.0770745708,47.0553875978,47.033767286,47.0122132513,
	46.9907251128,46.9693024927,46.9479450163,46.926652312,46.9054240114,
	46.884259749,46.8631591622,46.8421218916,46.8211475806,46.8002358755,
	46.7793864255,46.7585988825,46.7378729014,46.7172081399,46.6966042582,
	46.6760609195,46.6555777895,46.6351545368,46.6147908322,46.5944863497,
	46.5742407654,46.5540537582,46.5339250095,46.5138542031,46.4938410254,
	46.4738851652,46.4539863139,46.434144165,46.4143584145,46.394628761,
	46.374954905,46.3553365498,46.3357734005,46.3162651648,46.2968115526,
	46.2774122759,46.258067049,46.2387755882,46.2195376123,46.200352842,
	46.181221,46.1621418113,46.143115003,46.124140304,46.1052174456,
	46.0863461607,46.0675261845,46.0487572541,46.0300391084,46.0113714885,
	45.9927541372,45.9741867993,45.9556692215,45.9372011522,45.9187823419,
	45.9004125427,45.8820915086,45.8638189954,45.8455947607,45.8274185639,
	45.8092901659,45.7912093296,45.7731758195,45.7551894018,45.7372498443,
	45.7193569166,45.7015103899,45.683710037,45.6659556324,45.648246952,
	45.6305837735,45.6129658761,45.5953930405,45.5778650491,45.5603816856,
	45.5429427354,45.5255479853,45.5081972237,45.4908902404,45.4736268266,
	45.4564067751,45.4392298799,45.4220959367,45.4050047424,45.3879560955,
	45.3709497956,45.3539856439,45.3370634429,45.3201829964,45.3033441096,
	45.286546589,45.2697902423,45.2530748788,45.2364003088,45.2197663439,
	45.2031727971,45.1866194827,45.170106216,45.1536328136,45.1371990936,
	45.120804875,45.1044499781,45.0881342244,45.0718574366,45.0556194386,
	45.0394200553,45.0232591129,45.0071364388,44.9910518613,44.97500521,
	44.9589963155,44.9430250097,44.9270911254,44.9111944966,44.8953349582,
	44.8795123463,44.8637264982,44.8479772519,44.8322644468,44.816587923,
	44.8009475218,44.7853430856,44.7697744577,44.7542414822,44.7387440046,
	44.7232818711,44.7078549288,44.6924630261,44.677106012,44.6617837367,
	44.6464960512,44.6312428075,44.6160238584,44.6008390578,44.5856882605,
	44.570571322,44.5554880988,44.5404384485,44.5254222292,44.5104393001,
	44.4954895213,44.4805727536,44.4656888589,44.4508376997,44.4360191394,
	44.4212330422,44.4064792734,44.3917576987,44.3770681849,44.3624105996,
	44.347784811,44.3331906883,44.3186281014,44.3040969209,44.2895970184,
	44.2751282661,44.2606905369,44.2462837046,44.2319076438,44.2175622296,
	44.2032473381,44.188962846,44.1747086307,44.1604845704,44.1462905441,
	44.1321264312,44.1179921121,44.1038874679,44.0898123802,44.0757667314,
	44.0617504046,44.0477632835,44.0338052526,44.0198761971,44.0059760025,
	43.9921045555,43.978261743,43.9644474528,43.9506615732,43.9369039933,
	43.9231746028,43.9094732918,43.8957999513,43.8821544728,43.8685367485,
	43.854946671,43.8413841338,43.8278490309,43.8143412567,43.8008607064,
	43.7874072758,43.7739808611,43.7605813594,43.747208668,43.733862685,
	43.720543309,43.7072504393,43.6939839756,43.6807438181,43.6675298677,
	43.6543420258,43.6411801944,43.628044276,43.6149341734,43.6018497904,
	43.5887910309,43.5757577997,43.5627500017,43.5497675426,43.5368103287,
	43.5238782665,43.5109712632,43.4980892264,43.4852320645,43.4723996859,
	43.459592,43.4468089162,43.4340503448,43.4213161963,43.4086063818,
	43.395920813,43.3832594017,43.3706220606,43.3580087026,43.3454192411,
	43.33285359,43.3203116637,43.3077933769,43.2952986449,43.2828273833,
	43.2703795084,43.2579549366,43.2455535849,43.2331753709,43.2208202124,
	43.2084880276,43.1961787354,43.1838922548,43.1716285054,43.1593874071,
	43.1471688805,43.1349728462,43.1227992256,43.1106479402,43.0985189119,
	43.0864120634,43.0743273173,43.0622645969,43.0502238257,43.0382049278,
	43.0262078276,43.0142324497,43.0022787194,42.9903465622,42.9784359039,
	42.9665466709,42.9546787897,42.9428321874,42.9310067914,42.9192025293,
	42.9074193294,42.89565712,42.88391583,42.8721953886,42.8604957252,
	42.8488167698,42.8371584525,42.825520704,42.8139034551,42.8023066371,
	42.7907301817,42.7791740206,42.7676380862,42.7561223111,42.7446266282,
	42.7331509707,42.7216952722,42.7102594667,42.6988434883,42.6874472716,
	42.6760707514,42.664713863,42.6533765417,42.6420587235,42.6307603444,
	42.6194813408,42.6082216494,42.5969812074,42.5857599519,42.5745578207,
	42.5633747516,42.5522106829,42.5410655531,42.529939301,42.5188318657,
	42.5077431866,42.4966732034,42.485621856,42.4745890847,42.4635748299,
	42.4525790326,42.4416016337,42.4306425747,42.4197017972,42.4087792431,
	42.3978748545,42.3869885739,42.3761203441,42.365270108,42.3544378088,
	42.3436233901,42.3328267957,42.3220479695,42.3112868559,42.3005433995,
	42.2898175449,42.2791092374,42.2684184221,42.2577450447,42.2470890509,
	42.2364503869,42.2258289989,42.2152248334,42.2046378373,42.1940679577,
	42.1835151416,42.1729793368,42.1624604909,42.1519585519,42.1414734681,
	42.1310051879,42.1205536599,42.1101188331,42.0997006567,42.08929908,
	42.0789140527,42.0685455244,42.0581934454,42.0478577658,42.0375384362,
	42.0272354073,42.0169486299,42.0066780553,41.9964236349,41.9861853201,
	41.9759630629,41.9657568151,41.955566529,41.9453921571,41.935233652,
	41.9250909665,41.9149640537,41.9048528668,41.8947573593,41.8846774848,
	41.8746131972,41.8645644507,41.8545311993,41.8445133977,41.8345110004,
	41.8245239623,41.8145522385,41.8045957842,41.7946545548,41.784728506,
	41.7748175936,41.7649217736,41.7550410021,41.7451752356,41.7353244307,
	41.725488544,41.7156675325,41.7058613534,41.696069964,41.6862933217,
	41.6765313841,41.6667841092,41.657051455,41.6473333796,41.6376298415,
	41.6279407991,41.6182662112,41.6086060367,41.5989602347,41.5893287644,
	41.5797115852,41.5701086567,41.5605199386,41.5509453909,41.5413849736,
	41.531838647,41.5223063714,41.5127881076,41.5032838162,41.493793458,
	41.4843169943,41.4748543861,41.4654055949,41.4559705822,41.4465493097,
	41.4371417393,41.427747833,41.4183675529,41.4090008614,41.3996477209,
	41.3903080941,41.3809819438,41.3716692328,41.3623699242,41.3530839814,
	41.3438113676,41.3345520464,41.3253059814,41.3160731366,41.3068534757,
	41.2976469631,41.2884535628,41.2792732394,41.2701059573,41.2609516812,
	41.251810376,41.2426820066,41.2335665381,41.2244639357,41.2153741649,
	41.2062971912,41.1972329801,41.1881814975,41.1791427094,41.1701165817,
	41.1611030807,41.1521021727,41.1431138241,41.1341380016,41.1251746718,
	41.1162238016,41.1072853581,41.0983593082,41.0894456193,41.0805442586,
	41.0716551938,41.0627783924,41.0539138221,41.0450614508,41.0362212466,
	41.0273931776,41.0185772119,41.0097733179,41.0009814642,40.9922016194,
	40.9834337521,40.9746778312,40.9659338257,40.9572017046,40.9484814373,
	40.9397729929,40.931076341,40.9223914511,40.9137182928,40.905056836,
	40.8964070505,40.8877689064,40.8791423738,40.8705274229,40.8619240242,
	40.853332148,40.8447517649,40.8361828457,40.8276253611,40.8190792821,
	40.8105445796,40.8020212248,40.7935091889,40.7850084433,40.7765189594,
	40.7680407088,40.7595736631,40.7511177941,40.7426730737,40.7342394738,
	40.7258169666,40.7174055242,40.7090051189,40.7006157231,40.6922373093,
	40.68386985,40.6755133181,40.6671676862,40.6588329272,40.6505090143,
	40.6421959203,40.6338936187,40.6256020825,40.6173212853,40.6090512004,
	40.6007918016,40.5925430624,40.5843049567,40.5760774582,40.567860541,
	40.5596541792,40.5514583468,40.5432730181,40.5350981675,40.5269337693,
	40.5187797982,40.5106362286,40.5025030354,40.4943801934,40.4862676773,
	40.4781654622,40.4700735231,40.4619918353,40.4539203738,40.4458591142,
	40.4378080318,40.429767102,40.4217363005,40.4137156031,40.4057049853,
	40.3977044232,40.3897138925,40.3817333695,40.37376283,40.3658022505,
	40.357851607,40.3499108761,40.3419800341,40.3340590575,40.3261479229,
	40.3182466072,40.3103550869,40.302473339,40.2946013404,40.2867390681,
	40.2788864992,40.2710436109,40.2632103804,40.2553867851,40.2475728023,
	40.2397684096,40.2319735845,40.2241883047,40.2164125479,40.2086462918,
	40.2008895143,40.1931421935,40.1854043073,40.1776758338,40.1699567512,
	40.1622470377,40.1545466718,40.1468556316,40.1391738959,40.131501443,
	40.1238382516,40.1161843004,40.1085395682,40.1009040337,40.093277676,
	40.0856604739,40.0780524066,40.0704534531,40.0628635927,40.0552828046,
	40.0477110681,40.0401483626,40.0325946677,40.0250499628,40.0175142275,
	40.0099874416,40.0024695847,39.9949606367,39.9874605775,39.979969387,
	39.9724870452,39.9650135322,39.9575488282,39.9500929133,39.9426457678,
	39.9352073722,39.9277777067,39.9203567518,39.9129444882,39.9055408964,
	39.898145957,39.8907596508,39.8833819586,39.8760128612,39.8686523396,
	39.8613003748,39.8539569477,39.8466220395,39.8392956313,39.8319777044,
	39.8246682402,39.8173672198,39.8100746247,39.8027904365,39.7955146366,
	39.7882472066,39.7809881283,39.7737373832,39.7664949532,39.75926082,
	39.7520349657,39.7448173721,39.7376080212,39.7304068951,39.7232139759,
	39.7160292458,39.708852687,39.7016842819,39.6945240127,39.6873718619,
	39.6802278119,39.6730918453,39.6659639446,39.6588440925,39.6517322716,
	39.6446284646,39.6375326544,39.6304448239,39.6233649558,39.6162930333,
	39.6092290392,39.6021729567,39.5951247688,39.5880844588,39.5810520098,
	39.5740274052,39.5670106282,39.5600016623,39.5530004909,39.5460070974,
	39.5390214655,39.5320435786,39.5250734205,39.5181109748,39.5111562253,
	39.5042091557,39.4972697499,39.4903379919,39.4834138654,39.4764973546,
	39.4695884435,39.4626871162,39.4557933567,39.4489071494,39.4420284784,
	39.435157328,39.4282936826,39.4214375266,39.4145888443,39.4077476203,
	39.4009138391,39.3940874853,39.3872685434,39.3804569982,39.3736528344,
	39.3668560367,39.36006659,39.353284479,39.3465096888,39.3397422042,
	39.3329820103,39.3262290921,39.3194834346,39.3127450231,39.3060138426,
	39.2992898784,39.2925731158,39.2858635401,39.2791611366,39.2724658907,
	39.2657777879,39.2590968136,39.2524229534,39.2457561929,39.2390965176,
	39.2324439132,39.2257983655,39.2191598602,39.212528383,39.2059039198,
	39.1992864564,39.1926759788,39.186072473,39.1794759249,39.1728863205,
	39.166303646,39.1597278875,39.153159031,39.1465970629,39.1400419694,
	39.1334937368,39.1269523513,39.1204177994,39.1138900674,39.1073691419,
	39.1008550092,39.094347656,39.0878470687,39.081353234,39.0748661385,
	39.068385769,39.0619121121,39.0554451545,39.0489848832,39.0425312849,
	39.0360843464,39.0296440548,39.023210397,39.0167833599,39.0103629306,
	39.0039490962,38.9975418437,38.9911411603,38.9847470331,38.9783594495,
	38.9719783965,38.9656038616,38.959235832,38.9528742952,38.9465192384,
	38.9401706492,38.933828515,38.9274928232,38.9211635616,38.9148407175,
	38.9085242787,38.9022142328,38.8959105674,38.8896132703,38.8833223293,
	38.877037732,38.8707594665,38.8644875204,38.8582218817,38.8519625383,
	38.8457094782,38.8394626894,38.8332221598,38.8269878777,38.8207598309,
	38.8145380078,38.8083223964,38.802112985,38.7959097617,38.7897127148,
	38.7835218327,38.7773371036,38.7711585159,38.7649860581,38.7588197184,
	38.7526594855,38.7465053477,38.7403572936,38.7342153118,38.7280793908,
	38.7219495192,38.7158256858,38.7097078791,38.7035960879,38.697490301,
	38.691390507,38.6852966949,38.6792088534,38.6731269715,38.667051038,
	38.6609810418
	};


tubetable_12AT7_rtable_0(r) = (tubetable_12AT7_0,r):rdtable;
tubetable_12AT7_rtable_1(r) = (tubetable_12AT7_1,r):rdtable;


// generated by ../../tools/tube_transfer.py
// tube: 12AU7
// plate current function: pentode
// mu: 21.5
// kx: 1.3
// kg1: 1180
// kp: 84
// kvb: 300


tubetable_12AU7_0 = waveform{ 127.202255052,127.144735521,127.087208545,127.029674135,126.972132303,
	126.914583061,126.857026422,126.799462397,126.741890998,126.684312237,
	126.626726127,126.569132679,126.511531906,126.45392382,126.396308434,
	126.338685759,126.281055807,126.223418592,126.165774125,126.108122418,
	126.050463485,125.992797338,125.935123988,125.877443449,125.819755734,
	125.762060854,125.704358822,125.646649651,125.588933353,125.531209942,
	125.473479429,125.415741829,125.357997152,125.300245413,125.242486624,
	125.184720797,125.126947947,125.069168085,125.011381225,124.953587379,
	124.895786561,124.837978784,124.780164061,124.722342404,124.664513828,
	124.606678345,124.548835968,124.490986711,124.433130587,124.375267609,
	124.317397791,124.259521146,124.201637688,124.143747429,124.085850383,
	124.027946564,123.970035986,123.912118661,123.854194604,123.796263828,
	123.738326347,123.680382175,123.622431324,123.56447381,123.506509646,
	123.448538845,123.390561421,123.332577389,123.274586763,123.216589556,
	123.158585782,123.100575455,123.04255859,122.984535201,122.926505301,
	122.868468905,122.810426027,122.752376682,122.694320883,122.636258645,
	122.578189982,122.520114909,122.46203344,122.40394559,122.345851372,
	122.287750803,122.229643895,122.171530664,122.113411125,122.055285291,
	121.997153178,121.939014801,121.880870174,121.822719312,121.76456223,
	121.706398942,121.648229465,121.590053812,121.531871999,121.47368404,
	121.415489952,121.357289748,121.299083444,121.240871056,121.182652598,
	121.124428085,121.066197534,121.007960959,120.949718376,120.891469799,
	120.833215245,120.77495473,120.716688268,120.658415874,120.600137566,
	120.541853358,120.483563266,120.425267305,120.366965492,120.308657843,
	120.250344372,120.192025096,120.133700031,120.075369193,120.017032598,
	119.958690261,119.900342199,119.841988428,119.783628965,119.725263824,
	119.666893023,119.608516578,119.550134505,119.49174682,119.433353539,
	119.37495468,119.316550259,119.258140292,119.199724795,119.141303785,
	119.08287728,119.024445295,118.966007847,118.907564953,118.84911663,
	118.790662894,118.732203763,118.673739253,118.615269382,118.556794165,
	118.498313621,118.439827767,118.381336619,118.322840194,118.26433851,
	118.205831585,118.147319435,118.088802077,118.03027953,117.97175181,
	117.913218935,117.854680922,117.796137789,117.737589554,117.679036234,
	117.620477847,117.56191441,117.503345942,117.444772459,117.386193981,
	117.327610524,117.269022108,117.210428748,117.151830465,117.093227275,
	117.034619197,116.97600625,116.91738845,116.858765817,116.800138368,
	116.741506123,116.682869099,116.624227315,116.565580789,116.50692954,
	116.448273586,116.389612947,116.330947639,116.272277683,116.213603098,
	116.1549239,116.096240111,116.037551747,115.97885883,115.920161376,
	115.861459406,115.802752938,115.744041992,115.685326586,115.62660674,
	115.567882473,115.509153805,115.450420754,115.39168334,115.332941582,
	115.274195501,115.215445115,115.156690443,115.097931507,115.039168325,
	114.980400916,114.921629302,114.862853501,114.804073533,114.745289419,
	114.686501178,114.62770883,114.568912395,114.510111894,114.451307346,
	114.392498772,114.333686192,114.274869626,114.216049094,114.157224618,
	114.098396216,114.039563911,113.980727722,113.92188767,113.863043775,
	113.804196059,113.745344542,113.686489244,113.627630187,113.568767392,
	113.509900879,113.451030669,113.392156784,113.333279244,113.274398071,
	113.215513286,113.156624909,113.097732963,113.038837469,112.979938447,
	112.92103592,112.862129909,112.803220436,112.744307521,112.685391187,
	112.626471456,112.567548349,112.508621887,112.449692094,112.39075899,
	112.331822598,112.272882939,112.213940036,112.154993911,112.096044586,
	112.037092083,111.978136425,111.919177633,111.860215731,111.801250739,
	111.742282682,111.683311582,111.624337461,111.565360341,111.506380246,
	111.447397198,111.38841122,111.329422335,111.270430566,111.211435936,
	111.152438467,111.093438183,111.034435107,110.975429263,110.916420672,
	110.857409359,110.798395347,110.73937866,110.68035932,110.621337352,
	110.562312778,110.503285623,110.44425591,110.385223663,110.326188906,
	110.267151662,110.208111956,110.149069811,110.090025251,110.030978301,
	109.971928984,109.912877325,109.853823348,109.794767077,109.735708537,
	109.676647751,109.617584745,109.558519543,109.49945217,109.440382649,
	109.381311006,109.322237266,109.263161453,109.204083592,109.145003709,
	109.085921827,109.026837972,108.96775217,108.908664445,108.849574822,
	108.790483327,108.731389985,108.672294822,108.613197862,108.554099132,
	108.494998657,108.435896462,108.376792573,108.317687016,108.258579817,
	108.199471001,108.140360595,108.081248624,108.022135114,107.963020092,
	107.903903583,107.844785615,107.785666212,107.726545401,107.667423209,
	107.608299663,107.549174788,107.490048611,107.430921159,107.371792458,
	107.312662535,107.253531418,107.194399132,107.135265705,107.076131164,
	107.016995535,106.957858847,106.898721125,106.839582398,106.780442692,
	106.721302034,106.662160454,106.603017976,106.54387463,106.484730443,
	106.425585442,106.366439655,106.30729311,106.248145835,106.188997857,
	106.129849205,106.070699906,106.011549989,105.952399482,105.893248413,
	105.83409681,105.774944701,105.715792116,105.656639082,105.597485627,
	105.538331781,105.479177572,105.420023029,105.360868181,105.301713056,
	105.242557683,105.183402091,105.124246309,105.065090367,105.005934293,
	104.946778117,104.887621867,104.828465574,104.769309266,104.710152973,
	104.650996725,104.591840551,104.532684481,104.473528544,104.41437277,
	104.35521719,104.296061832,104.236906727,104.177751906,104.118597397,
	104.059443232,104.00028944,103.941136051,103.881983097,103.822830607,
	103.763678612,103.704527143,103.64537623,103.586225903,103.527076194,
	103.467927133,103.408778751,103.34963108,103.290484149,103.231337991,
	103.172192635,103.113048115,103.05390446,102.994761702,102.935619872,
	102.876479002,102.817339124,102.758200268,102.699062467,102.639925752,
	102.580790156,102.521655709,102.462522444,102.403390393,102.344259588,
	102.285130061,102.226001843,102.166874968,102.107749468,102.048625375,
	101.989502721,101.930381539,101.871261862,101.812143721,101.753027151,
	101.693912183,101.634798851,101.575687186,101.516577224,101.457468995,
	101.398362534,101.339257873,101.280155047,101.221054087,101.161955028,
	101.102857902,101.043762744,100.984669587,100.925578465,100.86648941,
	100.807402458,100.748317642,100.689234995,100.630154552,100.571076347,
	100.512000413,100.452926786,100.393855498,100.334786586,100.275720082,
	100.216656021,100.157594438,100.098535367,100.039478843,99.9804249014,
	99.9213735758,99.8623249014,99.8032789131,99.7442356459,99.6851951348,
	99.626157415,99.5671225215,99.5080904897,99.4490613547,99.390035152,
	99.3310119171,99.2719916853,99.2129744923,99.1539603737,99.0949493652,
	99.0359415025,98.9769368215,98.9179353582,98.8589371484,98.7999422282,
	98.7409506337,98.681962401,98.6229775665,98.5639961663,98.5050182369,
	98.4460438148,98.3870729363,98.3281056381,98.2691419569,98.2101819292,
	98.151225592,98.092272982,98.0333241361,97.9743790913,97.9154378847,
	97.8565005533,97.7975671344,97.7386376651,97.6797121827,97.6207907248,
	97.5618733286,97.5029600316,97.4440508716,97.3851458861,97.3262451127,
	97.2673485894,97.2084563538,97.149568444,97.0906848979,97.0318057536,
	96.972931049,96.9140608226,96.8551951123,96.7963339567,96.737477394,
	96.6786254626,96.6197782012,96.5609356482,96.5020978424,96.4432648223,
	96.3844366268,96.3256132947,96.2667948649,96.2079813764,96.1491728683,
	96.0903693795,96.0315709494,95.9727776171,95.9139894219,95.8552064032,
	95.7964286005,95.7376560531,95.6788888008,95.6201268831,95.5613703397,
	95.5026192104,95.443873535,95.3851333534,95.3263987056,95.2676696315,
	95.2089461714,95.1502283653,95.0915162534,95.0328098761,94.9741092737,
	94.9154144866,94.8567255554,94.7980425205,94.7393654225,94.6806943022,
	94.6220292003,94.5633701577,94.5047172151,94.4460704135,94.387429794,
	94.3287953976,94.2701672655,94.2115454388,94.1529299589,94.094320867,
	94.0357182045,93.977122013,93.918532334,93.859949209,93.8013726797,
	93.7428027879,93.6842395753,93.6256830838,93.5671333553,93.5085904318,
	93.4500543553,93.391525168,93.3330029121,93.2744876298,93.2159793634,
	93.1574781553,93.098984048,93.0404970839,92.9820173057,92.923544756,
	92.8650794774,92.8066215128,92.7481709051,92.689727697,92.6312919317,
	92.572863652,92.5144429013,92.4560297225,92.397624159,92.3392262541,
	92.2808360511,92.2224535935,92.1640789248,92.1057120886,92.0473531285,
	91.9890020883,91.9306590116,91.8723239425,91.8139969247,91.7556780023,
	91.6973672194,91.63906462,91.5807702484,91.5224841489,91.4642063657,
	91.4059369434,91.3476759263,91.289423359,91.2311792862,91.1729437526,
	91.1147168029,91.0564984821,90.9982888349,90.9400879065,90.8818957418,
	90.8237123861,90.7655378846,90.7073722826,90.6492156254,90.5910679586,
	90.5329293276,90.4747997782,90.4166793559,90.3585681067,90.3004660764,
	90.2423733109,90.1842898562,90.1262157586,90.0681510643,90.0100958195,
	89.9520500706,89.8940138642,89.8359872468,89.7779702652,89.719962966,
	89.6619653962,89.6039776027,89.5459996326,89.4880315331,89.4300733515,
	89.3721251352,89.3141869316,89.2562587884,89.1983407533,89.1404328741,
	89.0825351988,89.0246477754,88.9667706523,88.9089038776,88.8510474998,
	88.7932015676,88.7353661296,88.6775412346,88.6197269318,88.5619232702,
	88.5041302991,88.446348068,88.3885766264,88.3308160242,88.2730663111,
	88.2153275374,88.1575997532,88.099883009,88.0421773555,87.9844828434,
	87.9267995237,87.8691274477,87.8114666667,87.7538172323,87.6961791964,
	87.6385526111,87.5809375286,87.5233340014,87.4657420824,87.4081618245,
	87.350593281,87.2930365055,87.2354915517,87.1779584739,87.1204373264,
	87.062928164,87.0054310416,86.9479460146,86.8904731388,86.8330124701,
	86.775564065,86.7181279803,86.6607042731,86.6032930011,86.545894222,
	86.4885079945,86.4311343773,86.3737734298,86.3164252117,86.2590897832,
	86.2017672053,86.1444575392,86.0871608467,86.0298771904,85.9726066331,
	85.9153492385,85.858105071,85.8008741953,85.743656677,85.6864525825,
	85.6292619788,85.5720849335,85.5149215154,85.4577717937,85.4006358386,
	85.3435137212,85.2864055135,85.2293112884,85.1722311199,85.1151650827,
	85.058113253,85.0010757077,84.9440525249,84.8870437842,84.830049566,
	84.7730699521,84.7161050257,84.6591548713,84.6022195749,84.5452992237,
	84.4883939067,84.4315037144,84.3746287389,84.317769074,84.2609248154,
	84.2040960603,84.1472829082,84.0904854603,84.03370382,83.9769380928,
	83.9201883863,83.8634548107,83.8067374781,83.7500365035,83.6933520043,
	83.6366841005,83.580032915,83.5233985736,83.4667812049,83.4101809407,
	83.3535979161,83.2970322693,83.2404841423,83.1839536804,83.1274410328,
	83.0709463526,83.0144697967,82.9580115264,82.9015717072,82.8451505094,
	82.7887481075,82.7323646812,82.676000415,82.619655499,82.5633301282,
	82.5070245037,82.4507388321,82.3944733263,82.3382282053,82.2820036947,
	82.2258000269,82.1696174413,82.1134561847,82.0573165111,82.0011986828,
	81.9451029699,81.8890296512,81.8329790139,81.7769513547,81.7209469793,
	81.6649662036,81.6090093531,81.5530767642,81.4971687841,81.4412857711,
	81.3854280954,81.3295961391,81.2737902971,81.2180109771,81.1622586004,
	81.1065336021,81.0508364319,80.9951675546,80.9395274501,80.8839166148,
	80.8283355615,80.7727848202,80.7172649388,80.6617764836,80.60632004,
	80.550896213,80.4955056283,80.4401489323,80.3848267936,80.3295399031,
	80.2742889753,80.2190747483,80.1638979857,80.1087594762,80.0536600356,
	79.9986005067,79.9435817607,79.8886046981,79.8336702492,79.7787793757,
	79.7239330709,79.6691323614,79.6143783076,79.5596720049,79.5050145846,
	79.4504072153,79.3958511034,79.3413474946,79.2868976751,79.232502972,
	79.1781647554,79.1238844387,79.0696634799,79.0155033833,78.9614056998,
	78.9073720286,78.8534040181,78.7995033671,78.745671826,78.6919111977,
	78.6382233388,78.5846101608,78.5310736309,78.4776157733,78.4242386699,
	78.3709444615,78.3177353487,78.2646135927,78.2115815159,78.1586415033,
	78.1057960025,78.0530475247,78.0003986452,77.947852004,77.8954103058,
	77.8430763209,77.7908528846,77.738742898,77.6867493276,77.6348752053,
	77.5831236277,77.5314977563,77.4800008163,77.4286360961,77.3774069467,
	77.3263167799,77.2753690679,77.2245673409,77.1739151864,77.1234162467,
	77.0730742172,77.0228928441,76.9728759219,76.9230272907,76.8733508334,
	76.8238504726,76.7745301674,76.7253939097,76.6764457203,76.6276896455,
	76.5791297525,76.530770125,76.4826148588,76.4346680573,76.3869338259,
	76.3394162677,76.2921194775,76.245047537,76.1982045089,76.1515944315,
	76.1052213127,76.0590891244,76.0132017967,75.9675632117,75.9221771979,
	75.8770475238,75.8321778926,75.787571936,75.7432332085,75.6991651814,
	75.6553712381,75.6118546675,75.5686186599,75.5256663009,75.4830005672,
	75.4406243218,75.3985403095,75.3567511527,75.3152593478,75.2740672612,
	75.2331771266,75.1925910414,75.1523109648,75.1123387149,75.0726759671,
	75.0333242522,74.9942849556,74.9555593161,74.9171484253,74.8790532275,
	74.84127452,74.8038129532,74.7666690316,74.729843115,74.6933354196,
	74.6571460201,74.6212748514,74.5857217107,74.5504862605,74.5155680309,
	74.4809664224,74.4466807098,74.4127100446,74.3790534589,74.3457098694,
	74.3126780802,74.2799567878,74.2475445842,74.2154399613,74.183641315,
	74.1521469494,74.1209550808,74.0900638421,74.0594712869,74.0291753936,
	73.9991740699,73.9694651566,73.940046432,73.9109156157,73.8820703727,
	73.8535083174,73.8252270172,73.7972239966,73.7694967405,73.7420426981,
	73.7148592861,73.6879438923,73.6612938788,73.6349065851,73.608779331,
	73.5829094199,73.5572941414,73.5319307741,73.5068165879,73.481948847,
	73.4573248118,73.4329417415,73.408796896,73.3848875381,73.3612109353,
	73.337764362,73.3145451007,73.2915504439,73.2687776959,73.2462241737,
	73.2238872088,73.2017641484,73.1798523562,73.1581492141,73.1366521227,
	73.1153585028,73.0942657956,73.073371464,73.0526729932,73.0321678913,
	73.01185369,72.9917279452,72.9717882373,72.9520321718,72.9324573797,
	72.9130615179,72.8938422692,72.8747973428,72.8559244746,72.8372214272,
	72.8186859901,72.8003159797,72.7821092396,72.7640636405,72.7461770802,
	72.7284474836,72.7108728027,72.6934510167,72.6761801314,72.6590581798,
	72.6420832213,72.6252533423,72.6085666551,72.5920212986,72.5756154379,
	72.5593472636,72.5432149922,72.5272168657,72.5113511511,72.4956161407,
	72.4800101513,72.4645315244,72.4491786254,72.433949844,72.4188435934,
	72.4038583105,72.388992455,72.3742445097,72.3596129798,72.3450963931,
	72.3306932992,72.3164022693,72.3022218964,72.2881507943,72.2741875978,
	72.2603309624,72.2465795636,72.232932097,72.2193872781,72.2059438415,
	72.192600541,72.1793561494,72.1662094579,72.1531592761,72.1402044315,
	72.1273437694,72.1145761524,72.1019004605,72.0893155905,72.0768204558,
	72.0644139862,72.0520951278,72.0398628423,72.0277161072,72.0156539153,
	72.0036752745,71.9917792075,71.9799647519,71.9682309594,71.956576896,
	71.9450016415,71.9335042896,71.9220839473,71.9107397349,71.8994707857,
	71.888276246,71.8771552744,71.8661070421,71.8551307324,71.8442255407,
	71.8333906741,71.8226253513,71.8119288024,71.8013002686,71.7907390024,
	71.7802442669,71.7698153359,71.7594514938,71.7491520351,71.7389162647,
	71.7287434971,71.718633057,71.7085842785,71.6985965052,71.6886690901,
	71.6788013952,71.6689927918,71.6592426597,71.6495503876,71.6399153729,
	71.6303370213,71.6208147466,71.6113479711,71.6019361248,71.592578646,
	71.5832749802,71.574024581,71.5648269093,71.5556814334,71.5465876288,
	71.5375449783,71.5285529715,71.5196111052,71.5107188828,71.5018758143,
	71.4930814165,71.4843352126,71.4756367321,71.4669855107,71.4583810906,
	71.4498230196,71.4413108518,71.432844147,71.424422471,71.416045395,
	71.407712496,71.3994233563,71.3911775639,71.3829747119,71.3748143987,
	71.366696228,71.3586198085,71.3505847537,71.3425906823,71.3346372179,
	71.3267239885,71.3188506271,71.3110167714,71.3032220633,71.2954661496,
	71.2877486811,71.2800693133,71.2724277058,71.2648235225,71.2572564313,
	71.2497261043,71.2422322176,71.2347744514,71.2273524895,71.2199660198,
	71.212614734,71.2052983272,71.1980164986,71.1907689508,71.18355539,
	71.1763755258,71.1692290714,71.1621157434,71.1550352617,71.1479873495,
	71.1409717334,71.133988143,71.1270363112,71.1201159739,71.1132268703,
	71.1063687424,71.0995413353,71.0927443969,71.0859776782,71.0792409329,
	71.0725339177,71.0658563918,71.0592081174,71.0525888592,71.0459983846,
	71.0394364638,71.0329028693,71.0263973764,71.0199197628,71.0134698085,
	71.0070472963,71.0006520112,70.9942837405,70.9879422739,70.9816274037,
	70.9753389239,70.9690766313,70.9628403246,70.9566298047,70.9504448748,
	70.94428534,70.9381510078,70.9320416875,70.9259571906,70.9198973305,
	70.9138619226,70.9078507843,70.901863735,70.8959005958,70.8899611899,
	70.8840453422,70.8781528795,70.8722836304,70.8664374253,70.8606140963,
	70.8548134773,70.8490354038,70.8432797131,70.8375462442,70.8318348376,
	70.8261453356,70.8204775819,70.814831422,70.8092067028,70.8036032728,
	70.7980209821,70.7924596821,70.7869192259,70.7813994679,70.7759002642,
	70.7704214719,70.7649629499,70.7595245583,70.7541061588,70.748707614,
	70.7433287883,70.7379695473,70.7326297578,70.7273092879,70.722008007,
	70.7167257859,70.7114624965,70.7062180119,70.7009922065,70.6957849559,
	70.6905961368,70.6854256272,70.6802733061,70.6751390538,70.6700227516,
	70.664924282,70.6598435285,70.6547803759,70.6497347097,70.6447064169,
	70.6396953852,70.6347015035,70.6297246618,70.6247647509,70.6198216628,
	70.6148952904,70.6099855275,70.6050922689,70.6002154106,70.5953548492,
	70.5905104824,70.5856822089,70.580869928,70.5760735403,70.5712929469,
	70.5665280502,70.5617787532,70.5570449596,70.5523265745,70.5476235032,
	70.5429356523,70.5382629289,70.5336052413,70.5289624981,70.5243346092,
	70.5197214849,70.5151230364,70.5105391758,70.5059698158,70.5014148699,
	70.4968742524,70.4923478781,70.4878356629,70.4833375231,70.4788533759,
	70.4743831391,70.4699267312,70.4654840714,70.4610550798,70.4566396767,
	70.4522377835,70.447849322,70.4434742148,70.439112385,70.4347637566,
	70.4304282539,70.426105802,70.4217963266,70.4174997541,70.4132160112,
	70.4089450256,70.4046867254,70.4004410391,70.3962078961,70.3919872262,
	70.3877789598,70.3835830278,70.3793993618,70.3752278939,70.3710685566,
	70.3669212831,70.3627860071,70.3586626627,70.3545511847,70.3504515084,
	70.3463635694,70.3422873042,70.3382226493,70.3341695421,70.3301279203,
	70.3260977221,70.3220788863,70.3180713521,70.314075059,70.3100899473,
	70.3061159575,70.3021530306,70.2982011081,70.2942601321,70.2903300448,
	70.2864107891,70.2825023083,70.278604546,70.2747174464,70.270840954,
	70.2669750137,70.263119571,70.2592745716,70.2554399617,70.2516156878,
	70.2478016971,70.2439979368,70.2402043547,70.2364208989,70.2326475181,
	70.2288841612,70.2251307773,70.2213873163,70.2176537281,70.2139299631,
	70.2102159721,70.2065117062,70.2028171169,70.1991321561,70.1954567758,
	70.1917909286,70.1881345674,70.1844876454,70.180850116,70.1772219332,
	70.1736030512,70.1699934245,70.1663930079,70.1628017565,70.159219626,
	70.155646572,70.1520825507,70.1485275185,70.1449814321,70.1414442485,
	70.1379159251,70.1343964195,70.1308856895,70.1273836935,70.1238903898,
	70.1204057374,70.1169296952,70.1134622226,70.1100032792,70.1065528249,
	70.10311082,70.0996772248,70.0962520002,70.0928351069,70.0894265065,
	70.0860261602,70.08263403,70.0792500778,70.0758742659,70.072506557,
	70.0691469136,70.065795299,70.0624516764,70.0591160093,70.0557882615,
	70.052468397,70.0491563801,70.0458521752,70.0425557471,70.0392670607,
	70.0359860812,70.032712774,70.0294471048,70.0261890395,70.022938544,
	70.0196955847,70.0164601282,70.0132321412,70.0100115905,70.0067984435,
	70.0035926675,70.0003942301,69.997203099,69.9940192423,69.9908426281,
	69.987673225,69.9845110014,69.9813559263,69.9782079686,69.9750670975,
	69.9719332824,69.968806493,69.9656866989,69.9625738702,69.9594679771,
	69.9563689898,69.9532768789,69.9501916152,69.9471131695,69.9440415128,
	69.9409766166,69.9379184521,69.934866991,69.9318222051,69.9287840663,
	69.9257525469,69.922727619,69.9197092551,69.916697428,69.9136921103,
	69.9106932751,69.9077008955,69.9047149448,69.9017353964,69.898762224,
	69.8957954014,69.8928349024,69.8898807013,69.8869327721,69.8839910894,
	69.8810556276,69.8781263615,69.875203266,69.872286316,69.8693754867,
	69.8664707534,69.8635720915,69.8606794767,69.8577928846,69.8549122911,
	69.8520376723,69.8491690042,69.8463062633,69.843449426,69.8405984687,
	69.8377533682,69.8349141014,69.8320806452,69.8292529768,69.8264310733,
	69.8236149122,69.820804471,69.8179997272,69.8152006587,69.8124072433,
	69.809619459,69.806837284,69.8040606966,69.8012896751,69.798524198,
	69.7957642439,69.7930097917,69.7902608201,69.7875173082,69.7847792351,
	69.7820465799,69.7793193221,69.7765974411,69.7738809164,69.7711697277,
	69.7684638549,69.7657632778,69.7630679764,69.760377931,69.7576931216,
	69.7550135287,69.7523391328,69.7496699143,69.747005854,69.7443469326,
	69.741693131,69.7390444302,69.7364008113,69.7337622555,69.731128744,
	69.7285002583,69.7258767798,69.7232582901,69.720644771,69.7180362043,
	69.7154325717,69.7128338553,69.7102400373,69.7076510997,69.7050670248,
	69.702487795,69.6999133929,69.6973438008,69.6947790015,69.6922189777,
	69.6896637122,69.6871131881,69.6845673881,69.6820262956,69.6794898936,
	69.6769581654,69.6744310945,69.6719086642,69.669390858,69.6668776597,
	69.6643690529,69.6618650215,69.6593655492,69.65687062,69.6543802181,
	69.6518943274,69.6494129323,69.646936017,69.6444635658,69.6419955633,
	69.6395319939,69.6370728423,69.6346180932,69.6321677312,69.6297217413,
	69.6272801083,69.6248428174,69.6224098534,69.6199812016,69.6175568472,
	69.6151367755,69.6127209718,69.6103094217,69.6079021105,69.605499024,
	69.6031001477,69.6007054674,69.5983149688,69.595928638,69.5935464607,
	69.5911684231,69.5887945111,69.586424711,69.5840590089,69.5816973912,
	69.5793398442,69.5769863543,69.5746369081,69.5722914919,69.5699500926,
	69.5676126967,69.565279291,69.5629498624,69.5606243976,69.5583028837,
	69.5559853076,69.5536716564,69.5513619173,69.5490560774,69.546754124,
	69.5444560444,69.542161826,69.5398714561,69.5375849224,69.5353022123,
	69.5330233135,69.5307482137,69.5284769005,69.5262093618,69.5239455854,
	69.5216855592,69.5194292712,69.5171767094,69.5149278619,69.5126827168,
	69.5104412624,69.5082034867,69.5059693782,69.5037389252,69.5015121161,
	69.4992889393,69.4970693835,69.4948534371,69.4926410887,69.4904323271,
	69.488227141,69.4860255191,69.4838274503,69.4816329235,69.4794419275,
	69.4772544515,69.4750704843,69.4728900152,69.4707130332,69.4685395275,
	69.4663694874,69.4642029021,69.462039761,69.4598800535,69.4577237689,
	69.4555708968,69.4534214266,69.451275348,69.4491326506,69.446993324,
	69.444857358,69.4427247423,69.4405954667,69.438469521,69.4363468952,
	69.4342275792,69.4321115629,69.4299988365,69.42788939,69.4257832134,
	69.4236802971,69.421580631,69.4194842056,69.4173910112,69.4153010379,
	69.4132142763,69.4111307167,69.4090503496,69.4069731655,69.404899155,
	69.4028283086,69.400760617,69.3986960708,69.3966346607,69.3945763775,
	69.392521212,69.390469155,69.3884201974,69.3863743301,69.384331544,
	69.3822918302,69.3802551795,69.3782215832,69.3761910323,69.374163518,
	69.3721390314,69.3701175638,69.3680991063,69.3660836504,69.3640711872,
	69.3620617083,69.360055205,69.3580516687,69.3560510909,69.3540534631,
	69.3520587769,69.3500670239,69.3480781956,69.3460922837,69.34410928,
	69.3421291761,69.3401519637,69.3381776348,69.3362061811,69.3342375944,
	69.3322718667,69.3303089899,69.328348956,69.3263917569,69.3244373848,
	69.3224858315,69.3205370893,69.3185911503,69.3166480066,69.3147076504,
	69.312770074,69.3108352696,69.3089032295,69.306973946,69.3050474114,
	69.3031236182,69.3012025588,69.2992842255,69.297368611,69.2954557076,
	69.293545508,69.2916380046,69.2897331902,69.2878310572,69.2859315985,
	69.2840348066,69.2821406742,69.2802491942,69.2783603593,69.2764741623,
	69.274590596,69.2727096534,69.2708313271,69.2689556103,69.2670824959,
	69.2652119768,69.263344046,69.2614786965,69.2596159215,69.2577557139,
	69.255898067,69.2540429739,69.2521904276,69.2503404215,69.2484929487,
	69.2466480025,69.2448055761,69.2429656629,69.2411282562,69.2392933493,
	69.2374609357,69.2356310086,69.2338035617,69.2319785882,69.2301560817,
	69.2283360358,69.2265184438,69.2247032995,69.2228905963,69.2210803279,
	69.2192724879,69.21746707,69.2156640679,69.2138634751,69.2120652856,
	69.210269493,69.2084760912,69.2066850738,69.2048964348,69.203110168,
	69.2013262672,69.1995447265,69.1977655395,69.1959887005,69.1942142031,
	69.1924420416,69.1906722099,69.1889047019,69.1871395119,69.1853766338,
	69.1836160617,69.1818577899,69.1801018123,69.1783481232,69.1765967169,
	69.1748475874,69.173100729,69.171356136,69.1696138026,69.1678737232,
	69.1661358921,69.1644003035,69.162666952,69.1609358317,69.1592069373,
	69.157480263,69.1557558033,69.1540335526,69.1523135056,69.1505956566,
	69.1488800002,69.1471665309,69.1454552434,69.1437461321,69.1420391917,
	69.1403344169,69.1386318022,69.1369313423,69.1352330319,69.1335368658,
	69.1318428385,69.130150945,69.1284611799,69.126773538,69.1250880141,
	69.1234046031,69.1217232997,69.1200440988,69.1183669953,69.1166919841,
	69.1150190601,69.1133482182,69.1116794534,69.1100127607,69.1083481349,
	69.1066855712,69.1050250645,69.1033666098,69.1017102023,69.100055837,
	69.098403509,69.0967532133,69.0951049452,69.0934586997,69.0918144721,
	69.0901722574,69.0885320509,69.0868938478,69.0852576434,69.0836234328,
	69.0819912113,69.0803609742,69.0787327168,69.0771064344,69.0754821223,
	69.0738597759,69.0722393905,69.0706209615,69.0690044844,69.0673899544,
	69.065777367,69.0641667177,69.0625580019,69.0609512151,69.0593463528,
	69.0577434105,69.0561423836,69.0545432678,69.0529460585,69.0513507514,
	69.049757342,69.0481658259,69.0465761987,69.0449884561,69.0434025936,
	69.041818607,69.0402364919,69.0386562439,69.0370778589,69.0355013325,
	69.0339266603,69.0323538383,69.0307828621,69.0292137275,69.0276464302,
	69.0260809661,69.0245173311,69.0229555208,69.0213955313,69.0198373582,
	69.0182809975,69.0167264451,69.0151736969,69.0136227488,69.0120735967,
	69.0105262365,69.0089806642,69.0074368758,69.0058948672,69.0043546345,
	69.0028161736,69.0012794806,68.9997445515,68.9982113823,68.9966799691,
	68.995150308,68.993622395,68.9920962263,68.990571798,68.9890491061,
	68.9875281469,68.9860089165,68.984491411,68.9829756266,68.9814615595,
	68.9799492059,68.978438562,68.976929624,68.9754223882,68.9739168508,
	68.9724130081,68.9709108564,68.9694103919,68.9679116109,68.9664145098,
	68.9649190848,68.9634253323,68.9619332487,68.9604428303,68.9589540734,
	68.9574669745,68.95598153,68.9544977362,68.9530155895,68.9515350864,
	68.9500562234,68.9485789968,68.9471034032,68.945629439,68.9441571007,
	68.9426863847,68.9412172877,68.9397498061,68.9382839364,68.9368196752,
	68.935357019,68.9338959644,68.932436508,68.9309786463,68.929522376,
	68.9280676936,68.9266145957,68.9251630791,68.9237131402,68.9222647759,
	68.9208179827,68.9193727572,68.9179290963,68.9164869965,68.9150464545,
	68.9136074672,68.9121700311,68.9107341431,68.9092997998,68.907866998,
	68.9064357345,68.9050060061,68.9035778095,68.9021511415,68.9007259989,
	68.8993023786,68.8978802773,68.8964596919,68.8950406192,68.8936230561,
	68.8922069994,68.890792446,68.8893793928,68.8879678367,68.8865577745,
	68.8851492032,68.8837421197,68.8823365209,68.8809324038,68.8795297653,
	68.8781286023,68.8767289119,68.8753306909,68.8739339364,68.8725386454,
	68.8711448149,68.8697524418,68.8683615232,68.8669720562,68.8655840377,
	68.8641974648,68.8628123346,68.8614286441,68.8600463904,68.8586655705,
	68.8572861817,68.8559082209,68.8545316853,68.853156572,68.8517828781,
	68.8504106007,68.8490397371,68.8476702843,68.8463022395,68.8449355998,
	68.8435703625,68.8422065248,68.8408440837,68.8394830366,68.8381233807,
	68.836765113,68.835408231,68.8340527318,68.8326986126,68.8313458707,
	68.8299945034,68.8286445079,68.8272958816,68.8259486216,68.8246027253,
	68.8232581899,68.8219150129,68.8205731915,68.8192327229,68.8178936047,
	68.816555834,68.8152194082,68.8138843248,68.812550581,68.8112181742,
	68.8098871018,68.8085573612,68.8072289498,68.8059018649,68.804576104,
	68.8032516645,68.8019285438,68.8006067394,68.7992862487,68.797967069,
	68.796649198,68.795332633,68.7940173715,68.7927034109,68.7913907488,
	68.7900793827,68.78876931,68.7874605283,68.786153035,68.7848468276,
	68.7835419038
	};

tubetable_12AU7_1 = waveform{
	127.202255052,127.144735521,127.087208545,127.029674135,126.972132303,
	126.914583061,126.857026422,126.799462397,126.741890998,126.684312237,
	126.626726127,126.569132679,126.511531906,126.45392382,126.396308434,
	126.338685759,126.281055807,126.223418592,126.165774125,126.108122418,
	126.050463485,125.992797338,125.935123988,125.877443449,125.819755734,
	125.762060854,125.704358822,125.646649651,125.588933353,125.531209942,
	125.473479429,125.415741829,125.357997152,125.300245413,125.242486624,
	125.184720797,125.126947947,125.069168085,125.011381225,124.953587379,
	124.895786561,124.837978784,124.780164061,124.722342404,124.664513828,
	124.606678345,124.548835968,124.490986711,124.433130587,124.375267609,
	124.317397791,124.259521146,124.201637688,124.143747429,124.085850383,
	124.027946564,123.970035986,123.912118661,123.854194604,123.796263828,
	123.738326347,123.680382175,123.622431324,123.56447381,123.506509646,
	123.448538845,123.390561421,123.332577389,123.274586763,123.216589556,
	123.158585782,123.100575455,123.04255859,122.984535201,122.926505301,
	122.868468905,122.810426027,122.752376682,122.694320883,122.636258645,
	122.578189982,122.520114909,122.46203344,122.40394559,122.345851372,
	122.287750803,122.229643895,122.171530664,122.113411125,122.055285291,
	121.997153178,121.939014801,121.880870174,121.822719312,121.76456223,
	121.706398942,121.648229465,121.590053812,121.531871999,121.47368404,
	121.415489952,121.357289748,121.299083444,121.240871056,121.182652598,
	121.124428085,121.066197534,121.007960959,120.949718376,120.891469799,
	120.833215245,120.77495473,120.716688268,120.658415874,120.600137566,
	120.541853358,120.483563266,120.425267305,120.366965492,120.308657843,
	120.250344372,120.192025096,120.133700031,120.075369193,120.017032598,
	119.958690261,119.900342199,119.841988428,119.783628965,119.725263824,
	119.666893023,119.608516578,119.550134505,119.49174682,119.433353539,
	119.37495468,119.316550259,119.258140292,119.199724795,119.141303786,
	119.08287728,119.024445295,118.966007847,118.907564953,118.84911663,
	118.790662894,118.732203763,118.673739253,118.615269382,118.556794165,
	118.498313621,118.439827767,118.381336619,118.322840194,118.26433851,
	118.205831585,118.147319435,118.088802077,118.03027953,117.97175181,
	117.913218935,117.854680922,117.796137789,117.737589554,117.679036234,
	117.620477847,117.56191441,117.503345942,117.444772459,117.386193981,
	117.327610524,117.269022108,117.210428748,117.151830465,117.093227275,
	117.034619197,116.97600625,116.91738845,116.858765817,116.800138368,
	116.741506123,116.682869099,116.624227315,116.565580789,116.50692954,
	116.448273586,116.389612947,116.330947639,116.272277683,116.213603098,
	116.1549239,116.096240111,116.037551747,115.97885883,115.920161376,
	115.861459406,115.802752938,115.744041992,115.685326586,115.62660674,
	115.567882473,115.509153805,115.450420754,115.39168334,115.332941582,
	115.274195501,115.215445115,115.156690443,115.097931507,115.039168325,
	114.980400916,114.921629302,114.862853501,114.804073533,114.745289419,
	114.686501178,114.62770883,114.568912395,114.510111894,114.451307346,
	114.392498772,114.333686192,114.274869626,114.216049094,114.157224618,
	114.098396216,114.039563911,113.980727722,113.92188767,113.863043775,
	113.804196059,113.745344542,113.686489244,113.627630188,113.568767392,
	113.509900879,113.451030669,113.392156784,113.333279244,113.274398071,
	113.215513286,113.156624909,113.097732963,113.038837469,112.979938447,
	112.92103592,112.862129909,112.803220436,112.744307521,112.685391187,
	112.626471456,112.567548349,112.508621888,112.449692094,112.39075899,
	112.331822598,112.272882939,112.213940037,112.154993911,112.096044586,
	112.037092083,111.978136425,111.919177633,111.860215731,111.80125074,
	111.742282682,111.683311582,111.624337461,111.565360341,111.506380246,
	111.447397198,111.38841122,111.329422336,111.270430566,111.211435936,
	111.152438467,111.093438183,111.034435107,110.975429263,110.916420672,
	110.857409359,110.798395347,110.73937866,110.68035932,110.621337352,
	110.562312778,110.503285623,110.44425591,110.385223663,110.326188906,
	110.267151662,110.208111956,110.149069811,110.090025251,110.030978301,
	109.971928984,109.912877325,109.853823348,109.794767077,109.735708537,
	109.676647752,109.617584746,109.558519543,109.49945217,109.440382649,
	109.381311006,109.322237266,109.263161453,109.204083593,109.145003709,
	109.085921827,109.026837973,108.96775217,108.908664445,108.849574822,
	108.790483327,108.731389986,108.672294822,108.613197863,108.554099132,
	108.494998657,108.435896462,108.376792573,108.317687016,108.258579817,
	108.199471001,108.140360595,108.081248624,108.022135115,107.963020092,
	107.903903584,107.844785615,107.785666212,107.726545402,107.66742321,
	107.608299663,107.549174788,107.490048611,107.430921159,107.371792458,
	107.312662536,107.253531418,107.194399133,107.135265706,107.076131165,
	107.016995536,106.957858848,106.898721126,106.839582398,106.780442692,
	106.721302035,106.662160454,106.603017977,106.543874631,106.484730444,
	106.425585443,106.366439656,106.307293111,106.248145836,106.188997858,
	106.129849206,106.070699908,106.011549991,105.952399484,105.893248414,
	105.834096811,105.774944703,105.715792117,105.656639083,105.597485629,
	105.538331783,105.479177574,105.420023031,105.360868183,105.301713058,
	105.242557685,105.183402093,105.124246312,105.065090369,105.005934295,
	104.946778119,104.88762187,104.828465577,104.769309269,104.710152976,
	104.650996728,104.591840554,104.532684484,104.473528547,104.414372774,
	104.355217194,104.296061836,104.236906732,104.17775191,104.118597402,
	104.059443236,104.000289445,103.941136056,103.881983102,103.822830613,
	103.763678618,103.704527149,103.645376236,103.586225909,103.527076201,
	103.46792714,103.408778759,103.349631087,103.290484157,103.231337999,
	103.172192644,103.113048124,103.053904469,102.994761711,102.935619882,
	102.876479012,102.817339134,102.758200279,102.699062479,102.639925765,
	102.580790168,102.521655722,102.462522458,102.403390407,102.344259603,
	102.285130076,102.226001859,102.166874985,102.107749485,102.048625393,
	101.989502739,101.930381558,101.871261882,101.812143742,101.753027172,
	101.693912205,101.634798874,101.575687211,101.516577249,101.457469021,
	101.398362561,101.339257902,101.280155076,101.221054117,101.161955059,
	101.102857935,101.043762779,100.984669623,100.925578502,100.866489449,
	100.807402498,100.748317684,100.689235038,100.630154597,100.571076394,
	100.512000462,100.452926836,100.393855551,100.33478664,100.275720138,
	100.21665608,100.157594499,100.098535431,100.03947891,99.9804249704,
	99.9213736475,99.8623249759,99.8032789906,99.7442357264,99.6851952186,
	99.626157502,99.567122612,99.5080905837,99.4490614525,99.3900352536,
	99.3310120227,99.2719917951,99.2129746064,99.1539604923,99.0949494884,
	99.0359416307,98.9769369548,98.9179354966,98.8589372923,98.7999423778,
	98.7409507892,98.6819625626,98.6229777345,98.563996341,98.5050184185,
	98.4460440035,98.3870731325,98.328105842,98.2691421688,98.2101821495,
	98.151225821,98.09227322,98.0333243835,97.9743793485,97.915438152,
	97.8565008311,97.7975674231,97.7386379652,97.6797124948,97.6207910491,
	97.5618736657,97.5029603821,97.4440512358,97.3851462647,97.3262455062,
	97.2673489984,97.208456779,97.149568886,97.0906853573,97.031806231,
	96.9729315454,96.9140613384,96.8551956486,96.7963345141,96.7374779733,
	96.6786260648,96.6197788271,96.5609362988,96.5020985186,96.4432655252,
	96.3844373574,96.3256140541,96.2667956543,96.2079821969,96.1491737211,
	96.090370266,96.0315718708,95.9727785748,95.9139904174,95.8552074379,
	95.796429676,95.737657171,95.6788899628,95.6201280909,95.5613715951,
	95.5026205153,95.4438748913,95.3851347632,95.3264001709,95.2676711546,
	95.2089477545,95.1502300108,95.0915179637,95.0328116538,94.9741111215,
	94.9154164072,94.8567275516,94.7980445954,94.7393675792,94.6806965439,
	94.6220315304,94.5633725795,94.5047197323,94.44607303,94.3874325135,
	94.3287982243,94.2701702035,94.2115484926,94.152933133,94.0943241661,
	94.0357216337,93.9771255772,93.9185360386,93.8599530596,93.801376682,
	93.7428069478,93.684243899,93.6256875779,93.5671380264,93.5085952869,
	93.4500594017,93.3915304132,93.3330083638,93.2744932962,93.215985253,
	93.1574842769,93.0989904107,93.0405036972,92.9820241794,92.9235519003,
	92.8650869031,92.806629231,92.7481789271,92.689736035,92.631300598,
	92.5728726596,92.5144522635,92.4560394534,92.397634273,92.3392367663,
	92.2808469772,92.2224649498,92.1640907283,92.1057243567,92.0473658796,
	91.9890153414,91.9306727865,91.8723382596,91.8140118055,91.7556934689,
	91.6973832947,91.6390813282,91.5807876143,91.5225021983,91.4642251255,
	91.4059564416,91.3476961919,91.2894444223,91.2312011785,91.1729665065,
	91.1147404523,91.0565230622,90.9983143824,90.9401144593,90.8819233396,
	90.8237410699,90.7655676971,90.7074032682,90.6492478303,90.5911014307,
	90.5329641168,90.4748359361,90.4167169366,90.3586071659,90.3005066723,
	90.242415504,90.1843337093,90.1262613369,90.0681984356,90.0101450544,
	89.9521012424,89.8940670489,89.8360425236,89.7780277163,89.7200226769,
	89.6620274557,89.6040421032,89.54606667,89.4881012072,89.4301457658,
	89.3722003975,89.3142651538,89.2563400868,89.1984252488,89.1405206923,
	89.0826264704,89.0247426361,88.966869243,88.9090063449,88.8511539961,
	88.7933122511,88.7354811649,88.6776607928,88.6198511904,88.5620524139,
	88.5042645199,88.4464875652,88.3887216073,88.3309667042,88.2732229142,
	88.2154902961,88.1577689093,88.1000588138,88.04236007,87.9846727391,
	87.9269968825,87.8693325627,87.8116798425,87.7540387854,87.6964094557,
	87.6387919184,87.5811862391,87.5235924843,87.4660107213,87.408441018,
	87.3508834435,87.2933380675,87.2358049606,87.1782841946,87.1207758422,
	87.0632799768,87.0057966733,86.9483260074,86.8908680562,86.8334228976,
	86.7759906111,86.7185712772,86.661164978,86.6037717966,86.5463918178,
	86.4890251277,86.4316718142,86.3743319664,86.3170056754,86.2596930337,
	86.2023941359,86.145109078,86.0878379584,86.0305808771,85.9733379363,
	85.9161092405,85.8588948961,85.8016950119,85.7445096993,85.687339072,
	85.6301832461,85.5730423407,85.5159164775,85.4588057811,85.4017103791,
	85.3446304022,85.2875659842,85.2305172625,85.1734843777,85.1164674741,
	85.0594666999,85.0024822069,84.945514151,84.8885626925,84.8316279957,
	84.7747102297,84.717809568,84.6609261892,84.6040602768,84.5472120195,
	84.4903816116,84.4335692527,84.3767751485,84.3199995108,84.2632425574,
	84.2065045129,84.1497856085,84.0930860825,84.0364061805,83.9797461556,
	83.9231062687,83.866486789,83.809887994,83.75331017,83.6967536122,
	83.6402186255,83.5837055244,83.5272146335,83.470746288,83.4143008337,
	83.3578786281,83.3014800399,83.2451054504,83.1887552531,83.1324298546,
	83.0761296751,83.0198551485,82.9636067233,82.9073848632,82.8511900471,
	82.79502277,82.7388835436,82.682772897,82.6266913768,82.5706395482,
	82.5146179955,82.4586273228,82.4026681544,82.346741136,82.290846935,
	82.2349862413,82.1791597684,82.1233682537,82.0676124596,82.0118931742,
	81.9562112123,81.9005674161,81.844962656,81.7893978318,81.7338738734,
	81.6783917418,81.6229524301,81.5675569644,81.5122064049,81.456901847,
	81.4016444219,81.3464352983,81.291275683,81.2361668221,81.1811100021,
	81.1261065514,81.0711578405,81.0162652843,80.9614303422,80.90665452,
	80.8519393705,80.7972864951,80.7426975448,80.6881742212,80.6337182778,
	80.579331521,80.5250158115,80.470773065,80.4166052536,80.3625144069,
	80.3085026127,80.2545720181,80.2007248309,80.1469633197,80.0932898155,
	80.0397067122,79.9862164673,79.9328216025,79.8795247049,79.8263284265,
	79.7732354857,79.7202486668,79.6673708208,79.6146048653,79.5619537845,
	79.5094206291,79.4570085162,79.4047206287,79.352560215,79.3005305881,
	79.2486351248,79.1968772648,79.1452605095,79.0937884205,79.042464618,
	78.9912927792,78.9402766362,78.8894199741,78.838726628,78.7882004811,
	78.7378454614,78.6876655389,78.6376647223,78.5878470553,78.5382166134,
	78.4887774995,78.4395338398,78.3904897799,78.3416494797,78.2930171091,
	78.2445968429,78.1963928557,78.1484093165,78.1006503837,78.053120199,
	78.0058228821,77.958762525,77.9119431858,77.8653688829,77.819043589,
	77.7729712253,77.7271556551,77.6816006782,77.6363100247,77.591287349,
	77.5465362241,77.5020601362,77.4578624787,77.4139465467,77.3703155323,
	77.3269725192,77.2839204776,77.2411622604,77.1987005979,77.1565380947,
	77.1146772253,77.0731203307,77.0318696155,76.990927145,76.9502948426,
	76.909974488,76.8699677149,76.8302760101,76.7909007119,76.7518430099,
	76.7131039444,76.6746844061,76.636585137,76.5988067306,76.5613496329,
	76.5242141439,76.4874004191,76.4509084712,76.4147381725,76.3788892573,
	76.3433613242,76.3081538394,76.2732661397,76.2386974356,76.2044468146,
	76.1705132456,76.1368955816,76.1035925643,76.070602828,76.0379249031,
	76.0055572212,75.9734981182,75.9417458394,75.9102985434,75.8791543063,
	75.848311126,75.8177669265,75.7875195623,75.7575668221,75.7279064333,
	75.6985360662,75.6694533373,75.6406558142,75.6121410187,75.5839064308,
	75.5559494925,75.5282676111,75.5008581629,75.4737184964,75.4468459357,
	75.4202377835,75.3938913241,75.3678038265,75.3419725471,75.3163947322,
	75.291067621,75.2659884475,75.2411544433,75.2165628397,75.1922108698,
	75.1680957703,75.1442147838,75.1205651605,75.0971441596,75.0739490514,
	75.0509771182,75.0282256564,75.0056919772,74.9833734085,74.9612672952,
	74.9393710013,74.9176819098,74.8961974247,74.874914971,74.8538319958,
	74.8329459692,74.8122543847,74.7917547597,74.7714446366,74.7513215823,
	74.7313831897,74.7116270773,74.6920508898,74.6726522985,74.6534290013,
	74.634378723,74.6154992156,74.5967882581,74.578243657,74.5598632461,
	74.5416448865,74.5235864667,74.5056859027,74.4879411377,74.470350142,
	74.4529109135,74.4356214765,74.4184798829,74.4014842108,74.3846325653,
	74.3679230776,74.3513539054,74.3349232322,74.3186292676,74.3024702466,
	74.2864444294,74.2705501017,74.2547855738,74.2391491806,74.2236392814,
	74.2082542598,74.1929925227,74.177852501,74.1628326486,74.1479314424,
	74.133147382,74.1184789894,74.1039248086,74.0894834054,74.0751533673,
	74.0609333028,74.0468218415,74.0328176334,74.0189193491,74.0051256791,
	73.9914353336,73.9778470424,73.9643595544,73.9509716375,73.937682078,
	73.9244896808,73.9113932687,73.8983916822,73.8854837795,73.8726684358,
	73.8599445434,73.8473110113,73.8347667649,73.8223107457,73.8099419111,
	73.7976592344,73.785461704,73.7733483235,73.7613181117,73.7493701016,
	73.737503341,73.7257168917,73.7140098296,73.7023812443,73.6908302387,
	73.6793559292,73.6679574452,73.6566339291,73.6453845356,73.6342084321,
	73.6231047982,73.6120728253,73.6011117169,73.590220688,73.579398965,
	73.5686457855,73.5579603984,73.547342063,73.5367900498,73.5263036396,
	73.5158821233,73.5055248024,73.495230988,73.4850000013,73.474831173,
	73.4647238434,73.4546773621,73.4446910879,73.4347643887,73.4248966411,
	73.4150872306,73.4053355513,73.3956410057,73.3860030047,73.3764209671,
	73.3668943202,73.3574224987,73.3480049456,73.3386411111,73.3293304532,
	73.3200724372,73.3108665357,73.3017122285,73.2926090024,73.2835563511,
	73.2745537752,73.2656007821,73.2566968855,73.2478416058,73.2390344699,
	73.2302750107,73.2215627675,73.2128972856,73.2042781163,73.1957048168,
	73.1871769501,73.178694085,73.1702557957,73.1618616621,73.1535112694,
	73.1452042084,73.1369400749,73.12871847,73.1205389999,73.1124012759,
	73.104304914,73.0962495354,73.0882347658,73.0802602359,73.0723255807,
	73.0644304401,73.0565744583,73.0487572841,73.0409785705,73.0332379747,
	73.0255351586,73.0178697878,73.0102415321,73.0026500655,72.9950950659,
	72.9875762151,72.9800931987,72.9726457062,72.9652334309,72.9578560697,
	72.950513323,72.9432048951,72.9359304935,72.9286898295,72.9214826175,
	72.9143085755,72.9071674247,72.9000588896,72.8929826981,72.885938581,
	72.8789262723,72.8719455093,72.8649960321,72.8580775839,72.8511899108,
	72.844332762,72.8375058893,72.8307090475,72.8239419941,72.8172044895,
	72.8104962966,72.8038171811,72.7971669113,72.7905452582,72.7839519951,
	72.7773868982,72.7708497458,72.764340319,72.757858401,72.7514037776,
	72.7449762369,72.7385755693,72.7322015676,72.7258540266,72.7195327435,
	72.7132375179,72.7069681511,72.7007244468,72.694506211,72.6883132513,
	72.6821453778,72.6760024024,72.6698841391,72.6637904036,72.6577210139,
	72.6516757897,72.6456545528,72.6396571265,72.6336833363,72.6277330094,
	72.6218059746,72.6159020628,72.6100211064,72.6041629397,72.5983273985,
	72.5925143204,72.5867235447,72.5809549122,72.5752082655,72.5694834485,
	72.5637803071,72.5580986883,72.5524384409,72.5467994152,72.5411814629,
	72.5355844373,72.530008193,72.5244525861,72.5189174741,72.5134027161,
	72.5079081723,72.5024337044,72.4969791754,72.4915444497,72.4861293931,
	72.4807338724,72.475357756,72.4700009133,72.4646632153,72.4593445339,
	72.4540447423,72.448763715,72.4435013277,72.4382574572,72.4330319815,
	72.4278247797,72.4226357321,72.4174647202,72.4123116263,72.4071763341,
	72.4020587284,72.3969586948,72.3918761201,72.3868108923,72.3817629002,
	72.3767320336,72.3717181837,72.3667212421,72.3617411019,72.3567776569,
	72.3518308019,72.3469004328,72.3419864461,72.3370887397,72.332207212,
	72.3273417625,72.3224922916,72.3176587005,72.3128408914,72.3080387673,
	72.3032522319,72.2984811901,72.2937255474,72.2889852101,72.2842600854,
	72.2795500813,72.2748551066,72.2701750709,72.2655098845,72.2608594586,
	72.2562237051,72.2516025367,72.2469958667,72.2424036093,72.2378256794,
	72.2332619927,72.2287124653,72.2241770145,72.2196555578,72.2151480137,
	72.2106543013,72.2061743404,72.2017080515,72.1972553556,72.1928161746,
	72.1883904309,72.1839780475,72.1795789482,72.1751930572,72.1708202995,
	72.1664606008,72.1621138871,72.1577800852,72.1534591226,72.1491509271,
	72.1448554274,72.1405725526,72.1363022322,72.1320443967,72.1277989769,
	72.123565904,72.1193451101,72.1151365275,72.1109400894,72.1067557292,
	72.1025833809,72.0984229793,72.0942744593,72.0901377566,72.0860128072,
	72.0818995479,72.0777979156,72.073707848,72.0696292831,72.0655621596,
	72.0615064164,72.0574619931,72.0534288296,72.0494068663,72.0453960442,
	72.0413963045,72.0374075891,72.0334298402,72.0294630004,72.0255070128,
	72.0215618211,72.017627369,72.0137036011,72.009790462,72.0058878971,
	72.0019958519,71.9981142724,71.9942431051,71.9903822968,71.9865317947,
	71.9826915465,71.9788615,71.9750416037,71.9712318063,71.967432057,
	71.9636423053,71.959862501,71.9560925943,71.9523325359,71.9485822768,
	71.9448417681,71.9411109616,71.9373898094,71.9336782636,71.9299762771,
	71.9262838028,71.9226007941,71.9189272048,71.9152629889,71.9116081006,
	71.9079624947,71.9043261262,71.9006989504,71.8970809229,71.8934719996,
	71.8898721369,71.8862812912,71.8826994194,71.8791264786,71.8755624264,
	71.8720072205,71.8684608189,71.8649231799,71.8613942621,71.8578740245,
	71.8543624263,71.8508594268,71.8473649859,71.8438790635,71.8404016199,
	71.8369326157,71.8334720117,71.8300197691,71.826575849,71.8231402132,
	71.8197128235,71.816293642,71.8128826312,71.8094797536,71.806084972,
	71.8026982497,71.79931955,71.7959488366,71.7925860731,71.7892312238,
	71.785884253,71.7825451252,71.7792138052,71.775890258,71.7725744489,
	71.7692663434,71.7659659071,71.762673106,71.7593879063,71.7561102742,
	71.7528401764,71.7495775796,71.746322451,71.7430747576,71.7398344669,
	71.7366015466,71.7333759644,71.7301576886,71.7269466872,71.7237429288,
	71.7205463819,71.7173570156,71.7141747987,71.7109997006,71.7078316906,
	71.7046707384,71.7015168139,71.698369887,71.6952299278,71.6920969069,
	71.6889707947,71.685851562,71.6827391798,71.679633619,71.676534851,
	71.6734428473,71.6703575795,71.6672790193,71.6642071389,71.6611419102,
	71.6580833057,71.6550312978,71.6519858592,71.6489469627,71.6459145813,
	71.6428886881,71.6398692565,71.6368562598,71.6338496718,71.6308494663,
	71.6278556171,71.6248680983,71.6218868843,71.6189119494,71.6159432682,
	71.6129808154,71.6100245659,71.6070744946,71.6041305767,71.6011927875,
	71.5982611025,71.5953354972,71.5924159474,71.589502429,71.5865949179,
	71.5836933903,71.5807978225,71.577908191,71.5750244723,71.5721466431,
	71.5692746802,71.5664085606,71.5635482615,71.56069376,71.5578450334,
	71.5550020594,71.5521648155,71.5493332795,71.5465074292,71.5436872426,
	71.5408726979,71.5380637733,71.5352604472,71.532462698,71.5296705045,
	71.5268838452,71.5241026992,71.5213270452,71.5185568625,71.5157921303,
	71.5130328278,71.5102789345,71.5075304299,71.5047872938,71.5020495058,
	71.4993170459,71.4965898941,71.4938680305,71.4911514352,71.4884400887,
	71.4857339713,71.4830330636,71.4803373463,71.4776468,71.4749614057,
	71.4722811443,71.4696059969,71.4669359446,71.4642709687,71.4616110506,
	71.4589561717,71.4563063136,71.453661458,71.4510215867,71.4483866814,
	71.4457567242,71.4431316972,71.4405115824,71.4378963621,71.4352860186,
	71.4326805345,71.4300798922,71.4274840743,71.4248930635,71.4223068427,
	71.4197253947,71.4171487025,71.4145767492,71.412009518,71.409446992,
	71.4068891546,71.4043359893,71.4017874795,71.3992436089,71.3967043611,
	71.3941697198,71.3916396689,71.3891141924,71.3865932742,71.3840768985,
	71.3815650494,71.3790577112,71.3765548681,71.3740565047,71.3715626054,
	71.3690731547,71.3665881374,71.3641075382,71.3616313418,71.3591595332,
	71.3566920973,71.3542290191,71.3517702838,71.3493158765,71.3468657825,
	71.3444199871,71.3419784758,71.3395412339,71.3371082471,71.334679501,
	71.3322549813,71.3298346737,71.3274185641,71.3250066384,71.3225988825,
	71.3201952826,71.3177958246,71.3154004948,71.3130092795,71.3106221649,
	71.3082391374,71.3058601835,71.3034852898,71.3011144427,71.2987476289,
	71.2963848352,71.2940260482,71.2916712549,71.2893204422,71.286973597,
	71.2846307063,71.2822917573,71.279956737,71.2776256327,71.2752984317,
	71.2729751214,71.270655689,71.2683401221,71.2660284081,71.2637205347,
	71.2614164895,71.2591162602,71.2568198345,71.2545272002,71.2522383453,
	71.2499532575,71.247671925,71.2453943357,71.2431204777,71.2408503393,
	71.2385839085,71.2363211736,71.234062123,71.2318067451,71.2295550282,
	71.2273069608,71.2250625314,71.2228217287,71.2205845412,71.2183509577,
	71.2161209669,71.2138945576,71.2116717186,71.2094524388,71.2072367071,
	71.2050245127,71.2028158444,71.2006106914,71.1984090428,71.1962108879,
	71.1940162159,71.191825016,71.1896372776,71.1874529901,71.1852721429,
	71.1830947256,71.1809207276,71.1787501385,71.176582948,71.1744191456,
	71.1722587212,71.1701016646,71.1679479654,71.1657976135,71.163650599,
	71.1615069116,71.1593665414,71.1572294785,71.1550957128,71.1529652346,
	71.1508380339,71.1487141011,71.1465934263,71.1444759999,71.1423618121,
	71.1402508534,71.1381431141,71.1360385848,71.133937256,71.1318391181,
	71.1297441618,71.1276523777,71.1255637565,71.1234782889,71.1213959656,
	71.1193167774,71.1172407152,71.1151677698,71.1130979321,71.1110311931,
	71.1089675437,71.106906975,71.1048494781,71.102795044,71.1007436639,
	71.098695329,71.0966500304,71.0946077595,71.0925685075,71.0905322657,
	71.0884990255,71.0864687783,71.0844415156,71.0824172287,71.0803959093,
	71.0783775489,71.0763621389,71.0743496712,71.0723401372,71.0703335287,
	71.0683298374,71.066329055,71.0643311734,71.0623361844,71.0603440798,
	71.0583548515,71.0563684914,71.0543849915,71.0524043438,71.0504265403,
	71.048451573,71.0464794341,71.0445101156,71.0425436098,71.0405799088,
	71.0386190048,71.03666089,71.0347055568,71.0327529975,71.0308032044,
	71.0288561699,71.0269118863,71.0249703462,71.023031542,71.0210954661,
	71.0191621112,71.0172314698,71.0153035344,71.0133782977,71.0114557523,
	71.009535891,71.0076187064,71.0057041912,71.0037923382,71.0018831403,
	70.9999765902,70.9980726807,70.9961714049,70.9942727555,70.9923767255,
	70.9904833079,70.9885924957,70.9867042819,70.9848186595,70.9829356216,
	70.9810551613,70.9791772718,70.9773019462,70.9754291776,70.9735589594,
	70.9716912847,70.9698261468,70.9679635389,70.9661034545,70.9642458868,
	70.9623908292,70.9605382751,70.958688218,70.9568406512,70.9549955682,
	70.9531529626,70.9513128279,70.9494751575,70.9476399451,70.9458071843,
	70.9439768687,70.9421489919,70.9403235476,70.9385005294,70.9366799312,
	70.9348617467,70.9330459695,70.9312325936,70.9294216127,70.9276130206,
	70.9258068113,70.9240029785,70.9222015163,70.9204024184,70.918605679,
	70.9168112919,70.9150192512,70.9132295508,70.9114421849,70.9096571474,
	70.9078744325,70.9060940343,70.904315947,70.9025401645,70.9007666812,
	70.8989954913,70.8972265889,70.8954599683,70.8936956238,70.8919335496,
	70.89017374,70.8884161894,70.8866608922,70.8849078426,70.8831570351,
	70.8814084641,70.879662124,70.8779180092,70.8761761143,70.8744364337,
	70.8726989619,70.8709636935,70.869230623,70.867499745,70.865771054,
	70.8640445448,70.8623202118,70.8605980499,70.8588780535,70.8571602175,
	70.8554445365,70.8537310053,70.8520196185,70.850310371,70.8486032576,
	70.846898273,70.8451954121,70.8434946697,70.8417960407,70.8400995199,
	70.8384051023,70.8367127827,70.8350225561,70.8333344174,70.8316483616,
	70.8299643837,70.8282824787,70.8266026417,70.8249248675,70.8232491514,
	70.8215754884,70.8199038735,70.8182343019,70.8165667687,70.8149012691,
	70.8132377981,70.8115763511,70.8099169231,70.8082595094,70.8066041053,
	70.8049507059,70.8032993065,70.8016499024,70.8000024889,70.7983570614,
	70.796713615,70.7950721452,70.7934326474,70.7917951169,70.7901595491,
	70.7885259394,70.7868942832,70.785264576,70.7836368132,70.7820109903,
	70.7803871028,70.7787651462,70.777145116,70.7755270077,70.7739108169,
	70.7722965391,70.77068417,70.769073705,70.7674651399,70.7658584703,
	70.7642536917,70.7626507999,70.7610497905,70.7594506591,70.7578534016,
	70.7562580136,70.7546644907,70.7530728289,70.7514830237,70.7498950711,
	70.7483089667,70.7467247064,70.745142286,70.7435617013,70.7419829481,
	70.7404060224,70.7388309199,70.7372576365,70.7356861682,70.7341165109,
	70.7325486605,70.7309826128,70.729418364,70.7278559098,70.7262952464,
	70.7247363697,70.7231792756,70.7216239603,70.7200704198,70.71851865,
	70.716968647,70.715420407,70.713873926,70.7123292001,70.7107862253,
	70.7092449979,70.707705514,70.7061677696,70.704631761,70.7030974843,
	70.7015649357,70.7000341115,70.6985050077,70.6969776207,70.6954519467,
	70.6939279818,70.6924057225,70.6908851648,70.6893663052,70.68784914,
	70.6863336653,70.6848198776,70.6833077731,70.6817973482,70.6802885993,
	70.6787815228,70.6772761149,70.6757723721,70.6742702908,70.6727698674,
	70.6712710983,70.66977398,70.6682785089,70.6667846814,70.6652924941,
	70.6638019434,70.6623130257,70.6608257377,70.6593400758,70.6578560365,
	70.6563736163,70.6548928119,70.6534136197,70.6519360364,70.6504600585,
	70.6489856826,70.6475129053,70.6460417232,70.6445721329,70.6431041311,
	70.6416377145,70.6401728795,70.638709623,70.6372479416,70.635787832,
	70.6343292908,70.6328723148,70.6314169007,70.6299630452,70.6285107451,
	70.6270599971,70.6256107979,70.6241631443,70.6227170332,70.6212724612,
	70.6198294252,70.618387922,70.6169479483,70.6155095011,70.6140725771,
	70.6126371732,70.6112032863,70.6097709132,70.6083400508,70.6069106959,
	70.6054828456,70.6040564965,70.6026316458,70.6012082902,70.5997864268,
	70.5983660524,70.5969471641,70.5955297587,70.5941138333,70.5926993847,
	70.5912864101,70.5898749064,70.5884648705,70.5870562996,70.5856491906,
	70.5842435406,70.5828393466,70.5814366056,70.5800353147,70.578635471,
	70.5772370716,70.5758401135,70.5744445938,70.5730505096,70.5716578581,
	70.5702666363,70.5688768414,70.5674884705,70.5661015208,70.5647159894,
	70.5633318734,70.5619491701,70.5605678767,70.5591879902,70.5578095079,
	70.5564324271,70.5550567448,70.5536824584,70.552309565,70.550938062,
	70.5495679464,70.5481992157,70.546831867,70.5454658977,70.5441013049,
	70.542738086,70.5413762383,70.5400157591,70.5386566456,70.5372988952,
	70.5359425053,70.534587473,70.5332337959,70.5318814712,70.5305304963,
	70.5291808686,70.5278325853,70.526485644,70.5251400419,70.5237957765,
	70.5224528452,70.5211112453,70.5197709744,70.5184320297,70.5170944088,
	70.5157581091,70.514423128,70.513089463,70.5117571115,70.510426071,
	70.5090963391,70.507767913,70.5064407904,70.5051149688,70.5037904455,
	70.5024672183,70.5011452845,70.4998246417,70.4985052874,70.4971872192,
	70.4958704345,70.494554931,70.4932407063,70.4919277578,70.4906160832,
	70.48930568,70.4879965458,70.4866886782,70.4853820748,70.4840767332,
	70.4827726511,70.481469826,70.4801682555,70.4788679374,70.4775688692,
	70.4762710486,70.4749744732,70.4736791407,70.4723850488,70.4710921952,
	70.4698005774,70.4685101933,70.4672210404,70.4659331165,70.4646464193,
	70.4633609466
	};

tubetable_12AU7_rtable_0(r) = (tubetable_12AU7_0,r):rdtable;
tubetable_12AU7_rtable_1(r) = (tubetable_12AU7_1,r):rdtable;


// generated by ../../tools/tube_transfer.py
// tube: 12AX7
// plate current function: triode
// mu: 100
// kx: 1.4
// kg1: 1060
// kp: 600
// kvb: 300

tubetable_12AX7_0 = waveform{
	249.98706929,249.986851225,249.986629489,249.986404021,249.986174757,
	249.985941635,249.985704589,249.985463554,249.985218463,249.984969247,
	249.984715838,249.984458166,249.984196158,249.983929743,249.983658846,
	249.983383392,249.983103306,249.982818508,249.982528921,249.982234464,
	249.981935056,249.981630613,249.981321052,249.981006287,249.98068623,
	249.980360793,249.980029887,249.979693419,249.979351296,249.979003424,
	249.978649708,249.978290048,249.977924346,249.9775525,249.977174409,
	249.976789967,249.976399069,249.976001606,249.97559747,249.975186548,
	249.974768727,249.974343893,249.973911927,249.973472711,249.973026125,
	249.972572044,249.972110345,249.9716409,249.971163579,249.970678252,
	249.970184785,249.969683043,249.969172887,249.968654177,249.968126772,
	249.967590526,249.967045292,249.96649092,249.965927258,249.965354153,
	249.964771446,249.964178978,249.963576587,249.962964107,249.962341372,
	249.961708211,249.96106445,249.960409914,249.959744424,249.959067797,
	249.95837985,249.957680393,249.956969237,249.956246188,249.955511048,
	249.954763616,249.95400369,249.953231063,249.952445523,249.951646857,
	249.950834849,249.950009276,249.949169916,249.94831654,249.947448916,
	249.946566809,249.945669979,249.944758184,249.943831177,249.942888706,
	249.941930516,249.940956349,249.93996594,249.938959023,249.937935324,
	249.936894568,249.935836475,249.934760758,249.933667127,249.932555289,
	249.931424944,249.930275788,249.929107511,249.9279198,249.926712337,
	249.925484796,249.92423685,249.922968162,249.921678394,249.9203672,
	249.91903423,249.917679127,249.916301529,249.914901069,249.913477372,
	249.912030061,249.910558748,249.909063042,249.907542547,249.905996856,
	249.904425561,249.902828244,249.901204482,249.899553844,249.897875894,
	249.896170188,249.894436274,249.892673696,249.890881989,249.889060679,
	249.887209288,249.885327328,249.883414305,249.881469716,249.879493052,
	249.877483793,249.875441414,249.87336538,249.87125515,249.869110171,
	249.866929885,249.864713724,249.86246111,249.860171458,249.857844173,
	249.855478652,249.853074281,249.850630438,249.848146491,249.845621799,
	249.843055711,249.840447565,249.837796689,249.835102404,249.832364016,
	249.829580824,249.826752115,249.823877166,249.820955243,249.8179856,
	249.81496748,249.811900117,249.80878273,249.80561453,249.802394713,
	249.799122465,249.795796959,249.792417358,249.788982809,249.785492449,
	249.781945403,249.778340779,249.774677678,249.770955183,249.767172365,
	249.763328284,249.759421981,249.75545249,249.751418824,249.747319988,
	249.743154968,249.738922738,249.734622257,249.730252468,249.725812301,
	249.72130067,249.716716471,249.712058589,249.70732589,249.702517225,
	249.697631429,249.692667321,249.687623703,249.682499361,249.677293063,
	249.672003562,249.666629592,249.661169871,249.655623098,249.649987954,
	249.644263106,249.638447197,249.632538857,249.626536694,249.620439299,
	249.614245244,249.607953082,249.601561346,249.59506855,249.588473189,
	249.581773739,249.574968653,249.568056367,249.561035295,249.553903831,
	249.546660348,249.5393032,249.531830718,249.524241211,249.516532969,
	249.508704259,249.500753327,249.492678397,249.48447767,249.476149326,
	249.467691521,249.459102391,249.450380046,249.441522576,249.432528047,
	249.423394501,249.414119957,249.404702411,249.395139834,249.385430176,
	249.37557136,249.365561287,249.355397831,249.345078845,249.334602156,
	249.323965565,249.313166851,249.302203767,249.291074039,249.27977537,
	249.268305439,249.256661896,249.244842368,249.232844458,249.220665739,
	249.208303762,249.195756051,249.183020104,249.170093394,249.156973366,
	249.143657441,249.130143014,249.116427453,249.102508098,249.088382267,
	249.074047249,249.059500307,249.044738677,249.029759572,249.014560175,
	248.999137645,248.983489114,248.967611688,248.951502446,248.935158442,
	248.918576704,248.901754233,248.884688005,248.867374969,248.84981205,
	248.831996145,248.813924127,248.795592843,248.776999115,248.75813974,
	248.739011488,248.719611106,248.699935316,248.679980814,248.659744274,
	248.639222342,248.618411645,248.597308781,248.575910327,248.554212837,
	248.532212841,248.509906845,248.487291335,248.464362771,248.441117595,
	248.417552224,248.393663055,248.369446462,248.344898801,248.320016406,
	248.29479559,248.269232647,248.243323852,248.217065459,248.190453706,
	248.163484811,248.136154974,248.108460379,248.080397191,248.05196156,
	248.02314962,247.993957487,247.964381265,247.934417041,247.904060889,
	247.87330887,247.84215703,247.810601403,247.778638011,247.746262866,
	247.713471967,247.680261303,247.646626855,247.612564592,247.578070476,
	247.543140461,247.507770494,247.471956513,247.435694453,247.398980241,
	247.3618098,247.32417905,247.286083906,247.247520279,247.208484082,
	247.168971222,247.128977607,247.088499146,247.047531747,247.00607132,
	246.964113777,246.921655031,246.878691002,246.835217611,246.791230785,
	246.746726457,246.701700566,246.656149058,246.610067887,246.563453015,
	246.516300414,246.468606066,246.420365964,246.371576111,246.322232524,
	246.272331232,246.221868279,246.170839722,246.119241634,246.067070104,
	246.014321237,245.960991157,245.907076004,245.852571939,245.79747514,
	245.74178181,245.685488167,245.628590455,245.571084939,245.512967907,
	245.454235672,245.394884569,245.334910961,245.274311236,245.213081807,
	245.151219115,245.08871963,245.02557985,244.9617963,244.897365536,
	244.832284146,244.766548747,244.700155987,244.633102547,244.565385141,
	244.497000515,244.427945449,244.358216758,244.287811291,244.216725932,
	244.144957602,244.072503257,243.999359889,243.92552453,243.850994248,
	243.775766147,243.699837372,243.623205106,243.545866572,243.467819032,
	243.389059786,243.309586179,243.229395592,243.148485449,243.066853216,
	242.984496398,242.901412546,242.817599248,242.733054138,242.647774892,
	242.561759227,242.475004906,242.387509732,242.299271553,242.210288262,
	242.120557793,242.030078124,241.938847279,241.846863324,241.754124371,
	241.660628575,241.566374134,241.471359294,241.375582341,241.279041608,
	241.181735472,241.083662355,240.984820721,240.885209081,240.784825989,
	240.683670043,240.581739885,240.479034203,240.375551726,240.271291229,
	240.166251531,240.060431493,239.95383002,239.846446061,239.738278607,
	239.629326695,239.5195894,239.409065844,239.29775519,239.185656641,
	239.072769446,238.959092892,238.84462631,238.729369072,238.61332059,
	238.496480317,238.378847747,238.260422414,238.141203892,238.021191795,
	237.900385775,237.778785524,237.656390773,237.533201291,237.409216884,
	237.284437398,237.158862715,237.032492753,236.905327469,236.777366855,
	236.648610938,236.519059783,236.388713489,236.257572188,236.125636051,
	235.992905278,235.859380107,235.725060807,235.58994768,235.454041062,
	235.31734132,235.179848852,235.041564089,234.902487493,234.762619556,
	234.6219608,234.480511776,234.338273067,234.195245283,234.051429062,
	233.906825072,233.761434008,233.615256591,233.468293572,233.320545726,
	233.172013855,233.022698786,232.872601372,232.721722492,232.570063047,
	232.417623965,232.264406196,232.110410713,231.955638512,231.800090614,
	231.643768059,231.48667191,231.328803251,231.170163188,231.010752847,
	230.850573373,230.689625933,230.527911712,230.365431915,230.202187764,
	230.0381805,229.873411384,229.707881693,229.541592719,229.374545774,
	229.206742186,229.038183299,228.868870471,228.698805078,228.527988509,
	228.356422169,228.184107477,228.011045867,227.837238785,227.662687692,
	227.487394061,227.311359378,227.134585141,226.957072863,226.778824064,
	226.59984028,226.420123056,226.239673947,226.058494521,225.876586355,
	225.693951036,225.510590161,225.326505336,225.141698178,224.956170309,
	224.769923365,224.582958985,224.39527882,224.206884527,224.017777772,
	223.827960226,223.637433569,223.446199487,223.254259674,223.061615828,
	222.868269655,222.674222866,222.479477179,222.284034315,222.087896002,
	221.891063973,221.693539966,221.495325721,221.296422987,221.096833513,
	220.896559053,220.695601367,220.493962216,220.291643365,220.088646583,
	219.884973642,219.680626315,219.475606381,219.269915618,219.063555809,
	218.856528737,218.64883619,218.440479954,218.231461819,218.021783577,
	217.811447019,217.600453941,217.388806137,217.176505402,216.963553533,
	216.749952328,216.535703584,216.3208091,216.105270675,215.889090106,
	215.672269193,215.454809735,215.23671353,215.017982376,214.798618071,
	214.578622412,214.357997196,214.136744219,213.914865275,213.692362159,
	213.469236664,213.245490582,213.021125704,212.796143819,212.570546714,
	212.344336178,212.117513994,211.890081946,211.662041815,211.433395383,
	211.204144425,210.97429072,210.74383604,210.512782158,210.281130844,
	210.048883865,209.816042987,209.582609974,209.348586585,209.113974579,
	208.878775712,208.642991738,208.406624407,208.169675468,207.932146665,
	207.694039743,207.455356441,207.216098496,206.976267643,206.735865613,
	206.494894135,206.253354936,206.011249738,205.76858026,205.52534822,
	205.281555332,205.037203306,204.792293851,204.54682867,204.300809466,
	204.054237936,203.807115776,203.559444679,203.311226332,203.062462422,
	202.813154631,202.563304638,202.312914121,202.06198475,201.810518197,
	201.558516128,201.305980206,201.05291209,200.799313438,200.545185904,
	200.290531137,200.035350786,199.779646493,199.5234199,199.266672645,
	199.009406363,198.751622683,198.493323236,198.234509646,197.975183536,
	197.715346523,197.455000226,197.194146256,196.932786223,196.670921736,
	196.408554398,196.145685811,195.882317572,195.618451279,195.354088524,
	195.089230896,194.823879985,194.558037374,194.291704646,194.024883381,
	193.757575156,193.489781546,193.221504124,192.952744459,192.68350412,
	192.413784672,192.143587679,191.872914702,191.601767301,191.330147033,
	191.058055454,190.785494118,190.512464577,190.238968382,189.965007082,
	189.690582224,189.415695355,189.14034802,188.864541763,188.588278126,
	188.311558653,188.034384883,187.756758358,187.478680617,187.200153199,
	186.921177645,186.641755492,186.36188828,186.081577548,185.800824834,
	185.519631679,185.237999622,184.955930205,184.673424969,184.390485457,
	184.107113213,183.823309782,183.539076713,183.254415552,182.969327853,
	182.683815168,182.397879052,182.111521065,181.824742767,181.537545724,
	181.249931504,180.961901678,180.673457823,180.384601519,180.095334351,
	179.805657909,179.515573788,179.225083588,178.934188917,178.642891387,
	178.351192617,178.059094236,177.766597877,177.473705181,177.1804178,
	176.886737393,176.592665628,176.298204182,176.003354745,175.708119016,
	175.412498704,175.116495531,174.820111234,174.523347558,174.226206264,
	173.92868913,173.630797944,173.332534512,173.033900658,172.734898219,
	172.435529055,172.13579504,171.835698069,171.53524006,171.234422948,
	170.933248694,170.631719279,170.32983671,170.027603019,169.725020263,
	169.422090529,169.118815931,168.815198611,168.511240746,168.206944541,
	167.902312237,167.597346111,167.292048474,166.986421676,166.680468107,
	166.374190197,166.06759042,165.760671293,165.453435381,165.145885296,
	164.8380237,164.529853307,164.221376886,163.912597261,163.603517315,
	163.294139991,162.984468296,162.674505303,162.36425415,162.05371805,
	161.742900285,161.431804217,161.120433284,160.808791007,160.496880994,
	160.184706939,159.872272629,159.559581944,159.246638866,158.933447477,
	158.620011964,158.306336627,157.992425878,157.678284247,157.363916386,
	157.049327076,156.734521226,156.419503883,156.104280235,155.788855613,
	155.473235502,155.15742554,154.841431529,154.525259436,154.2089154,
	153.89240574,153.575736958,153.258915746,152.941948993,152.624843791,
	152.307607442,151.990247462,151.672771591,151.3551878,151.037504296,
	150.719729528,150.4018722,150.083941272,149.765945972,149.4478958,
	149.129800541,148.811670267,148.493515348,148.17534646,147.857174591,
	147.539011052,147.220867482,146.90275586,146.584688509,146.266678104,
	145.948737684,145.630880657,145.313120806,144.995472301,144.677949704,
	144.360567975,144.043342481,143.726289002,143.409423738,143.092763314,
	142.776324787,142.46012565,142.144183838,141.828517734,141.513146167,
	141.198088421,140.883364237,140.56899381,140.254997798,139.941397314,
	139.628213931,139.31546968,139.003187046,138.691388964,138.380098818,
	138.069340432,137.759138065,137.449516402,137.140500548,136.832116012,
	136.524388701,136.217344903,135.911011273,135.605414819,135.300582882,
	134.99654312,134.693323486,134.390952204,134.089457749,133.788868823,
	133.489214324,133.190523322,132.89282503,132.596148773,132.300523955,
	132.005980028,131.712546456,131.420252683,131.129128093,130.839201977,
	130.550503492,130.263061625,129.97690515,129.692062595,129.408562198,
	129.126431866,128.845699141,128.566391153,128.288534586,128.012155639,
	127.737279983,127.463932729,127.19213839,126.921920841,126.653303293,
	126.386308253,126.120957494,125.857272028,125.595272075,125.334977038,
	125.076405477,124.819575089,124.564502686,124.311204176,124.059694549,
	123.809987864,123.562097233,123.316034816,123.071811813,122.829438459,
	122.588924021,122.3502768,122.113504129,121.878612383,121.645606978,
	121.414492385,121.185272137,120.957948844,120.732524201,120.508999009,
	120.287373188,120.067645798,119.849815055,119.633878355,119.419832294,
	119.207672691,118.997394612,118.788992394,118.582459671,118.377789395,
	118.174973871,117.974004772,117.774873176,117.577569586,117.382083958,
	117.188405731,116.996523847,116.806426787,116.618102586,116.431538869,
	116.246722869,116.063641457,115.882281163,115.702628206,115.524668508,
	115.348387726,115.173771271,115.000804328,114.82947188,114.659758727,
	114.491649506,114.325128711,114.160180708,113.996789759,113.834940032,
	113.674615621,113.515800563,113.358478849,113.20263444,113.048251282,
	112.895313317,112.743804495,112.593708787,112.445010196,112.297692766,
	112.151740591,112.007137828,111.863868702,111.721917517,111.581268659,
	111.441906608,111.303815943,111.166981347,111.031387613,110.897019652,
	110.763862493,110.63190129,110.501121329,110.371508026,110.243046933,
	110.115723745,109.989524294,109.864434561,109.740440669,109.617528892,
	109.495685656,109.374897534,109.255151254,109.1364337,109.018731905,
	108.902033061,108.786324515,108.671593767,108.557828476,108.445016453,
	108.333145667,108.222204241,108.112180452,108.003062732,107.894839664,
	107.787499986,107.681032587,107.575426505,107.470670928,107.366755194,
	107.263668787,107.161401337,107.059942619,106.959282552,106.859411195,
	106.760318751,106.661995559,106.564432098,106.467618982,106.37154696,
	106.276206914,106.181589858,106.087686935,105.994489418,105.901988705,
	105.81017632,105.719043911,105.628583246,105.538786217,105.44964483,
	105.361151211,105.273297602,105.186076356,105.09947994,105.013500931,
	104.928132016,104.843365988,104.759195746,104.675614294,104.592614738,
	104.510190286,104.428334244,104.347040018,104.266301109,104.186111115,
	104.106463726,104.027352725,103.948771984,103.870715468,103.793177227,
	103.716151398,103.639632204,103.563613952,103.48809103,103.41305791,
	103.33850914,103.26443935,103.190843246,103.117715611,103.045051301,
	102.972845249,102.901092457,102.829788,102.758927024,102.688504742,
	102.618516438,102.54895746,102.479823222,102.411109205,102.342810952,
	102.274924068,102.207444221,102.140367139,102.07368861,102.007404481,
	101.941510654,101.876003092,101.810877811,101.746130883,101.681758433,
	101.617756641,101.554121738,101.490850007,101.427937781,101.365381444,
	101.303177428,101.241322214,101.179812331,101.118644352,101.057814898,
	100.997320637,100.937158279,100.877324577,100.817816329,100.758630377,
	100.6997636,100.641212922,100.582975306,100.525047756,100.467427312,
	100.410111057,100.353096108,100.296379621,100.23995879,100.183830844,
	100.127993045,100.072442696,100.017177128,99.9621937113,99.9074898464,
	99.8530629679,99.7989105427,99.7450300696,99.6914190787,99.6380751312,
	99.5849958187,99.5321787628,99.4796216147,99.4273220547,99.3752777916,
	99.3234865625,99.2719461323,99.2206542933,99.1696088648,99.1188076924,
	99.0682486481,99.0179296296,98.9678485599,98.918003387,98.8683920837,
	98.8190126467,98.769863097,98.7209414788,98.6722458598,98.6237743302,
	98.5755250031,98.5274960135,98.4796855184,98.4320916962,98.3847127468,
	98.3375468908,98.2905923695,98.2438474444,98.1973103972,98.1509795293,
	98.1048531614,98.0589296337,98.013207305,97.9676845528,97.922359773,
	97.8772313798,97.8322978049,97.7875574979,97.7430089255,97.6986505718,
	97.6544809376,97.6104985402,97.5667019136,97.5230896077,97.4796601886,
	97.4364122381,97.3933443532,97.3504551465,97.3077432458,97.2652072933,
	97.2228459464,97.1806578767,97.1386417702,97.0967963268,97.0551202605,
	97.0136122989,96.9722711833,96.931095668,96.8900845209,96.8492365225,
	96.8085504664,96.7680251586,96.7276594179,96.687452075,96.6474019731,
	96.6075079673,96.5677689244,96.528183723,96.4887512533,96.4494704166,
	96.4103401258,96.3713593045,96.3325268876,96.2938418206,96.2553030595,
	96.2169095712,96.1786603327,96.1405543314,96.1025905648,96.0647680402,
	96.0270857751,95.9895427965,95.9521381411,95.9148708551,95.8777399941,
	95.840744623,95.8038838156,95.767156655,95.7305622332,95.6940996508,
	95.6577680174,95.621566451,95.5854940781,95.5495500336,95.5137334607,
	95.4780435108,95.4424793434,95.4070401257,95.3717250333,95.3365332491,
	95.3014639639,95.2665163763,95.231689692,95.1969831244,95.1623958942,
	95.1279272293,95.0935763647,95.0593425426,95.0252250121,94.9912230293,
	94.957335857,94.9235627648,94.889903029,94.8563559325,94.8229207646,
	94.7895968211,94.7563834042,94.7232798225,94.6902853904,94.6573994289,
	94.6246212649,94.5919502312,94.5593856666,94.5269269159,94.4945733296,
	94.4623242638,94.4301790804,94.398137147,94.3661978366,94.3343605276,
	94.3026246041,94.2709894553,94.2394544758,94.2080190654,94.1766826291,
	94.145444577,94.1143043243,94.0832612913,94.052314903,94.0214645895,
	93.9907097857,93.9600499313,93.9294844707,93.899012853,93.8686345319,
	93.8383489659,93.8081556177,93.7780539548,93.7480434489,93.7181235762,
	93.6882938173,93.658553657,93.6289025843,93.5993400927,93.5698656795,
	93.5404788464,93.5111790989,93.4819659468,93.4528389037,93.4237974873,
	93.3948412191,93.3659696245,93.3371822327,93.3084785767,93.2798581933,
	93.2513206229,93.2228654096,93.1944921013,93.1662002492,93.1379894083,
	93.109859137,93.0818089971,93.0538385542,93.0259473769,92.9981350374,
	92.9704011112,92.9427451771,92.9151668171,92.8876656167,92.8602411644,
	92.8328930518,92.8056208739,92.7784242286,92.7513027171,92.7242559433,
	92.6972835146,92.670385041,92.6435601356,92.6168084145,92.5901294966,
	92.5635230038,92.5369885607,92.5105257949,92.4841343366,92.4578138189,
	92.4315638777,92.4053841514,92.3792742812,92.353233911,92.3272626873,
	92.3013602592,92.2755262785,92.2497603994,92.2240622787,92.1984315757,
	92.1728679522,92.1473710724,92.1219406032,92.0965762136,92.0712775751,
	92.0460443617,92.0208762495,91.9957729173,91.9707340457,91.9457593182,
	91.9208484199,91.8960010388,91.8712168645,91.8464955894,91.8218369075,
	91.7972405155,91.7727061118,91.7482333973,91.7238220746,91.6994718488,
	91.6751824268,91.6509535176,91.6267848322,91.6026760837,91.5786269871,
	91.5546372594,91.5307066197,91.5068347888,91.4830214895,91.4592664466,
	91.4355693866,91.4119300382,91.3883481315,91.3648233988,91.3413555741,
	91.3179443931,91.2945895935,91.2712909146,91.2480480975,91.224860885,
	91.2017290219,91.1786522542,91.1556303301,91.1326629992,91.1097500128,
	91.086891124,91.0640860873,91.041334659,91.0186365969,90.9959916605,
	90.9733996109,90.9508602106,90.9283732238,90.9059384162,90.883555555,
	90.8612244091,90.8389447485,90.8167163451,90.7945389721,90.7724124041,
	90.7503364174,90.7283107894,90.7063352991,90.6844097271,90.6625338551,
	90.6407074663,90.6189303453,90.5972022781,90.5755230521,90.5538924558,
	90.5323102793,90.510776314,90.4892903525,90.4678521887,90.4464616179,
	90.4251184365,90.4038224425,90.3825734349,90.3613712139,90.3402155812,
	90.3191063395,90.2980432928,90.2770262463,90.2560550065,90.2351293809,
	90.2142491783,90.1934142087,90.1726242833,90.1518792142,90.131178815,
	90.1105229001,90.0899112853,90.0693437874,90.0488202242,90.0283404148,
	90.0079041793,89.9875113389,89.9671617157,89.9468551333,89.9265914158,
	89.9063703888,89.8861918787,89.866055713,89.8459617203,89.82590973,
	89.8058995729,89.7859310803,89.7660040849,89.7461184202,89.7262739206,
	89.7064704218,89.68670776,89.6669857728,89.6473042984,89.6276631762,
	89.6080622464,89.5885013501,89.5689803294,89.5494990274,89.5300572878,
	89.5106549554,89.491291876,89.4719678961,89.4526828632,89.4334366256,
	89.4142290324,89.3950599338,89.3759291805,89.3568366244,89.3377821181,
	89.3187655149,89.2997866691,89.2808454357,89.2619416708,89.2430752308,
	89.2242459734,89.2054537569,89.1866984403,89.1679798835,89.1492979471,
	89.1306524926,89.1120433823,89.0934704789,89.0749336464,89.056432749,
	89.0379676522,89.0195382218,89.0011443245,88.9827858277,88.9644625997,
	88.9461745092,88.927921426,88.9097032202,88.8915197629,88.8733709258,
	88.8552565813,88.8371766024,88.8191308631,88.8011192377,88.7831416014,
	88.7651978299,88.7472877998,88.7294113881,88.7115684728,88.6937589321,
	88.6759826453,88.658239492,88.6405293526,88.6228521081,88.6052076402,
	88.5875958312,88.5700165638,88.5524697217,88.5349551889,88.5174728501,
	88.5000225908,88.4826042968,88.4652178545,88.4478631513,88.4305400746,
	88.413248513,88.3959883551,88.3787594905,88.3615618091,88.3443952016,
	88.3272595591,88.3101547733,88.2930807364,88.2760373414,88.2590244815,
	88.2420420507,88.2250899434,88.2081680546,88.1912762799,88.1744145152,
	88.1575826573,88.1407806031,88.1240082504,88.1072654973,88.0905522424,
	88.0738683849,88.0572138245,88.0405884613,88.0239921962,88.0074249301,
	87.9908865649,87.9743770026,87.9578961459,87.941443898,87.9250201625,
	87.9086248434,87.8922578454,87.8759190734,87.859608433,87.8433258301,
	87.8270711713,87.8108443633,87.7946453135,87.7784739298,87.7623301204,
	87.746213794,87.7301248597,87.7140632271,87.6980288064,87.6820215078,
	87.6660412424,87.6500879215,87.6341614567,87.6182617604,87.6023887451,
	87.5865423238,87.57072241,87.5549289176,87.5391617608,87.5234208543,
	87.5077061131,87.4920174528,87.4763547894,87.4607180389,87.4451071183,
	87.4295219444,87.4139624349,87.3984285076,87.3829200807,87.3674370729,
	87.3519794032,87.3365469909,87.321139756,87.3057576185,87.2904004989,
	87.2750683183,87.2597609977,87.2444784589,87.2292206238,87.2139874149,
	87.1987787547,87.1835945665,87.1684347736,87.1532992998,87.1381880693,
	87.1231010065,87.1080380363,87.0929990838,87.0779840746,87.0629929344,
	87.0480255896,87.0330819666,87.0181619923,87.0032655939,86.988392699,
	86.9735432353,86.9587171311,86.9439143149,86.9291347155,86.914378262,
	86.899644884,86.8849345112,86.8702470737,86.855582502,86.8409407267,
	86.8263216789,86.81172529,86.7971514915,86.7826002155,86.7680713942,
	86.7535649602,86.7390808462,86.7246189855,86.7101793115,86.695761758,
	86.681366259,86.6669927487,86.6526411619,86.6383114334,86.6240034983,
	86.6097172923,86.5954527509,86.5812098103,86.5669884067,86.5527884768,
	86.5386099573,86.5244527855,86.5103168987,86.4962022346,86.4821087312,
	86.4680363266,86.4539849594,86.4399545682,86.4259450922,86.4119564705,
	86.3979886428,86.3840415487,86.3701151284,86.356209322,86.3423240703,
	86.328459314,86.3146149941,86.3007910521,86.2869874293,86.2732040677,
	86.2594409093,86.2456978963,86.2319749714,86.2182720773,86.204589157,
	86.1909261539,86.1772830113,86.1636596731,86.1500560831,86.1364721857,
	86.1229079253,86.1093632464,86.0958380941,86.0823324135,86.0688461498,
	86.0553792488,86.0419316561,86.0285033179,86.0150941804,86.0017041901,
	85.9883332936,85.9749814379,85.9616485701,85.9483346376,85.935039588,
	85.9217633689,85.9085059285,85.8952672149,85.8820471765,85.868845762,
	85.8556629201,85.8424986001,85.829352751,85.8162253223,85.8031162638,
	85.7900255253,85.7769530568,85.7638988086,85.7508627312,85.7378447752,
	85.7248448915,85.7118630312,85.6988991455,85.6859531858,85.6730251039,
	85.6601148515,85.6472223807,85.6343476437,85.6214905929,85.608651181,
	85.5958293606,85.5830250847,85.5702383066,85.5574689796,85.5447170572,
	85.531982493,85.5192652411,85.5065652554,85.4938824903,85.4812169001,
	85.4685684394,85.4559370631,85.4433227262,85.4307253837,85.4181449909,
	85.4055815034,85.3930348768,85.380505067,85.36799203,85.3554957218,
	85.3430160989,85.3305531178,85.3181067352,85.3056769079,85.2932635929,
	85.2808667474,85.2684863287,85.2561222943,85.243774602,85.2314432095,
	85.2191280748,85.2068291561,85.1945464117,85.1822798,85.1700292797,
	85.1577948095,85.1455763484,85.1333738555,85.1211872901,85.1090166115,
	85.0968617793,85.0847227531,85.0725994929,85.0604919587,85.0484001106,
	85.036323909,85.0242633142,85.0122182869,85.0001887879,84.988174778,
	84.9761762183,84.96419307,84.9522252944,84.940272853,84.9283357074,
	84.9164138193,84.9045071507,84.8926156637,84.8807393203,84.8688780829,
	84.8570319141,84.8452007763,84.8333846323,84.821583445,84.8097971775,
	84.7980257927,84.7862692541,84.7745275251,84.7628005691,84.7510883499,
	84.7393908313,84.7277079772,84.7160397517,84.704386119,84.6927470434,
	84.6811224894,84.6695124216,84.6579168048,84.6463356037,84.6347687833,
	84.6232163088,84.6116781453,84.6001542582,84.588644613,84.5771491752,
	84.5656679107,84.5542007852,84.5427477647,84.5313088153,84.5198839031,
	84.5084729946,84.4970760562,84.4856930544,84.4743239558,84.4629687275,
	84.4516273361,84.4402997488,84.4289859327,84.4176858551,84.4063994834,
	84.395126785,84.3838677277,84.372622279,84.3613904068,84.3501720791,
	84.338967264,84.3277759297,84.3165980443,84.3054335763,84.2942824943,
	84.2831447667,84.2720203625,84.2609092503,84.2498113991,84.238726778,
	84.2276553561,84.2165971027,84.2055519872,84.194519979,84.1835010476,
	84.1724951629,84.1615022946,84.1505224125,84.1395554866,84.1286014871,
	84.1176603842,84.1067321481,84.0958167492,84.0849141581,84.0740243453,
	84.0631472816,84.0522829378,84.0414312847,84.0305922934,84.0197659349,
	84.0089521804,83.9981510014,83.987362369,83.9765862548,83.9658226305,
	83.9550714676,83.944332738,83.9336064135,83.922892466,83.9121908677,
	83.9015015907,83.8908246072,83.8801598895,83.8695074102,83.8588671416,
	83.8482390564,83.8376231274,83.8270193272,83.8164276289,83.8058480053,
	83.7952804295,83.7847248747,83.774181314,83.763649721,83.7531300688,
	83.7426223311,83.7321264815,83.7216424936,83.7111703411,83.700709998,
	83.6902614382,83.6798246356,83.6693995644,83.6589861988,83.648584513,
	83.6381944814,83.6278160785,83.6174492788,83.6070940568,83.5967503873,
	83.586418245,83.5760976048,83.5657884417,83.5554907305,83.5452044465,
	83.5349295648,83.5246660606,83.5144139094,83.5041730864,83.4939435673,
	83.4837253275,83.4735183427,83.4633225887,83.4531380413,83.4429646763,
	83.4328024696,83.4226513974,83.4125114358,83.4023825609,83.392264749,
	83.3821579764,83.3720622196,83.361977455,83.3519036592,83.3418408089,
	83.3317888807,83.3217478514,83.3117176979,83.3016983972,83.2916899262,
	83.281692262,83.2717053817,83.2617292627,83.251763882,83.2418092172,
	83.2318652457,83.2219319449,83.2120092924,83.2020972659,83.1921958431,
	83.1823050018,83.1724247198,83.162554975,83.1526957454,83.1428470091,
	83.1330087443,83.123180929,83.1133635416,83.1035565603,83.0937599636,
	83.08397373,83.0741978379,83.064432266,83.0546769929,83.0449319973,
	83.035197258,83.0254727539,83.0157584639,83.006054367,82.9963604422,
	82.9866766686,82.9770030254,82.9673394918,82.9576860472,82.9480426709,
	82.9384093423,82.9287860409,82.9191727463,82.9095694381,82.8999760959,
	82.8903926995,82.8808192286,82.8712556633,82.8617019832,82.8521581685,
	82.8426241992,82.8331000553,82.8235857171,82.8140811647,82.8045863785,
	82.7951013386,82.7856260257,82.77616042,82.7667045022,82.7572582527,
	82.7478216522,82.7383946815,82.7289773211,82.719569552,82.710171355,
	82.700782711,82.6914036009,82.6820340059,82.6726739069,82.6633232851,
	82.6539821217,82.644650398,82.6353280953,82.6260151948,82.6167116781,
	82.6074175266,82.5981327217,82.5888572452,82.5795910786,82.5703342036,
	82.5610866019,82.5518482554,82.5426191458,82.5333992551,82.5241885652,
	82.5149870582,82.505794716,82.4966115208,82.4874374547,82.4782724999,
	82.4691166388,82.4599698535,82.4508321266,82.4417034403,82.4325837772,
	82.4234731197,82.4143714505,82.4052787521,82.3961950073,82.3871201986,
	82.378054309,82.3689973211,82.3599492179,82.3509099823,82.3418795973,
	82.3328580457,82.3238453108,82.3148413756,82.3058462233,82.296859837,
	82.2878822
	};

tubetable_12AX7_1 = waveform{
	249.98706929,249.986851225,249.986629489,249.986404021,249.986174757,
	249.985941635,249.985704589,249.985463554,249.985218463,249.984969247,
	249.984715838,249.984458166,249.984196158,249.983929743,249.983658846,
	249.983383392,249.983103306,249.982818508,249.982528921,249.982234464,
	249.981935056,249.981630613,249.981321052,249.981006287,249.98068623,
	249.980360793,249.980029887,249.979693419,249.979351296,249.979003424,
	249.978649708,249.978290048,249.977924346,249.9775525,249.977174409,
	249.976789967,249.976399069,249.976001606,249.97559747,249.975186548,
	249.974768727,249.974343893,249.973911927,249.973472711,249.973026125,
	249.972572044,249.972110345,249.9716409,249.971163579,249.970678252,
	249.970184785,249.969683043,249.969172887,249.968654177,249.968126772,
	249.967590526,249.967045292,249.96649092,249.965927258,249.965354153,
	249.964771446,249.964178978,249.963576587,249.962964107,249.962341372,
	249.961708211,249.96106445,249.960409914,249.959744424,249.959067797,
	249.95837985,249.957680393,249.956969237,249.956246188,249.955511048,
	249.954763616,249.95400369,249.953231063,249.952445523,249.951646857,
	249.950834849,249.950009276,249.949169916,249.94831654,249.947448916,
	249.946566809,249.945669979,249.944758184,249.943831177,249.942888706,
	249.941930516,249.940956349,249.93996594,249.938959023,249.937935324,
	249.936894568,249.935836475,249.934760758,249.933667127,249.932555289,
	249.931424944,249.930275788,249.929107511,249.9279198,249.926712337,
	249.925484796,249.92423685,249.922968162,249.921678394,249.9203672,
	249.91903423,249.917679127,249.916301529,249.914901069,249.913477372,
	249.912030061,249.910558748,249.909063042,249.907542547,249.905996856,
	249.904425561,249.902828244,249.901204482,249.899553844,249.897875894,
	249.896170188,249.894436274,249.892673696,249.890881989,249.889060679,
	249.887209288,249.885327328,249.883414305,249.881469716,249.879493052,
	249.877483793,249.875441414,249.87336538,249.87125515,249.869110171,
	249.866929885,249.864713724,249.86246111,249.860171458,249.857844173,
	249.855478652,249.853074281,249.850630438,249.848146491,249.845621799,
	249.843055711,249.840447565,249.837796689,249.835102404,249.832364016,
	249.829580824,249.826752115,249.823877166,249.820955243,249.8179856,
	249.81496748,249.811900117,249.80878273,249.80561453,249.802394713,
	249.799122465,249.795796959,249.792417358,249.788982809,249.785492449,
	249.781945403,249.778340779,249.774677678,249.770955183,249.767172365,
	249.763328284,249.759421981,249.75545249,249.751418824,249.747319988,
	249.743154968,249.738922738,249.734622257,249.730252468,249.725812301,
	249.72130067,249.716716471,249.712058589,249.70732589,249.702517225,
	249.697631429,249.692667321,249.687623703,249.682499361,249.677293063,
	249.672003562,249.666629592,249.661169871,249.655623098,249.649987954,
	249.644263106,249.638447197,249.632538857,249.626536694,249.620439299,
	249.614245244,249.607953082,249.601561346,249.59506855,249.588473189,
	249.581773739,249.574968653,249.568056367,249.561035295,249.553903831,
	249.546660348,249.5393032,249.531830718,249.524241211,249.516532969,
	249.508704259,249.500753327,249.492678397,249.48447767,249.476149326,
	249.467691521,249.459102391,249.450380046,249.441522576,249.432528047,
	249.423394501,249.414119957,249.404702411,249.395139834,249.385430176,
	249.37557136,249.365561287,249.355397831,249.345078845,249.334602156,
	249.323965565,249.313166851,249.302203767,249.291074039,249.27977537,
	249.268305439,249.256661896,249.244842368,249.232844458,249.220665739,
	249.208303762,249.195756051,249.183020104,249.170093394,249.156973366,
	249.143657441,249.130143014,249.116427453,249.102508098,249.088382267,
	249.074047249,249.059500307,249.044738677,249.029759572,249.014560175,
	248.999137645,248.983489114,248.967611688,248.951502446,248.935158442,
	248.918576704,248.901754233,248.884688005,248.867374969,248.84981205,
	248.831996145,248.813924127,248.795592843,248.776999115,248.75813974,
	248.739011488,248.719611106,248.699935316,248.679980814,248.659744274,
	248.639222342,248.618411645,248.597308781,248.575910327,248.554212837,
	248.532212841,248.509906845,248.487291335,248.464362771,248.441117595,
	248.417552224,248.393663055,248.369446462,248.344898801,248.320016406,
	248.29479559,248.269232647,248.243323852,248.217065459,248.190453706,
	248.163484811,248.136154974,248.108460379,248.080397191,248.05196156,
	248.02314962,247.993957487,247.964381265,247.934417041,247.90406089,
	247.87330887,247.84215703,247.810601403,247.778638011,247.746262866,
	247.713471967,247.680261304,247.646626855,247.612564592,247.578070476,
	247.543140462,247.507770494,247.471956513,247.435694453,247.398980241,
	247.361809801,247.32417905,247.286083906,247.24752028,247.208484082,
	247.168971222,247.128977608,247.088499147,247.047531748,247.006071321,
	246.964113777,246.921655032,246.878691002,246.835217611,246.791230786,
	246.746726458,246.701700567,246.656149059,246.610067888,246.563453016,
	246.516300415,246.468606067,246.420365965,246.371576112,246.322232525,
	246.272331233,246.22186828,246.170839723,246.119241635,246.067070105,
	246.014321238,245.960991158,245.907076005,245.85257194,245.797475142,
	245.741781811,245.685488168,245.628590456,245.57108494,245.512967909,
	245.454235673,245.394884571,245.334910963,245.274311238,245.213081809,
	245.151219118,245.088719633,245.025579852,244.961796302,244.897365539,
	244.832284149,244.76654875,244.70015599,244.633102551,244.565385144,
	244.497000518,244.427945453,244.358216762,244.287811295,244.216725936,
	244.144957607,244.072503262,243.999359895,243.925524536,243.850994253,
	243.775766153,243.699837378,243.623205113,243.545866579,243.467819039,
	243.389059794,243.309586187,243.2293956,243.148485458,243.066853225,
	242.984496408,242.901412556,242.817599259,242.733054149,242.647774903,
	242.561759239,242.475004919,242.387509745,242.299271568,242.210288277,
	242.120557808,242.03007814,241.938847296,241.846863343,241.75412439,
	241.660628595,241.566374155,241.471359316,241.375582364,241.279041632,
	241.181735498,241.083662381,240.984820749,240.88520911,240.78482602,
	240.683670075,240.581739919,240.479034238,240.375551763,240.271291268,
	240.166251571,240.060431535,239.953830064,239.846446107,239.738278656,
	239.629326745,239.519589453,239.4090659,239.297755248,239.185656702,
	239.072769509,238.959092958,238.84462638,238.729369145,238.613320666,
	238.496480396,238.37884783,238.260422501,238.141203983,238.02119189,
	237.900385875,237.778785628,237.656390882,237.533201405,237.409217004,
	237.284437524,237.158862846,237.03249289,236.905327613,236.777367005,
	236.648611095,236.519059947,236.38871366,236.257572368,236.125636239,
	235.992905475,235.859380313,235.725061022,235.589947905,235.454041297,
	235.317341565,235.179849108,235.041564357,234.902487774,234.762619849,
	234.621961106,234.480512096,234.338273402,234.195245633,234.051429428,
	233.906825454,233.761434407,233.615257009,233.468294009,233.320546182,
	233.172014331,233.022699284,232.872601892,232.721723035,232.570063615,
	232.417624559,232.264406816,232.110411361,231.955639189,231.800091321,
	231.643768797,231.486672681,231.328804057,231.17016403,231.010753726,
	230.850574292,230.689626893,230.527912715,230.365432962,230.202188857,
	230.038181642,229.873412577,229.707882938,229.541594019,229.374547132,
	229.206743604,229.038184779,228.868872017,228.698806692,228.527990194,
	228.356423928,228.184109314,228.011047785,227.837240787,227.662689782,
	227.487396243,227.311361655,227.134587519,226.957075345,226.778826655,
	226.599842984,226.420125878,226.239676893,226.058497596,225.876589564,
	225.693954385,225.510593656,225.326508984,225.141701984,224.956174281,
	224.769927509,224.58296331,224.395283333,224.206889237,224.017782686,
	223.827965353,223.637438918,223.446205069,223.254265497,223.061621903,
	222.868275994,222.674229479,222.479484077,222.284041512,222.08790351,
	221.891071805,221.693548135,221.495334244,221.296431876,221.096842785,
	220.896568725,220.695611455,220.493972738,220.29165434,220.08865803,
	219.88498558,219.680638766,219.475619366,219.269929161,219.063569932,
	218.856543466,218.648851549,218.440495971,218.231478522,218.021800994,
	217.811465182,217.60047288,217.388825884,217.176525993,216.963575003,
	216.749974714,216.535726925,216.320833437,216.105296048,215.88911656,
	215.672296774,215.45483849,215.236743508,215.018013629,214.798650652,
	214.578656378,214.358032605,214.136781131,213.914903754,213.692402271,
	213.469278477,213.245534168,213.021171136,212.796191175,212.570596077,
	212.344387629,212.117567622,211.890137843,211.662100076,211.433456105,
	211.204207714,210.974356681,210.743904787,210.512853806,210.281205515,
	210.048961685,209.816124088,209.582694492,209.348674664,209.114066368,
	208.878871366,208.643091418,208.406728281,208.169783711,207.93225946,
	207.694157278,207.455478915,207.216226114,206.97640062,206.736004172,
	206.49503851,206.253505367,206.011406477,205.768743571,205.525518376,
	205.281732618,205.037388018,204.792486297,204.547029172,204.301018358,
	204.054455568,203.80734251,203.559680893,203.31147242,203.062718793,
	202.813421712,202.563582874,202.313203973,202.062286701,201.810832747,
	201.558843799,201.306321542,201.053267658,200.799683826,200.545571726,
	200.290933032,200.035769418,199.780082556,199.523874114,199.26714576,
	199.00989916,198.752135977,198.493857873,198.235066508,197.97576354,
	197.715950626,197.455629421,197.19480158,196.933468754,196.671632596,
	196.409294756,196.146456882,195.883120624,195.619287629,195.354959544,
	195.090138015,194.824824689,194.559021212,194.292729229,194.025950385,
	193.758686328,193.490938703,193.222709157,192.953999338,192.684810894,
	192.415145475,192.145004731,191.874390314,191.603303879,191.331747082,
	191.059721579,190.787229033,190.514271105,190.240849462,189.966965773,
	189.69262171,189.417818949,189.14255917,188.866844059,188.590675304,
	188.314054599,188.036983645,187.759464146,187.481497813,187.203086365,
	186.924231527,186.64493503,186.365198614,186.085024028,185.804413028,
	185.523367379,185.241888858,184.95997925,184.677640352,184.394873972,
	184.11168193,183.828066057,183.544028199,183.259570217,182.974693983,
	182.689401387,182.403694334,182.117574747,181.831044563,181.544105742,
	181.25676026,180.969010115,180.680857324,180.392303929,180.103351992,
	179.814003602,179.524260869,179.234125934,178.943600962,178.652688148,
	178.361389716,178.069707923,177.777645057,177.485203439,177.192385426,
	176.899193414,176.605629834,176.311697159,176.017397903,175.722734622,
	175.42770992,175.132326446,174.836586898,174.540494025,174.244050629,
	173.947259568,173.650123755,173.352646164,173.054829832,172.756677859,
	172.458193411,172.159379726,171.860240112,171.560777954,171.260996712,
	170.960899932,170.660491239,170.359774348,170.058753063,169.757431286,
	169.455813011,169.153902337,168.851703468,168.549220714,168.246458503,
	167.943421374,167.640113993,167.336541149,167.032707762,166.728618886,
	166.424279716,166.119695592,165.814872003,165.509814594,165.204529171,
	164.899021704,164.593298336,164.287365388,163.981229364,163.674896958,
	163.36837506,163.061670761,162.754791362,162.447744379,162.140537551,
	161.833178847,161.525676469,161.218038867,160.91027474,160.602393044,
	160.294403003,159.986314114,159.678136154,159.369879193,159.061553594,
	158.753170027,158.444739474,158.13627324,157.827782957,157.519280595,
	157.21077847,156.90228925,156.593825964,156.285402011,155.977031166,
	155.668727586,155.360505823,155.052380826,154.744367948,154.436482957,
	154.128742038,153.821161801,153.513759285,153.206551968,152.899557763,
	152.592795032,152.286282581,151.980039672,151.674086016,151.368441781,
	151.063127591,150.758164527,150.453574123,150.149378371,149.84559971,
	149.542261029,149.239385659,148.936997368,148.635120356,148.333779243,
	148.032999061,147.732805244,147.433223619,147.134280384,146.836002101,
	146.538415678,146.241548349,145.945427656,145.650081429,145.355537765,
	145.061825,144.768971689,144.477006578,144.185958573,143.895856717,
	143.606730155,143.318608101,143.031519811,142.745494544,142.460561528,
	142.176749925,141.894088794,141.612607053,141.33233344,141.053296478,
	140.775524432,140.499045269,140.223886626,139.950075761,139.677639521,
	139.406604303,139.13699601,138.86884002,138.602161147,138.336983605,
	138.073330973,137.811226163,137.550691387,137.291748127,137.034417106,
	136.778718261,136.524670718,136.272292766,136.021601842,135.772614503,
	135.525346418,135.279812345,135.036026122,134.79400066,134.553747926,
	134.315278945,134.078603792,133.843731591,133.610670518,133.379427799,
	133.150009719,132.922421627,132.696667945,132.472752176,132.25067692,
	132.030443888,131.812053912,131.595506968,131.380802191,131.167937895,
	130.956911595,130.747720026,130.540359167,130.334824266,130.13110986,
	129.929209804,129.729117294,129.53082489,129.334324549,129.139607641,
	128.946664984,128.755486867,128.566063074,128.378382911,128.192435235,
	128.008208475,127.82569066,127.644869442,127.465732122,127.288265674,
	127.112456765,126.938291784,126.765756859,126.594837879,126.425520519,
	126.257790258,126.091632396,125.92703208,125.763974314,125.602443985,
	125.442425874,125.283904673,125.126865007,124.971291439,124.817168494,
	124.664480664,124.51321243,124.363348265,124.214872655,124.067770102,
	123.922025141,123.777622345,123.634546339,123.492781803,123.352313488,
	123.213126215,123.075204892,122.938534511,122.803100162,122.668887034,
	122.535880424,122.404065739,122.273428504,122.143954363,122.015629084,
	121.888438563,121.76236883,121.637406044,121.513536504,121.390746648,
	121.269023054,121.148352444,121.028721683,120.910117783,120.792527903,
	120.675939349,120.560339577,120.445716191,120.332056945,120.219349742,
	120.107582636,119.996743831,119.886821679,119.777804682,119.669681491,
	119.562440905,119.45607187,119.350563481,119.245904975,119.142085739,
	119.039095299,118.936923328,118.835559639,118.734994187,118.635217064,
	118.536218503,118.437988872,118.340518677,118.243798555,118.147819277,
	118.052571748,117.958046998,117.864236189,117.771130609,117.678721671,
	117.587000912,117.495959991,117.405590688,117.315884902,117.226834649,
	117.138432063,117.050669391,116.963538993,116.87703334,116.791145014,
	116.705866704,116.621191207,116.537111424,116.453620361,116.370711124,
	116.288376922,116.206611062,116.125406949,116.044758083,115.964658061,
	115.885100572,115.806079397,115.727588408,115.649621564,115.572172916,
	115.495236596,115.418806826,115.342877908,115.267444229,115.192500255,
	115.118040534,115.04405969,114.970552425,114.89751352,114.824937826,
	114.752820271,114.681155856,114.60993965,114.539166794,114.4688325,
	114.398932045,114.329460774,114.260414097,114.191787491,114.123576494,
	114.055776708,113.988383796,113.921393483,113.854801553,113.788603846,
	113.722796265,113.657374766,113.592335361,113.527674118,113.463387161,
	113.399470663,113.335920853,113.27273401,113.209906463,113.147434593,
	113.085314829,113.023543648,112.962117574,112.901033179,112.840287082,
	112.779875944,112.719796474,112.660045423,112.600619585,112.541515797,
	112.482730939,112.42426193,112.36610573,112.308259341,112.250719802,
	112.19348419,112.136549623,112.079913253,112.023572271,111.967523904,
	111.911765414,111.856294098,111.801107289,111.746202353,111.691576689,
	111.637227729,111.583152939,111.529349816,111.475815888,111.422548715,
	111.369545886,111.316805023,111.264323773,111.212099817,111.160130862,
	111.108414643,111.056948924,111.005731497,110.954760178,110.904032814,
	110.853547274,110.803301456,110.75329328,110.703520696,110.653981674,
	110.60467421,110.555596324,110.50674606,110.458121485,110.409720688,
	110.361541782,110.313582902,110.265842202,110.218317863,110.171008082,
	110.123911081,110.077025099,110.030348399,109.983879261,109.937615986,
	109.891556896,109.845700329,109.800044645,109.754588221,109.709329453,
	109.664266754,109.619398556,109.57472331,109.530239481,109.485945553,
	109.441840028,109.397921423,109.354188272,109.310639125,109.267272548,
	109.224087122,109.181081447,109.138254133,109.095603809,109.053129118,
	109.010828717,108.968701278,108.926745487,108.884960045,108.843343665,
	108.801895077,108.760613021,108.719496253,108.67854354,108.637753663,
	108.597125417,108.556657609,108.516349056,108.476198591,108.436205057,
	108.39636731,108.356684217,108.317154657,108.277777521,108.238551712,
	108.199476141,108.160549735,108.121771427,108.083140165,108.044654905,
	108.006314614,107.96811827,107.930064861,107.892153386,107.854382852,
	107.816752278,107.77926069,107.741907128,107.704690637,107.667610274,
	107.630665104,107.593854203,107.557176653,107.520631548,107.48421799,
	107.447935087,107.41178196,107.375757736,107.339861549,107.304092545,
	107.268449875,107.2329327,107.197540188,107.162271514,107.127125864,
	107.092102428,107.057200405,107.022419004,106.987757437,106.953214926,
	106.9187907,106.884483995,106.850294054,106.816220127,106.78226147,
	106.748417348,106.714687031,106.681069796,106.647564927,106.614171713,
	106.580889453,106.547717448,106.514655009,106.48170145,106.448856093,
	106.416118267,106.383487304,106.350962545,106.318543335,106.286229026,
	106.254018974,106.221912543,106.189909101,106.158008021,106.126208684,
	106.094510473,106.06291278,106.031414999,106.000016532,105.968716784,
	105.937515166,105.906411094,105.87540399,105.844493279,105.813678393,
	105.782958766,105.752333841,105.721803061,105.691365878,105.661021745,
	105.630770122,105.600610472,105.570542264,105.540564971,105.51067807,
	105.480881041,105.451173372,105.421554551,105.392024073,105.362581436,
	105.333226143,105.3039577,105.274775617,105.245679411,105.216668597,
	105.1877427,105.158901246,105.130143764,105.101469788,105.072878857,
	105.04437051,105.015944294,104.987599757,104.959336451,104.931153932,
	104.903051759,104.875029495,104.847086706,104.819222962,104.791437835,
	104.763730902,104.736101743,104.708549941,104.681075081,104.653676754,
	104.626354551,104.599108068,104.571936905,104.544840663,104.517818946,
	104.490871364,104.463997527,104.437197048,104.410469545,104.383814638,
	104.357231948,104.330721102,104.304281728,104.277913457,104.251615922,
	104.225388761,104.199231613,104.173144119,104.147125925,104.121176677,
	104.095296026,104.069483624,104.043739125,104.018062189,103.992452474,
	103.966909643,103.941433361,103.916023296,103.890679118,103.865400498,
	103.840187112,103.815038637,103.789954751,103.764935137,103.739979478,
	103.715087461,103.690258774,103.665493107,103.640790154,103.616149609,
	103.59157117,103.567054536,103.542599408,103.51820549,103.493872487,
	103.469600108,103.445388062,103.42123606,103.397143817,103.373111047,
	103.34913747,103.325222804,103.301366771,103.277569095,103.253829501,
	103.230147716,103.206523469,103.182956493,103.159446518,103.13599328,
	103.112596516,103.089255964,103.065971363,103.042742456,103.019568986,
	102.996450698,102.97338734,102.950378659,102.927424406,102.904524334,
	102.881678195,102.858885746,102.836146742,102.813460943,102.790828108,
	102.768247999,102.74572038,102.723245015,102.700821671,102.678450115,
	102.656130116,102.633861446,102.611643877,102.589477183,102.567361139,
	102.545295522,102.523280109,102.501314681,102.479399019,102.457532905,
	102.435716122,102.413948457,102.392229695,102.370559624,102.348938035,
	102.327364716,102.305839461,102.284362062,102.262932314,102.241550013,
	102.220214956,102.198926941,102.177685768,102.156491237,102.135343152,
	102.114241314,102.093185529,102.072175603,102.051211342,102.030292555,
	102.009419051,101.98859064,101.967807134,101.947068347,101.926374091,
	101.905724182,101.885118436,101.864556671,101.844038704,101.823564356,
	101.803133447,101.782745799,101.762401235,101.742099578,101.721840653,
	101.701624287,101.681450305,101.661318537,101.641228811,101.621180958,
	101.601174808,101.581210193,101.561286947,101.541404903,101.521563896,
	101.501763763,101.482004341,101.462285466,101.442606979,101.422968719,
	101.403370526,101.383812242,101.36429371,101.344814774,101.325375276,
	101.305975064,101.286613983,101.267291879,101.248008601,101.228763999,
	101.20955792,101.190390216,101.171260738,101.152169339,101.133115871,
	101.114100189,101.095122146,101.076181599,101.057278403,101.038412416,
	101.019583497,101.000791503,100.982036294,100.96331773,100.944635673,
	100.925989984,100.907380526,100.888807163,100.870269758,100.851768177,
	100.833302284,100.814871947,100.796477033,100.778117409,100.759792944,
	100.741503507,100.723248969,100.705029199,100.68684407,100.668693453,
	100.650577222,100.632495249,100.614447409,100.596433577,100.578453629,
	100.56050744,100.542594887,100.524715848,100.506870202,100.489057826,
	100.471278601,100.453532406,100.435819123,100.418138632,100.400490816,
	100.382875557,100.365292739,100.347742246,100.330223961,100.312737771,
	100.29528356,100.277861215,100.260470623,100.243111672,100.225784249,
	100.208488243,100.191223543,100.17399004,100.156787623,100.139616184,
	100.122475614,100.105365804,100.088286649,100.07123804,100.054219871,
	100.037232038,100.020274434,100.003346955,99.9864494965,99.9695819554,
	99.9527442284,99.935936213,99.9191578071,99.9024089092,99.8856894183,
	99.8689992338,99.8523382559,99.8357063851,99.8191035222,99.8025295689,
	99.7859844271,99.7694679993,99.7529801885,99.7365208981,99.7200900321,
	99.7036874949,99.6873131914,99.6709670269,99.6546489073,99.6383587388,
	99.6220964281,99.6058618826,99.5896550097,99.5734757178,99.5573239152,
	99.5411995111,99.5251024148,99.5090325364,99.492989786,99.4769740745,
	99.460985313,99.4450234132,99.4290882872,99.4131798474,99.3972980067,
	99.3814426785,99.3656137764,99.3498112147,99.3340349078,99.3182847708,
	99.3025607191,99.2868626683,99.2711905347,99.2555442348,99.2399236857,
	99.2243288047,99.2087595095,99.1932157183,99.1776973497,99.1622043225,
	99.146736556,99.1312939699,99.1158764842,99.1004840195,99.0851164964,
	99.0697738362,99.0544559603,99.0391627907,99.0238942497,99.0086502598,
	98.993430744,98.9782356258,98.9630648287,98.9479182768,98.9327958945,
	98.9176976065,98.902623338,98.8875730143,98.8725465613,98.857543905,
	98.8425649718,98.8276096887,98.8126779826,98.7977697811,98.7828850119,
	98.7680236031,98.7531854831,98.7383705808,98.7235788251,98.7088101455,
	98.6940644717,98.6793417336,98.6646418617,98.6499647867,98.6353104394,
	98.6206787511,98.6060696534,98.5914830783,98.5769189578,98.5623772246,
	98.5478578113,98.533360651,98.5188856772,98.5044328236,98.490002024,
	98.4755932127,98.4612063243,98.4468412937,98.4324980559,98.4181765464,
	98.4038767009,98.3895984552,98.3753417457,98.361106509,98.3468926817,
	98.332700201,98.3185290043,98.3043790291,98.2902502134,98.2761424952,
	98.2620558131,98.2479901058,98.2339453121,98.2199213714,98.205918223,
	98.1919358068,98.1779740627,98.164032931,98.1501123522,98.136212267,
	98.1223326165,98.108473342,98.0946343849,98.080815687,98.0670171904,
	98.0532388372,98.03948057,98.0257423315,98.0120240648,97.9983257129,
	97.9846472195,97.9709885281,97.9573495827,97.9437303276,97.930130707,
	97.9165506656,97.9029901484,97.8894491003,97.8759274667,97.8624251931,
	97.8489422254,97.8354785095,97.8220339916,97.8086086182,97.795202336,
	97.7818150918,97.7684468328,97.7550975062,97.7417670596,97.7284554407,
	97.7151625976,97.7018884783,97.6886330313,97.6753962052,97.6621779488,
	97.648978211,97.6357969412,97.6226340887,97.6094896032,97.5963634346,
	97.5832555327,97.570165848,97.5570943308,97.5440409318,97.5310056019,
	97.5179882919,97.5049889533,97.4920075374,97.4790439958,97.4660982804,
	97.4531703431,97.4402601362,97.427367612,97.4144927232,97.4016354224,
	97.3887956627,97.3759733971,97.3631685791,97.350381162,97.3376110997,
	97.3248583459,97.3121228548,97.2994045805,97.2867034775,97.2740195003,
	97.2613526038,97.2487027429,97.2360698727,97.2234539485,97.2108549257,
	97.1982727601,97.1857074075,97.1731588237,97.1606269651,97.1481117878,
	97.1356132485,97.1231313037,97.1106659104,97.0982170254,97.0857846061,
	97.0733686096,97.0609689935,97.0485857155,97.0362187333,97.0238680049,
	97.0115334885,96.9992151424,96.9869129251,96.974626795,96.9623567111,
	96.9501026322,96.9378645174,96.925642326,96.9134360174,96.901245551,
	96.8890708866,96.8769119841,96.8647688034,96.8526413048,96.8405294484,
	96.8284331947,96.8163525044,96.8042873382,96.792237657,96.7802034217,
	96.7681845937,96.7561811342,96.7441930046,96.7322201667,96.7202625821,
	96.7083202128,96.6963930208,96.6844809683,96.6725840175,96.660702131,
	96.6488352713,96.6369834012,96.6251464835,96.6133244813,96.6015173576,
	96.5897250758,96.5779475993,96.5661848916,96.5544369164,96.5427036375,
	96.5309850188,96.5192810244,96.5075916186,96.4959167655,96.4842564298,
	96.472610576,96.4609791688,96.449362173,96.4377595536,96.4261712758,
	96.4145973047,96.4030376057,96.3914921443,96.379960886,96.3684437966,
	96.3569408419,96.3454519879,96.3339772007,96.3225164464,96.3110696914,
	96.2996369022,96.2882180452,96.2768130873,96.2654219951,96.2540447357,
	96.242681276,96.2313315832,96.2199956245,96.2086733674,96.1973647793,
	96.1860698279,96.1747884809,96.1635207061,96.1522664715,96.1410257451,
	96.1297984951,96.1185846898,96.1073842976,96.096197287,96.0850236266,
	96.0738632851,96.0627162315,96.0515824345,96.0404618634,96.0293544871,
	96.018260275,96.0071791965,95.9961112211,95.9850563182,95.9740144577,
	95.9629856092,95.9519697427,95.9409668282,95.9299768358,95.9189997356,
	95.908035498,95.8970840934,95.8861454923,95.8752196653,95.8643065831,
	95.8534062165,95.8425185365,95.8316435139,95.82078112,95.8099313258,
	95.7990941028,95.7882694223,95.7774572558,95.7666575748,95.7558703512,
	95.7450955566,95.7343331628,95.723583142,95.7128454661,95.7021201073,
	95.6914070379,95.6807062301,95.6700176564,95.6593412894,95.6486771016,
	95.6380250658,95.6273851547,95.6167573413,95.6061415985,95.5955378994,
	95.5849462171,95.5743665249,95.5637987962,95.5532430042,95.5426991226,
	95.532167125,95.521646985,95.5111386764,95.500642173,95.4901574488,
	95.4796844778,95.4692232342,95.4587736921,95.4483358257,95.4379096096,
	95.4274950181,95.4170920257,95.406700607,95.3963207368,95.3859523898,
	95.375595541,95.3652501651,95.3549162373,95.3445937326,95.3342826263,
	95.3239828935,95.3136945097,95.3034174503,95.2931516907,95.2828972066,
	95.2726539735,95.2624219673,95.2522011637,95.2419915386,95.231793068,
	95.221605728,95.2114294947,95.2012643442,95.1911102528,95.1809671969,
	95.1708351529,95.1607140973,95.1506040066,95.1405048576,95.1304166269,
	95.1203392913,95.1102728277,95.100217213,95.0901724243,95.0801384386,
	95.070115233,95.0601027849,95.0501010715,95.0401100701,95.0301297583,
	95.0201601135,95.0102011132,95.0002527353,94.9903149573,94.9803877571,
	94.9704711125,94.9605650015,94.950669402,94.9407842921,94.93090965,
	94.9210454538,94.9111916818,94.9013483124,94.8915153239,94.8816926948,
	94.8718804037,94.8620784292,94.8522867499,94.8425053445,94.8327341919,
	94.8229732709,94.8132225604,94.8034820394,94.793751687,94.7840314824,
	94.7743214046,94.7646214329,94.7549315467,94.7452517252,94.7355819481,
	94.7259221946,94.7162724445,94.7066326773,94.6970028726,94.6873830104,
	94.6777730702,94.6681730321,94.658582876,94.6490025817,94.6394321295,
	94.6298714993,94.6203206714,94.610779626,94.6012483433,94.5917268037,
	94.5822149877,94.5727128756,94.563220448,94.5537376855,94.5442645687,
	94.5348010783,94.525347195,94.5159028997,94.5064681732,94.4970429965,
	94.4876273505,94.4782212162,94.4688245748,94.4594374074,94.4500596952,
	94.4406914195,94.4313325615,94.4219831026,94.4126430243,94.403312308,
	94.3939909353,94.3846788878,94.375376147,94.3660826947,94.3567985126,
	94.3475235826,94.3382578864,94.329001406,94.3197541234,94.3105160205,
	94.3012870794,94.2920672823,94.2828566112,94.2736550485,94.2644625763,
	94.255279177,94.2461048331,94.2369395268,94.2277832407,94.2186359572,
	94.2094976591,94.2003683288,94.1912479492,94.1821365028,94.1730339724,
	94.163940341,94.1548555913,94.1457797063,94.136712669,94.1276544623,
	94.1186050694,94.1095644733,94.1005326572,94.0915096044,94.082495298,
	94.0734897214,94.064492858,94.0555046911,94.0465252043,94.0375543809,
	94.0285922045,94.0196386587,94.0106937272,94.0017573936,93.9928296417,
	93.9839104552,93.974999818,93.9660977138,93.9572041267,93.9483190405,
	93.9394424393,93.9305743071,93.921714628,93.9128633861,93.9040205657,
	93.8951861508,93.8863601258,93.8775424751,93.8687331828,93.8599322335,
	93.8511396116,93.8423553016,93.8335792879,93.8248115552,93.816052088,
	93.8073008711,93.798557889,93.7898231266,93.7810965686,93.7723781999,
	93.7636680053
	};

tubetable_12AX7_rtable_0(r) = (tubetable_12AX7_0,r):rdtable;
tubetable_12AX7_rtable_1(r) = (tubetable_12AX7_1,r):rdtable;
//////////////////////////////////////////////////////////////////////////////////////////
// WARNING: Deprecated Library!!
// Read the README file in /libraries for more information
//////////////////////////////////////////////////////////////////////////////////////////
 
declare name "Faust Audio Effect Library";
declare author "Julius O. Smith (jos at ccrma.stanford.edu)";
declare copyright "Julius O. Smith III";
declare version "1.33";
declare license "STK-4.3"; // Synthesis Tool Kit 4.3 (MIT style license)
declare deprecated "This library is deprecated and is not maintained anymore. It will be removed in August 2017.";

import("filter.lib"); // dcblocker*, lowpass, filterbank, ...

// The following utilities (or equivalents) could go in music.lib:

//----------------------- midikey2hz,pianokey2hz ------------------------
midikey2hz(mk)  = 440.0*pow(2.0, (mk-69.0)/12); // MIDI key 69 = A440
pianokey2hz(pk) = 440.0*pow(2.0, (pk-49.0)/12); // piano key 49 = A440
hz2pianokey(f)  = 12*log2(f/440.0) + 49.0;
log2(x) = log(x)/log(2.0);

//---------------- cross2, bypass1, bypass2, select2stereo --------------
//
cross2 = _,_,_,_ <: _,!,_,!,!,_,!,_;

bypass1(bpc,e) = _ <: select2(bpc,(inswitch:e),_)
                 with {inswitch = select2(bpc,_,0);};

bypass2(bpc,e) = _,_ <: ((inswitch:e),_,_) : select2stereo(bpc) with {
  inswitch = _,_ : (select2(bpc,_,0), select2(bpc,_,0)) : _,_;
};

select2stereo(bpc) = cross2 : select2(bpc), select2(bpc) : _,_;

//---------------------- levelfilter, levelfilterN ----------------------
// Dynamic level lowpass filter:
//
// USAGE: levelfilter(L,freq), where
//  L    = desired level (in dB) at Nyquist limit (SR/2), e.g., -60
//  freq = corner frequency (-3dB point) usually set to fundamental freq
//
// REFERENCE:
// https://ccrma.stanford.edu/realsimple/faust_strings/Dynamic_Level_Lowpass_Filter.html
//
levelfilter(L,freq,x) = (L * L0 * x) + ((1.0-L) * lp2out(x))
with {
  L0 = pow(L,1/3);
  Lw = PI*freq/SR; // = w1 T / 2
  Lgain = Lw / (1.0 + Lw);
  Lpole2 = (1.0 - Lw) / (1.0 + Lw);
  lp2out = *(Lgain) : + ~ *(Lpole2);
};

levelfilterN(N,freq,L) = seq(i,N,levelfilter((L/N),freq));

//------------------------- speakerbp -------------------------------
// Dirt-simple speaker simulator (overall bandpass eq with observed
// roll-offs above and below the passband).
//
// Low-frequency speaker model = +12 dB/octave slope breaking to
// flat near f1. Implemented using two dc blockers in series.
//
// High-frequency model = -24 dB/octave slope implemented using a
// fourth-order Butterworth lowpass.
//
// Example based on measured Celestion G12 (12" speaker):
// speakerbp(130,5000);
//
// Requires filter.lib
//
speakerbp(f1,f2) = dcblockerat(f1) : dcblockerat(f1) : lowpass(4,f2);


//--------------------- cubicnl(drive,offset) -----------------------
// Cubic nonlinearity distortion
//
// USAGE: cubicnl(drive,offset), where
//   drive  = distortion amount, between 0 and 1
//   offset = constant added before nonlinearity to give even harmonics
//            Note: offset can introduce a nonzero mean - feed
//            cubicnl output to dcblocker to remove this.
//
// REFERENCES:
//   https://ccrma.stanford.edu/~jos/pasp/Cubic_Soft_Clipper.html
//   https://ccrma.stanford.edu/~jos/pasp/Nonlinear_Distortion.html
//
cubicnl(drive,offset) = *(pregain) : +(offset) : clip(-1,1) : cubic
with {
    pregain = pow(10.0,2*drive);
    clip(lo,hi) = min(hi) : max(lo);
    cubic(x) = x - x*x*x/3;
    postgain = max(1.0,1.0/pregain);
};

cubicnl_nodc(drive,offset) = cubicnl(drive,offset) : dcblocker;

//--------------------------- cubicnl_demo --------------------------
// USAGE: _ : cubicnl_demo : _;
//
cubicnl_demo = bypass1(bp,
   cubicnl_nodc(drive:smooth(0.999),offset:smooth(0.999)))
with {
   cnl_group(x)  = vgroup("CUBIC NONLINEARITY cubicnl
        [tooltip: Reference:
         https://ccrma.stanford.edu/~jos/pasp/Cubic_Soft_Clipper.html]", x);
   bp = cnl_group(checkbox("[0] Bypass
        [tooltip: When this is checked, the nonlinearity has no effect]"));
   drive = cnl_group(hslider("[1] Drive
                       [tooltip: Amount of distortion]",
                       0, 0, 1, 0.01));
   offset = cnl_group(hslider("[2] Offset
                       [tooltip: Brings in even harmonics]",
                       0, 0, 1, 0.01));
};

//------------------------------- exciter -------------------------------
// Psychoacoustic harmonic exciter, with GUI
//
// USAGE: _ : exciter : _
// REFERENCES:
//  https://secure.aes.org/forum/pubs/ebriefs/?elib=16939
//  https://www.researchgate.net/publication/258333577_Modeling_the_Harmonic_Exciter

declare exciter_name "Harmonic Exciter";
declare exciter_author "Priyanka Shekar (pshekar@ccrma.stanford.edu)";
declare exciter_copyright "Copyright (c) 2013 Priyanka Shekar";
declare exciter_version "1.0";
declare exciter_license "MIT License (MIT)";

exciter = _ <: (highpass : compressor : pregain : harmonicCreator : postgain), _ : balance with {

  compressor = bypass1(cbp,compressorMono) with {

    comp_group(x) = vgroup("COMPRESSOR  [tooltip: Reference: http://en.wikipedia.org/wiki/Dynamic_range_compression]", x);

    meter_group(x)  = comp_group(hgroup("[0]", x));
    knob_group(x)  = comp_group(hgroup("[1]", x));

    cbp = meter_group(checkbox("[0] Bypass  [tooltip: When this is checked, the compressor has no effect]"));

    gainview = compression_gain_mono(ratio,threshold,attack,release) : linear2db : meter_group(hbargraph("[1] Compressor Gain [unit:dB] [tooltip: Current gain of the compressor in dB]",-50,+10));

    displaygain = _ <: _,abs : _,gainview : attach;

    compressorMono = displaygain(compressor_mono(ratio,threshold,attack,release));

    ctl_group(x)  = knob_group(hgroup("[3] Compression Control", x));

    ratio = ctl_group(hslider("[0] Ratio [style:knob]  [tooltip: A compression Ratio of N means that for each N dB increase in input signal level above Threshold, the output level goes up 1 dB]",
    5, 1, 20, 0.1));

    threshold = ctl_group(hslider("[1] Threshold [unit:dB] [style:knob]  [tooltip: When the signal level exceeds the Threshold (in dB), its level is compressed according to the Ratio]",
    -30, -100, 10, 0.1));

    env_group(x)  = knob_group(hgroup("[4] Compression Response", x));

    attack = env_group(hslider("[1] Attack [unit:ms] [style:knob]  [tooltip: Time constant in ms (1/e smoothing time) for the compression gain to approach (exponentially) a new lower target level (the compression `kicking in')]",
    50, 0, 500, 0.1)) : *(0.001) : max(1/SR);

    release = env_group(hslider("[2] Release [unit:ms] [style: knob]  [tooltip: Time constant in ms (1/e smoothing time) for the compression gain to approach (exponentially) a new higher target level (the compression 'releasing')]",
    500, 0, 1000, 0.1)) : *(0.001) : max(1/SR);

  };

  //Exciter GUI controls
  ex_group(x) = hgroup("EXCITER  [tooltip: Reference: Patent US4150253 A]", x);

  //Highpass - selectable cutoff frequency
  fc = ex_group(hslider("[0] Cutoff Frequency [unit:Hz] [style:knob] [scale:log]
                        [tooltip: Cutoff frequency for highpassed components to be excited]",
                        5000, 1000, 10000, 100));
  highpass = component("filter.lib").highpass(2, fc);
  
  //Pre-distortion gain - selectable percentage of harmonics
  ph = ex_group(hslider("[1] Harmonics [unit:percent] [style:knob] [tooltip: Percentage of harmonics generated]", 20, 0, 200, 1)) / 100;
  pregain = * (ph);
  
  //Asymmetric cubic soft clipper
  harmonicCreator(x) = x <: cubDist1, cubDist2, cubDist3 :> _;
  cubDist1(x) = (x < 0) * x;
  cubDist2(x) = (x >= 0) * (x <= 1) * (x - x ^ 3 / 3);
  cubDist3(x) = (x > 1) * 2/3;

  //Post-distortion gain - undoes effect of pre-gain
  postgain = * (1/ph);

  //Balance - selectable dry/wet mix
  ml = ex_group(hslider("[2] Mix [style:knob] [tooltip: Dry/Wet mix of original signal to excited signal]", 0.50, 0.00, 1.00, 0.01));
  balance = (_ * ml), (_ * (1.0 - ml)) :> _;

};

//------------------------- moog_vcf(res,fr) ---------------------------
// Moog "Voltage Controlled Filter" (VCF) in "analog" form
//
// USAGE: moog_vcf(res,fr), where
//   fr = corner-resonance frequency in Hz ( less than SR/6.3 or so )
//   res  = Normalized amount of corner-resonance between 0 and 1
//        (0 is no resonance, 1 is maximum)
//
// REQUIRES: filter.lib
//
// DESCRIPTION: Moog VCF implemented using the same logical block diagram
//   as the classic analog circuit.  As such, it neglects the one-sample
//   delay associated with the feedback path around the four one-poles.
//   This extra delay alters the response, especially at high frequencies
//   (see reference [1] for details).
//   See moog_vcf_2b below for a more accurate implementation.
//
// REFERENCES:
//   [1] https://ccrma.stanford.edu/~stilti/papers/moogvcf.pdf
//   [2] https://ccrma.stanford.edu/~jos/pasp/vegf.html
//
moog_vcf(res,fr) = (+ : seq(i,4,pole(p)) : *(unitygain(p))) ~ *(mk)
with {
     p = 1.0 - fr * 2.0 * PI / SR; // good approximation for fr << SR
     unitygain(p) = pow(1.0-p,4.0); // one-pole unity-gain scaling
     mk = -4.0*max(0,min(res,0.999999)); // need mk > -4 for stability
};

//----------------------- moog_vcf_2b[n] ---------------------------
// Moog "Voltage Controlled Filter" (VCF) as two biquads
//
// USAGE:
//   moog_vcf_2b(res,fr)
//   moog_vcf_2bn(res,fr)
// where
//   fr = corner-resonance frequency in Hz
//   res  = Normalized amount of corner-resonance between 0 and 1
//        (0 is min resonance, 1 is maximum)
//
// DESCRIPTION: Implementation of the ideal Moog VCF transfer
//   function factored into second-order sections.  As a result, it is
//   more accurate than moog_vcf above, but its coefficient formulas are
//   more complex when one or both parameters are varied.  Here, res
//   is the fourth root of that in moog_vcf, so, as the sampling rate
//   approaches infinity, moog_vcf(res,fr) becomes equivalent
//   to moog_vcf_2b[n](res^4,fr) (when res and fr are constant).
//
//   moog_vcf_2b  uses two direct-form biquads (tf2)
//   moog_vcf_2bn uses two protected normalized-ladder biquads (tf2np)
//
// REQUIRES: filter.lib
//
moog_vcf_2b(res,fr) = tf2s(0,0,b0,a11,a01,w1) : tf2s(0,0,b0,a12,a02,w1)
with {
 s = 1; // minus the open-loop location of all four poles
 frl = max(20,min(10000,fr)); // limit fr to reasonable 20-10k Hz range
 w1 = 2*PI*frl; // frequency-scaling parameter for bilinear xform
 // Equivalent: w1 = 1; s = 2*PI*frl;
 kmax = sqrt(2)*0.999; // 0.999 gives stability margin (tf2 is unprotected)
 k = min(kmax,sqrt(2)*res); // fourth root of Moog VCF feedback gain
 b0 = s^2;
 s2k = sqrt(2) * k;
 a11 = s * (2 + s2k);
 a12 = s * (2 - s2k);
 a01 = b0 * (1 + s2k + k^2);
 a02 = b0 * (1 - s2k + k^2);
};

moog_vcf_2bn(res,fr) = tf2snp(0,0,b0,a11,a01,w1) : tf2snp(0,0,b0,a12,a02,w1)
with {
 s = 1; // minus the open-loop location of all four poles
 w1 = 2*PI*max(fr,20); // frequency-scaling parameter for bilinear xform
 k = sqrt(2)*0.999*res; // fourth root of Moog VCF feedback gain
 b0 = s^2;
 s2k = sqrt(2) * k;
 a11 = s * (2 + s2k);
 a12 = s * (2 - s2k);
 a01 = b0 * (1 + s2k + k^2);
 a02 = b0 * (1 - s2k + k^2);
};

//------------------------- moog_vcf_demo ---------------------------
// Illustrate and compare all three Moog VCF implementations above
// (called by <faust>/examples/vcf_wah_pedals.dsp).
//
// USAGE: _ : moog_vcf_demo : _;

moog_vcf_demo = bypass1(bp,vcf) with {
   mvcf_group(x)  = hgroup("MOOG VCF (Voltage Controlled Filter)
      [tooltip: See Faust's effect.lib for info and references]",x);
   cb_group(x) = mvcf_group(hgroup("[0]",x));

   bp = cb_group(checkbox("[0] Bypass  [tooltip: When this is checked, the Moog VCF has no effect]"));
   archsw = cb_group(checkbox("[1] Use Biquads
   [tooltip: Select moog_vcf_2b (two-biquad) implementation, instead of the default moog_vcf (analog style) implementation]"));
   bqsw = cb_group(checkbox("[2] Normalized Ladders
   [tooltip: If using biquads, make them normalized ladders (moog_vcf_2bn)]"));

   freq = mvcf_group(hslider("[1] Corner Frequency [unit:PK]
   [tooltip: The VCF resonates at the corner frequency (specified in PianoKey (PK) units, with A440 = 49 PK).  The VCF response is flat below the corner frequency, and rolls off -24 dB per octave above.]",
   25, 1, 88, 0.01) : pianokey2hz) : smooth(0.999);

   res = mvcf_group(hslider("[2] Corner Resonance [style:knob]
   [tooltip: Amount of resonance near VCF corner frequency (specified between 0 and 1)]",
   0.9, 0, 1, 0.01));

   outgain  = mvcf_group(hslider("[3] VCF Output Level [unit:dB] [style:knob]
   [tooltip: output level in decibels]",
   5, -60, 20, 0.1)) : component("music.lib").db2linear : smooth(0.999);

   vcfbq =  _ <: select2(bqsw, moog_vcf_2b(res,freq), moog_vcf_2bn(res,freq));
   vcfarch =  _ <: select2(archsw, moog_vcf(res^4,freq), vcfbq);
   vcf = vcfarch : *(outgain);
};

//-------------------------- wah4(fr) -------------------------------
// Wah effect, 4th order
// USAGE: wah4(fr), where fr = resonance frequency in Hz
// REFERENCE "https://ccrma.stanford.edu/~jos/pasp/vegf.html";
//
wah4(fr) = 4*moog_vcf((3.2/4),fr:smooth(0.999));

//------------------------- wah4_demo ---------------------------
// USAGE: _ : wah4_demo : _;

wah4_demo = bypass1(bp, wah4(fr)) with {
  wah4_group(x)  = hgroup("WAH4
       [tooltip: Fourth-order wah effect made using moog_vcf]", x);
  bp = wah4_group(checkbox("[0] Bypass
       [tooltip: When this is checked, the wah pedal has no effect]"));
  fr = wah4_group(hslider("[1] Resonance Frequency [scale:log]
       [tooltip: wah resonance frequency in Hz]",
     200,100,2000,1));
// Avoid dc with the moog_vcf (amplitude too high when freq comes up from dc)
// Also, avoid very high resonance frequencies (e.g., 5kHz or above).
};

//------------------------ autowah(level) -----------------------------
// Auto-wah effect
// USAGE: _ : autowah(level) : _;
// where level = amount of effect desired (0 to 1).
//
autowah(level,x) = level * crybaby(amp_follower(0.1,x),x) + (1.0-level)*x;

//-------------------------- crybaby(wah) -----------------------------
// Digitized CryBaby wah pedal
// USAGE: _ : crybaby(wah) : _;
// where wah = "pedal angle" from 0 to 1.
// REFERENCE: https://ccrma.stanford.edu/~jos/pasp/vegf.html
//
crybaby(wah) = *(gs) : tf2(1,-1,0,a1s,a2s)
with {
  Q  = pow(2.0,(2.0*(1.0-wah)+1.0)); // Resonance "quality factor"
  fr = 450.0*pow(2.0,2.3*wah);       // Resonance tuning
  g  = 0.1*pow(4.0,wah);             // gain (optional)

  // Biquad fit using z = exp(s T) ~ 1 + sT for low frequencies:
  frn = fr/SR; // Normalized pole frequency (cycles per sample)
  R = 1 - PI*frn/Q; // pole radius
  theta = 2*PI*frn; // pole angle
  a1 = 0-2.0*R*cos(theta); // biquad coeff
  a2 = R*R;                // biquad coeff

  // dezippering of slider-driven signals:
  s = 0.999; // smoothing parameter (one-pole pole location)
  a1s = a1 : smooth(s);
  a2s = a2 : smooth(s);
  gs =  g  : smooth(s);

  tf2 = component("filter.lib").tf2;
};

//------------------------- crybaby_demo ---------------------------
// USAGE: _ : crybaby_demo : _ ;

crybaby_demo = bypass1(bp, crybaby(wah)) with {
   crybaby_group(x)  = hgroup("CRYBABY [tooltip: Reference: https://ccrma.stanford.edu/~jos/pasp/vegf.html]", x);
   bp = crybaby_group(checkbox("[0] Bypass [tooltip: When this is checked, the wah pedal has no effect]"));
   wah = crybaby_group(hslider("[1] Wah parameter [tooltip: wah pedal angle between 0 (rocked back) and 1 (rocked forward)]",0.8,0,1,0.01));
};

//------------ apnl(a1,a2) ---------------
// Passive Nonlinear Allpass:
// switch between allpass coefficient a1 and a2 at signal zero crossings
// REFERENCE:
//  "A Passive Nonlinear Digital Filter Design ..."
//  by John R. Pierce and Scott A. Van Duyne,
//  JASA, vol. 101, no. 2, pp. 1120-1126, 1997
// Written by Romain Michon and JOS based on Pierce switching springs idea:
  apnl(a1,a2,x) = nonLinFilter
  with{
   condition = _>0;
   nonLinFilter = (x - _ <: _*(condition*a1 + (1-condition)*a2),_')~_ :> +;
  };

//------------ piano_dispersion_filter(M,B,f0) ---------------
// Piano dispersion allpass filter in closed form
//
// ARGUMENTS:
//   M = number of first-order allpass sections (compile-time only)
//       Keep below 20. 8 is typical for medium-sized piano strings.
//   B = string inharmonicity coefficient (0.0001 is typical)
//  f0 = fundamental frequency in Hz
//
// INPUT:
//   Signal to be filtered by the allpass chain
//
// OUTPUTS:
//  1. MINUS the estimated delay at f0 of allpass chain in samples,
//     provided in negative form to facilitate subtraction
//     from delay-line length (see USAGE below).
//  2. Output signal from allpass chain
//
// USAGE:
//  piano_dispersion_filter(1,B,f0) : +(totalDelay),_ : fdelay(maxDelay)
//
// REFERENCE:
//   "Dispersion Modeling in Waveguide Piano Synthesis
//    Using Tunable Allpass Filters",
//   by Jukka Rauhala and Vesa Valimaki, DAFX-2006, pp. 71-76
//   URL: http://www.dafx.ca/proceedings/papers/p_071.pdf
//   NOTE: An erratum in Eq. (7) is corrected in Dr. Rauhala's
//    encompassing dissertation (and below).
//   See also: http://www.acoustics.hut.fi/research/asp/piano/
//
piano_dispersion_filter(M,B,f0) = -Df0*M,seq(i,M,tf1(a1,1,a1))
with {
 a1 = (1-D)/(1+D); // By Eq. 3, have D >= 0, hence a1 >= 0 also
 D = exp(Cd - Ikey(f0)*kd);
 trt = pow(2.0,1.0/12.0); // 12th root of 2
 logb(b,x) = log(x) / log(b); // log-base-b of x
 Ikey(f0) = logb(trt,f0*trt/27.5);
 Bc = max(B,0.000001);
 kd = exp(k1*log(Bc)*log(Bc) + k2*log(Bc)+k3);
 Cd = exp((m1*log(M)+m2)*log(Bc)+m3*log(M)+m4);
 k1 = -0.00179;
 k2 = -0.0233;
 k3 = -2.93;
 m1 = 0.0126;
 m2 = 0.0606;
 m3 = -0.00825;
 m4 = 1.97;
 wT = 2*PI*f0/SR;
 polydel(a) = atan(sin(wT)/(a+cos(wT)))/wT;
 Df0 = polydel(a1) - polydel(1.0/a1);
};

//===================== Phasing and Flanging Effects  ====================

//--------------- flanger_mono, flanger_stereo, flanger_demo -------------
// Flanging effect
//
// USAGE:
//     _ : flanger_mono(dmax,curdel,depth,fb,invert) : _;
//   _,_ : flanger_stereo(dmax,curdel1,curdel2,depth,fb,invert) : _,_;
//   _,_ : flanger_demo : _,_;
//
// ARGUMENTS:
//   dmax   = maximum delay-line length (power of 2) - 10 ms typical
//   curdel = current dynamic delay (not to exceed dmax)
//   depth  = effect strength between 0 and 1 (1 typical)
//   fb     = feedback gain between 0 and 1 (0 typical)
//   invert = 0 for normal, 1 to invert sign of flanging sum
//
// REFERENCE:
//    https://ccrma.stanford.edu/~jos/pasp/Flanging.html
//
flanger_mono(dmax,curdel,depth,fb,invert)
  = _ <: _, (-:fdelay(dmax,curdel)) ~ *(fb) : _,
  *(select2(invert,depth,0-depth))
  : + : *(0.5);

flanger_stereo(dmax,curdel1,curdel2,depth,fb,invert)
  =  flanger_mono(dmax,curdel1,depth,fb,invert),
     flanger_mono(dmax,curdel2,depth,fb,invert);

//------------------------- flanger_demo ---------------------------
// USAGE:  _,_ : flanger_demo : _,_;
//
flanger_demo = bypass2(fbp,flanger_stereo_demo) with {
   flanger_group(x) =
    vgroup("FLANGER [tooltip: Reference: https://ccrma.stanford.edu/~jos/pasp/Flanging.html]", x);
   meter_group(x) = flanger_group(hgroup("[0]", x));
   ctl_group(x)  = flanger_group(hgroup("[1]", x));
   del_group(x)  = flanger_group(hgroup("[2] Delay Controls", x));
   lvl_group(x)  = flanger_group(hgroup("[3]", x));

   fbp = meter_group(checkbox(
         "[0] Bypass  [tooltip: When this is checked, the flanger has no effect]"));
   invert = meter_group(checkbox("[1] Invert Flange Sum"));

   // FIXME: This should be an amplitude-response display:
   flangeview = lfor(freq) + lfol(freq) : meter_group(hbargraph(
      "[2] Flange LFO [style: led] [tooltip: Display sum of flange delays]", -1.5,+1.5));

   flanger_stereo_demo(x,y) = attach(x,flangeview),y :
     *(level),*(level) : flanger_stereo(dmax,curdel1,curdel2,depth,fb,invert);

   lfol = component("oscillator.lib").oscrs; // sine for left channel
   lfor = component("oscillator.lib").oscrc; // cosine for right channel
   dmax = 2048;
   dflange = 0.001 * SR *
     del_group(hslider("[1] Flange Delay [unit:ms] [style:knob]", 10, 0, 20, 0.001));
   odflange = 0.001 * SR *
     del_group(hslider("[2] Delay Offset [unit:ms] [style:knob]", 1, 0, 20, 0.001));
   freq   = ctl_group(hslider("[1] Speed [unit:Hz] [style:knob]", 0.5, 0, 10, 0.01));
   depth  = ctl_group(hslider("[2] Depth [style:knob]", 1, 0, 1, 0.001));
   fb     = ctl_group(hslider("[3] Feedback [style:knob]", 0, -0.999, 0.999, 0.001));
   level  = lvl_group(hslider("Flanger Output Level [unit:dB]", 0, -60, 10, 0.1)) : db2linear;
   curdel1 = odflange+dflange*(1 + lfol(freq))/2;
   curdel2 = odflange+dflange*(1 + lfor(freq))/2;
};

//------- phaser2_mono, phaser2_stereo, phaser2_demo -------
// Phasing effect
//
// USAGE:
//   _ : phaser2_mono(Notches,phase,width,frqmin,fratio,frqmax,speed,depth,fb,invert) : _;
// _,_ : phaser2_stereo(") : _,_;
// _,_ : phaser2_demo : _,_;
//
// ARGUMENTS:
//   Notches = number of spectral notches (MACRO ARGUMENT - not a signal)
//	 phase  = phase of the oscillator (0-1)
//   width  = approximate width of spectral notches in Hz
//   frqmin = approximate minimum frequency of first spectral notch in Hz
//   fratio = ratio of adjacent notch frequencies
//   frqmax = approximate maximum frequency of first spectral notch in Hz
//   speed  = LFO frequency in Hz (rate of periodic notch sweep cycles)
//   depth  = effect strength between 0 and 1 (1 typical) (aka "intensity")
//            when depth=2, "vibrato mode" is obtained (pure allpass chain)
//   fb     = feedback gain between -1 and 1 (0 typical)
//   invert = 0 for normal, 1 to invert sign of flanging sum
//
// REFERENCES:
//    https://ccrma.stanford.edu/~jos/pasp/Phasing.html
//    http://www.geofex.com/Article_Folders/phasers/phase.html
//    'An Allpass Approach to Digital Phasing and Flanging', Julius O. Smith III,
//    Proc. Int. Computer Music Conf. (ICMC-84), pp. 103-109, Paris, 1984.
//    CCRMA Tech. Report STAN-M-21: https://ccrma.stanford.edu/STANM/stanms/stanm21/

vibrato2_mono(sections,phase01,fb,width,frqmin,fratio,frqmax,speed) =
 (+ : seq(i,sections,ap2p(R,th(i)))) ~ *(fb)
with {
     tf2 = component("filter.lib").tf2;
     // second-order resonant digital allpass given pole radius and angle:
     ap2p(R,th) = tf2(a2,a1,1,a1,a2) with {
       a2 = R^2;
       a1 = -2*R*cos(th);
     };
     SR = component("music.lib").SR;
     R = exp(-pi*width/SR);
     cososc = component("oscillator.lib").oscrc;
     sinosc = component("oscillator.lib").oscrs;
     osc = cososc(speed) * phase01 + sinosc(speed) * (1-phase01);
     lfo = (1-osc)/2; // in [0,1]
     pi = 4*atan(1);
     thmin = 2*pi*frqmin/SR;
     thmax = 2*pi*frqmax/SR;
     th1 = thmin + (thmax-thmin)*lfo;
     th(i) = (fratio^(i+1))*th1;
};

phaser2_mono(Notches,phase01,width,frqmin,fratio,frqmax,speed,depth,fb,invert) =
      _ <: *(g1) + g2mi*vibrato2_mono(Notches,phase01,fb,width,frqmin,fratio,frqmax,speed)
with {               // depth=0 => direct-signal only
     g1 = 1-depth/2; // depth=1 => phaser mode (equal sum of direct and allpass-chain)
     g2 = depth/2;   // depth=2 => vibrato mode (allpass-chain signal only)
     g2mi = select2(invert,g2,-g2); // inversion negates the allpass-chain signal
};

phaser2_stereo(Notches,width,frqmin,fratio,frqmax,speed,depth,fb,invert)
   = phaser2_mono(Notches,0,width,frqmin,fratio,frqmax,speed,depth,fb,invert),
     phaser2_mono(Notches,1,width,frqmin,fratio,frqmax,speed,depth,fb,invert);

//------------------------- phaser2_demo ---------------------------
// USAGE:  _,_ : phaser2_demo : _,_;
//
phaser2_demo = bypass2(pbp,phaser2_stereo_demo) with {
   phaser2_group(x) =
    vgroup("PHASER2 [tooltip: Reference: https://ccrma.stanford.edu/~jos/pasp/Flanging.html]", x);
   meter_group(x) = phaser2_group(hgroup("[0]", x));
   ctl_group(x)  = phaser2_group(hgroup("[1]", x));
   nch_group(x)  = phaser2_group(hgroup("[2]", x));
   lvl_group(x)  = phaser2_group(hgroup("[3]", x));

   pbp = meter_group(checkbox(
         "[0] Bypass  [tooltip: When this is checked, the phaser has no effect]"));
   invert = meter_group(checkbox("[1] Invert Internal Phaser Sum"));
   vibr   = meter_group(checkbox("[2] Vibrato Mode")); // In this mode you can hear any "Doppler"

   // FIXME: This should be an amplitude-response display:
   //flangeview = phaser2_amp_resp : meter_group(hspectrumview("[2] Phaser Amplitude Response", 0,1));
   //phaser2_stereo_demo(x,y) = attach(x,flangeview),y : ...

   phaser2_stereo_demo = *(level),*(level) :
     phaser2_stereo(Notches,width,frqmin,fratio,frqmax,speed,mdepth,fb,invert);

   Notches = 4; // Compile-time parameter: 2 is typical for analog phaser stomp-boxes

   // FIXME: Add tooltips
   speed  = ctl_group(hslider("[1] Speed [unit:Hz] [style:knob]", 0.5, 0, 10, 0.001));
   depth  = ctl_group(hslider("[2] Notch Depth (Intensity) [style:knob]", 1, 0, 1, 0.001));
   fb     = ctl_group(hslider("[3] Feedback Gain [style:knob]", 0, -0.999, 0.999, 0.001));

   width  = nch_group(hslider("[1] Notch width [unit:Hz] [style:knob] [scale:log]", 1000, 10, 5000, 1));
   frqmin = nch_group(hslider("[2] Min Notch1 Freq [unit:Hz] [style:knob] [scale:log]", 100, 20, 5000, 1));
   frqmax = nch_group(hslider("[3] Max Notch1 Freq [unit:Hz] [style:knob] [scale:log]", 800, 20, 10000, 1)) : max(frqmin);
   fratio = nch_group(hslider("[4] Notch Freq Ratio: NotchFreq(n+1)/NotchFreq(n)  [style:knob]", 1.5, 1.1, 4, 0.001));

   level  = lvl_group(hslider("Phaser Output Level [unit:dB]", 0, -60, 10, 0.1)) : component("music.lib").db2linear;

   mdepth = select2(vibr,depth,2); // Improve "ease of use"
};

//---------------------------- vocoder -------------------------
// A very simple vocoder where the spectrum of the modulation signal
// is analyzed using a filter bank.
//
// USAGE:
//              vocoder(nBands,att,rel,BWRatio,source,excitation) : _;
//
// where
// nBands = Number of vocoder bands
// att = Attack time in seconds
// rel = Release time in seconds
// BWRatio = Coefficient to adjust the bandwidth of each band (0.1 - 2)
// source = Modulation signal
// excitation = Excitation/Carrier signal

oneVocoderBand(band,bandsNumb,bwRatio,bandGain,x) = x : resonbp(bandFreq,bandQ,bandGain) with{
        bandFreq = 25*pow(2,(band+1)*(9/bandsNumb));
        BW = (bandFreq - 25*pow(2,(band)*(9/bandsNumb)))*bwRatio;
        bandQ = bandFreq/BW;
};

vocoder(nBands,att,rel,BWRatio,source,excitation) = source <: par(i,nBands,oneVocoderBand(i,nBands,BWRatio,1) : amp_follower_ar(att,rel) : _,excitation : oneVocoderBand(i,nBands,BWRatio)) :> _ ;

//---------------------------- vocoder_demo -------------------------
// Use example of the vocoder function where an impulse train is used
// as excitation.
// USAGE:
//              _ : vocoder_demo : _;

vocoder_demo = hgroup("My Vocoder",_,impTrain(freq)*gain : vocoder(bands,att,rel,BWRatio) <: _,_) with{
        bands = 32;
        impTrain = component("oscillator.lib").lf_imptrain;
        vocoderGroup(x) = vgroup("Vocoder",x);
        att = vocoderGroup(hslider("[0] Attack [style:knob] [tooltip: Attack time in seconds]",5,0.1,100,0.1)*0.001);
        rel = vocoderGroup(hslider("[1] Release [style:knob] [tooltip: Release time in seconds]",5,0.1,100,0.1)*0.001);
        BWRatio = vocoderGroup(hslider("[2] BW [style:knob] [tooltip: Coefficient to adjust the bandwidth of each band]",0.5,0.1,2,0.001));
        excitGroup(x) = vgroup("Excitation",x);
        freq = excitGroup(hslider("[0] Freq [style:knob]",330,50,2000,0.1));
        gain = excitGroup(vslider("[1] Gain",0.5,0,1,0.01) : smooth(0.999));
};

//------------------------- stereo_width(w) ---------------------------
// Stereo Width effect using the Blumlein Shuffler technique.
//
// USAGE: "_,_ : stereo_width(w) : _,_", where
//   w = stereo width between 0 and 1
//
// At w=0, the output signal is mono ((left+right)/2 in both channels).
// At w=1, there is no effect (original stereo image).
// Thus, w between 0 and 1 varies stereo width from 0 to "original".
//
// REFERENCE:
// "Applications of Blumlein Shuffling to Stereo Microphone Techniques"
// Michael A. Gerzon, JAES vol. 42, no. 6, June 1994
//
stereo_width(w) = shuffle : *(mgain),*(sgain) : shuffle
with {
     shuffle =  _,_ <: +,-; // normally scaled by 1/sqrt(2) for orthonormality,
     mgain = 1-w/2;  // but we pick up the needed normalization here.
     sgain = w/2;
};

//--------------------------- amp_follower ---------------------------
// Classic analog audio envelope follower with infinitely fast rise and
// exponential decay.  The amplitude envelope instantaneously follows
// the absolute value going up, but then floats down exponentially.
//
// USAGE:
//    _ : amp_follower(rel) : _
//
// where
//  rel = release time = amplitude-envelope time-constant (sec) going down
//
// REFERENCES:
//  Musical Engineer's Handbook, Bernie Hutchins, Ithaca NY, 1975
//  Electronotes Newsletter, Bernie Hutchins

amp_follower(rel) = abs : env with {
 p = tau2pole(rel);
 env(x) = x * (1.0 - p) : (+ : max(x,_)) ~ *(p);
};

//--------------------------- amp_follower_ud ---------------------------
// Envelope follower with different up and down time-constants
// (also called a "peak detector").
//
// USAGE:
//    _ : amp_follower_ud(att,rel) : _
//
// where
//  att = attack time = amplitude-envelope time constant (sec) going up
//  rel = release time = amplitude-envelope time constant (sec) going down
//
// NOTE: We assume rel >> att.  Otherwise, consider rel ~ max(rel,att).
// For audio, att is normally faster (smaller) than rel (e.g., 0.001 and 0.01).
// Use
//
//   _ : amp_follower_ar(att,rel) : _
//
// below to remove this restriction.
//
// REFERENCE:
//   "Digital Dynamic Range Compressor Design --- A Tutorial and Analysis", by
//   Dimitrios Giannoulis, Michael Massberg, and Joshua D. Reiss
//   http://www.eecs.qmul.ac.uk/~josh/documents/GiannoulisMassbergReiss-dynamicrangecompression-JAES2012.pdf

amp_follower_ud(att,rel) = amp_follower(rel) : smooth(tau2pole(att));

// Begin contributions by Jonatan Liljedahl at http://kymatica.com
// (in addition to his refinement of amp_follower above)

/*****************************************************
    _ : amp_follower_ar(att,rel) : _;

Envelope follower with independent attack and release times. The
release can be shorter than the attack (unlike in amp_follower_ud
above).

*****************************************************/

amp_follower_ar(att,rel) = abs : lag_ud(att,rel);

/*****************************************************
    _ : lag_ud(up, dn, signal) : _;

    Lag filter with separate times for up and down.
*****************************************************/

lag_ud(up,dn) = _ <: ((>,tau2pole(up),tau2pole(dn):select2),_:smooth) ~ _;

/*****************************************************
    _ : peakhold(mode,sig) : _;

    Outputs current max value above zero.
    'mode' means:
    0 - Pass through. A single sample 0 trigger will work as a reset.
    1 - Track and hold max value.
*****************************************************/

peakhold = (*,_:max) ~ _;

/*****************************************************
    sweep(period,run);

    Counts from 0 to 'period' samples repeatedly, while 'run' is 1.
    Outsputs zero while 'run' is 0.
*****************************************************/

sweep = %(int(*:max(1)))~+(1);

/*****************************************************
    peakholder(holdtime, sig);

    Tracks abs peak and holds peak for 'holdtime' samples.
*****************************************************/

peakholder(holdtime) = peakhold2 ~ reset : (!,_) with {
    reset = sweep(holdtime) > 0;
    // first out is gate that is 1 while holding last peak
    peakhold2 = _,abs <: peakhold,!,_ <: >=,_,!;
};

// End of contributions (so far) by Jonatan Liljedahl at http://kymatica.com

//=============== Gates, Limiters, and Dynamic Range Compression ============

//----------------- gate_mono, gate_stereo -------------------
// Mono and stereo signal gates
//
// USAGE:
//    _ : gate_mono(thresh,att,hold,rel)   : _
// or
//  _,_ : gate_stereo(thresh,att,hold,rel) : _,_
//
// where
//  thresh = dB level threshold above which gate opens (e.g., -60 dB)
//  att    = attack time = time constant (sec) for gate to open (e.g., 0.0001 s = 0.1 ms)
//  hold   = hold time = time (sec) gate stays open after signal level < thresh (e.g., 0.1 s)
//  rel    = release time = time constant (sec) for gate to close (e.g., 0.020 s = 20 ms)
//
// REFERENCES:
// - http://en.wikipedia.org/wiki/Noise_gate
// - http://www.soundonsound.com/sos/apr01/articles/advanced.asp
// - http://en.wikipedia.org/wiki/Gating_(sound_engineering)

gate_mono(thresh,att,hold,rel,x) = x * gate_gain_mono(thresh,att,hold,rel,x);

gate_stereo(thresh,att,hold,rel,x,y) = ggm*x, ggm*y with {
  ggm = gate_gain_mono(thresh,att,hold,rel,abs(x)+abs(y));
};

gate_gain_mono(thresh,att,hold,rel,x) = x : extendedrawgate : amp_follower_ar(att,rel) with {
  extendedrawgate(x) = max(float(rawgatesig(x)),holdsig(x));
  rawgatesig(x) = inlevel(x) > db2linear(thresh);
  minrate = min(att,rel);
  inlevel = amp_follower_ar(minrate,minrate);
  holdcounter(x) = (max(holdreset(x) * holdsamps,_) ~-(1));
  holdsig(x) = holdcounter(x) > 0;
  holdreset(x) = rawgatesig(x) < rawgatesig(x)'; // reset hold when raw gate falls
  holdsamps = int(hold*SR);
};

//-------------------- compressor_mono, compressor_stereo ----------------------
// Mono and stereo dynamic range compressors
//
// USAGE:
//    _ : compressor_mono(ratio,thresh,att,rel)   : _
// or
//  _,_ : compressor_stereo(ratio,thresh,att,rel) : _,_
//
// where
//  ratio  = compression ratio (1 = no compression, >1 means compression)
//  thresh = dB level threshold above which compression kicks in (0 dB = max level)
//  att    = attack time = time constant (sec) when level & compression going up
//  rel    = release time = time constant (sec) coming out of compression
//
// REFERENCES:
// - http://en.wikipedia.org/wiki/Dynamic_range_compression
// - https://ccrma.stanford.edu/~jos/filters/Nonlinear_Filter_Example_Dynamic.html
// - Albert Graef's <faust2pd>/examples/synth/compressor_.dsp
// - More features: https://github.com/magnetophon/faustCompressors

compressor_mono(ratio,thresh,att,rel,x) = x * compression_gain_mono(ratio,thresh,att,rel,x);

compressor_stereo(ratio,thresh,att,rel,x,y) = cgm*x, cgm*y with {
  cgm = compression_gain_mono(ratio,thresh,att,rel,abs(x)+abs(y));
};

compression_gain_mono(ratio,thresh,att,rel) =
  amp_follower_ar(att,rel) : linear2db : outminusindb(ratio,thresh) :
  kneesmooth(att) : db2linear
with {
  // kneesmooth(att) installs a "knee" in the dynamic-range compression,
  // where knee smoothness is set equal to half that of the compression-attack.
  // A general 'knee' parameter could be used instead of tying it to att/2:
  kneesmooth(att)  = smooth(tau2pole(att/2.0));
  // compression gain in dB:
   outminusindb(ratio,thresh,level) = max(level-thresh,0.0) * (1.0/float(ratio)-1.0);
  // Note: "float(ratio)" REQUIRED when ratio is an integer > 1!
};

//---------------------------- gate_demo -------------------------
// USAGE: _,_ : gate_demo : _,_;
//
gate_demo = bypass2(gbp,gate_stereo_demo) with {

   gate_group(x)  = vgroup("GATE  [tooltip: Reference: http://en.wikipedia.org/wiki/Noise_gate]", x);
   meter_group(x) = gate_group(hgroup("[0]", x));
   knob_group(x)  = gate_group(hgroup("[1]", x));

   gbp = meter_group(checkbox("[0] Bypass  [tooltip: When this is checked, the gate has no effect]"));

   gateview = gate_gain_mono(gatethr,gateatt,gatehold,gaterel) : linear2db :
     meter_group(hbargraph("[1] Gate Gain [unit:dB]  [tooltip: Current gain of the gate in dB]",
      -50,+10)); // [style:led]

   gate_stereo_demo(x,y) = attach(x,gateview(abs(x)+abs(y))),y :
     gate_stereo(gatethr,gateatt,gatehold,gaterel);

   gatethr = knob_group(hslider("[1] Threshold [unit:dB] [style:knob]  [tooltip: When the signal level falls below the Threshold (expressed in dB), the signal is muted]",
     -30, -120, 0, 0.1));

   gateatt = knob_group(hslider("[2] Attack [unit:us] [style:knob] [scale:log]
     [tooltip: Time constant in MICROseconds (1/e smoothing time) for the gate gain to go (exponentially) from 0 (muted) to 1 (unmuted)]",
     10, 10, 10000, 1)) : *(0.000001) : max(1.0/float(SR));

   gatehold = knob_group(hslider("[3] Hold [unit:ms] [style:knob] [scale:log]
     [tooltip: Time in ms to keep the gate open (no muting) after the signal level falls below the Threshold]",
     200, 1, 1000, 1)) : *(0.001) : max(1.0/float(SR));

   gaterel = knob_group(hslider("[4] Release [unit:ms] [style:knob] [scale:log]
     [tooltip: Time constant in ms (1/e smoothing time) for the gain to go (exponentially) from 1 (unmuted) to 0 (muted)]",
     100, 1, 1000, 1)) : *(0.001) : max(1.0/float(SR));
};

//---------------------------- compressor_demo -------------------------
// USAGE: _,_ : compressor_demo : _,_;
//
compressor_demo = bypass2(cbp,compressor_stereo_demo) with {

   comp_group(x) = vgroup("COMPRESSOR  [tooltip: Reference: http://en.wikipedia.org/wiki/Dynamic_range_compression]", x);

   meter_group(x)  = comp_group(hgroup("[0]", x));
   knob_group(x)  = comp_group(hgroup("[1]", x));

   cbp = meter_group(checkbox("[0] Bypass  [tooltip: When this is checked, the compressor has no effect]"));

   gainview =
     compression_gain_mono(ratio,threshold,attack,release) : linear2db :
     meter_group(hbargraph("[1] Compressor Gain [unit:dB] [tooltip: Current gain of the compressor in dB]",
      -50,+10));

   displaygain = _,_ <: _,_,(abs,abs:+) : _,_,gainview : _,attach;

   compressor_stereo_demo =
     displaygain(compressor_stereo(ratio,threshold,attack,release)) :
     *(makeupgain), *(makeupgain);

   ctl_group(x)  = knob_group(hgroup("[3] Compression Control", x));

   ratio = ctl_group(hslider("[0] Ratio [style:knob]
     [tooltip: A compression Ratio of N means that for each N dB increase in input signal level above Threshold, the output level goes up 1 dB]",
     5, 1, 20, 0.1));

   threshold = ctl_group(hslider("[1] Threshold [unit:dB] [style:knob]
     [tooltip: When the signal level exceeds the Threshold (in dB), its level is compressed according to the Ratio]",
     -30, -100, 10, 0.1));

   env_group(x)  = knob_group(hgroup("[4] Compression Response", x));

   attack = env_group(hslider("[1] Attack [unit:ms] [style:knob] [scale:log]
     [tooltip: Time constant in ms (1/e smoothing time) for the compression gain to approach (exponentially) a new lower target level (the compression `kicking in')]",
     50, 1, 1000, 0.1)) : *(0.001) : max(1/SR);

   release = env_group(hslider("[2] Release [unit:ms] [style: knob] [scale:log]
     [tooltip: Time constant in ms (1/e smoothing time) for the compression gain to approach (exponentially) a new higher target level (the compression 'releasing')]",
     500, 1, 1000, 0.1)) : *(0.001) : max(1/SR);

   makeupgain = comp_group(hslider("[5] Makeup Gain [unit:dB]
     [tooltip: The compressed-signal output level is increased by this amount (in dB) to make up for the level lost due to compression]",
     40, -96, 96, 0.1)) : db2linear;
};

//------------------------------- limiter_* ------------------------------------
// USAGE:
//     _ : limiter_1176_R4_mono   : _;
//   _,_ : limiter_1176_R4_stereo : _,_;
//
// DESCRIPTION:
//   A limiter guards against hard-clipping.  It can be can be
//   implemented as a compressor having a high threshold (near the
//   clipping level), fast attack and release, and high ratio.  Since
//   the ratio is so high, some knee smoothing is
//   desirable ("soft limiting").  This example is intended
//   to get you started using compressor_* as a limiter, so all
//   parameters are hardwired to nominal values here.
//
// REFERENCE: http://en.wikipedia.org/wiki/1176_Peak_Limiter
//   Ratios: 4 (moderate compression), 8 (severe compression),
//          12 (mild limiting), or 20 to 1 (hard limiting)
//   Att: 20-800 MICROseconds (Note: scaled by ratio in the 1176)
//   Rel: 50-1100 ms (Note: scaled by ratio in the 1176)
//   Mike Shipley likes 4:1 (Grammy-winning mixer for Queen, Tom Petty, etc.)
//     Faster attack gives "more bite" (e.g. on vocals)
//     He hears a bright, clear eq effect as well (not implemented here)
//
limiter_1176_R4_mono = compressor_mono(4,-6,0.0008,0.5);
limiter_1176_R4_stereo = compressor_stereo(4,-6,0.0008,0.5);

//========================== Schroeder Reverberators  ======================

//------------------------------ jcrev,satrev ------------------------------
// USAGE:
//     _ :  jcrev : _,_,_,_
//     _ : satrev : _,_
//
// DESCRIPTION:
//   These artificial reverberators take a mono signal and output stereo
//   (satrev) and quad (jcrev).  They were implemented by John Chowning
//   in the MUS10 computer-music language (descended from Music V by Max
//   Mathews).  They are Schroeder Reverberators, well tuned for their size.
//   Nowadays, the more expensive freeverb is more commonly used (see the
//   Faust examples directory).

// The reverb below was made from a listing of "RV", dated April 14, 1972,
// which was recovered from an old SAIL DART backup tape.
// John Chowning thinks this might be the one that became the
// well known and often copied JCREV:

jcrev = *(0.06) : allpass_chain <: comb_bank : mix_mtx with {

  rev1N = component("filter.lib").rev1;

  rev12(len,g) = rev1N(2048,len,g);
  rev14(len,g) = rev1N(4096,len,g);

  allpass_chain =
    rev2(512,347,0.7) :
    rev2(128,113,0.7) :
    rev2( 64, 37,0.7);

  comb_bank =
    rev12(1601,.802),
    rev12(1867,.773),
    rev14(2053,.753),
    rev14(2251,.733);

    mix_mtx = _,_,_,_ <: psum, -psum, asum, -asum : _,_,_,_ with {
    psum = _,_,_,_ :> _;
    asum = *(-1),_,*(-1),_ :> _;
  };
};

// The reverb below was made from a listing of "SATREV", dated May 15, 1971,
// which was recovered from an old SAIL DART backup tape.
// John Chowning thinks this might be the one used on his
// often-heard brass canon sound examples, one of which can be found at
// https://ccrma.stanford.edu/~jos/wav/FM_BrassCanon2.wav

satrev = *(0.2) <: comb_bank :> allpass_chain <: _,*(-1) with {

  rev1N = component("filter.lib").rev1;

  rev11(len,g) = rev1N(1024,len,g);
  rev12(len,g) = rev1N(2048,len,g);

  comb_bank =
    rev11( 778,.827),
    rev11( 901,.805),
    rev11(1011,.783),
    rev12(1123,.764);

  rev2N = component("filter.lib").rev2;

  allpass_chain =
    rev2N(128,125,0.7) :
    rev2N( 64, 42,0.7) :
    rev2N( 16, 12,0.7);
};

//---------------------------- mono_freeverb, stereo_freeverb -------------------------
// A simple Schroeder reverberator primarily developed by "Jezar at Dreampoint" that
// is extensively used in the free-software world. It uses four Schroeder allpasses in
// series and eight parallel Schroeder-Moorer filtered-feedback comb-filters for each
//audio channel, and is said to be especially well tuned.
//
// USAGE:
//              _ : mono_freeverb(fb1, fb2, damp, spread) : _;
// or
//              _,_ : stereo_freeverb(fb1, fb2, damp, spread) : _,_;
//
// where
// fb1 = coefficient of the lowpass comb filters (0-1)
// fb2 = coefficient of the allpass comb filters (0-1)
// damp = damping of the lowpass comb filter (0-1)
// spread = spatial spread in number of samples (for stereo)

mono_freeverb(fb1, fb2, damp, spread) = _ <: par(i,8,lbcf(combtuningL(i)+spread,fb1,damp)) :> seq(i,4,allpass_comb(1024, allpasstuningL(i)+spread, -fb2))
with{
        origSR = 44100;

        // Filters parameters
        combtuningL(0) = 1116*SR/origSR : int;
        combtuningL(1) = 1188*SR/origSR : int;
        combtuningL(2) = 1277*SR/origSR : int;
        combtuningL(3) = 1356*SR/origSR : int;
        combtuningL(4) = 1422*SR/origSR : int;
        combtuningL(5) = 1491*SR/origSR : int;
        combtuningL(6) = 1557*SR/origSR : int;
        combtuningL(7) = 1617*SR/origSR : int;

        allpasstuningL(0) = 556*SR/origSR : int;
        allpasstuningL(1) = 441*SR/origSR : int;
        allpasstuningL(2) = 341*SR/origSR : int;
        allpasstuningL(3) = 225*SR/origSR : int;
        // Lowpass Feedback Combfiler:
        // https://ccrma.stanford.edu/~jos/pasp/Lowpass_Feedback_Comb_Filter.html
        lbcf(dt, fb, damp) = (+:@(dt)) ~ (*(1-damp) : (+ ~ *(damp)) : *(fb));
};

stereo_freeverb(fb1, fb2, damp, spread) =  + <: mono_freeverb(fb1, fb2, damp,0), mono_freeverb(fb1, fb2, damp, spread);

//---------------------------- freeverb_demo -------------------------
// USAGE: _,_ : freeverb_demo : _,_;
//

freeverb_demo = _,_ <: (*(g)*fixedgain,*(g)*fixedgain : stereo_freeverb(combfeed, allpassfeed, damping, spatSpread)), *(1-g), *(1-g) :> _,_ with{
        scaleroom   = 0.28;
        offsetroom  = 0.7;
        allpassfeed = 0.5;
        scaledamp   = 0.4;
        fixedgain   = 0.1;
        origSR = 44100;
        parameters(x) = hgroup("Freeverb",x);
        knobGroup(x) = parameters(vgroup("[0]",x));
        damping = knobGroup(vslider("[0] Damp [style: knob] [tooltip: Somehow control the density of the reverb.]",0.5, 0, 1, 0.025)*scaledamp*origSR/SR);
        combfeed = knobGroup(vslider("[1] RoomSize [style: knob] [tooltip: The room size between 0 and 1 with 1 for the largest room.]", 0.5, 0, 1, 0.025)*scaleroom*origSR/SR + offsetroom);
        spatSpread = knobGroup(vslider("[2] Stereo Spread [style: knob] [tooltip: Spatial spread between 0 and 1 with 1 for maximum spread.]",0.5,0,1,0.01)*46*SR/origSR : int);
        g = parameters(vslider("[1] Wet [tooltip: The amount of reverb applied to the signal between 0 and 1 with 1 for the maximum amount of reverb.]", 0.3333, 0, 1, 0.025));
};

//=============== Feedback Delay Network (FDN) Reverberators  ==============

//-------------------------------- fdnrev0 ---------------------------------
// Pure Feedback Delay Network Reverberator (generalized for easy scaling).
//
// USAGE:
//   <1,2,4,...,N signals> <:
//   fdnrev0(MAXDELAY,delays,BBSO,freqs,durs,loopgainmax,nonl) :>
//   <1,2,4,...,N signals>
//
// WHERE
//   N = 2, 4, 8, ...  (power of 2)
//   MAXDELAY = power of 2 at least as large as longest delay-line length
//   delays = N delay lines, N a power of 2, lengths perferably coprime
//   BBSO = odd positive integer = order of bandsplit desired at freqs
//   freqs  = NB-1 crossover frequencies separating desired frequency bands
//   durs   = NB decay times (t60) desired for the various bands
//   loopgainmax = scalar gain between 0 and 1 used to "squelch" the reverb
//   nonl = nonlinearity (0 to 0.999..., 0 being linear)
//
// REFERENCE:
//   https://ccrma.stanford.edu/~jos/pasp/FDN_Reverberation.html
//
// DEPENDENCIES: filter.lib (filterbank)

fdnrev0(MAXDELAY, delays, BBSO, freqs, durs, loopgainmax, nonl)
  = (bus(2*N) :> bus(N) : delaylines(N)) ~
    (delayfilters(N,freqs,durs) : feedbackmatrix(N))
with {
  N = count(delays);
  NB = count(durs);
//assert(count(freqs)+1==NB);
  delayval(i) = take(i+1,delays);
  dlmax(i) = MAXDELAY; // must hardwire this from argument for now
//dlmax(i) = 2^max(1,nextpow2(delayval(i))) // try when slider min/max is known
//           with { nextpow2(x) = ceil(log(x)/log(2.0)); };
// -1 is for feedback delay:
  delaylines(N) = par(i,N,(delay(dlmax(i),(delayval(i)-1))));
  delayfilters(N,freqs,durs) = par(i,N,filter(i,freqs,durs));
  feedbackmatrix(N) = bhadamard(N);
  vbutterfly(n) = bus(n) <: (bus(n):>bus(n/2)) , ((bus(n/2),(bus(n/2):par(i,n/2,*(-1)))) :> bus(n/2));
  bhadamard(2) = bus(2) <: +,-;
  bhadamard(n) = bus(n) <: (bus(n):>bus(n/2)) , ((bus(n/2),(bus(n/2):par(i,n/2,*(-1)))) :> bus(n/2))
                 : (bhadamard(n/2) , bhadamard(n/2));

  // Experimental nonlinearities:
  // nonlinallpass = apnl(nonl,-nonl);
  // s = nonl*PI;
  // nonlinallpass(x) = allpassnn(3,(s*x,s*x*x,s*x*x*x)); // filter.lib
     nonlinallpass = _; // disabled by default (rather expensive)

  filter(i,freqs,durs) = filterbank(BBSO,freqs) : par(j,NB,*(g(j,i)))
                         :> *(loopgainmax) / sqrt(N) : nonlinallpass
  with {
    dur(j) = take(j+1,durs);
    n60(j) = dur(j)*SR; // decay time in samples
    g(j,i) = exp(-3.0*log(10.0)*delayval(i)/n60(j));
        // ~ 1.0 - 6.91*delayval(i)/(SR*dur(j)); // valid for large dur(j)
  };
};

// ---------- prime_power_delays -----
// Prime Power Delay Line Lengths
//
// USAGE:
//   bus(N) : prime_power_delays(N,pathmin,pathmax) : bus(N);
//
// WHERE
//   N = positive integer up to 16
//       (for higher powers of 2, extend 'primes' array below.)
//   pathmin = minimum acoustic ray length in the reverberator (in meters)
//   pathmax = maximum acoustic ray length (meters) - think "room size"
//
// DEPENDENCIES:
//   math.lib (SR, selector, take)
//   music.lib (db2linear)
//
// REFERENCE:
//   https://ccrma.stanford.edu/~jos/pasp/Prime_Power_Delay_Line.html
//
prime_power_delays(N,pathmin,pathmax) = par(i,N,delayvals(i)) with {
  Np = 16;
  primes = 2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53;
  prime(n) = primes : selector(n,Np); // math.lib

  // Prime Power Bounds [matlab: floor(log(maxdel)./log(primes(53)))]
  maxdel=8192; // more than 63 meters at 44100 samples/sec & 343 m/s
  ppbs = 13,8,5,4, 3,3,3,3, 2,2,2,2, 2,2,2,2; // 8192 is enough for all
  ppb(i) = take(i+1,ppbs);

  // Approximate desired delay-line lengths using powers of distinct primes:
  c = 343; // soundspeed in m/s at 20 degrees C for dry air
  dmin = SR*pathmin/c;
  dmax = SR*pathmax/c;
  dl(i) = dmin * (dmax/dmin)^(i/float(N-1)); // desired delay in samples
  ppwr(i) = floor(0.5+log(dl(i))/log(prime(i))); // best prime power
  delayvals(i) = prime(i)^ppwr(i); // each delay a power of a distinct prime
};

//--------------------- stereo_reverb_tester --------------------
// Handy test inputs for reverberator demos below.

stereo_reverb_tester(revin_group,x,y) = inx,iny with {
  ck_group(x) = revin_group(vgroup("[1] Input Config",x));
  mutegain = 1 - ck_group(checkbox("[1] Mute Ext Inputs
         [tooltip: When this is checked, the stereo external audio inputs are disabled (good for hearing the impulse response or pink-noise response alone)]"));
  pinkin = ck_group(checkbox("[2] Pink Noise
         [tooltip: Pink Noise (or 1/f noise) is Constant-Q Noise (useful for adjusting the EQ sections)]"));

  impulsify = _ <: _,mem : - : >(0);
  imp_group(x) = revin_group(hgroup("[2] Impulse Selection",x));
  pulseL =  imp_group(button("[1] Left
         [tooltip: Send impulse into LEFT channel]")) : impulsify;
  pulseC =  imp_group(button("[2] Center
         [tooltip: Send impulse into LEFT and RIGHT channels]")) : impulsify;
  pulseR =  imp_group(button("[3] Right
         [tooltip: Send impulse into RIGHT channel]")) : impulsify;

  inx = x*mutegain + (pulseL+pulseC) + pn;
  iny = y*mutegain + (pulseR+pulseC) + pn;
  pn = 0.1*pinkin*component("oscillator.lib").pink_noise;
};

//------------------------- fdnrev0_demo ---------------------------
// USAGE: _,_ : fdnrev0_demo(N,NB,BBSO) : _,_
// WHERE
//    N = Feedback Delay Network (FDN) order
//      = number of delay lines used = order of feedback matrix
//      = 2, 4, 8, or 16 [extend primes array below for 32, 64, ...]
//   NB = number of frequency bands
//      = number of (nearly) independent T60 controls
//      = integer 3 or greater
// BBSO = Butterworth band-split order
//      = order of lowpass/highpass bandsplit used at each crossover freq
//      = odd positive integer

fdnrev0_demo(N,NB,BBSO,x,y) = stereo_reverb_tester(revin_group,x,y)
          <: fdnrev0(MAXDELAY,delays,BBSO,freqs,durs,loopgainmax,nonl)
          :> *(gain),*(gain)
with {
  MAXDELAY = 8192; // sync w delays and prime_power_delays above
  defdurs = (8.4,6.5,5.0,3.8,2.7); // NB default durations (sec)
  deffreqs = (500,1000,2000,4000); // NB-1 default crossover frequencies (Hz)
  deflens = (56.3,63.0); // 2 default min and max path lengths

  fdn_group(x)  = vgroup("FEEDBACK DELAY NETWORK (FDN) REVERBERATOR, ORDER 16
    [tooltip: See Faust's effect.lib for documentation and references]", x);

  freq_group(x)  = fdn_group(vgroup("[1] Band Crossover Frequencies", x));
  t60_group(x)  = fdn_group(hgroup("[2] Band Decay Times (T60)", x));
  path_group(x)  = fdn_group(vgroup("[3] Room Dimensions", x));
  revin_group(x)  = fdn_group(hgroup("[4] Input Controls", x));
  nonl_group(x) = revin_group(vgroup("[4] Nonlinearity",x));
  quench_group(x) = revin_group(vgroup("[3] Reverb State",x));

  nonl = nonl_group(hslider("[style:knob] [tooltip: nonlinear mode coupling]",
            0, -0.999, 0.999, 0.001));
  loopgainmax = 1.0-0.5*quench_group(button("[1] Quench
         [tooltip: Hold down 'Quench' to clear the reverberator]"));

  pathmin = path_group(hslider("[1] min acoustic ray length [unit:m] [scale:log]
    [tooltip: This length (in meters) determines the shortest delay-line used in the FDN reverberator.
              Think of it as the shortest wall-to-wall separation in the room.]",
            46, 0.1, 63, 0.1));
  pathmax = path_group(hslider("[2] max acoustic ray length [unit:m] [scale:log]
    [tooltip: This length (in meters) determines the longest delay-line used in the FDN reverberator.
              Think of it as the largest wall-to-wall separation in the room.]",
            63, 0.1, 63, 0.1));

  durvals(i) = t60_group(vslider("[%i] %i [unit:s] [scale:log]
    [tooltip: T60 is the 60dB decay-time in seconds. For concert halls, an overall reverberation time (T60) near 1.9 seconds is typical [Beranek 2004]. Here we may set T60 independently in each frequency band.  In real rooms, higher frequency bands generally decay faster due to absorption and scattering.]",
    take(i+1,defdurs), 0.1, 100, 0.1));
  durs = par(i,NB,durvals(NB-1-i));

  freqvals(i) = freq_group(hslider("[%i] Band %i upper edge in Hz [unit:Hz] [scale:log]
    [tooltip: Each delay-line signal is split into frequency-bands for separate decay-time control in each band]",
    take(i+1,deffreqs), 100, 10000, 1));
  freqs = par(i,NB-1,freqvals(i));

  delays = prime_power_delays(N,pathmin,pathmax);

  gain = hslider("[3] Output Level (dB) [unit:dB]
    [tooltip: Output scale factor]", -40, -70, 20, 0.1) : db2linear;
     // (can cause infinite loop:) with { db2linear(x) = pow(10, x/20.0); };
};

//------------------------------- zita_rev_fdn -------------------------------
// Internal 8x8 late-reverberation FDN used in the FOSS Linux reverb zita-rev1
// by Fons Adriaensen <fons@linuxaudio.org>.  This is an FDN reverb with
// allpass comb filters in each feedback delay in addition to the
// damping filters.
//
// USAGE:
//   bus(8) : zita_rev_fdn(f1,f2,t60dc,t60m,fsmax) : bus(8)
//
// WHERE
//   f1    = crossover frequency (Hz) separating dc and midrange frequencies
//   f2    = frequency (Hz) above f1 where T60 = t60m/2 (see below)
//   t60dc = desired decay time (t60) at frequency 0 (sec)
//   t60m  = desired decay time (t60) at midrange frequencies (sec)
//   fsmax = maximum sampling rate to be used (Hz)
//
// REFERENCES:
//   http://www.kokkinizita.net/linuxaudio/zita-rev1-doc/quickguide.html
//   https://ccrma.stanford.edu/~jos/pasp/Zita_Rev1.html
//
// DEPENDENCIES:
//   filter.lib (allpass_comb, lowpass, smooth)
//   math.lib (hadamard, take, etc.)

zita_rev_fdn(f1,f2,t60dc,t60m,fsmax) =
  ((bus(2*N) :> allpass_combs(N) : feedbackmatrix(N)) ~
   (delayfilters(N,freqs,durs) : fbdelaylines(N)))
with {
  N = 8;

  // Delay-line lengths in seconds:
  apdelays = (0.020346, 0.024421, 0.031604, 0.027333, 0.022904,
              0.029291, 0.013458, 0.019123); // feedforward delays in seconds
  tdelays = ( 0.153129, 0.210389, 0.127837, 0.256891, 0.174713,
              0.192303, 0.125000, 0.219991); // total delays in seconds
  tdelay(i) = floor(0.5 + SR*take(i+1,tdelays)); // samples
  apdelay(i) = floor(0.5 + SR*take(i+1,apdelays));
  fbdelay(i) = tdelay(i) - apdelay(i);
  // NOTE: Since SR is not bounded at compile time, we can't use it to
  // allocate delay lines; hence, the fsmax parameter:
  tdelaymaxfs(i) = floor(0.5 + fsmax*take(i+1,tdelays));
  apdelaymaxfs(i) = floor(0.5 + fsmax*take(i+1,apdelays));
  fbdelaymaxfs(i) = tdelaymaxfs(i) - apdelaymaxfs(i);
  nextpow2(x) = ceil(log(x)/log(2.0));
  maxapdelay(i) = int(2.0^max(1.0,nextpow2(apdelaymaxfs(i))));
  maxfbdelay(i) = int(2.0^max(1.0,nextpow2(fbdelaymaxfs(i))));

  apcoeff(i) = select2(i&1,0.6,-0.6);  // allpass comb-filter coefficient
  allpass_combs(N) =
    par(i,N,(allpass_comb(maxapdelay(i),apdelay(i),apcoeff(i)))); // filter.lib
  fbdelaylines(N) = par(i,N,(delay(maxfbdelay(i),(fbdelay(i)))));
  freqs = (f1,f2); durs = (t60dc,t60m);
  delayfilters(N,freqs,durs) = par(i,N,filter(i,freqs,durs));
  feedbackmatrix(N) = hadamard(N); // math.lib

  staynormal = 10.0^(-20); // let signals decay well below LSB, but not to zero

  special_lowpass(g,f) = smooth(p) with {
    // unity-dc-gain lowpass needs gain g at frequency f => quadratic formula:
    p = mbo2 - sqrt(max(0,mbo2*mbo2 - 1.0)); // other solution is unstable
    mbo2 = (1.0 - gs*c)/(1.0 - gs); // NOTE: must ensure |g|<1 (t60m finite)
    gs = g*g;
    c = cos(2.0*PI*f/float(SR));
  };

  filter(i,freqs,durs) = lowshelf_lowpass(i)/sqrt(float(N))+staynormal
  with {
    lowshelf_lowpass(i) = gM*low_shelf1_l(g0/gM,f(1)):special_lowpass(gM,f(2));
    low_shelf1_l(G0,fx,x) = x + (G0-1)*lowpass(1,fx,x); // filter.lib
    g0 = g(0,i);
    gM = g(1,i);
    f(k) = take(k,freqs);
    dur(j) = take(j+1,durs);
    n60(j) = dur(j)*SR; // decay time in samples
    g(j,i) = exp(-3.0*log(10.0)*tdelay(i)/n60(j));
  };
};

// Stereo input delay used by zita_rev1 in both stereo and ambisonics mode:
zita_in_delay(rdel) = zita_delay_mono(rdel), zita_delay_mono(rdel) with {
  zita_delay_mono(rdel) = delay(8192,SR*rdel*0.001) * 0.3;
};

// Stereo input mapping used by zita_rev1 in both stereo and ambisonics mode:
zita_distrib2(N) = _,_ <: fanflip(N) with {
   fanflip(4) = _,_,*(-1),*(-1);
   fanflip(N) = fanflip(N/2),fanflip(N/2);
};

//--------------------------- zita_rev_fdn_demo ------------------------------
// zita_rev_fdn_demo = zita_rev_fdn (above) + basic GUI
//
// USAGE:
//   bus(8) : zita_rev_fdn_demo(f1,f2,t60dc,t60m,fsmax) : bus(8)
//
// WHERE
//   (args and references as for zita_rev_fdn above)

zita_rev_fdn_demo = zita_rev_fdn(f1,f2,t60dc,t60m,fsmax)
with {
  fsmax = 48000.0;
  fdn_group(x) = hgroup(
    "Zita_Rev Internal FDN Reverb [tooltip: ~ Zita_Rev's internal 8x8 Feedback Delay Network (FDN) & Schroeder allpass-comb reverberator.  See Faust's effect.lib for documentation and references]",x);
  t60dc = fdn_group(vslider("[1] Low RT60 [unit:s] [style:knob]
    [style:knob]
    [tooltip: T60 = time (in seconds) to decay 60dB in low-frequency band]",
    3, 1, 8, 0.1));
  f1 = fdn_group(vslider("[2] LF X [unit:Hz] [style:knob] [scale:log]
    [tooltip: Crossover frequency (Hz) separating low and middle frequencies]",
    200, 50, 1000, 1));
  t60m = fdn_group(vslider("[3] Mid RT60 [unit:s] [style:knob] [scale:log]
    [tooltip: T60 = time (in seconds) to decay 60dB in middle band]",
    2, 1, 8, 0.1));
  f2 = fdn_group(vslider("[4] HF Damping [unit:Hz] [style:knob] [scale:log]
    [tooltip: Frequency (Hz) at which the high-frequency T60 is half the middle-band's T60]",
    6000, 1500, 0.49*fsmax, 1));
};

//---------------------------- zita_rev1_stereo ---------------------------
// Extend zita_rev_fdn to include zita_rev1 input/output mapping in stereo mode.
//
// USAGE:
//   _,_ : zita_rev1_stereo(rdel,f1,f2,t60dc,t60m,fsmax) : _,_
//
// WHERE
//   rdel  = delay (in ms) before reverberation begins (e.g., 0 to ~100 ms)
//   (remaining args and refs as for zita_rev_fdn above)

zita_rev1_stereo(rdel,f1,f2,t60dc,t60m,fsmax) =
   zita_in_delay(rdel)
 : zita_distrib2(N)
 : zita_rev_fdn(f1,f2,t60dc,t60m,fsmax)
 : output2(N)
with {
 N = 8;
 output2(N) = outmix(N) : *(t1),*(t1);
 t1 = 0.37; // zita-rev1 linearly ramps from 0 to t1 over one buffer
 outmix(4) = !,butterfly(2),!; // probably the result of some experimenting!
 outmix(N) = outmix(N/2),par(i,N/2,!);
};

//----------------------------- zita_rev1_ambi ---------------------------
// Extend zita_rev_fdn to include zita_rev1 input/output mapping in
// "ambisonics mode", as provided in the Linux C++ version.
//
// USAGE:
//   _,_ : zita_rev1_ambi(rgxyz,rdel,f1,f2,t60dc,t60m,fsmax) : _,_,_,_
//
// WHERE
//   rgxyz = relative gain of lanes 1,4,2 to lane 0 in output (e.g., -9 to 9)
//   (remaining args and references as for zita_rev1_stereo above)

zita_rev1_ambi(rgxyz,rdel,f1,f2,t60dc,t60m,fsmax) =
   zita_in_delay(rdel)
 : zita_distrib2(N)
 : zita_rev_fdn(f1,f2,t60dc,t60m,fsmax)
 : output4(N) // ambisonics mode
with {
  N=8;
  output4(N) = select4 : *(t0),*(t1),*(t1),*(t1);
  select4 = _,_,_,!,_,!,!,! : _,_,cross with { cross(x,y) = y,x; };
  t0 = 1.0/sqrt(2.0);
  t1 = t0 * 10.0^(0.05 * rgxyz);
};

//---------------------------------- zita_rev1 ------------------------------
// Example GUI for zita_rev1_stereo (mostly following the Linux zita-rev1 GUI).
//
// Only the dry/wet and output level parameters are "dezippered" here.  If
// parameters are to be varied in real time, use "smooth(0.999)" or the like
// in the same way.
//
// REFERENCE:
//   http://www.kokkinizita.net/linuxaudio/zita-rev1-doc/quickguide.html
//
// DEPENDENCIES:
//   filter.lib (peak_eq_rm)

zita_rev1(x,y) = zita_rev1_stereo(rdel,f1,f2,t60dc,t60m,fsmax,x,y)
          : out_eq : dry_wet(x,y) : out_level
with {

  fsmax = 48000.0;  // highest sampling rate that will be used

  fdn_group(x) = hgroup(
    "[0] Zita_Rev1 [tooltip: ~ ZITA REV1 FEEDBACK DELAY NETWORK (FDN) & SCHROEDER ALLPASS-COMB REVERBERATOR (8x8). See Faust's effect.lib for documentation and references]", x);

  in_group(x) = fdn_group(hgroup("[1] Input", x));

  rdel = in_group(vslider("[1] In Delay [unit:ms] [style:knob]
                  [tooltip: Delay in ms before reverberation begins]",
                  60,20,100,1));

  freq_group(x) = fdn_group(hgroup("[2] Decay Times in Bands (see tooltips)", x));

  f1 = freq_group(vslider("[1] LF X [unit:Hz] [style:knob] [scale:log]
       [tooltip: Crossover frequency (Hz) separating low and middle frequencies]",
       200, 50, 1000, 1));

  t60dc = freq_group(vslider("[2] Low RT60 [unit:s] [style:knob] [scale:log]
          [style:knob] [tooltip: T60 = time (in seconds) to decay 60dB in low-frequency band]",
          3, 1, 8, 0.1));

  t60m = freq_group(vslider("[3] Mid RT60 [unit:s] [style:knob] [scale:log]
          [tooltip: T60 = time (in seconds) to decay 60dB in middle band]",
          2, 1, 8, 0.1));

  f2 = freq_group(vslider("[4] HF Damping [unit:Hz] [style:knob] [scale:log]
       [tooltip: Frequency (Hz) at which the high-frequency T60 is half the middle-band's T60]",
       6000, 1500, 0.49*fsmax, 1));

  out_eq = pareq_stereo(eq1f,eq1l,eq1q) : pareq_stereo(eq2f,eq2l,eq2q);
// Zolzer style peaking eq (not used in zita-rev1) (filter.lib):
// pareq_stereo(eqf,eql,Q) = peak_eq(eql,eqf,eqf/Q), peak_eq(eql,eqf,eqf/Q);
// Regalia-Mitra peaking eq with "Q" hard-wired near sqrt(g)/2 (filter.lib):
  pareq_stereo(eqf,eql,Q) = peak_eq_rm(eql,eqf,tpbt), peak_eq_rm(eql,eqf,tpbt)
  with {
    tpbt = wcT/sqrt(max(0,g)); // tan(PI*B/SR), B bw in Hz (Q^2 ~ g/4)
    wcT = 2*PI*eqf/SR;  // peak frequency in rad/sample
    g = db2linear(eql); // peak gain
  };

  eq1_group(x) = fdn_group(hgroup("[3] RM Peaking Equalizer 1", x));

  eq1f = eq1_group(vslider("[1] Eq1 Freq [unit:Hz] [style:knob] [scale:log]
       [tooltip: Center-frequency of second-order Regalia-Mitra peaking equalizer section 1]",
       315, 40, 2500, 1));

  eq1l = eq1_group(vslider("[2] Eq1 Level [unit:dB] [style:knob]
       [tooltip: Peak level in dB of second-order Regalia-Mitra peaking equalizer section 1]",
       0, -15, 15, 0.1));

  eq1q = eq1_group(vslider("[3] Eq1 Q [style:knob]
       [tooltip: Q = centerFrequency/bandwidth of second-order peaking equalizer section 1]",
       3, 0.1, 10, 0.1));

  eq2_group(x) = fdn_group(hgroup("[4] RM Peaking Equalizer 2", x));

  eq2f = eq2_group(vslider("[1] Eq2 Freq [unit:Hz] [style:knob] [scale:log]
       [tooltip: Center-frequency of second-order Regalia-Mitra peaking equalizer section 2]",
       1500, 160, 10000, 1));

  eq2l = eq2_group(vslider("[2] Eq2 Level [unit:dB] [style:knob]
       [tooltip: Peak level in dB of second-order Regalia-Mitra peaking equalizer section 2]",
       0, -15, 15, 0.1));

  eq2q = eq2_group(vslider("[3] Eq2 Q [style:knob]
       [tooltip: Q = centerFrequency/bandwidth of second-order peaking equalizer section 2]",
       3, 0.1, 10, 0.1));

  out_group(x)  = fdn_group(hgroup("[5] Output", x));

  dry_wet(x,y) = *(wet) + dry*x, *(wet) + dry*y with {
    wet = 0.5*(drywet+1.0);
    dry = 1.0-wet;
  };

  drywet = out_group(vslider("[1] Dry/Wet Mix [style:knob]
       [tooltip: -1 = dry, 1 = wet]",
       0, -1.0, 1.0, 0.01)) : smooth(0.999);

  out_level = *(gain),*(gain);

  gain = out_group(vslider("[2] Level [unit:dB] [style:knob]
    [tooltip: Output scale factor]", -20, -70, 40, 0.1))
    : db2linear : smooth(0.999);

};

//---------------------------------- mesh_square ------------------------------
// Square Rectangular Digital Waveguide Mesh
//
// USAGE:
//   bus(4*N) : mesh_square(N) : bus(4*N);
//
// WHERE
//   N = number of nodes along each edge - a power of two (1,2,4,8,...)
//
// REQUIRES: math.lib
//
// REFERENCE:
//   https://ccrma.stanford.edu/~jos/pasp/Digital_Waveguide_Mesh.html
//
// SIGNAL ORDER IN AND OUT:
//   The mesh is constructed recursively using 2x2 embeddings.  Thus,
//   the top level of mesh_square(M) is a block 2x2 mesh, where each
//   block is a mesh(M/2).  Let these blocks be numbered 1,2,3,4 in the
//   geometry [NW,NE;SW,SE], i.e., as
//         1 2
//         3 4
//   Each block has four vector inputs and four vector outputs, where the
//   length of each vector is M/2.  Label the input vectors as Ni,Ei,Wi,Si,
//   i.e., as the inputs from the North, East South, and West,
//   and similarly for the outputs.  Then, for example, the upper
//   left input block of M/2 signals is labeled 1Ni.  Most of the
//   connections are internal, such as 1Eo -> 2Wi.  The 8*(M/2) input
//   signals are grouped in the order
//        1Ni 2Ni
//        3Si 4Si
//        1Wi 3Wi
//        2Ei 4Ei
//   and the output signals are
//        1No 1Wo
//        2No 2Eo
//        3So 3Wo
//        4So 4Eo
//   or
//         In: 1Ni 2Ni 3Si 4Si 1Wi 3Wi 2Ei 4Ei
//        Out: 1No 1Wo 2No 2Eo 3So 3Wo 4So 4Eo
//   Thus, the inputs are grouped by direction N,S,W,E, while the
//   outputs are grouped by block number 1,2,3,4, which can also be
//   interpreted as directions NW, NE, SW, SE.  A simple program
//   illustrating these orderings is `process = mesh_square(2);`.
//
// EXAMPLE: Reflectively terminated mesh impulsed at one corner:
//  `mesh_square_test(N,x) = mesh_square(N)~(busi(4*N,x)) // input to corner
//   with { busi(N,x) = bus(N) : par(i,N,*(-1)) : par(i,N-1,_), +(x); };
//   process = 1-1' : mesh_square_test(4); // all modes excited forever`
// In this simple example, the mesh edges are connected as follows:
//        1No -> 1Ni, 1Wo -> 2Ni, 2No -> 3Si, 2Eo -> 4Si,
//        3So -> 1Wi, 3Wo -> 3Wi, 4So -> 2Ei, 4Eo -> 4Ei
// A routing matrix can be used to obtain other connection geometries.

// four-port scattering junction:
mesh_square(1) =
          bus(4) <: par(i,4,*(-1)), (bus(4) :> (*(.5)) <: bus(4)) :> bus(4);

// rectangular NxN square waveguide mesh:
mesh_square(N) = bus(4*N) : (route_inputs(N/2) : par(i,4,mesh_square(N/2)))
          ~(prune_feedback(N/2))
          : prune_outputs(N/2) : route_outputs(N/2) : bus(4*N)
with {
  block(N) = par(i,N,!);

  // select block i of N, block size = M:
  s(i,N,M) = par(j, M*N, Sv(i, j))
     with { Sv(i,i) = bus(N); Sv(i,j) = block(N); };

  // prune mesh outputs down to the signals which make it out:
  prune_outputs(N)
    = bus(16*N) :
      block(N), bus(N),   block(N), bus(N),
      block(N), bus(N),   bus(N),   block(N),
      bus(N),   block(N), block(N), bus(N),
      bus(N),   block(N), bus(N),   block(N)
      : bus(8*N);

  // collect mesh outputs into standard order (N,W,E,S):
  route_outputs(N)
    = bus(8*N)
      <: s(4,N,8),s(5,N,8), s(0,N,8),s(2,N,8),
         s(3,N,8),s(7,N,8), s(1,N,8),s(6,N,8)
      : bus(8*N);

  // collect signals used as feedback:
  prune_feedback(N) = bus(16*N) :
      bus(N),   block(N), bus(N),   block(N),
      bus(N),   block(N), block(N), bus(N),
      block(N), bus(N),   bus(N),   block(N),
      block(N), bus(N),   block(N), bus(N) :
      bus(8*N);

  // route mesh inputs (feedback, external inputs):
  route_inputs(N) = bus(8*N), bus(8*N)
  <:s(8,N,16),s(4,N,16), s(12,N,16),s(3,N,16),
    s(9,N,16),s(6,N,16), s(1,N,16),s(14,N,16),
    s(0,N,16),s(10,N,16), s(13,N,16),s(7,N,16),
    s(2,N,16),s(11,N,16), s(5,N,16),s(15,N,16)
    : bus(16*N);
};
//#################################### vaeffects.lib ########################################
// A library of virtual analog filter effects. Its official prefix is `ve`.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/vaeffects.lib>
//########################################################################################

ma = library("maths.lib");
si = library("signals.lib");
an = library("analyzers.lib");
fi = library("filters.lib");
ef = library("misceffects.lib");

declare name "Faust Virtual Analog Filter Effect Library";
declare version "0.2";

//########################################################################################
/************************************************************************
FAUST library file, jos section

Except where noted otherwise, The Faust functions below in this
section are Copyright (C) 2003-2017 by Julius O. Smith III <jos@ccrma.stanford.edu>
([jos](http://ccrma.stanford.edu/~jos/)), and released under the
(MIT-style) [STK-4.3](#stk-4.3-license) license.

All MarkDown comments in this section are Copyright 2016-2017 by Romain
Michon and Julius O. Smith III, and are released under the
[CCA4I](https://creativecommons.org/licenses/by/4.0/) license (TODO: if/when Romain agrees!)

************************************************************************/

//====================================Moog Filters========================================
//========================================================================================

//-------------------------`(ve.)moog_vcf`---------------------------
// Moog "Voltage Controlled Filter" (VCF) in "analog" form. Moog VCF
// implemented using the same logical block diagram as the classic
// analog circuit.  As such, it neglects the one-sample delay associated
// with the feedback path around the four one-poles.
// This extra delay alters the response, especially at high frequencies
// (see reference [1] for details).
// See `moog_vcf_2b` below for a more accurate implementation.
//
// #### Usage
//
// ```
// _ : moog_vcf(res,fr) : _
// ```
// Where:
//
// * `res`: normalized amount of corner-resonance between 0 and 1 
// (0 is no resonance, 1 is maximum)
// * `fr`: corner-resonance frequency in Hz (less than SR/6.3 or so)
//
// #### References
// * <https://ccrma.stanford.edu/~stilti/papers/moogvcf.pdf>
// * <https://ccrma.stanford.edu/~jos/pasp/vegf.html>
//------------------------------------------------------------
declare moog_vcf author "Julius O. Smith III";
declare moog_vcf copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare moog_vcf license "MIT-style STK-4.3 license";
moog_vcf(res,fr) = (+ : seq(i,4,fi.pole(p)) : *(unitygain(p))) ~ *(mk)
with {
     p = 1.0 - fr * 2.0 * ma.PI / ma.SR; // good approximation for fr << SR
     unitygain(p) = pow(1.0-p,4.0); // one-pole unity-gain scaling
     mk = -4.0*max(0,min(res,0.999999)); // need mk > -4 for stability
};

//-----------------------`(ve.)moog_vcf_2b[n]`---------------------------
// Moog "Voltage Controlled Filter" (VCF) as two biquads. Implementation
// of the ideal Moog VCF transfer function factored into second-order
// sections. As a result, it is more accurate than `moog_vcf` above, but
// its coefficient formulas are more complex when one or both parameters
// are varied.  Here, res is the fourth root of that in `moog_vcf`, so, as
// the sampling rate approaches infinity, `moog_vcf(res,fr)` becomes equivalent
// to `moog_vcf_2b[n](res^4,fr)` (when res and fr are constant).
// `moog_vcf_2b` uses two direct-form biquads (`tf2`).
// `moog_vcf_2bn` uses two protected normalized-ladder biquads (`tf2np`).
//
// #### Usage
//
// ```
// _ : moog_vcf_2b(res,fr) : _
// _ : moog_vcf_2bn(res,fr) : _
// ```
//
// Where:
//
// * `res`: normalized amount of corner-resonance between 0 and 1
// 	(0 is min resonance, 1 is maximum)
// * `fr`: corner-resonance frequency in Hz
//------------------------------------------------------------
declare moog_vcf_2b author "Julius O. Smith III";
declare moog_vcf_2b copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare moog_vcf_2b license "MIT-style STK-4.3 license";
moog_vcf_2b(res,fr) = fi.tf2s(0,0,b0,a11,a01,w1) : fi.tf2s(0,0,b0,a12,a02,w1)
with {
 s = 1; // minus the open-loop location of all four poles
 frl = max(20,min(10000,fr)); // limit fr to reasonable 20-10k Hz range
 w1 = 2*ma.PI*frl; // frequency-scaling parameter for bilinear xform
 // Equivalent: w1 = 1; s = 2*PI*frl;
 kmax = sqrt(2)*0.99999; // 0.99999 gives stability margin (tf2 is unprotected)
 k = min(kmax,sqrt(2)*res); // fourth root of Moog VCF feedback gain
 b0 = s^2;
 s2k = sqrt(2) * k;
 a11 = s * (2 + s2k);
 a12 = s * (2 - s2k);
 a01 = b0 * (1 + s2k + k^2);
 a02 = b0 * (1 - s2k + k^2);
};

declare moog_vcf_2bn author "Julius O. Smith III";
declare moog_vcf_2bn copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare moog_vcf_2bn license "MIT-style STK-4.3 license";
moog_vcf_2bn(res,fr) = fi.tf2snp(0,0,b0,a11,a01,w1) : fi.tf2snp(0,0,b0,a12,a02,w1)
with {
 s = 1; // minus the open-loop location of all four poles
 w1 = 2*ma.PI*max(fr,20); // frequency-scaling parameter for bilinear xform
 k = sqrt(2)*0.99999*res; // fourth root of Moog VCF feedback gain
 b0 = s^2;
 s2k = sqrt(2) * k;
 a11 = s * (2 + s2k);
 a12 = s * (2 - s2k);
 a01 = b0 * (1 + s2k + k^2);
 a02 = b0 * (1 - s2k + k^2);
};


//------------------`(ve.)moogLadder`-----------------
// Virtual analog model of the 4th-order Moog Ladder, which is arguably the 
// most well-known ladder filter in analog synthesizers. Several 
// 1st-order filters are cascaded in series. Feedback is then used, in part, to 
// control the cut-off frequency and the resonance.
//
// #### References
//
// [Zavalishin 2012] (revision 2.1.2, February 2020): 
//
// * <https://www.native-instruments.com/fileadmin/ni_media/downloads/pdf/VAFilterDesign_2.1.2.pdf>
//
// This fix is based on Lorenzo Della Cioppa's correction to Pirkle's implementation; see this post: 
// https://www.kvraudio.com/forum/viewtopic.php?f=33&t=571909
//
// #### Usage
//
// ```
// _ : moogLadder(normFreq,Q) : _
// ```
//
// Where:
//
// * `normFreq`: normalized frequency (0-1)
// * `Q`: quality factor between .707 (0 feedback coefficient) to 25 (feedback = 4, which is the self-oscillating threshold).
//---------------------------------------------------------------------
declare moogLadder author "Dario Sanfilippo";
declare moogLadder license "MIT-style STK-4.3 license";
moogLadder(normFreq, Q, x) = loop ~ si.bus(4) : (!,!,!,!,_)
with {
    loop(s1, s2, s3, s4) =  v1 + lp1 , // define s1
                            v2 + lp2 , // define s2
                            v3 + lp3 , // define s3
                            v4 + lp4 , // define s4
                            lp4 // system output
        with {
            T = 1.0 / ma.SR;
            cf = normFreq * .5 * ma.SR;
            k = 4.0 * (Q - 0.707) / (25.0 - 0.707);
            omegaWarp = tan(ma.PI * cf * T);
            g = omegaWarp / (1.0 + omegaWarp);
            G = g * g * g * g; // ladder's G in generalised form y = G * xi + S
            S = g * g * g * (s1 * (1 - g)) + g * g * (s2 * (1 - g)) + g * (s3 * (1 - g)) + (s4 * (1 - g)); // ladder's S in generalised form y = G * xi + S
            u = (x - k * S) / (1.0 + k * G); // input to the first LP stage: u = (x - kS) / (1 + kG)
            v1 = g * (u - s1); // v-signals in TPT integrator (Zavalishin, Figure 3.30)
            v2 = g * (lp1 - s2); // second stage
            v3 = g * (lp2 - s3); // third stage
            v4 = g * (lp3 - s4); // fourth stage
            lp1 = v1 + s1; // define outputs
            lp2 = v2 + s2;
            lp3 = v3 + s3;
            lp4 = v4 + s4;
        };
};


//------------------`(ve.)moogHalfLadder`-----------------
// Virtual analog model of the 2nd-order Moog Half Ladder (simplified version of
// `(ve.)moogLadder`). Several 1st-order filters are cascaded in series. 
// Feedback is then used, in part, to control the cut-off frequency and the 
// resonance.
//
// This filter was implemented in Faust by Eric Tarr during the 
// [2019 Embedded DSP With Faust Workshop](https://ccrma.stanford.edu/workshops/faust-embedded-19/).
// 
// #### References
//
// * <https://www.willpirkle.com/app-notes/virtual-analog-moog-half-ladder-filter>
// * <http://www.willpirkle.com/Downloads/AN-8MoogHalfLadderFilter.pdf>
//
// #### Usage
//
// ```
// _ : moogHalfLadder(normFreq,Q) : _
// ```
//
// Where:
//
// * `normFreq`: normalized frequency (0-1)
// * `Q`: q
//---------------------------------------------------------------------
declare moogHalfLadder author "Eric Tarr";
declare moogHalfLadder license "MIT-style STK-4.3 license";
moogHalfLadder(normFreq,Q) = _ <: (s1,s2,s3,y) : !,!,!,_ 
letrec{
  's1 = -(s3*B3*k):-(s2*B2*k):-(s1*B1*k):*(alpha0):-(s1):*(alpha*2):+(s1);
  's2 = -(s3*B3*k):-(s2*B2*k):-(s1*B1*k):*(alpha0):-(s1):*(alpha):+(s1):-(s2):*(alpha*2):+(s2);
  's3 = -(s3*B3*k):-(s2*B2*k):-(s1*B1*k):*(alpha0):-(s1):*(alpha):+(s1):-(s2):*(alpha):+(s2):-(s3):*(alpha*2):+(s3);
  'y = -(s3*B3*k):-(s2*B2*k):-(s1*B1*k):*(alpha0):-(s1):*(alpha):+(s1):-(s2):*(alpha):+(s2) <:_*-1,((-(s3):*(alpha):+(s3))*2):>_;
}
with{
  freq = 2*(10^(3*normFreq+1));
  k = 2.0*(Q - 0.707)/(25.0 - 0.707);
  wd = 2*ma.PI*freq;
  T = 1/ma.SR;
  wa = (2/T)*tan(wd*T/2);
  g = wa*T/2; 
  G = g/(1.0 + g);
  alpha = G;
  GA = 2*G-1; // All-pass gain
  B1 = GA*G/(1+g);
  B2 = GA/(1+g);
  B3 = 2/(1+g);
  alpha0 = 1/(1 + k*GA*G*G);
};


//------------------`(ve.)diodeLadder`-----------------
// 4th order virtual analog diode ladder filter. In addition to the individual 
// states used within each independent 1st-order filter, there are also additional 
// feedback paths found in the block diagram. These feedback paths are labeled 
// as connecting states. Rather than separately storing these connecting states 
// in the Faust implementation, they are simply implicitly calculated by 
// tracing back to the other states (`s1`,`s2`,`s3`,`s4`) each recursive step.
//
// This filter was implemented in Faust by Eric Tarr during the 
// [2019 Embedded DSP With Faust Workshop](https://ccrma.stanford.edu/workshops/faust-embedded-19/).
// 
// #### References
//
// * <https://www.willpirkle.com/virtual-analog-diode-ladder-filter/>
// * <http://www.willpirkle.com/Downloads/AN-6DiodeLadderFilter.pdf>
//
// #### Usage
//
// ```
// _ : diodeLadder(normFreq,Q) : _
// ```
//
// Where:
//
// * `normFreq`: normalized frequency (0-1)
// * `Q`: q
//---------------------------------------------------------------------
declare diodeLadder author "Eric Tarr";
declare diodeLadder license "MIT-style STK-4.3 license";
diodeLadder(normFreq,Q) = ef.cubicnl(1,0)*1.5 <:(s1,s2,s3,s4,y)  : !,!,!,!,_ 
letrec{
  's1 = _-(s4*B4*SG4*k) : 
    _-((s4*B4*d3+s3)*B3*SG3*k) : 
    _-(((s4*B4*d3+s3)*B3*d2 + s2)*B2*SG3*k) :
    _-((((s4*B4*d3+s3)*B3*d2 + s2)*B2*d1 + s1)*B1*SG1*k) :
    _*alpha0: _*gam1 : _+((s4*B4*d3+s3)*B3*d2 + s2)*B2 : //_+S2
    _+((((s4*B4*d3+s3)*B3*d2 + s2)*B2)*d1 + s1)*B1*G2 : // _ + (S2 ...
    _*a1 : _-s1 :_*alpha*2 : _+s1;

  's2 = _-(s4*B4*SG4*k) : 
    _-((s4*B4*d3+s3)*B3*SG3*k) : 
    _-(((s4*B4*d3+s3)*B3*d2 + s2)*B2*SG3*k):
    _-((((s4*B4*d3+s3)*B3*d2 + s2)*B2*d1 + s1)*B1*SG1*k) :
    _*alpha0: _*gam1 : _+((s4*B4*d3+s3)*B3*d2 + s2)*B2 : //_+S2
    _+((((s4*B4*d3+s3)*B3*d2 + s2)*B2)*d1 + s1)*B1*G2 : // _ + (S2 ...
    _*a1 : _-s1 :_*alpha : _+s1 : _*gam2 :
    _+(s4*B4*d3 + s3)*B3 : //_+S3 :
    _+(((s4*B4*d3 + s3)*B3)*d2 + s2)*B2*G3 : //_+(S3...)
    _*a2 : _-s2 : _*alpha*2 : _+s2;
		
  's3 = _-(s4*B4*SG4*k) : 
    _-((s4*B4*d3+s3)*B3*SG3*k) : 
    _-(((s4*B4*d3+s3)*B3*d2 + s2)*B2*SG3*k) :
    _-((((s4*B4*d3+s3)*B3*d2 + s2)*B2*d1 + s1)*B1*SG1*k) :
    _*alpha0 : _*gam1 : _+((s4*B4*d3+s3)*B3*d2 + s2)*B2 : //_+S2
    _+((((s4*B4*d3+s3)*B3*d2 + s2)*B2)*d1+s1)*B1*G2 : // _ + (S2 ...
    _*a1 : _-s1 :_*alpha : _+s1 : _*gam2 :
    _+(s4*B4*d3 + s3)*B3 : //_+S3 :
    _+(((s4*B4*d3 + s3)*B3)*d2 + s2)*B2*G3 : //_+(S3...)
    _*a2 : _-s2 : _*alpha : _+s2 : _*gam3:
    _+s4*B4 : // _ + S4
    _+((s4*B4)*d3 + s3)*B3*G4: // _ + S4 ...
    _*a3 : _-s3 : _*alpha*2 : _+s3;
  
  's4 = _-(s4*B4*SG4*k) : 
    _-((s4*B4*d3+s3)*B3*SG3*k) : 
    _-(((s4*B4*d3+s3)*B3*d2 + s2)*B2*SG3*k) :
    _-((((s4*B4*d3+s3)*B3*d2 + s2)*B2*d1 + s1 )*B1*SG1*k) :
    _*alpha0 : _*gam1 : _+((s4*B4*d3+s3)*B3*d2 + s2)*B2 : //_+S2
    _+((((s4*B4*d3+s3)*B3*d2 + s2)*B2)*d1 + s1)*B1*G2 : // _ + (S2 ...
    _*a1 : _-s1 :_*alpha : _+s1 : _*gam2 :
    _+(s4*B4*d3 + s3)*B3 : //_+S3 :
    _+(((s4*B4*d3 + s3)*B3)  *d2+s2)*B2*G3 : //_+(S3...)
    _*a2 : _-s2 : _*alpha : _+s2 : _*gam3 :
    _+s4*B4 : // _ + S4
    _+((s4*B4)*d3 + s3)*B3*G4: // _ + S4 ...
    _*a3 : _-s3 : _*alpha : _+s3 : _*gam4 : _*a4 : _-s4 : _*alpha*2 : _+s4;
  
  // Output signal
  'y = _-(s4*B4*SG4*k) : 
    _-((s4*B4*d3+s3)*B3*SG3*k) : 
    _-(((s4*B4*d3+s3)*B3*d2 + s2)*B2*SG3*k) :
    _-((((s4*B4*d3+s3)*B3*d2 + s2)*B2*d1 + s1 )*B1*SG1*k) :
    _*alpha0: _*gam1 : _+((s4*B4*d3+s3)*B3*d2 + s2)*B2 : //_+S2
    _+((((s4*B4*d3+s3)*B3*d2 + s2)*B2)*d1 + s1)*B1*G2 : // _ + (S2 ...
    _*a1 : _-s1 :_*alpha : _+s1 : _*gam2 :
    _+(s4*B4*d3 + s3)*B3 : //_+S3 :
    _+(((s4*B4*d3 + s3)*B3)*d2 + s2)*B2*G3 : //_+(S3...)
    _*a2 : _-s2 : _*alpha : _+s2 : _*gam3 :
    _+s4*B4 : // _ + S4
    _+((s4*B4)*d3 + s3)*B3*G4: // _ + S4 ...
    _*a3 : _-s3 : _*alpha : _+s3 : _*gam4 : _*a4 : _-s4 : _*alpha : _+s4;
}
with{
  freq = 2*(10^(3*normFreq+1));
  k = (17 - (normFreq^10)*9.7)*(Q - 0.707)/(25.0 - 0.707);
  wd = 2*ma.PI*freq;
  T = 1/ma.SR;
  wa = (2/T)*tan(wd*T/2);
  g = wa*T/2; 
  G4 = 0.5*g/(1 + g);
  G3 = 0.5*g/(1 + g - 0.5*g*G4);
  G2 = 0.5*g/(1 + g - 0.5*g*G3);
  G1 = g/(1.0 + g - g*G2);
  Gamma = G1*G2*G3*G4;
  SG1 = G4*G3*G2; // feedback gain pre-calculated
  SG2 = G4*G3; 
  SG3 = G4; 
  SG4 = 1;
  alpha = g/(1+g);
  alpha0 = 1/(1+k*Gamma);
  gam1 = 1+G1*G2;
  gam2 = 1+G2*G3;
  gam3 = 1+G3*G4; 
  gam4 = 1;
  a1 = 1; // a0 for 1st LPF
  a2 = 0.5; // a0 for 2nd LPF
  a3 = 0.5;
  a4 = 0.5;
  B1 = 1/(1+g-g*G2); // Beta for 1st block
  B2 = 1/(1+g-0.5*g*G3);
  B3 = 1/(1+g-0.5*g*G4);
  B4 = 1/(1+g);
  d1 = g; // delta for 1st block
  d2 = 0.5*g;
  d3 = 0.5*g;
  //d4 = 0;
};


//===================================Korg 35 Filters======================================
// The following filters are virtual analog models of the Korg 35 low-pass 
// filter and high-pass filter found in the MS-10 and MS-20 synthesizers.
// The virtual analog models for the LPF and HPF are different, making these 
// filters more interesting than simply tapping different states of the same 
// circuit. 
//
// These filters were implemented in Faust by Eric Tarr during the 
// [2019 Embedded DSP With Faust Workshop](https://ccrma.stanford.edu/workshops/faust-embedded-19/).
//
// #### Filter history:
//
// <https://secretlifeofsynthesizers.com/the-korg-35-filter/>
//========================================================================================

//------------------`(ve.)korg35LPF`-----------------
// Virtual analog models of the Korg 35 low-pass filter found in the MS-10 and 
// MS-20 synthesizers.
//
// #### Usage
//
// ```
// _ : korg35LPF(normFreq,Q) : _
// ```
//
// Where:
//
// * `normFreq`: normalized frequency (0-1)
// * `Q`: q
//---------------------------------------------------------------------
declare korg35LPF author "Eric Tarr";
declare korg35LPF license "MIT-style STK-4.3 license";
korg35LPF(normFreq,Q) = _ <: (s1,s2,s3,y) : !,!,!,_
letrec{
  's1 = _-s1:_*(alpha*2):_+s1;
  's2 = _-s1:_*alpha:_+s1:_+(s3*B3):_+(s2*B2):_*alpha0:_-s3:_*alpha:_+s3:_*K:_-s2:_*(alpha*2):_+s2;
  's3 = _-s1:_*alpha:_+s1:_+(s3*B3):_+(s2*B2):_*alpha0:_-s3:_*(alpha*2):_+s3;
  'y = _-s1:_*alpha:_+s1:_+(s3*B3):_+(s2*B2) :_*alpha0:_-s3:_*alpha:_+s3;
}
with{
  freq = 2*(10^(3*normFreq+1));
  K = 2.0*(Q - 0.707)/(10.0 - 0.707);
  wd = 2*ma.PI*freq;
  T = 1/ma.SR;
  wa = (2/T)*tan(wd*T/2);
  g = wa*T/2; 
  G = g/(1.0 + g);
  alpha = G;
  B3 = (K - K*G)/(1 + g);
  B2 = -1/(1 + g);
  alpha0 = 1/(1 - K*G + K*G*G); 
};


//------------------`(ve.)korg35HPF`-----------------
// Virtual analog models of the Korg 35 high-pass filter found in the MS-10 and 
// MS-20 synthesizers.
//
// #### Usage
//
// ```
// _ : korg35HPF(normFreq,Q) : _
// ```
//
// Where:
//
// * `normFreq`: normalized frequency (0-1)
// * `Q`: q
//---------------------------------------------------------------------
declare korg35HPF author "Eric Tarr";
declare korg35HPF license "MIT-style STK-4.3 license";
korg35HPF(normFreq,Q) = _ <: (s1,s2,s3,y) : !,!,!,_
letrec{
  's1 = _-s1:_*(alpha*2):_+s1;
  's2 = _<:(_-s1:_*alpha:_+s1)*-1,_:>_+(s3*B3):_+(s2*B2):_*alpha0:_*K:_-s2:_*alpha*2:_+s2;
  's3 = _<:(_-s1:_*alpha:_+s1)*-1,_:>_+(s3*B3):_+(s2*B2):_*alpha0:_*K:_<:(_-s2:_*alpha:_+s2)*-1,_:>_-s3:_*alpha*2:_+s3;
  'y = _<:(_-s1:_*alpha:_+s1)*-1,_:>_+(s3*B3):_+(s2*B2):_*alpha0;
}
with{
  freq = 2*(10^(3*normFreq+1));
  K = 2.0*(Q - 0.707)/(10.0 - 0.707);
  wd = 2*ma.PI*freq;
  T = 1/ma.SR;
  wa = (2/T)*tan(wd*T/2);
  g = wa*T/2; 
  G = g/(1.0 + g);
  alpha = G;
  B3 = 1.0/(1.0 + g);
  B2 = -1.0*G/(1.0 + g);
  alpha0 = 1/(1 - K*G + K*G*G);
};


//==================================Oberheim Filters======================================
// The following filter (4 types) is an implementation of the virtual analog 
// model described in Section 7.2 of the Will Pirkle book, "Designing Software 
// Synthesizer Plug-ins in C++". It is based on the block diagram in Figure 7.5. 
//
// The Oberheim filter is a state-variable filter with soft-clipping distortion 
// within the circuit. 
//
// In many VA filters, distortion is accomplished using the "tanh" function. 
// For this Faust implementation, that distortion function was replaced with 
// the `(ef.)cubicnl` function.
//========================================================================================

//------------------`(ve.)oberheim`-----------------
// Generic multi-outputs Oberheim filter that produces the BSF, BPF, HPF and LPF outputs (see description above).
//
// #### Usage
//
// ```
// _ : oberheim(normFreq,Q) : _,_,_,_
// ```
//
// Where:
//
// * `normFreq`: normalized frequency (0-1)
// * `Q`: q
//---------------------------------------------------------------------
declare oberheim author "Eric Tarr";
declare oberheim license "MIT-style STK-4.3 license";
oberheim(normFreq,Q) = _<:(s1,s2,ybsf,ybpf,yhpf,ylpf) : !,!,_,_,_,_  
letrec{
  's1 = _-s2:_-(s1*FBs1):_*alpha0:_*g<:_,(_+s1:ef.cubicnl(0.0,0)):>_;
  's2 = _-s2:_-(s1*FBs1):_*alpha0:_*g:_+s1:ef.cubicnl(0.0,0):_*g*2:_+s2;
  // Compute the BSF, BPF, HPF, LPF outputs
  'ybsf = _-s2:_-(s1*FBs1):_*alpha0<:(_*g:_+s1:ef.cubicnl(0.0,0):_*g:_+s2),_:>_;
  'ybpf = _-s2:_-(s1*FBs1):_*alpha0:_*g:_+s1:ef.cubicnl(0.0,0);
  'yhpf = _-s2:_-(s1*FBs1):_*alpha0;
  'ylpf = _-s2:_-(s1*FBs1):_*alpha0:_*g :_+s1:ef.cubicnl(0.0,0):_*g:_+s2;
}
with{
  freq = 2*(10^(3*normFreq+1));
  wd = 2*ma.PI*freq;
  T = 1/ma.SR;
  wa = (2/T)*tan(wd*T/2);
  g = wa*T/2; 
  G = g/(1.0 + g);
  R = 1/(2*Q);
  FBs1 = (2*R+g);
  alpha0 = 1/(1 + 2*R*g + g*g);
};


//------------------`(ve.)oberheimBSF`-----------------
// Band-Stop Oberheim filter (see description above). 
// Specialize the generic implementation: keep the first BSF output, 
// the compiler will only generate the needed code.
//
// #### Usage
//
// ```
// _ : oberheimBSF(normFreq,Q) : _
// ```
//
// Where:
//
// * `normFreq`: normalized frequency (0-1)
// * `Q`: q
//---------------------------------------------------------------------
declare oberheimBSF author "Eric Tarr";
declare oberheimBSF license "MIT-style STK-4.3 license";
oberheimBSF(normFreq,Q) = oberheim(normFreq,Q):_,!,!,!;


//------------------`(ve.)oberheimBPF`-----------------
// Band-Pass Oberheim filter (see description above).
// Specialize the generic implementation: keep the second BPF output, 
// the compiler will only generate the needed code.
//
// #### Usage
//
// ```
// _ : oberheimBPF(normFreq,Q) : _
// ```
//
// Where:
//
// * `normFreq`: normalized frequency (0-1)
// * `Q`: q
//---------------------------------------------------------------------
declare oberheimBPF author "Eric Tarr";
declare oberheimBPF license "MIT-style STK-4.3 license";
oberheimBPF(normFreq,Q) = oberheim(normFreq,Q):!,_,!,!;


//------------------`(ve.)oberheimHPF`-----------------
// High-Pass Oberheim filter (see description above).
// Specialize the generic implementation: keep the third HPF output, 
// the compiler will only generate the needed code.
//
// #### Usage
//
// ```
// _ : oberheimHPF(normFreq,Q) : _
// ```
//
// Where:
//
// * `normFreq`: normalized frequency (0-1)
// * `Q`: q
//---------------------------------------------------------------------
declare oberheimHPF author "Eric Tarr";
declare oberheimHPF license "MIT-style STK-4.3 license";
oberheimHPF(normFreq,Q) = oberheim(normFreq,Q):!,!,_,!;


//------------------`(ve.)oberheimLPF`-----------------
// Low-Pass Oberheim filter (see description above). 
// Specialize the generic implementation: keep the fourth LPF output,
// the compiler will only generate the needed code.
//
// #### Usage
//
// ```
// _ : oberheimLPF(normFreq,Q) : _
// ```
//
// Where:
//
// * `normFreq`: normalized frequency (0-1)
// * `Q`: q
//---------------------------------------------------------------------
declare oberheimLPF author "Eric Tarr";
declare oberheimLPF license "MIT-style STK-4.3 license";
oberheimLPF(normFreq,Q) = oberheim(normFreq,Q):!,!,!,_;


//================================Sallen Key Filters======================================
// The following filters were implemented based on VA models of synthesizer 
// filters.
//
// The modeling approach is based on a Topology Preserving Transform (TPT) to 
// resolve the delay-free feedback loop in the corresponding analog filters.  
//
// The primary processing block used to build other filters (Moog, Korg, etc.) is
// based on a 1st-order Sallen-Key filter. 
//
// The filters included in this script are 1st-order LPF/HPF and 2nd-order 
// state-variable filters capable of LPF, HPF, and BPF.  
//
// #### Resources:
//
// * Vadim Zavalishin (2018) "The Art of VA Filter Design", v2.1.0
// <https://www.native-instruments.com/fileadmin/ni_media/downloads/pdf/VAFilterDesign_2.1.0.pdf>
// * Will Pirkle (2014) "Resolving Delay-Free Loops in Recursive Filters Using 
// the Modified Härmä Method", AES 137 <http://www.aes.org/e-lib/browse.cfm?elib=17517>
// * Description and diagrams of 1st- and 2nd-order TPT filters: 
// <https://www.willpirkle.com/706-2/>
//========================================================================================


//------------------`(ve.)sallenKeyOnePole`-----------------
// Sallen-Key generic One Pole filter that produces the LPF and HPF outputs (see description above).
//
// For the Faust implementation of this filter, recursion (`letrec`) is used 
// for storing filter "states". The output (e.g. `y`) is calculated by using 
// the input signal and the previous states of the filter.
// During the current recursive step, the states of the filter (e.g. `s`) for 
// the next step are also calculated.
// Admittedly, this is not an efficient way to implement a filter because it 
// requires independently calculating the output and each state during each 
// recursive step. However, it works as a way to store and use "states"
// within the constraints of Faust. 

// The simplest example is the 1st-order LPF (shown on the cover of Zavalishin 
// 2018 and Fig 4.3 of <https://www.willpirkle.com/706-2/>). Here, the input 
// signal is split in parallel for the calculation of the output signal, `y`, and 
// the state `s`. The value of the state is only used for feedback to the next 
// step of recursion. It is blocked (!) from also being routed to the output. 
// A trick used for calculating the state `s` is to observe that the input to 
// the delay block is the sum of two signal: what appears to be a feedforward 
// path and a feedback path. In reality, the signals being summed are identical 
// (signal*2) plus the value of the current state.
//
// #### Usage
//
// ```
// _ : sallenKeyOnePole(normFreq) : _,_
// ```
//
// Where:
//
// * `normFreq`: normalized frequency (0-1)

declare sallenKeyOnePole author "Eric Tarr";
declare sallenKeyOnePole license "MIT-style STK-4.3 license";
sallenKeyOnePole(normFreq) = _<:(s,ylpf,-(ylpf)) : !,_,_
letrec {  
  's = -(s):*(2*G):+(s);
  'ylpf = -(s):*(G):+(s);
}
with{
  freq = 2*(10^(3*normFreq+1));
  wd = 2*ma.PI*freq;
  T = 1/ma.SR;
  wa = (2/T)*tan(wd*T/2);
  g = wa*T/2; 
  G = g/(1.0 + g);
};


//------------------`(ve.)sallenKeyOnePoleLPF`-----------------
// Sallen-Key One Pole lowpass filter (see description above).
// Specialize the generic implementation: keep the first LPF output, 
// the compiler will only generate the needed code.
//
// #### Usage
//
// ```
// _ : sallenKeyOnePoleLPF(normFreq) : _
// ```
//
// Where:
//
// * `normFreq`: normalized frequency (0-1)

declare sallenKeyOnePoleLPF author "Eric Tarr";
declare sallenKeyOnePoleLPF license "MIT-style STK-4.3 license";
sallenKeyOnePoleLPF(normFreq) = sallenKeyOnePole(normFreq) : _,!;


//------------------`(ve.)sallenKeyOnePoleHPF`-----------------
// Sallen-Key One Pole Highpass filter (see description above). The dry input 
// signal is routed in parallel to the output. The LPF'd signal is subtracted 
// from the input so that the HPF remains.
// Specialize the generic implementation: keep the second HPF output, 
// the compiler will only generate the needed code.
//
// #### Usage
//
// ```
// _ : sallenKeyOnePoleHPF(normFreq) : _
// ```
//
// Where:
//
// * `normFreq`: normalized frequency (0-1)
//---------------------------------------------------------------------
declare sallenKeyOnePoleHPF author "Eric Tarr";
declare sallenKeyOnePoleHPF license "MIT-style STK-4.3 license";
sallenKeyOnePoleHPF(normFreq) = sallenKeyOnePole(normFreq) : !,_;


//------------------`(ve.)sallenKey2ndOrder`-----------------
// Sallen-Key generic 2nd order filter that produces the LPF, BPF and HPF outputs. 
//
// This is a 2nd-order Sallen-Key state-variable filter. The idea is that by 
// "tapping" into different points in the circuit, different filters 
// (LPF,BPF,HPF) can be achieved. See Figure 4.6 of 
// <https://www.willpirkle.com/706-2/>
//
// This is also a good example of the next step for generalizing the Faust 
// programming approach used for all these VA filters. In this case, there are 
// three things to calculate each recursive step (`y`,`s1`,`s2`). For each thing, the 
// circuit is only calculated up to that point. 
//
// Comparing the LPF to BPF, the output signal (`y`) is calculated similarly. 
// Except, the output of the BPF stops earlier in the circuit. Similarly, the 
// states (`s1` and `s2`) only differ in that `s2` includes a couple more terms 
// beyond what is used for `s1`. 
//
// #### Usage
//
// ```
// _ : sallenKey2ndOrder(normFreq,Q) : _,_,_
// ```
//
// Where:
//
// * `normFreq`: normalized frequency (0-1)
// * `Q`: q
//---------------------------------------------------------------------
declare sallenKey2ndOrder author "Eric Tarr";
declare sallenKey2ndOrder license "MIT-style STK-4.3 license";
sallenKey2ndOrder(normFreq,Q) = _<:(s1,s2,ylpf,ybpf,yhpf) : !,!,_,_,_ 
letrec{
  's1 = -(s2):-(s1*FBs1):*(alpha0):*(g*2):+(s1);
  's2 = -(s2):-(s1*FBs1):*(alpha0):*(g):+(s1):*(g*2):+(s2);
  // Compute the LPF, BPF, HPF outputs
  'ylpf = -(s2):-(s1*FBs1):*(alpha0):*(g*2):+(s1):*(g):+(s2);
  'ybpf = -(s2):-(s1*FBs1):*(alpha0):*(g):+(s1);
  'yhpf = -(s2):-(s1*FBs1):*(alpha0); 
}
with{
  freq = 2*(10^(3*normFreq+1));
  wd = 2*ma.PI*freq;
  T = 1/ma.SR;
  wa = (2/T)*tan(wd*T/2);
  g = wa*T/2; 
  G = g/(1.0 + g);
  R = 1/(2*Q);
  FBs1 = (2*R+g);
  alpha0 = 1/(1 + 2*R*g + g*g);
};

//------------------`(ve.)sallenKey2ndOrderLPF`-----------------
// Sallen-Key 2nd order lowpass filter (see description above). 
// Specialize the generic implementation: keep the first LPF output,
// the compiler will only generate the needed code.
//
// #### Usage
//
// ```
// _ : sallenKey2ndOrderLPF(normFreq,Q) : _
// ```
//
// Where:
//
// * `normFreq`: normalized frequency (0-1)
// * `Q`: q
//---------------------------------------------------------------------
declare sallenKey2ndOrderLPF author "Eric Tarr";
declare sallenKey2ndOrderLPF license "MIT-style STK-4.3 license";
sallenKey2ndOrderLPF(normFreq,Q) = sallenKey2ndOrder(normFreq,Q) : _,!,!;


//------------------`(ve.)sallenKey2ndOrderBPF`-----------------
// Sallen-Key 2nd order bandpass filter (see description above). 
// Specialize the generic implementation: keep the second BPF output, 
// the compiler will only generate the needed code.
//
// #### Usage
//
// ```
// _ : sallenKey2ndOrderBPF(normFreq,Q) : _
// ```
//
// Where:
//
// * `normFreq`: normalized frequency (0-1)
// * `Q`: q
//---------------------------------------------------------------------
declare sallenKey2ndOrderBPF author "Eric Tarr";
declare sallenKey2ndOrderBPF license "MIT-style STK-4.3 license";
sallenKey2ndOrderBPF(normFreq,Q) = sallenKey2ndOrder(normFreq,Q) : !,_,!;


//------------------`(ve.)sallenKey2ndOrderHPF`-----------------
// Sallen-Key 2nd order highpass filter (see description above). 
// Specialize the generic implementation: keep the third HPF output, 
// the compiler will only generate the needed code.
//
// #### Usage
//
// ```
// _ : sallenKey2ndOrderHPF(normFreq,Q) : _
// ```
//
// Where:
//
// * `normFreq`: normalized frequency (0-1)
// * `Q`: q
//---------------------------------------------------------------------
declare sallenKey2ndOrderHPF author "Eric Tarr";
declare sallenKey2ndOrderHPF license "MIT-style STK-4.3 license";
sallenKey2ndOrderHPF(normFreq,Q) = sallenKey2ndOrder(normFreq,Q) : !,!,_;


//=========================================Effects========================================
//========================================================================================

//--------------------------`(ve.)wah4`-------------------------------
// Wah effect, 4th order.
// `wah4` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : wah4(fr) : _
// ```
//
// Where:
//
// * `fr`: resonance frequency in Hz
//
// #### Reference
//
// <https://ccrma.stanford.edu/~jos/pasp/vegf.html>
//------------------------------------------------------------
wah4(fr) = 4*moog_vcf((3.2/4),fr:si.smooth(0.999));

//------------------------`(ve.)autowah`-----------------------------
// Auto-wah effect.
// `autowah` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : autowah(level) : _
// ```
//
// Where:
//
// * `level`: amount of effect desired (0 to 1).
//------------------------------------------------------------
autowah(level,x) = level * crybaby(an.amp_follower(0.1,x),x) + (1.0-level)*x;

//--------------------------`(ve.)crybaby`-----------------------------
// Digitized CryBaby wah pedal.
// `crybaby` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : crybaby(wah) : _
// ```
//
// Where:
//
// * `wah`: "pedal angle" from 0 to 1
//
// #### Reference
//
// <https://ccrma.stanford.edu/~jos/pasp/vegf.html>
//------------------------------------------------------------
crybaby(wah) = *(gs) : fi.tf2(1,-1,0,a1s,a2s)
with {
  Q  = pow(2.0,(2.0*(1.0-wah)+1.0)); // Resonance "quality factor"
  fr = 450.0*pow(2.0,2.3*wah);       // Resonance tuning
  g  = 0.1*pow(4.0,wah);             // gain (optional)

  // Biquad fit using z = exp(s T) ~ 1 + sT for low frequencies:
  frn = fr/ma.SR; // Normalized pole frequency (cycles per sample)
  R = 1 - ma.PI*frn/Q; // pole radius
  theta = 2*ma.PI*frn; // pole angle
  a1 = 0-2.0*R*cos(theta); // biquad coeff
  a2 = R*R;                // biquad coeff

  // dezippering of slider-driven signals:
  s = 0.999; // smoothing parameter (one-pole pole location)
  a1s = a1 : si.smooth(s);
  a2s = a2 : si.smooth(s);
  gs =  g  : si.smooth(s);

  //tf2 = component("filters.lib").tf2;
};

// end jos section
/************************************************************************
************************************************************************
FAUST library file, GRAME section

Except where noted otherwise, Copyright (C) 2003-2017 by GRAME,
Centre National de Creation Musicale.
----------------------------------------------------------------------
GRAME LICENSE

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

//----------------------------`(ve.)vocoder`-------------------------
// A very simple vocoder where the spectrum of the modulation signal
// is analyzed using a filter bank.
// `vocoder` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : vocoder(nBands,att,rel,BWRatio,source,excitation) : _
// ```
//
// Where:
//
// * `nBands`: Number of vocoder bands
// * `att`: Attack time in seconds
// * `rel`: Release time in seconds
// * `BWRatio`: Coefficient to adjust the bandwidth of each band (0.1 - 2)
// * `source`: Modulation signal
// * `excitation`: Excitation/Carrier signal
//------------------------------------------------------------
// TODO: author RM
oneVocoderBand(band,bandsNumb,bwRatio,bandGain,x) = x : fi.resonbp(bandFreq,bandQ,bandGain) with {
        bandFreq = 25*pow(2,(band+1)*(9/bandsNumb));
        BW = (bandFreq - 25*pow(2,(band)*(9/bandsNumb)))*bwRatio;
        bandQ = bandFreq/BW;
};

vocoder(nBands,att,rel,BWRatio,source,excitation) = source <: par(i,nBands,oneVocoderBand(i,nBands,BWRatio,1) :
	an.amp_follower_ar(att,rel) : _,excitation : oneVocoderBand(i,nBands,BWRatio)) :> _ ;

//########################################################################################
/************************************************************************
FAUST library file, further contributions section

All contributions below should indicate both the contributor and terms
of license.  If no such indication is found, "git blame" will say who
last edited each line, and that person can be emailed to inquire about
license disposition, if their license choice is not already indicated
elsewhere among the libraries.  It is expected that all software will be
released under LGPL, STK-4.3, MIT, BSD, or a similar FOSS license.
************************************************************************/

// end further further contributions section
/************************************************************************
************************************************************************
FAUST library file
Copyright (C) 2019-2020 GRAME, Centre National de Creation Musicale
---------------------------------------------------------------------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commerci
************************************************************************
************************************************************************/

ba = library("basics.lib");
ma = library("maths.lib");

declare name "MaxMSP compatibility Library";
declare author "GRAME";
declare copyright "GRAME";
declare version "1.1";
declare license "LGPL with exception";

atodb = db2lin;

//-------------------------------------------------------------------------
//
// Implementation of MaxMSP filtercoeff
//
//    from : Cookbook formulae for audio EQ biquad filter coefficients
//        by : Robert Bristow-Johnson  <rbj@audioimagination.com>
//       URL : <http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt>
//
//-------------------------------------------------------------------------

filtercoeff(f0, dBgain, Q) = environment
{
    //----------------------------------------
    // biquad coeffs for various filters
    // usage : filtercoeff(f0, dBgain, Q).LPF
    //----------------------------------------

    LPF = rbjcoef(a0, a1, a2, b0, b1, b2)
        with {
            b0 = (1 - cos(w0))/2;
            b1 =  1 - cos(w0);
            b2 = (1 - cos(w0))/2;
            a0 =  1 + alpha;
            a1 = -2*cos(w0);
            a2 =  1 - alpha;
        };

    HPF = rbjcoef(a0, a1, a2, b0, b1, b2)
        with {
            b0 = (1 + cos(w0))/2;
            b1 = -1 - cos(w0);
            b2 = (1 + cos(w0))/2;
            a0 =  1 + alpha;
            a1 = -2*cos(w0);
            a2 =  1 - alpha;
        };

    BPF = rbjcoef(a0, a1, a2, b0, b1, b2) // constant 0 dB peak gain
        with {
            b0 = alpha;
            b1 = 0;
            b2 = -alpha;
            a0 = 1 + alpha;
            a1 = -2*cos(w0);
            a2 = 1 - alpha;
        };

    notch = rbjcoef(a0, a1, a2, b0, b1, b2)
        with {
            b0 = 1;
            b1 = -2*cos(w0);
            b2 = 1;
            a0 = 1 + alpha;
            a1 = -2*cos(w0);
            a2 = 1 - alpha;
        };

    APF = rbjcoef(a0, a1, a2, b0, b1, b2)
        with {
            b0 = 1 - alpha;
            b1 = -2*cos(w0);
            b2 = 1 + alpha;
            a0 = 1 + alpha;
            a1 = -2*cos(w0);
            a2 = 1 - alpha;
        };

    peakingEQ = rbjcoef(a0, a1, a2, b0, b1, b2)
        with {
            b0 = 1 + alpha*A;
            b1 = -2*cos(w0);
            b2 = 1 - alpha*A;
            a0 = 1 + alpha/A;
            a1 = -2*cos(w0);
            a2 = 1 - alpha/A;
        };

    peakNotch = rbjcoef(a0, a1, a2, b0, b1, b2)
        with {
            b0 = 1 + alpha*G;
            b1 = -2*cos(w0);
            b2 = 1 - alpha*G;
            a0 = 1 + alpha/G;
            a1 = -2*cos(w0);
            a2 = 1 - alpha/G;
        };

    lowShelf = rbjcoef(a0, a1, a2, b0, b1, b2)
        with {
            b0 =   A*((A+1) - (A-1)*cos(w0) + 2*sqrt(A)*alpha);
            b1 = 2*A*((A-1) - (A+1)*cos(w0));
            b2 =   A*((A+1) - (A-1)*cos(w0) - 2*sqrt(A)*alpha);
            a0 =      (A+1) + (A-1)*cos(w0) + 2*sqrt(A)*alpha;
            a1 =  -2*((A-1) + (A+1)*cos(w0));
            a2 =      (A+1) + (A-1)*cos(w0) - 2*sqrt(A)*alpha;
        };

    highShelf = rbjcoef(a0, a1, a2, b0, b1, b2)
        with {
            b0 =    A*((A+1) + (A-1)*cos(w0) + 2*sqrt(A)*alpha);
            b1 = -2*A*((A-1) + (A+1)*cos(w0));
            b2 =    A*((A+1) + (A-1)*cos(w0) - 2*sqrt(A)*alpha);
            a0 =       (A+1) - (A-1)*cos(w0) + 2*sqrt(A)*alpha;
            a1 =    2*((A-1) - (A+1)*cos(w0));
            a2 =       (A+1) - (A-1)*cos(w0) - 2*sqrt(A)*alpha;
        };

    // --------------------- implementation ------------------------------

    // convert rbj coeffs to biquad coeffs
    rbjcoef(a0,a1,a2,b0,b1,b2) = (b0/a0, b1/a0, b2/a0, a1/a0, a2/a0);

    // common values
    alpha = sin(w0)/(2*max(0.001,Q));
    w0    = 2*ma.PI*max(0,f0)/Fs;
    Fs    = ma.SR;
    A     = 10^(dBgain/40);             // (for peaking and shelving EQ filters only)
    G     = sqrt(max(0.00001, dBgain)); // When gain is a linear values (i.e. not in dB)
};


//-------------------------------------------------------------------------
// Implementation of MaxMSP biquad~
// y[n] = a0 * x[n] + a1 * x[n-1] + a2 * x[n-2] - b1 * y[n-1] - b2 * y[n-2]
//-------------------------------------------------------------------------

biquad(x,a0,a1,a2,b1,b2) =  x : + ~ ((-1)*conv2(b1, b2)) : conv3(a0, a1, a2)
    with {
        conv2(c0,c1,x) = c0*x+c1*x';
        conv3(c0,c1,c2,x) = c0*x+c1*x'+c2*x'';
    };

//-------------------------------------------------------------------------
//
// Filters using filtercoeff and biquad
//
//-------------------------------------------------------------------------

// Low Pass Filter
LPF(x, f0, gain, Q)= x , filtercoeff(f0,gain,Q).LPF : biquad;

// High Pass Filter
HPF(x, f0, gain, Q) = x , filtercoeff(f0,gain,Q).HPF : biquad;

// Band Pass Filter
BPF(x, f0, gain, Q) = x , filtercoeff(f0,gain,Q).BPF : biquad;

// notch Filter
notch(x, f0, gain, Q)= x , filtercoeff(f0,gain,Q).notch : biquad;

// All Pass Filter
APF(x, f0, gain, Q) = x , filtercoeff(f0,gain,Q).APF : biquad;

// ????
peakingEQ(x, f0, gain, Q) = x , filtercoeff(f0,gain,Q).peakingEQ : biquad;

// Max peakNotch is like peakingEQ but with a linear gain
peakNotch(x, f0, gain, Q) = x , filtercoeff(f0,gain,Q).peakNotch : biquad;

// ????
lowShelf(x, f0, gain, Q) = x , filtercoeff(f0,gain,Q).lowShelf : biquad;

// ????
highShelf(x, f0, gain, Q) = x , filtercoeff(f0,gain,Q).highShelf : biquad;


//-------------------------------------------------------------------------
// Implementation of Max/MSP line~. Generate signal ramp or envelop
//
// USAGE : line(value, time)
//    value : the desired output value
//    time  : the interpolation time to reach this value (in milliseconds)
//
// NOTE : the interpolation process is restarted every time the desired
// output value changes. The interpolation time is sampled only then.
//-------------------------------------------------------------------------

line(value, time) = state~(_,_):!,_
    with {
        state(t, c) = nt,nc 
        with {
            nt = ba.if(value != value', samples, t-1);
            nc = ba.if(nt > 0, c + (value - c)/nt, value);
            samples = time*ma.SR/1000.0;
        };
    };
//#################################### platform.lib ########################################
// A library to handle platform specific code in Faust. Its official prefix is `pl`.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/platform.lib>
//########################################################################################
// It can be reimplemented to globally change the SR and the tablesize definitions


/************************************************************************
************************************************************************
FAUST library file
Copyright (C) 2020 GRAME, Centre National de Creation Musicale
----------------------------------------------------------------------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

declare name "Generic Platform Library";
declare version "0.2";

//---------------------------------`(pl.)SR`-----------------------------------
// Current sampling rate (between 1Hz and 192000Hz). Constant during
// program execution.
//-----------------------------------------------------------------------------
SR = min(192000.0, max(1.0, fconstant(int fSamplingFreq, <math.h>)));

//---------------------------------`(pl.)BS`---------------------------------------
// Current block-size. Can change during the execution.
//-----------------------------------------------------------------------------
BS = fvariable(int count, <math.h>);

//---------------------------------`(pl.)tablesize`----------------------------
// Oscillator table size
//-----------------------------------------------------------------------------
tablesize = 1 << 16;
//################################### synths.lib ##########################################
// This library contains a collection of synthesizers. Its official prefix is `sy`. 
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/synths.lib>
//########################################################################################

/************************************************************************
************************************************************************
FAUST library file
Copyright (C) 2003-2016 GRAME, Centre National de Creation Musicale
----------------------------------------------------------------------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

ma = library("maths.lib");
ba = library("basics.lib");
en = library("envelopes.lib");
fi = library("filters.lib");
os = library("oscillators.lib");
no = library("noises.lib");

declare name "Faust Synthesizer Library";
declare version "0.1";

//-----------------------------------`(sy.)popFilterPerc`--------------------------------------
// A simple percussion instrument based on a "popped" resonant bandpass filter.
// `popFilterPerc` is a standard Faust function.
//
// #### Usage
//
// ```
// popFilterDrum(freq,q,gate) : _
// ```
//
// Where:
//
// * `freq`: the resonance frequency of the instrument
// * `q`: the q of the res filter (typically, 5 is a good value)
// * `gate`: the trigger signal (0 or 1)
//----------------------------------------------------------------------------------------
// TODO: author RM
popFilterDrum(freq,q,gate) = en.ar(0.001,0.001,gate)*no.noise : fi.resonbp(freq,q,1);


//---------------------------------------`(sy.)dubDub`-----------------------------------------
// A simple synth based on a sawtooth wave filtered by a resonant lowpass.
// `dubDub` is a standard Faust function.
//
// #### Usage
//
// ```
// dubDub(freq,ctFreq,q,gate) : _
// ```
//
// Where:
//
// * `freq`: frequency of the sawtooth
// * `ctFreq`: cutoff frequency of the filter
// * `q`: Q of the filter
// * `gate`: the trigger signal (0 or 1)
//----------------------------------------------------------------------------------------
// TODO: author RM
dubDub(freq,ctFreq,q,gate) = os.sawtooth(freq)*gainEnvelope : fi.resonlp(ctFreq,q,1)
with {
    maxGain = 0.5;
    gainEnvelope = en.smoothEnvelope(0.01,gate)*maxGain;
};


//-----------------------------------`(sy.)sawTrombone`----------------------------------------
// A simple trombone based on a lowpassed sawtooth wave.
// `sawTrombone` is a standard Faust function.
//
// #### Usage
//
// ```
// sawTrombone(att,freq,gain,gate) : _
// ```
//
// Where:
//
// * `att`: exponential attack duration in s (typically 0.01)
// * `freq`: the frequency
// * `gain`: the gain (0-1)
// * `gate`: the gate (0 or 1)
//----------------------------------------------------------------------------------------
// TODO: author RM
sawTrombone(freq,gain,gate) = os.sawtooth(freq)*gainEnvelope : fi.lowpass(3,cutoff)
with {
    // controls both the gain of the instrument and the lowpass frequency
    gainEnvelope = en.smoothEnvelope(0.01,gate)*gain;
    cutoff = gainEnvelope*5000+50;
};


//-----------------------------------`(sy.)combString`-----------------------------------------
// Simplest string physical model ever based on a comb filter.
// `combString` is a standard Faust function.
//
// #### Usage
//
// ```
// combString(freq,res,gate) : _
// ```
//
// Where:
//
// * `freq`: the frequency of the string
// * `res`: string T60 (resonance time) in second
// * `gate`: trigger signal (0 or 1)
//----------------------------------------------------------------------------------------
// TODO: author RM
combString(freq,res,gate) = excitation : fi.fb_fcomb(maxDel,N,b0,aN)
with {
    maxDel = 1024;
    N = ma.SR/freq;
    b0 = 1;
    aN = ba.tau2pole(res*0.001)*-1;
    excitation = no.noise*en.ar(0.001,0.001,gate);
};


//-----------------------------------`(sy.)additiveDrum`---------------------------------------
// A simple drum using additive synthesis.
// `additiveDrum` is a standard Faust function.
//
// #### Usage
//
// ```
// additiveDrum(freq,freqRatio,gain,harmDec,att,rel,gate) : _
// ```
//
// Where:
//
// * `freq`: the resonance frequency of the drum
// * `freqRatio`: a list of ratio to choose the frequency of the mode in
//                function of `freq` e.g.(1 1.2 1.5 ...). The first element should always
//                be one (fundamental).
// * `gain`: the gain of each mode as a list (1 0.9 0.8 ...). The first element
//           is the gain of the fundamental.
// * `harmDec`: harmonic decay ratio (0-1): configure the speed at which
//              higher modes decay compare to lower modes.
// * `att`: attack duration in second
// * `rel`: release duration in second
// * `gate`: trigger signal (0 or 1)
//----------------------------------------------------------------------------------------
// TODO: author RM
additiveDrum(freq,freqRatio,gain,modeDec,att,rel,gate) = par(i,N,os.osc(modeFreq(i))*gainEnvelope(i)) :> _
with {
    N = ba.count(freqRatio);
    modeFreq(i) = freq*ba.take(i+1,freqRatio);
    modeGain(i) = ba.take(i+1,gain);
    gainEnvelope(i) = modeGain(i)*en.ar(att,rel*(1-(modeDec*(i/N))),gate);
};


//-----------------------------------`(sy.)fm`---------------------------------------
// An FM synthesizer with an arbitrary number of modulators connected as a sequence.
// `fm` is a standard Faust function.
//
// #### Usage
//
// ```
// freqs = (300,400,...);
// indices = (20,...);
// fm(freqs,indices) : _
// ```
//
// Where:
//
// * `freqs`: a list of frequencies where the first one is the frequency of the carrier
//            and the others, the frequency of the modulator(s)
// * `indices`: the indices of modulation (Nfreqs-1)
//----------------------------------------------------------------------------------------
// TODO: author RM
fm(freqs,indices) = seq(i,N,fmBlock(i))
with {
    N = ba.count(freqs);
    freq(i) = ba.take(N-i,freqs);
    gain(i) = ba.take(N-i,indices);
    fmBlock(0) = freq(0) : os.osc;
    fmBlock(i) = *(gain(i))+freq(i) : os.osc;
};


//===============================Drum Synthesis===================================
// Drum Synthesis ported in Faust from a version written in [Elementary](https://www.elementary.audio/) 
// and JavaScript by Nick Thompson. 
//
// #### Reference
//
// <https://www.nickwritesablog.com/drum-synthesis-in-javascript/>
//========================================================================================

//-----------------------------------`(sy.)kick`---------------------------------------
// Kick drum synthesis via a pitched sine sweep.
// 
// #### Usage 
// 
// ```
// kick(pitch, click, attack, decay, drive, gate) : _
// ```
//
// Where:
//
// * `pitch`: the base frequency of the kick drum in Hz
// * `click`: the speed of the pitch envelope, tuned for [0.005s, 1s]
// * `attack`: attack time in seconds, tuned for [0.005s, 0.4s]
// * `decay`: decay time in seconds, tuned for [0.005s, 4.0s]
// * `drive`: a gain multiplier going into the saturator. Tuned for [1, 10]
// * `gate`: the gate which triggers the amp envelope
// 
// #### Reference
//
// <https://github.com/nick-thompson/drumsynth/blob/master/kick.js>
//-------------------------------------------------------------------------------------
kick(pitch, click, attack, decay, drive, gate) = out
with {
    env = en.adsr(attack, decay, 0.0, 0.1, gate);
    pitchenv = en.adsr(0.005, click, 0.0, 0.1, gate);
    clean = env * os.osc((1 + pitchenv * 4) * pitch);
    out = ma.tanh(clean * drive);
};


//-----------------------------------`(sy.)clap`---------------------------------------
// Clap synthesis via filtered white noise.
// 
// #### Usage 
// 
// ```
// clap(tone, attack, decay, gate) : _
// ```
//
// Where:
//
// * `tone`: bandpass filter cutoff frequency, tuned for [400Hz, 3500Hz]
// * `attack`: attack time in seconds, tuned for [0s, 0.2s]
// * `decay`: decay time in seconds, tuned for [0s, 4.0s]
// * `gate`: the gate which triggers the amp envelope
//
// #### Reference
//
// <https://github.com/nick-thompson/drumsynth/blob/master/clap.js>
//-------------------------------------------------------------------------------------
clap(tone, attack, decay, gate) = out
with {
    e1 = en.adsr(0.035 + attack, 0.06 + decay, 0.0, 0.1, gate);
    e2 = en.adsr(0.025 + attack, 0.05 + decay, 0.0, 0.1, gate);
    e3 = en.adsr(0.015 + attack, 0.04 + decay, 0.0, 0.1, gate);
    e4 = en.adsr(0.005 + attack, 0.02 + decay, 0.0, 0.1, gate);
    out = ma.tanh(((e1 + e2 + e3 + e4) * no.noise) : fi.resonlp(tone, 1.214, 1));
};


//-----------------------------------`(sy.)hat`---------------------------------------
// Hi hat drum synthesis via phase modulation.
// 
// #### Usage 
// 
// ```
// hat(pitch, tone, attack, decay, gate): _
// ```
//
// Where:
//
// * `pitch`: base frequency in the range [317Hz, 3170Hz]
// * `tone`: bandpass filter cutoff frequency, tuned for [800Hz, 18kHz]
// * `attack`: attack time in seconds, tuned for [0.005s, 0.2s]
// * `decay`: decay time in seconds, tuned for [0.005s, 4.0s]
// * `gate`: the gate which triggers the amp envelope
//
// #### Reference
//
// <https://github.com/nick-thompson/drumsynth/blob/master/hat.js>
//-------------------------------------------------------------------------------------
hat(pitch, tone, attack, decay, gate) = out
with {
    m2 = no.noise;
    m1 = cycle(2 * pitch, 2 * m2);
    m0 = cycle(pitch, 2 * m1);
    f = m0 : fi.resonlp(tone, 1.214, 1);
    env = en.adsr(attack, decay, 0.0, 0.1, gate);  
    out = f * env;  
    cycle(freq, offset) = sin(2 * ma.PI * p)
    with {
        t = phasor(freq) + offset;
        p = t - floor(t);
        phasor(f) = f/ma.SR : (+ : decimalpart) ~ _ with { decimalpart(x) = x-int(x); };
    };
};
/* 
  sf.lib - aliases all prefixes to sf = all.lib, so that both old and new prefixes can be mixed.

  USAGE:

  import("sf.lib");  // use either standard prefixes or the one prefix "sf"

  The Faust team is committed to unique names for standard Faust
  functions, allowing them to all be in the same namespace.
  Therefore, only two namespaces are needed: (1) the highest-level
  scope (no prefix), and (2) the Standard Faust scope, using prefix 'sf'.
*/

sf = library("all.lib"); // "Standard Faust" prefix

//--- use old library prefixes using old libraries ---
/*
    ml = library("old/music.lib");
    fl = library("old/filter.lib");
    ol = library("old/oscillator.lib");
    el = library("old/effect.lib");
*/
//--- use old library prefixes using new libraries ---
ol = sf;
fl = sf;
ml = sf;
el = sf;
//--- new library prefixes ---
an = sf;
ba = sf;
co = sf;
de = sf;
dm = sf;
dx = sf;
ef = sf;
en = sf;
fd = sf;
fi = sf;
ho = sf;
ma = sf;
os = sf;
no = sf;
pf = sf;
pm = sf;
re = sf;
ro = sf;
sp = sf;
si = sf;
so = sf;
sy = sf;
ve = sf;
wa = sf;
//-----
//############################# fds.lib ######################################

// This library allows to build linear, explicit finite difference schemes
// physical models in 1 or 2 dimensions using an approach based on the cellular
// automata formalism. Its official prefix is `fd`. 
// In order to use the library, one needs to discretize the linear partial
// differential equation of the desired system both at boundaries and in-between
// them, thus obtaining a set of explicit recursion relations. Each one
// of these will provide, for each spatial point the scalar coefficients to be
// multiplied by the states of the current and past neighbour points.
// Coefficients need to be stacked in parallel in order to form a coefficients
// matrix for each point in the mesh. It is necessary to provide one matrix for
// coefficients matrices are defined, they need to be placed in parallel and
// ordered following the desired mesh structure (i.e., coefficients for the top
// left boundaries will come first, while bottom right boundaries will come
// last), to form a *coefficients scheme*, which can be used with the library
// functions.

// ## Sources

// Here are listed some works on finite difference schemes and cellular
// automata thet were the basis for the implementation of this library
//
// * S. Bilbao, Numerical Sound Synthesis.Chichester, UK: John Wiley Sons,
// Ltd, 2009

// * P. Narbel, "Qualitative and quantitative cellular automata from
// differential equations," Lecture Notes in Computer Science, vol. 4173,
// pp. 112–121, 10 2006

// * X.-S. Yang and Y. Young, Cellular Automata, PDEs, and Pattern Formation.
// Chapman & Hall/CRC, 092005, ch. 18, pp. 271–282.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/fds.lib>
//#############################################################################

ba = library("basics.lib");
si = library("signals.lib");
ma = library("maths.lib");

declare name "Faust Finite Difference Schemes Library";
declare version "0.0";
declare author "Riccardo Russo";
declare author "Romain Michon";

/*
TODO:
  - In case of big 2-D meshes the generated c++ code is too long, making the
    compiler crash. Consider introducing data structures support.
  - Implement a way to set nonzero initial conditions.
  - It would be nice to set the length of a mesh directly in meters and not
    in points.
  - Cubic interpolators.
*/

//===============================Model Construction=============================
// Once the coefficients scheme is defined, the user can simply call one of
// these functions to obtain a fully working physical model. They expect to
// receive a force input signal for each mesh point and output the state of each
// point. Interpolation operators can be used to drive external forces to the
// desired points, and to get the signal only from a certain area of the mesh.
//==============================================================================

//--------------------------------`(fd.)model1D`-------------------------------
// This function can be used to obtain a physical model in 1 dimension.
// Takes a force input signal for each point and outputs the state of each
// point.
//
// #### Usage
//
// ```
// si.bus(points) : model1D(points,R,T,scheme) : si.bus(points)
// ```
//
// Where:
//
// * `points`: size of the mesh in points
// * `R`: neighbourhood radius, indicates how many side points are needed (i.e.
//        if R=1 the mesh depends on one point on the left and one on the right)
// * `T`: time coefficient, indicates how much steps back in time are needed (i.
//        e. if T=1 the maximum delay needed for a neighbour state is 1 sample)
// * `scheme`: coefficients scheme
//------------------------------------------------------------------------------
model1D(points,R,T,scheme) =
    (route1D(points,R,T,scheme) : buildScheme1D(points,R,T)) ~ si.bus(points);

//--------------------------------`(fd.)model2D`-------------------------------
// This function can be used to obtain a physical model in 2 dimension.
// Takes a force input signal for each point and outputs the state of each
// point.
// IMPORTANT: 2D models with more than 30x20 points might crash the c++
// compiler. 2D models need to be compiled with the command line compiler,
// the online one presents some issues.
//
// #### Usage
//
// ```
// si.bus(pointsX*pointsY) : model2D(pointsX,pointsY,R,T,scheme) :
//    si.bus(pointsX*pointsY)
// ```
//
// Where:
//
// * `pointsX`: horizontal size of the mesh in points
// * `pointsY`: vertical size of the mesh in points
// * `R`: neighbourhood radius, indicates how many side points are needed (i.e.
//        if R=1 the mesh depends on one point on the left and one on the right)
// * `T`: time coefficient, indicates how much steps back in time are needed (i.
//        e. if T=1 the maximum delay needed for a neighbour state is 1 sample)
// * `scheme`: coefficients scheme
//------------------------------------------------------------------------------
model2D(pointsX,pointsY,R,T,scheme) =
    (route2D(pointsX,pointsY,R,T,scheme) :
        buildScheme2D(pointsX,pointsY,R,T)) ~ si.bus(pointsX*pointsY);

//===============================Interpolation=================================
// Interpolation functions can be used to drive the input signals to the
// correct mesh points, or to get the output signal from the
// desired points. All the interpolation functions allow to change the
// input/output points at run time. In general, all these functions get in
// input a number of connections, and output the same number of connections,
// where each signal is multiplied by zero except the ones specified by the
// arguments.
//==============================================================================

//-----------------------------`(fd.)stairsInterp1D`---------------------------
// Stairs interpolator in 1 dimension. Takes a number of signals and outputs
// the same number of signals, where each one is multiplied by zero except the
// one specified by the argument. This can vary at run time (i.e. a slider),
// but must be an integer.
//
// #### Usage
//
// ```
// si.bus(points) : stairsInterp1D(points,point) : si.bus(points)
// ```
//
// Where:
//
// * `points`: total number of points in the mesh
// * `point`: number of the desired nonzero signal
//------------------------------------------------------------------------------
stairsInterp1D(points,point) = par(i,points,_*select2(i==point,0,1));

//-----------------------------`(fd.)stairsInterp2D`---------------------------
// Stairs interpolator in 2 dimensions. Similar to the 1-D version.
//
// #### Usage
//
// ```
// si.bus(pointsX*pointsY) : stairsInterp2D(pointsX,pointsY,pointX,pointY) :
//    si.bus(pointsX*pointsY)
// ```
//
// Where:
//
// * `pointsX`: total number of points in the X direction
// * `pointsY`: total number of points in the Y direction
// * `pointX`: horizontal index of the desired nonzero signal
// * `pointY`: vertical index of the desired nonzero signal
//------------------------------------------------------------------------------
stairsInterp2D(pointsX,pointsY,pointX,pointY) =
    par(i,pointsX,
        par(j,pointsY,_*select2((i==pointX) & (j==pointY),0,1)));

//-----------------------------`(fd.)linInterp1D`---------------------------
// Linear interpolator in 1 dimension. Takes a number of signals and outputs
// the same number of signals, where each one is multiplied by zero except two
// signals around a floating point index. This is essentially a Faust
// implementation of the $J(x_i)$ operator, not scaled by the spatial step.
// (see Stefan Bilbao's book, Numerical Sound Synthesis). The index can vary
// at run time.
//
// #### Usage
//
// ```
// si.bus(points) : linInterp1D(points,point) : si.bus(points)
// ```
//
// Where:
//
// * `points`: total number of points in the mesh
// * `point`: floating point index
//------------------------------------------------------------------------------
linInterp1D(points,point) = par(i,points,_*select2(
        i==int(point), select2(i==int(point+1),0,fraction),(1-fraction)))
with
{
    fraction = ma.frac(point);
};

//-----------------------------`(fd.)linInterp2D`---------------------------
// Linear interpolator in 2 dimensions. Similar to the 1 D version.
//
// #### Usage
//
// ```
// si.bus(pointsX*pointsY) : linInterp2D(pointsX,pointsY,pointX,pointY) :
//    si.bus(pointsX*pointsY)
// ```
//
// Where:
//
// * `pointsX`: total number of points in the X direction
// * `pointsY`: total number of points in the Y direction
// * `pointX`: horizontal float index
// * `pointY`: vertical float index
//------------------------------------------------------------------------------
linInterp2D(pointsX,pointsY,pointX,pointY) =
par(i,pointsX,
    par(j,pointsY,_*
        select2((i==intX) & (j==intY),
            select2((i==(intX+1)) & (j==intY),
                select2((i==intX) & (j==(intY+1)),
                    select2((i==(intX+1)) & (j==(intY+1)),
                        0,
                        fractionX*fractionY),
                    (1-fractionX)*fractionY),
                fractionX*(1-fractionY)),
            (1-fractionX)*(1-fractionY))))
with
{
    fractionX = ma.frac(pointX);
    fractionY = ma.frac(pointY);
    intX = int(pointX);
    intY = int(pointY);
};

//---------------------------`(fd.)stairsInterp1DOut`--------------------------
// Stairs interpolator in 1 dimension. Similar to stairsInterp1D, except it
// outputs only the desired signal.
//
// #### Usage
//
// ```
// si.bus(points) : stairsInterp1DOut(points,point) : _
// ```
//
// Where:
//
// * `points`: total number of points in the mesh
// * `point`: number of the desired nonzero signal
//------------------------------------------------------------------------------
stairsInterp1DOut(points,point) = ba.selectn(points,point);

//---------------------------`(fd.)stairsInterp2DOut`--------------------------
// Stairs interpolator in 2 dimensions which outputs only one signal.
//
// #### Usage
//
// ```
// si.bus(pointsX*pointsY) : stairsInterp2DOut(pointsX,pointsY,pointX,pointY) : _
// ```
//
// Where:
//
// * `pointsX`: total number of points in the X direction
// * `pointsY`: total number of points in the Y direction
// * `pointX`: horizontal index of the desired nonzero signal
// * `pointY`: vertical index of the desired nonzero signal
//------------------------------------------------------------------------------
stairsInterp2DOut(pointsX,pointsY,pointX,pointY) =
    ba.selectn(pointsX*pointsY,pointY+pointX*Y);

//---------------------------`(fd.)linInterp1DOut`--------------------------
// Linear interpolator in 1 dimension. Similar to stairsInterp1D, except it
// sums each output signal and provides only one output value.
//
// #### Usage
//
// ```
// si.bus(points) : linInterp1DOut(points,point) : _
// ```
//
// Where:
//
// * `points`: total number of points in the mesh
// * `point`: floating point index
//------------------------------------------------------------------------------
linInterp1DOut(points,point) = linInterp1D(points,point):>_;

//---------------------------`(fd.)stairsInterp2DOut`--------------------------
// Linear interpolator in 2 dimensions which outputs only one signal.
//
// #### Usage
//
// ```
// si.bus(pointsX*pointsY) : linInterp2DOut(pointsX,pointsY,pointX,pointY) : _
// ```
//
// Where:
//
// * `pointsX`: total number of points in the X direction
// * `pointsY`: total number of points in the Y direction
// * `pointX`: horizontal float index
// * `pointY`: vertical float index
//------------------------------------------------------------------------------
linInterp2DOut(pointsX,pointsY,pointX,pointY) =
    linInterp2D(pointsX,pointsY,pointX,pointY):>_;

//====================================Routing==================================
// The routing functions are used internally by the model building functions,
// but can also be taken separately. These functions route the forces, the
// coefficients scheme and the neighbours’ signals into the correct scheme
// points and take as input, in this order: the coefficients block, the
// feedback signals and the forces. In output they provide, in order, for each
// scheme point: the force signal, the coefficient matrices and the neighbours’
// signals. These functions are based on the Faust route primitive.
//==============================================================================

//---------------------------------`(fd.)route1D`------------------------------
// Routing function for 1 dimensional schemes.
//
// #### Usage
//
// ```
// si.bus((2*R+1)*(T+1)*points),si.bus(points*2) : route1D(points, R, T) :
//    si.bus((1 + ((2*R+1)*(T+1)) + (2*R+1))*points)
// ```
//
// Where:
//
// * `points`: total number of points in the mesh
// * `R`: neighbourhood radius
// * `T`: time coefficient
//------------------------------------------------------------------------------
route1D(points, R, T) = route(points*2+points*nCoeffs, points*nInputs,
                                par(x, points, connections(x)))
with
{
    connections(x) =  par(k,nCoeffs,x*nCoeffs+k+1,C(x,k+1)),
                      P(x) + points, C(x,0),
                      par(i, nNeighbors, P(x),C(x-R+i,nInputs-1-i));

    P(x) = x+1 + nCoeffs*points;
    C(x,count) = (1 + count + (x*nInputs)) * (x>=0) * (x<points);

    nNeighbors = 2*R+1;
    nCoeffs = nNeighbors*(T+1);
    nInputs = nNeighbors+1+nCoeffs;
};

//--------------------------------`(fd.)route2D`-------------------------------
// Routing function for 2 dimensional schemes.
//
// #### Usage
//
// ```
// si.bus((2*R+1)^2*(T+1)*pointsX*pointsY),si.bus(pointsX*pointsY*2) :
//    route2D(pointsX, pointsY, R, T) :
//        si.bus((1 + ((2*R+1)^2*(T+1)) + (2*R+1)^2)*pointsX*pointsY)
// ```
//
// Where:
//
// * `pointsX`: total number of points in the X direction
// * `pointsY`: total number of points in the Y direction
// * `R`: neighbourhood radius
// * `T`: time coefficient
//------------------------------------------------------------------------------
route2D(pointsX, pointsY, R, T) =
    route(nPoints*2+nPoints*nCoeffs, nPoints*nInputs,
        par(x, pointsX, par(y, pointsY, connections(x,y))))
with
{
    connections(x,y) =
        P(x,y) + nPoints, C(x,y,0),
        par(k,nCoeffs,(x*pointsY+y)*nCoeffs+k+1,C(x,y,k+1)),
        par(j,nNeighborsXY,
        par(i,nNeighborsXY,
            P(x,y),C(x+i-R,y+j-R,nInputs-1-(i*nNeighborsXY+j))));

    P(x,y) = x*pointsY+y+1 + nCoeffs*nPoints;
    C(x,y,count) = (1 + count + (x*pointsY+y)*nInputs)
                      * (x>=0) * (x<pointsX) * (y>=0) * (y<pointsY);

    nNeighborsXY = 2*R+1;
    nNeighbors = nNeighborsXY^2;
    nCoeffs = nNeighbors*(T+1);
    nInputs = nNeighbors+1+nCoeffs;
    nPoints = pointsX*pointsY;
};

//================================Scheme Operations=============================
// The scheme operation functions are used internally by the model building
// functions but can also be taken separately. The schemePoint function is
// where the update equation is actually calculated. The buildScheme functions
// are used to stack in parallel several schemePoint blocks, according to the
// choosed mesh size.
//==============================================================================

//------------------------------`(fd.)schemePoint`-----------------------------
// This function calculates the next state for each mesh point, in order to
// form a scheme, several of these blocks need to be stacked in parallel.
// This function takes in input, in order, the force, the coefficient matrices
// and the neighbours’ signals and outputs the next point state.
//
// #### Usage
//
// ```
// _,si.bus((2*R+1)^D*(T+1)),si.bus((2*R+1)^D) : schemePoint(R,T,D) : _
// ```
//
// Where:
//
// * `R`: neighbourhood radius
// * `T`: time coefficient
// * `D`: scheme spatial dimensions (i.e. 1 if 1-D, 2 if 2-D)
//------------------------------------------------------------------------------
schemePoint(R,T,D) = routing:operations:>_
with
{
    nNeighbors = (2*R+1)^D;
    routing =
        route(nNeighbors*(T+1)+nNeighbors+1,2*nNeighbors*(T+1)+1,
            (1,1),
            par(t,T+1,
                par(i,nNeighbors,i+t*nNeighbors+2,2*(i+t*nNeighbors)+3,
                                i+nNeighbors*(T+1)+2,2*(i+t*nNeighbors)+2)));
    operations = _,par(t,T+1,
                    par(i,nNeighbors,(_@t),_:*));
};

//------------------------------`(fd.)buildScheme1D`---------------------------
// This function is used to stack in parallel several schemePoint functions in
// 1 dimension, according to the number of points.
//
// #### Usage
//
// ```
// si.bus((1 + ((2*R+1)*(T+1)) + (2*R+1))*points) : buildScheme1D(points,R,T) :
//    si.bus(points)
// ```
//
// Where:
//
// * `points`: total number of points in the mesh
// * `R`: neighbourhood radius
// * `T`: time coefficient
//------------------------------------------------------------------------------
buildScheme1D(points,R,T) =
    par (x, points,schemePoint(R,T,1));

//------------------------------`(fd.)buildScheme2D`---------------------------
// This function is used to stack in parallel several schemePoint functions in
// 2 dimensions, according to the number of points in the X and Y directions.
//
// #### Usage
//
// ```
// si.bus((1 + ((2*R+1)^2*(T+1)) + (2*R+1)^2)*pointsX*pointsY) :
//    buildScheme2D(pointsX,pointsY,R,T) : si.bus(pointsX*pointsY)
// ```
//
// Where:
//
// * `pointsX`: total number of points in the X direction
// * `pointsY`: total number of points in the Y direction
// * `R`: neighbourhood radius
// * `T`: time coefficient
//------------------------------------------------------------------------------
buildScheme2D(pointsX,pointsY,R,T) =
    par (x, pointsX,
        par(y,pointsY, schemePoint(R,T,2)));

//================================Interaction Models============================
// Here are defined two physically based interaction algorithms: a hammer and
// a bow. These functions need to be coupled to the mesh pde, in the point
// where the interaction happens: to do so, the mesh output signals can be fed
// back and driven into the force block using the interpolation operators.
// The latters can be also used to drive the single force output signal to the
// correct scheme points.
//==============================================================================

//---------------------------------`(fd.)hammer`-------------------------------
// Implementation of a nonlinear collision model. The hammer is essentially a
// finite difference scheme of a linear damped oscillator, which is coupled
// with the mesh through the collision model (see Stefan Bilbao's book,
// Numerical Sound Synthesis).
//
// #### Usage
//
// ```
// _ :hammer(coeff,omega0Sqr,sigma0,kH,alpha,k,offset,fIn) : _
// ```
//
// Where:
//
// * `coeff`: output force scaling coefficient
// * `omega0Sqr`: squared angular frequency of the hammer oscillator
// * `sigma0`: damping coefficient of the hammer oscillator
// * `kH`: hammer stiffness coefficient
// * `alpha`: nonlinearity parameter
// * `k`: time sampling step (the same as for the mesh)
// * `offset`: distance between the string and the hammer at rest in meters
// * `fIn`: hammer excitation signal (i.e. a button)
//------------------------------------------------------------------------------
hammer(coeff,omega0Sqr,sigma0,kH,alpha,k,offset,fIn) =
    (hammerForce<:hammerModel(fIn,k,offset,_),_)~_:!,_*coeff
with
{
    hammerModel(in,k,offset) =
        (_,_,_*forceCoeff,in :> _) ~ (_ <: A*_,B*_') :_-offset;
    hammerForce(uh,u)=select2((uh-u)>0,0,((uh-u)^alpha)*(-kH));
    A = (2-omega0Sqr^2*k^2)/(1+sigma0*k);
    B = (-1)*(1-sigma0*k)/(1+sigma0*k);
    forceCoeff = k^2/(1+sigma0*k);
};

//---------------------------------`(fd.)bow`-------------------------------
// Implementation of a nonlinear friction based interaction model that induces
// Helmholtz motion. (see Stefan Bilbao's book, Numerical Sound Synthesis).
//
// #### Usage
//
// ```
// _ :bow(coeff,alpha,k,vb) : _
// ```
//
// Where:
//
// * `coeff`: output force scaling coefficient
// * `alpha`: nonlinearity parameter
// * `k`: time sampling step (the same as for the mesh)
// * `vb`: bow velocity [m/s]
//------------------------------------------------------------------------------
bow(coeff,alpha,k,vb) = _:phi*(-coeff)
with
{
    phi(u) = 1.41*alpha*dVel(u)*exp(-alpha*dVel(u)*dVel(u)+0.5);
    dVel(x) = select2(vb==0,(x-x')/k - vb,0);
};
//#################################### reducemaps.lib ########################################
// A library to handle reduce/map kind of operation in Faust. Its official prefix is `rm`.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/reducemaps.lib>
//##############################################################################################

/************************************************************************
************************************************************************
FAUST library file
Copyright (C) 2010-2011 GRAME, Centre National de Creation Musicale
---------------------------------------------------------------------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as 
published by the Free Software Foundation; either version 2.1 of the 
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA. 

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

ba = library("basics.lib");

declare name "Reduce Library";
declare author "Yann Orlarey (orlarey at grame.fr)";
declare copyright "Grame";
declare version "0.1";
declare license "LGPL with exception"; 

//---------------------------------------------------------------
// Provides various operations on block of samples
// using a high order 'reduce(op, n)' fold-like function :
//
//   sumn(n) : the sum  of a block of n input samples
//   maxn(n) : the max  of a block of n input samples
//   minn(n) : the min  of a block of n input samples
//   mean(n) : the mean of a block of n input samples
//   RMS(n)  : the RMS  of a block of n input samples
//---------------------------------------------------------------


//--------------------`(rm.)reduce`------------------------------
// Fold-like high order function. Apply a binary operation `op`
// on a block of consecutive samples of a signal `x`. 
// For example: `reduce(max,128)` will compute the maximun of each
// block of 128 samples. Please note that the resulting
// value, while produced continuously, will be constant for 
// the duration of a block. A new value is only produced 
// at the end of a block. Note also that blocks should be of at
// least one sample (n>0). 
//
// #### Usage
//
// ```
// reduce(op, n, x)
// ```
//-----------------------------------------------------------------------------

reduce(op, n, x) = compute ~ (_,_,_) : (!,!,_)
    with {
        compute(acc, count, val) =
            ba.if(count<n, op(acc,x), x), // new acc
            ba.if(count<n, count+1, 1),   // new count
            ba.if(count<n, val, acc);     // new val
    };


//--------------------`(rm.)reducemap`---------------------------
// Like `reduce` but a `foo` function is applied to the result. From
// a mathematical point of view:
// `reducemap(op,foo,n)` is equivalent to `reduce(op,n):foo`
// but more efficient.
//
// #### Usage
//
// ```
// reducemap(op, foo, n, x)
// ```
//-----------------------------------------------------------------------------

reducemap(op, foo, n, x) = compute ~ (_,_,_) : (!,!,_)
    with {
        compute(acc, count, val) =
            ba.if(count<n, op(acc,x), x),   // new acc
            ba.if(count<n, count+1, 1),     // new count
            ba.if(count<n, val, foo(acc));  // new val
    };

  
// the sum of the amplitudes of the input signal
sumn(n) = reduce(+,n);

// the maximum amplitude of the input signal
maxn(n) = reduce(max,n);

// the minimum amplitude of the input signal
minn(n) = reduce(min,n);

// the average amplitude of the input signal
mean(n) = reducemap(+, /(n), n);

// RMS
RMS(n) = float : ^(2) : reducemap(+, (/(n):sqrt), n);

//#################################### phaflangers.lib ########################################
// A library of phasor and flanger effects. Its official prefix is `pf`.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/phaflangers.lib>
//########################################################################################

ma = library("maths.lib");
de = library("delays.lib");
fi = library("filters.lib");
os = library("oscillators.lib");
pf = library("phaflangers.lib");

declare name "Faust Phaser and Flanger Library";
declare version "0.1";

//########################################################################################
/************************************************************************
FAUST library file, jos section

Except where noted otherwise, The Faust functions below in this
section are Copyright (C) 2003-2017 by Julius O. Smith III <jos@ccrma.stanford.edu>
([jos](http://ccrma.stanford.edu/~jos/)), and released under the
(MIT-style) [STK-4.3](#stk-4.3-license) license.

All MarkDown comments in this section are Copyright 2016-2017 by Romain
Michon and Julius O. Smith III, and are released under the
[CCA4I](https://creativecommons.org/licenses/by/4.0/) license (TODO: if/when Romain agrees!)

************************************************************************/

//=============================Functions Reference========================================
//========================================================================================

//---------------`(pf.)flanger_mono`-------------
// Mono flanging effect.
//
// #### Usage:
//
// ```
// _ : flanger_mono(dmax,curdel,depth,fb,invert) : _
// ```
//
// Where:
//
// * `dmax`: maximum delay-line length (power of 2) - 10 ms typical
// * `curdel`: current dynamic delay (not to exceed dmax)
// * `depth`: effect strength between 0 and 1 (1 typical)
// * `fb`: feedback gain between 0 and 1 (0 typical)
// * `invert`: 0 for normal, 1 to invert sign of flanging sum
//
// #### Reference
//
// <https://ccrma.stanford.edu/~jos/pasp/Flanging.html>
//------------------------------------------------------------
flanger_mono(dmax,curdel,depth,fb,invert)
  = _ <: _, (- : de.fdelay(dmax,curdel)) ~ *(fb) : _,
  *(select2(invert,depth,0-depth))
  : + : *(0.5);

//---------------`(pf.)flanger_stereo`-------------
// Stereo flanging effect.
// `flanger_stereo` is a standard Faust function.
//
// #### Usage:
//
// ```
// _,_ : flanger_stereo(dmax,curdel1,curdel2,depth,fb,invert) : _,_
// ```
//
// Where:
//
// * `dmax`: maximum delay-line length (power of 2) - 10 ms typical
// * `curdel`: current dynamic delay (not to exceed dmax)
// * `depth`: effect strength between 0 and 1 (1 typical)
// * `fb`: feedback gain between 0 and 1 (0 typical)
// * `invert`: 0 for normal, 1 to invert sign of flanging sum
//
// #### Reference
//
// <https://ccrma.stanford.edu/~jos/pasp/Flanging.html>
//------------------------------------------------------------
flanger_stereo(dmax,curdel1,curdel2,depth,fb,invert)
  =  flanger_mono(dmax,curdel1,depth,fb,invert),
     flanger_mono(dmax,curdel2,depth,fb,invert);


vibrato2_mono(sections,phase01,fb,width,frqmin,fratio,frqmax,speed) =
 (+ : seq(i,sections,ap2p(R,th(i)))) ~ *(fb)
with {
     //tf2 = component("filters.lib").tf2;
     // second-order resonant digital allpass given pole radius and angle:
     ap2p(R,th) = fi.tf2(a2,a1,1,a1,a2) with {
       a2 = R^2;
       a1 = -2*R*cos(th);
     };
     R = exp(-pi*width/ma.SR);
     cososc = os.oscrc; // oscillators.lib
     sinosc = os.oscrs; // oscillators.lib
     osc = cososc(speed) * phase01 + sinosc(speed) * (1-phase01);
     lfo = (1-osc)/2; // in [0,1]
     pi = 4*atan(1);
     thmin = 2*pi*frqmin/ma.SR;
     thmax = 2*pi*frqmax/ma.SR;
     th1 = thmin + (thmax-thmin)*lfo;
     th(i) = (fratio^(i+1))*th1;
};


//-------`(pf.)phaser2_mono`-----------------
// Mono phasing effect.
//
// #### Phaser
//
// ```
// _ : phaser2_mono(Notches,phase,width,frqmin,fratio,frqmax,speed,depth,fb,invert) : _
// ```
//
// Where:
//
// * `Notches`: number of spectral notches (MACRO ARGUMENT - not a signal)
// * `phase`: phase of the oscillator (0-1)
// * `width`: approximate width of spectral notches in Hz
// * `frqmin`: approximate minimum frequency of first spectral notch in Hz
// * `fratio`: ratio of adjacent notch frequencies
// * `frqmax`: approximate maximum frequency of first spectral notch in Hz
// * `speed`: LFO frequency in Hz (rate of periodic notch sweep cycles)
// * `depth`: effect strength between 0 and 1 (1 typical) (aka "intensity")
//            when depth=2, "vibrato mode" is obtained (pure allpass chain)
// * `fb`: feedback gain between -1 and 1 (0 typical)
// * `invert`: 0 for normal, 1 to invert sign of flanging sum
//
// Reference:
//
// * <https://ccrma.stanford.edu/~jos/pasp/Phasing.html>
// * <http://www.geofex.com/Article_Folders/phasers/phase.html>
// * 'An Allpass Approach to Digital Phasing and Flanging', Julius O. Smith III,
//		Proc. Int. Computer Music Conf. (ICMC-84), pp. 103-109, Paris, 1984.
// * CCRMA Tech. Report STAN-M-21: <https://ccrma.stanford.edu/STANM/stanms/stanm21/>
//------------------------------------------------------------
phaser2_mono(Notches,phase01,width,frqmin,fratio,frqmax,speed,depth,fb,invert) =
      _ <: *(g1) + g2mi*vibrato2_mono(Notches,phase01,fb,width,frqmin,fratio,frqmax,speed)
with {               // depth=0 => direct-signal only
     g1 = 1-depth/2; // depth=1 => phaser mode (equal sum of direct and allpass-chain)
     g2 = depth/2;   // depth=2 => vibrato mode (allpass-chain signal only)
     g2mi = select2(invert,g2,-g2); // inversion negates the allpass-chain signal
};


//-------`(pf.)phaser2_stereo`-------
// Stereo phasing effect.
// `phaser2_stereo` is a standard Faust function.
//
// #### Phaser
//
// ```
// _,_ : phaser2_stereo(Notches,width,frqmin,fratio,frqmax,speed,depth,fb,invert) : _,_
// ```
//
// Where:
//
// * `Notches`: number of spectral notches (MACRO ARGUMENT - not a signal)
// * `width`: approximate width of spectral notches in Hz
// * `frqmin`: approximate minimum frequency of first spectral notch in Hz
// * `fratio`: ratio of adjacent notch frequencies
// * `frqmax`: approximate maximum frequency of first spectral notch in Hz
// * `speed`: LFO frequency in Hz (rate of periodic notch sweep cycles)
// * `depth`: effect strength between 0 and 1 (1 typical) (aka "intensity")
//            when depth=2, "vibrato mode" is obtained (pure allpass chain)
// * `fb`: feedback gain between -1 and 1 (0 typical)
// * `invert`: 0 for normal, 1 to invert sign of flanging sum
//
// Reference:
//
// * <https://ccrma.stanford.edu/~jos/pasp/Phasing.html>
// * <http://www.geofex.com/Article_Folders/phasers/phase.html>
// * 'An Allpass Approach to Digital Phasing and Flanging', Julius O. Smith III,
//		Proc. Int. Computer Music Conf. (ICMC-84), pp. 103-109, Paris, 1984.
// * CCRMA Tech. Report STAN-M-21: <https://ccrma.stanford.edu/STANM/stanms/stanm21/>
//------------------------------------------------------------
phaser2_stereo(Notches,width,frqmin,fratio,frqmax,speed,depth,fb,invert)
   = phaser2_mono(Notches,0,width,frqmin,fratio,frqmax,speed,depth,fb,invert),
     phaser2_mono(Notches,1,width,frqmin,fratio,frqmax,speed,depth,fb,invert);

// end jos section
/************************************************************************
************************************************************************
FAUST library file, GRAME section

Except where noted otherwise, Copyright (C) 2003-2017 by GRAME,
Centre National de Creation Musicale.
----------------------------------------------------------------------
GRAME LICENSE

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

// TODO: Add GRAME functions here

//########################################################################################
/************************************************************************
FAUST library file, further contributions section

All contributions below should indicate both the contributor and terms
of license.  If no such indication is found, "git blame" will say who
last edited each line, and that person can be emailed to inquire about
license disposition, if their license choice is not already indicated
elsewhere among the libraries.  It is expected that all software will be
released under LGPL, STK-4.3, MIT, BSD, or a similar FOSS license.
************************************************************************/
//##################################### filters.lib ########################################
// Faust Filters library. Its official prefix is `fi`.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/filters.lib>
//
// The Filters library is organized into 19 sections:
//
// * Basic Filters
// * Comb Filters
// * Direct-Form Digital Filter Sections
// * Direct-Form Second-Order Biquad Sections
// * Ladder/Lattice Digital Filters
// * Useful Special Cases
// * Ladder/Lattice Allpass Filters
// * Digital Filter Sections Specified as Analog Filter Sections
// * Simple Resonator Filters
// * Butterworth Lowpass/Highpass Filters
// * Special Filter-Bank Delay-Equalizing Allpass Filters
// * Elliptic (Cauer) Lowpass Filters
// * Elliptic Highpass Filters
// * Butterworth Bandpass/Bandstop Filters
// * Elliptic Bandpass Filters
// * Parametric Equalizers (Shelf, Peaking)
// * Mth-Octave Filter-Banks
// * Arbitrary-Crossover Filter-Banks and Spectrum Analyzers
// * SVF filters
//
//########################################################################################

// NOTE ABOUT LICENSES:
// Each function in this library has its own license. Licenses are declared
// before each function. Corresponding license terms can be found at the 
// bottom of this file or in the Faust libraries documentation.

ma = library("maths.lib");
ba = library("basics.lib");
ro = library("routes.lib");
de = library("delays.lib");
an = library("analyzers.lib");
ef = library("misceffects.lib");
si = library("signals.lib");
fi = library("filters.lib"); // for compatible copy/paste out of this file

declare name "Faust Filters Library";
declare version "0.3";

//===============================Basic Filters============================================
//========================================================================================

//----------------------`(fi.)zero`--------------------------
// One zero filter. Difference equation: \(y(n) = x(n) - zx(n-1)\).
//
// #### Usage
//
// ```
// _ : zero(z) : _
// ```
//
// Where:
//
// * `z`: location of zero along real axis in z-plane
//
// #### Reference
// <https://ccrma.stanford.edu/~jos/filters/One_Zero.html>
//----------------------------------------------------------
declare zero author "Julius O. Smith III";
declare zero copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare zero license "MIT-style STK-4.3 license";
zero(z) = _ <: _,mem : _,*(z) : -;

//------------------------`(fi.)pole`---------------------------
// One pole filter. Could also be called a "leaky integrator".
// Difference equation: \(y(n) = x(n) + py(n-1)\).
//
// #### Usage
//
// ```
// _ : pole(p) : _
// ```
//
// Where:
//
// * `p`: pole location = feedback coefficient
//
// #### Reference
// <https://ccrma.stanford.edu/~jos/filters/One_Pole.html>
//------------------------------------------------------------
declare pole author "Julius O. Smith III";
declare pole copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare pole license "MIT-style STK-4.3 license";
pole(p) = + ~ *(p);

//----------------------`(fi.)integrator`--------------------------
// Same as `pole(1)` [implemented separately for block-diagram clarity].
//------------------------------------------------------------
declare integrator author "Julius O. Smith III";
declare integrator copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare integrator license "MIT-style STK-4.3 license";
integrator = + ~ _;

//-------------------`(fi.)dcblockerat`-----------------------
// DC blocker with configurable break frequency.
// The amplitude response is substantially flat above \(fb\),
// and sloped at about +6 dB/octave below \(fb\).
// Derived from the analog transfer function
// \(H(s) = \frac{s}{(s + 2 \pi fb)}\)
// (which can be seen as a 1st-order Butterworth highpass filter)
// by the low-frequency-matching bilinear transform method
// (i.e., the standard frequency-scaling constant 2*SR).
//
// #### Usage
//
// ```
// _ : dcblockerat(fb) : _
// ```
//
// Where:
//
// * `fb`: "break frequency" in Hz, i.e., -3 dB gain frequency.
//
// #### Reference
// <https://ccrma.stanford.edu/~jos/pasp/Bilinear_Transformation.html>
//------------------------------------------------------------
declare dcblockerat author "Julius O. Smith III";
declare dcblockerat copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare dcblockerat license "MIT-style STK-4.3 license";
dcblockerat(fb) = *(b0) : zero(1) : pole(p)
with {
  wn = ma.PI*fb/ma.SR;
  b0 = 1.0 / (1 + wn);
  p = (1 - wn) * b0;
};

//----------------------`(fi.)dcblocker`--------------------------
// DC blocker. Default dc blocker has -3dB point near 35 Hz (at 44.1 kHz)
// and high-frequency gain near 1.0025 (due to no scaling).
// `dcblocker` is as standard Faust function.
//
// #### Usage
//
// ```
// _ : dcblocker : _
// ```
//------------------------------------------------------------
declare dcblocker author "Julius O. Smith III";
declare dcblocker copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare dcblocker license "MIT-style STK-4.3 license";
dcblocker = zero(1) : pole(0.995);

//----------------------------`(fi.)lptN`--------------------------------------
// One-pole lowpass filter with arbitrary dis/charging factors set in dB and
// times set in seconds.
//
// #### Usage
//
// ```
// _ : lptN(N, tN) : _
// ```
//
// Where:
//
// * `N`: is the attenuation factor in dB
// * `tN`: is the filter period in seconds, that is, the time for the
// impulse response to decay by `N` dB
//
// #### Reference
// <https://ccrma.stanford.edu/~jos/mdft/Exponentials.html>
//----------------------------------------------------------
declare lptN author "Julius O. Smith III";
declare lptN copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare lptN license "MIT-style STK-4.3 license";
lptN(N, tN, x) = x : si.smooth(ba.tau2pole(tN / log(10.0^(float(N)/20.0))));
// Special cases of lptN
lptau(tN, x) = lptN(8.6858896381, tN, x); // Tau time constant, i.e., 1/e atten. after tN secs
lpt60(tN, x) = lptN(60, tN, x); // T60 constant, i.e., 1/1000 atten. after tN secs
lpt19(tN, x) = lptN(19, tN, x); // T19 constant, i.e., 1/e^2.2 atten. after tN secs

//=======================================Comb Filters=====================================
//========================================================================================

//------`(fi.)ff_comb`--------
// Feed-Forward Comb Filter. Note that `ff_comb` requires integer delays
// (uses `delay`  internally).
// `ff_comb` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : ff_comb(maxdel,intdel,b0,bM) : _
// ```
//
// Where:
//
// * `maxdel`: maximum delay (a power of 2)
// * `intdel`: current (integer) comb-filter delay between 0 and maxdel
// * `del`: current (float) comb-filter delay between 0 and maxdel
// * `b0`: gain applied to delay-line input
// * `bM`: gain applied to delay-line output and then summed with input
//
// #### Reference
// <https://ccrma.stanford.edu/~jos/pasp/Feedforward_Comb_Filters.html>
//------------------------------------------------------------
declare ff_comb author "Julius O. Smith III";
declare ff_comb copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare ff_comb license "MIT-style STK-4.3 license";
ff_comb(maxdel,M,b0,bM) = _ <: *(b0), bM * de.delay(maxdel,M) : +;

//------`(fi.)ff_fcomb`--------
// Feed-Forward Comb Filter. Note that `ff_fcomb` takes floating-point delays
// (uses `fdelay` internally).
// `ff_fcomb` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : ff_fcomb(maxdel,del,b0,bM) : _
// ```
//
// Where:
//
// * `maxdel`: maximum delay (a power of 2)
// * `intdel`: current (integer) comb-filter delay between 0 and maxdel
// * `del`: current (float) comb-filter delay between 0 and maxdel
// * `b0`: gain applied to delay-line input
// * `bM`: gain applied to delay-line output and then summed with input
//
// #### Reference
// <https://ccrma.stanford.edu/~jos/pasp/Feedforward_Comb_Filters.html>
//------------------------------------------------------------
declare ff_fcomb author "Julius O. Smith III";
declare ff_fcomb copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare ff_fcomb license "MIT-style STK-4.3 license";
ff_fcomb(maxdel,M,b0,bM) = _ <: *(b0), bM * de.fdelay(maxdel,M) : +;

//-----------`(fi.)ffcombfilter`-------------------
// Typical special case of `ff_comb()` where: `b0 = 1`.
//------------------------------------------------------------
declare ff_combfilter author "Julius O. Smith III";
declare ff_combfilter copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare ff_combfilter license "MIT-style STK-4.3 license";
ffcombfilter(maxdel,del,g) = ff_comb(maxdel,del,1,g);


//-----------------------`(fi.)fb_comb`-----------------------
// Feed-Back Comb Filter (integer delay).
//
// #### Usage
//
// ```
// _ : fb_comb(maxdel,intdel,b0,aN) : _
// ```
//
// Where:
//
// * `maxdel`: maximum delay (a power of 2)
// * `intdel`: current (integer) comb-filter delay between 0 and maxdel
// * `del`: current (float) comb-filter delay between 0 and maxdel
// * `b0`: gain applied to delay-line input and forwarded to output
// * `aN`: minus the gain applied to delay-line output before summing with the input
// 	and feeding to the delay line
//
// #### Reference
// <https://ccrma.stanford.edu/~jos/pasp/Feedback_Comb_Filters.html>
//------------------------------------------------------------
declare fb_comb author "Julius O. Smith III";
declare fb_comb copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare fb_comb license "MIT-style STK-4.3 license";
fb_comb(maxdel,N,b0,aN) = (+ <: de.delay(maxdel,N-1),_) ~ *(-aN) : !,*(b0) : mem;


//-----------------------`(fi.)fb_fcomb`-----------------------
// Feed-Back Comb Filter (floating point delay).
//
// #### Usage
//
// ```
// _ : fb_fcomb(maxdel,del,b0,aN) : _
// ```
//
// Where:
//
// * `maxdel`: maximum delay (a power of 2)
// * `intdel`: current (integer) comb-filter delay between 0 and maxdel
// * `del`: current (float) comb-filter delay between 0 and maxdel
// * `b0`: gain applied to delay-line input and forwarded to output
// * `aN`: minus the gain applied to delay-line output before summing with the input
// 	and feeding to the delay line
//
// #### Reference
// <https://ccrma.stanford.edu/~jos/pasp/Feedback_Comb_Filters.html>
//------------------------------------------------------------
declare fb_fcomb author "Julius O. Smith III";
declare fb_fcomb copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare fb_fcomb license "MIT-style STK-4.3 license";
fb_fcomb(maxdel,N,b0,aN) = (+ <: de.fdelay(maxdel,float(N)-1.0),_) ~ *(-aN) : !,*(b0) : mem;

//-----------------------`(fi.)rev1`-----------------------
// Special case of `fb_comb` (`rev1(maxdel,N,g)`).
// The "rev1 section" dates back to the 1960s in computer-music reverberation.
// See the `jcrev` and `brassrev` in `reverbs.lib` for usage examples.
//------------------------------------------------------------
declare rev1 author "Julius O. Smith III";
declare rev1 copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare rev1 license "MIT-style STK-4.3 license";
rev1(maxdel,N,g) = fb_comb (maxdel,N,1,-g);

//-----`(fi.)fbcombfilter` and `(fi.)ffbcombfilter`------------
// Other special cases of Feed-Back Comb Filter.
//
// #### Usage
//
// ```
// _ : fbcombfilter(maxdel,intdel,g) : _
// _ : ffbcombfilter(maxdel,del,g) : _
// ```
//
// Where:
//
// * `maxdel`: maximum delay (a power of 2)
// * `intdel`: current (integer) comb-filter delay between 0 and maxdel
// * `del`: current (float) comb-filter delay between 0 and maxdel
// * `g`: feedback gain
//
// #### Reference
// <https://ccrma.stanford.edu/~jos/pasp/Feedback_Comb_Filters.html>
//------------------------------------------------------------
declare fbcombfilter author "Julius O. Smith III";
declare fbcombfilter copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare fbcombfilter license "MIT-style STK-4.3 license";
fbcombfilter(maxdel,intdel,g) = (+ : de.delay(maxdel,intdel)) ~ *(g);

declare ffbcombfilter author "Julius O. Smith III";
declare ffbcombfilter copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare ffbcombfilter license "MIT-style STK-4.3 license";
ffbcombfilter(maxdel,del,g) = (+ : de.fdelay(maxdel,del)) ~ *(g);


//-------------------`(fi.)allpass_comb`-----------------
// Schroeder Allpass Comb Filter. Note that:
//
// ```
// allpass_comb(maxlen,len,aN) = ff_comb(maxlen,len,aN,1) : fb_comb(maxlen,len-1,1,aN);
// ```
//
// which is a direct-form-1 implementation, requiring two delay lines.
// The implementation here is direct-form-2 requiring only one delay line.
//
// #### Usage
//
// ```
// _ : allpass_comb(maxdel,intdel,aN) : _
// ```
//
// Where:
//
// * `maxdel`: maximum delay (a power of 2)
// * `intdel`: current (integer) comb-filter delay between 0 and maxdel
// * `del`: current (float) comb-filter delay between 0 and maxdel
// * `aN`: minus the feedback gain
//
// #### References
// * <https://ccrma.stanford.edu/~jos/pasp/Allpass_Two_Combs.html>
// * <https://ccrma.stanford.edu/~jos/pasp/Schroeder_Allpass_Sections.html>
// * <https://ccrma.stanford.edu/~jos/filters/Four_Direct_Forms.html>
//------------------------------------------------------------
declare allpass_comb author "Julius O. Smith III";
declare allpass_comb copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare allpass_comb license "MIT-style STK-4.3 license";
allpass_comb(maxdel,N,aN) = (+ <: de.delay(maxdel,N-1),*(aN)) ~ *(-aN) : mem,_ : +;


//-------------------`(fi.)allpass_fcomb`-----------------
// Schroeder Allpass Comb Filter. Note that:
//
// ```
// allpass_comb(maxlen,len,aN) = ff_comb(maxlen,len,aN,1) : fb_comb(maxlen,len-1,1,aN);
// ```
//
// which is a direct-form-1 implementation, requiring two delay lines.
// The implementation here is direct-form-2 requiring only one delay line.
//
// `allpass_fcomb` is a standard Faust library.
//
// #### Usage
//
// ```
// _ : allpass_comb(maxdel,intdel,aN) : _
// _ : allpass_fcomb(maxdel,del,aN) : _
// ```
//
// Where:
//
// * `maxdel`: maximum delay (a power of 2)
// * `intdel`: current (float) comb-filter delay between 0 and maxdel
// * `del`: current (float) comb-filter delay between 0 and maxdel
// * `aN`: minus the feedback gain
//
// #### References
// * <https://ccrma.stanford.edu/~jos/pasp/Allpass_Two_Combs.html>
// * <https://ccrma.stanford.edu/~jos/pasp/Schroeder_Allpass_Sections.html>
// * <https://ccrma.stanford.edu/~jos/filters/Four_Direct_Forms.html>
//------------------------------------------------------------
declare allpass_fcomb author "Julius O. Smith III";
declare allpass_fcomb copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare allpass_fcomb license "MIT-style STK-4.3 license";
allpass_fcomb(maxdel,N,aN) = (+ <: de.fdelay(maxdel,N-1),*(aN)) ~ *(-aN) : mem,_ : +;


//-----------------------`(fi.)rev2`-----------------------
// Special case of `allpass_comb` (`rev2(maxlen,len,g)`).
// The "rev2 section" dates back to the 1960s in computer-music reverberation.
// See the `jcrev` and `brassrev` in `reverbs.lib` for usage examples.
//------------------------------------------------------------
declare rev2 author "Julius O. Smith III";
declare rev2 copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare rev2 license "MIT-style STK-4.3 license";
rev2(maxlen,len,g) = allpass_comb(maxlen,len,-g);

//-------------------`(fi.)allpass_fcomb5` and `(fi.)allpass_fcomb1a`-----------------
// Same as `allpass_fcomb` but use `fdelay5` and `fdelay1a` internally
// (Interpolation helps - look at an fft of faust2octave on
//
// ```
// `1-1' <: allpass_fcomb(1024,10.5,0.95), allpass_fcomb5(1024,10.5,0.95);`).
// ```
//------------------------------------------------------------
declare allpass_fcomb5 author "Julius O. Smith III";
declare allpass_fcomb5 copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare allpass_fcomb5 license "MIT-style STK-4.3 license";
allpass_fcomb5(maxdel,N,aN) = (+ <: de.fdelay5(maxdel,N-1),*(aN)) ~ *(-aN) : mem,_ : +;

declare allpass_fcomb1a author "Julius O. Smith III";
declare allpass_fcomb1a copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare allpass_fcomb1a license "MIT-style STK-4.3 license";
allpass_fcomb1a(maxdel,N,aN) = (+ <: de.fdelay1a(maxdel,N-1),*(aN)) ~ *(-aN) : mem,_ : +;


//========================Direct-Form Digital Filter Sections=============================
//========================================================================================

// Specified by transfer-function polynomials B(z)/A(z) as in matlab

//----------------------------`(fi.)iir`-------------------------------
// Nth-order Infinite-Impulse-Response (IIR) digital filter,
// implemented in terms of the Transfer-Function (TF) coefficients.
// Such filter structures are termed "direct form".
//
// `iir` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : iir(bcoeffs,acoeffs) : _
// ```
//
// Where:
//
// * `bcoeffs`: (b0,b1,...,b_order) = TF numerator coefficients
// * `acoeffs`: (a1,...,a_order) = TF denominator coeffs (a0=1)
//
// #### Reference
// <https://ccrma.stanford.edu/~jos/filters/Four_Direct_Forms.html>
//------------------------------------------------------------
declare iir author "Julius O. Smith III";
declare iir copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare iir license "MIT-style STK-4.3 license";
iir(bv,av) = ma.sub ~ fir(av) : fir(bv);

//-----------------------------`(fi.)fir`---------------------------------
// FIR filter (convolution of FIR filter coefficients with a signal). `fir` is standard Faust function.
//
// #### Usage
//
// ```
// _ : fir(bv) : _
// ```
//
// Where:
//
// * `bv` = b0,b1,...,bn is a parallel bank of coefficient signals.
//
// #### Note
//
// `bv` is processed using pattern-matching at compile time,
//       so it must have this normal form (parallel signals).
//
// #### Example
//
// Smoothing white noise with a five-point moving average:
//
// ```
// bv = .2,.2,.2,.2,.2;
// process = noise : fir(bv);
// ```
//
// Equivalent (note double parens):
//
// ```
// process = noise : fir((.2,.2,.2,.2,.2));
// ```
//------------------------------------------------------------
//fir(bv) = conv(bv);
declare fir author "Julius O. Smith III";
declare fir copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare fir license "MIT-style STK-4.3 license";
fir((b0,bv)) = _ <: *(b0), R(1,bv) :> _ with {
	R(n,(bn,bv)) = (@(n):*(bn)), R(n+1,bv);
	R(n, bn)     = (@(n):*(bn)); };
fir(b0) = *(b0);

//---------------`(fi.)conv` and `(fi.)convN`-------------------------------
// Convolution of input signal with given coefficients.
//
// #### Usage
//
// ```
// _ : conv((k1,k2,k3,...,kN)) : _ // Argument = one signal bank
// _ : convN(N,(k1,k2,k3,...)) : _ // Useful when N < count((k1,...))
// ```
//------------------------------------------------------------
//convN(N,kv,x) = sum(i,N,take(i+1,kv) * x@i); // take() defined in math.lib

declare convN author "Julius O. Smith III";
declare convN copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare convN license "MIT-style STK-4.3 license";
convN(N,kv) = sum(i,N, @(i)*take(i+1,kv)); // take() defined in math.lib
//conv(kv,x) = sum(i,count(kv),take(i+1,kv) * x@i); // count() from math.lib

declare conv author "Julius O. Smith III";
declare conv copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare conv license "MIT-style STK-4.3 license";
conv(kv) = fir(kv);

//----------------`(fi.)tf1`, `(fi.)tf2` and `(fi.)tf3`----------------------
// tfN = N'th-order direct-form digital filter.
//
// #### Usage
//
// ```
// _ : tf1(b0,b1,a1) : _
// _ : tf2(b0,b1,b2,a1,a2) : _
// _ : tf3(b0,b1,b2,b3,a1,a2,a3) : _
// ```
//
// Where:
//
// * `a`: the poles
// * `b`: the zeros
//
// #### Reference
// <https://ccrma.stanford.edu/~jos/fp/Direct_Form_I.html>
//------------------------------------------------------------
declare tf1 author "Julius O. Smith III";
declare tf1 copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare tf1 license "MIT-style STK-4.3 license";
tf1(b0,b1,a1) = _ <: *(b0), (mem : *(b1)) :> + ~ *(0-a1);

declare tf2 author "Julius O. Smith III";
declare tf2 copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare tf2 license "MIT-style STK-4.3 license";
tf2(b0,b1,b2,a1,a2) = iir((b0,b1,b2),(a1,a2));
// tf2 is a variant of tf22 below with duplicated mems

declare tf3 author "Julius O. Smith III";
declare tf3 copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare tf3 license "MIT-style STK-4.3 license";
tf3(b0,b1,b2,b3,a1,a2,a3) = iir((b0,b1,b2,b3),(a1,a2,a3));

// "Original" version for music.lib. This is here for comparison but people should
// use tf2 instead
TF2(b0,b1,b2,a1,a2) = sub ~ conv2(a1,a2) : conv3(b0,b1,b2)
with {
	conv3(k0,k1,k2,x) = k0*x + k1*x' + k2*x'';
	conv2(k0,k1,x)    = k0*x + k1*x';
	sub(x,y)          = y-x;
};

//------------`(fi.)notchw`--------------
// Simple notch filter based on a biquad (`tf2`).
// `notchw` is a standard Faust function.
//
// #### Usage:
//
// ```
// _ : notchw(width,freq) : _
// ```
//
// Where:
//
// * `width`: "notch width" in Hz (approximate)
// * `freq`: "notch frequency" in Hz
//
// #### Reference
// <https://ccrma.stanford.edu/~jos/pasp/Phasing_2nd_Order_Allpass_Filters.html>
//------------------------------------------------------------
declare notchw author "Julius O. Smith III";
declare notchw copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare notchw license "MIT-style STK-4.3 license";
notchw(width,freq) = tf2(b0,b1,b2,a1,a2)
with {
  fb = 0.5*width; // First design a dcblockerat(width/2)
  wn = ma.PI*fb/ma.SR;
  b0db = 1.0 / (1 + wn);
  p = (1 - wn) * b0db; // This is our pole radius.
  // Now place unit-circle zeros at desired angles:
  tn = 2*ma.PI*freq/ma.SR;
  a2 = p * p;
  a2p1 = 1+a2;
  a1 = -a2p1*cos(tn);
  b1 = a1;
  b0 = 0.5*a2p1;
  b2 = b0;
};

//======================Direct-Form Second-Order Biquad Sections==========================
// Direct-Form Second-Order Biquad Sections
//
// #### Reference
// <https://ccrma.stanford.edu/~jos/filters/Four_Direct_Forms.html>
//========================================================================================

//----------------`(fi.)tf21`, `(fi.)tf22`, `(fi.)tf22t` and `(fi.)tf21t`----------------------
// tfN = N'th-order direct-form digital filter where:
//
// * `tf21` is tf2, direct-form 1
// * `tf22` is tf2, direct-form 2
// * `tf22t` is tf2, direct-form 2 transposed
// * `tf21t` is tf2, direct-form 1 transposed
//
// #### Usage
//
// ```
// _ : tf21(b0,b1,b2,a1,a2) : _
// _ : tf22(b0,b1,b2,a1,a2) : _
// _ : tf22t(b0,b1,b2,a1,a2) : _
// _ : tf21t(b0,b1,b2,a1,a2) : _
// ```
//
// Where:
//
// * `a`: the poles
// * `b`: the zeros
//
// #### Reference
// <https://ccrma.stanford.edu/~jos/fp/Direct_Form_I.html>
//------------------------------------------------------------
declare tf21 author "Julius O. Smith III";
declare tf21 copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare tf21 license "MIT-style STK-4.3 license";
tf21(b0,b1,b2,a1,a2) = // tf2, direct-form 1:
    _ <:(mem<:((mem:*(b2)),*(b1))),*(b0) :>_
    : ((_,_,_:>_) ~(_<:*(-a1),(mem:*(-a2))));
    
declare tf22 author "Julius O. Smith III";
declare tf22 copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare tf22 license "MIT-style STK-4.3 license";
tf22(b0,b1,b2,a1,a2) = // tf2, direct-form 2:
    _ : (((_,_,_:>_)~*(-a1)<:mem,*(b0))~*(-a2))
      : (_<:mem,*(b1)),_ : *(b2),_,_ :> _;

declare tf22t author "Julius O. Smith III";
declare tf22t copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare tf22t license "MIT-style STK-4.3 license";
tf22t(b0,b1,b2,a1,a2) = // tf2, direct-form 2 transposed:
    _ : (_,_,(_ <: *(b2)',*(b1)',*(b0))
      : _,+',_,_ :> _)~*(-a1)~*(-a2) : _;

declare tf21t author "Julius O. Smith III";
declare tf21t copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare tf21t license "MIT-style STK-4.3 license";
tf21t(b0,b1,b2,a1,a2) = // tf2, direct-form 1 transposed:
    tf22t(1,0,0,a1,a2) : tf22t(b0,b1,b2,0,0); // or write it out if you want

//=========================== Ladder/Lattice Digital Filters =============================
// Ladder and lattice digital filters generally have superior numerical
// properties relative to direct-form digital filters.  They can be derived
// from digital waveguide filters, which gives them a physical interpretation.

// #### Reference
// * F. Itakura and S. Saito: "Digital Filtering Techniques for Speech Analysis and Synthesis",
//     7th Int. Cong. Acoustics, Budapest, 25 C 1, 1971.
// * J. D. Markel and A. H. Gray: Linear Prediction of Speech, New York: Springer Verlag, 1976.
// * <https://ccrma.stanford.edu/~jos/pasp/Conventional_Ladder_Filters.html>
//========================================================================================

//-------------------------------`(fi.)av2sv`-----------------------------------
// Compute reflection coefficients sv from transfer-function denominator av.
//
// #### Usage
//
// ```
// sv = av2sv(av)
// ```
//
// Where:
//
// * `av`: parallel signal bank `a1,...,aN`
// * `sv`: parallel signal bank `s1,...,sN`
//
// where `ro = ith` reflection coefficient, and
//       `ai` = coefficient of `z^(-i)` in the filter
//          transfer-function denominator `A(z)`.
//
// #### Reference
//   <https://ccrma.stanford.edu/~jos/filters/Step_Down_Procedure.html>
//   (where reflection coefficients are denoted by k rather than s).
//------------------------------------------------------------
declare av2sv author "Julius O. Smith III";
declare av2sv copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare av2sv license "MIT-style STK-4.3 license";
av2sv(av) = par(i,M,s(i+1)) with {
  M = ba.count(av);
  s(m) = sr(M-m+1); // m=1..M
  sr(m) = Ari(m,M-m+1); // s_{M-1-m}
  Ari(m,i) = ba.take(i+1,Ar(m-1));
  //step-down recursion for lattice/ladder digital filters:
  Ar(0) = (1,av); // Ar(m) is order M-m (i.e. "reverse-indexed")
  Ar(m) = 1,par(i,M-m, (Ari(m,i+1) - sr(m)*Ari(m,M-m-i))/(1-sr(m)*sr(m)));
};

//----------------------------`(fi.)bvav2nuv`--------------------------------
// Compute lattice tap coefficients from transfer-function coefficients.
//
// #### Usage
//
// ```
// nuv = bvav2nuv(bv,av)
// ```
//
// Where:
//
// * `av`: parallel signal bank `a1,...,aN`
// * `bv`: parallel signal bank `b0,b1,...,aN`
// * `nuv`: parallel signal bank  `nu1,...,nuN`
//
// where `nui` is the i'th tap coefficient,
//       `bi` is the coefficient of `z^(-i)` in the filter numerator,
//       `ai` is the coefficient of `z^(-i)` in the filter denominator
//------------------------------------------------------------
declare bvav2nuv author "Julius O. Smith III";
declare bvav2nuv copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare bvav2nuv license "MIT-style STK-4.3 license";
bvav2nuv(bv,av) = par(m,M+1,nu(m)) with {
  M = ba.count(av);
  nu(m) = ba.take(m+1,Pr(M-m)); // m=0..M
  // lattice/ladder tap parameters:
  Pr(0) = bv; // Pr(m) is order M-m, 'r' means "reversed"
  Pr(m) = par(i,M-m+1, (Pri(m,i) - nu(M-m+1)*Ari(m,M-m-i+1)));
  Pri(m,i) = ba.take(i+1,Pr(m-1));
  Ari(m,i) = ba.take(i+1,Ar(m-1));
  //step-down recursion for lattice/ladder digital filters:
  Ar(0) = (1,av); // Ar(m) is order M-m (recursion index must start at constant)
  Ar(m) = 1,par(i,M-m, (Ari(m,i+1) - sr(m)*Ari(m,M-m-i))/(1-sr(m)*sr(m)));
  sr(m) = Ari(m,M-m+1); // s_{M-1-m}
};

//--------------------`(fi.)iir_lat2`-----------------------
// Two-multiply latice IIR filter of arbitrary order.
//
// #### Usage
//
// ```
// _ : iir_lat2(bv,av) : _
// ```
//
// Where:
//
// * bv: zeros as a bank of parallel signals
// * av: poles as a bank of parallel signals
//------------------------------------------------------------
declare iir_lat2 author "Julius O. Smith III";
declare iir_lat2 copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare iir_lat2 license "MIT-style STK-4.3 license";
iir_lat2(bv,av) = allpassnt(M,sv) : sum(i,M+1,*(ba.take(M-i+1,tg)))
with {
  M = ba.count(av);
  sv = av2sv(av); // sv = vector of sin(theta) reflection coefficients
  tg = bvav2nuv(bv,av); // tg = vector of tap gains
};

//-----------------------`(fi.)allpassnt`--------------------------
// Two-multiply lattice allpass (nested order-1 direct-form-ii allpasses).
//
// #### Usage
//
// ```
// _ : allpassnt(n,sv) : _
// ```
//
// Where:
//
// * `n`: the order of the filter
// * `sv`: the reflection coefficients (-1 1)
//------------------------------------------------------------
declare allpassnt author "Julius O. Smith III";
declare allpassnt copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare allpassnt license "MIT-style STK-4.3 license";
allpassnt(0,sv) = _;
allpassnt(n,sv) = _ : ((+ <: (allpassnt(n-1,sv),*(s)))~*(-s)) : fsec(n)
with {
  fsec(1) = ro.crossnn(1) : _, (_<:mem,_) : +,_;
  fsec(n) = ro.crossn1(n) : _, (_<:mem,_),par(i,n-1,_) : +, par(i,n,_);
  innertaps(n) = par(i,n,_);
  s = ba.take(n,sv); // reflection coefficient s = sin(theta)
};

//--------------------`(fi.)iir_kl`-----------------------
// Kelly-Lochbaum ladder IIR filter of arbitrary order.
//
// #### Usage
//
// ```
// _ : iir_kl(bv,av) : _
// ```
//
// Where:
//
// * bv: zeros as a bank of parallel signals
// * av: poles as a bank of parallel signals
//------------------------------------------------------------
declare iir_kl author "Julius O. Smith III";
declare iir_kl copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare iir_kl license "MIT-style STK-4.3 license";
iir_kl(bv,av) = allpassnklt(M,sv) : sum(i,M+1,*(tghr(i)))
with {
  M = ba.count(av);
  sv = av2sv(av); // sv = vector of sin(theta) reflection coefficients
  tg = bvav2nuv(bv,av); // tg = vector of tap gains for 2mul case
  tgr(i) = ba.take(M+1-i,tg);
  tghr(n) = tgr(n)/pi(n);
  pi(0) = 1;
  pi(n) = pi(n-1)*(1+ba.take(M-n+1,sv)); // all sign parameters '+'
};

//-----------------------`(fi.)allpassnklt`--------------------------
// Kelly-Lochbaum ladder allpass.
//
// #### Usage:
//
// ```
// _ : allpassklt(n,sv) : _
// ```
//
// Where:
//
// * `n`: the order of the filter
// * `sv`: the reflection coefficients (-1 1)
//------------------------------------------------------------
declare allpassnklt author "Julius O. Smith III";
declare allpassnklt copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare allpassnklt license "MIT-style STK-4.3 license";
allpassnklt(0,sv) = _;
allpassnklt(n,sv) = _ <: *(s),(*(1+s) : (+
                   : allpassnklt(n-1,sv))~(*(-s))) : fsec(n)
with {
  fsec(1) = _, (_<:mem*(1-s),_) : sumandtaps(n);
  fsec(n) = _, (_<:mem*(1-s),_), par(i,n-1,_) : sumandtaps(n);
  s = ba.take(n,sv);
  sumandtaps(n) = +,par(i,n,_);
};

//--------------------`(fi.)iir_lat1`-----------------------
// One-multiply latice IIR filter of arbitrary order.
//
// #### Usage
//
// ```
// _ : iir_lat1(bv,av) : _
// ```
//
// Where:
//
// * bv: zeros as a bank of parallel signals
// * av: poles as a bank of parallel signals
//------------------------------------------------------------
declare iir_lat1 author "Julius O. Smith III";
declare iir_lat1 copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare iir_lat1 license "MIT-style STK-4.3 license";
iir_lat1(bv,av) = allpassn1mt(M,sv) : sum(i,M+1,*(tghr(i+1)))
with {
  M = ba.count(av);
  sv = av2sv(av); // sv = vector of sin(theta) reflection coefficients
  tg = bvav2nuv(bv,av); // tg = vector of tap gains
  tgr(i) = ba.take(M+2-i,tg); // i=1..M+1 (for "takability")
  tghr(n) = tgr(n)/pi(n);
  pi(1) = 1;
  pi(n) = pi(n-1)*(1+ba.take(M-n+2,sv)); // all sign parameters '+'
};

//-----------------------`(fi.)allpassn1mt`--------------------------
// One-multiply lattice allpass with tap lines.
//
// #### Usage
//
// ```
// _ : allpassn1mt(N,sv) : _
// ```
//
// Where:
//
// * `N`: the order of the filter (fixed at compile time)
// * `sv`: the reflection coefficients (-1 1)
//------------------------------------------------------------
declare allpassn1mt author "Julius O. Smith III";
declare allpassn1mt copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare allpassn1mt license "MIT-style STK-4.3 license";
allpassn1mt(0,sv) = _;
allpassn1mt(n,sv) = _ <: _,_ : ((+:*(s) <: _,_),_ : _,+ : ro.crossnn(1)
		  : allpassn1mt(n-1,sv),_)~(*(-1)) : fsec(n)
with {
  fsec(1) = ro.crossnn(1) : _, (_<:mem,_) : +,_;
  fsec(n) = ro.crossn1(n) : _, (_<:mem,_),par(i,n-1,_) : +, par(i,n,_);
  innertaps(n) = par(i,n,_);
  s = ba.take(n,sv); // reflection coefficient s = sin(theta)
};

//-------------------------------`(fi.)iir_nl`-------------------------
// Normalized ladder filter of arbitrary order.
//
// #### Usage
//
// ```
// _ : iir_nl(bv,av) : _
// ```
//
// Where:
//
// * bv: zeros as a bank of parallel signals
// * av: poles as a bank of parallel signals
//
// #### References
// * J. D. Markel and A. H. Gray, Linear Prediction of Speech, New York: Springer Verlag, 1976.
// * <https://ccrma.stanford.edu/~jos/pasp/Normalized_Scattering_Junctions.html>
//------------------------------------------------------------
declare iir_nl author "Julius O. Smith III";
declare iir_nl copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare iir_nl license "MIT-style STK-4.3 license";
iir_nl(bv,av) = allpassnnlt(M,sv) : sum(i,M+1,*(tghr(i)))
with {
  M = ba.count(av);
  sv = av2sv(av); // sv = vector of sin(theta) reflection coefficients
  tg = bvav2nuv(bv,av); // tg = vector of tap gains for 2mul case
  tgr(i) = ba.take(M+1-i,tg);
  tghr(n) = tgr(n)/pi(n);
  pi(0) = 1;
  s(n) = ba.take(M-n+1,sv); // reflection coefficient = sin(theta)
  c(n) = sqrt(max(0,1-s(n)*s(n))); // compiler crashes on sqrt(-)
  pi(n) = pi(n-1)*c(n);
};

//-------------------------------`(fi.)allpassnnlt`-------------------------
// Normalized ladder allpass filter of arbitrary order.
//
// #### Usage:
//
// ```
// _ : allpassnnlt(N,sv) : _
// ```
//
// Where:
//
// * `N`: the order of the filter (fixed at compile time)
// * `sv`: the reflection coefficients (-1,1)
//
// #### References
// * J. D. Markel and A. H. Gray, Linear Prediction of Speech, New York: Springer Verlag, 1976.
// * <https://ccrma.stanford.edu/~jos/pasp/Normalized_Scattering_Junctions.html>
//------------------------------------------------------------
declare allpassnnlt author "Julius O. Smith III";
declare allpassnnlt copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare allpassnnlt license "MIT-style STK-4.3 license";
allpassnnlt(0,sv) = _;
allpassnnlt(n,scl*(sv)) = allpassnnlt(n,par(i,count(sv),scl*(sv(i))));
allpassnnlt(n,sv) = _ <: *(s),(*(c) : (+
                   : allpassnnlt(n-1,sv))~(*(-s))) : fsec(n)
with {
  fsec(1) = _, (_<:mem*(c),_) : sumandtaps(n);
  fsec(n) = _, (_<:mem*(c),_), par(i,n-1,_) : sumandtaps(n);
  s = ba.take(n,sv);
  c = sqrt(max(0,1-s*s));
  sumandtaps(n) = +,par(i,n,_);
};

//=============================Useful Special Cases=======================================
//========================================================================================

//--------------------------------`(fi.)tf2np`------------------------------------
// Biquad based on a stable second-order Normalized Ladder Filter
// (more robust to modulation than `tf2` and protected against instability).
//
// #### Usage
//
// ```
// _ : tf2np(b0,b1,b2,a1,a2) : _
// ```
//
// Where:
//
// * `a`: the poles
// * `b`: the zeros
//------------------------------------------------------------
declare tf2np author "Julius O. Smith III";
declare tf2np copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare tf2np license "MIT-style STK-4.3 license";
tf2np(b0,b1,b2,a1,a2) = allpassnnlt(M,sv) : sum(i,M+1,*(tghr(i)))
with {
  smax = 1.0-ma.EPSILON; // maximum reflection-coefficient magnitude allowed
  s2 = max(-smax, min(smax,a2)); // Project both reflection-coefficients
  s1 = max(-smax, min(smax,a1/(1+a2))); // into the defined stability-region.
  sv = (s1,s2); // vector of sin(theta) reflection coefficients
  M = 2;
  nu(2) = b2;
  nu(1) = b1 - b2*a1;
  nu(0) = (b0-b2*a2) - nu(1)*s1;
  tg = (nu(0),nu(1),nu(2));
  tgr(i) = ba.take(M+1-i,tg); // vector of tap gains for 2mul case
  tghr(n) = tgr(n)/pi(n);  // apply pi parameters for NLF case
  pi(0) = 1;
  s(n) = ba.take(M-n+1,sv);
  c(n) = sqrt(1-s(n)*s(n));
  pi(n) = pi(n-1)*c(n);
};

//-----------------------------`(fi.)wgr`---------------------------------
// Second-order transformer-normalized digital waveguide resonator.
//
// #### Usage
//
// ```
// _ : wgr(f,r) : _
// ```
//
// Where:
//
// * `f`: resonance frequency (Hz)
// * `r`: loss factor for exponential decay (set to 1 to make a numerically stable oscillator)
//
// #### References
// * <https://ccrma.stanford.edu/~jos/pasp/Power_Normalized_Waveguide_Filters.html>
// * <https://ccrma.stanford.edu/~jos/pasp/Digital_Waveguide_Oscillator.html>
//------------------------------------------------------------
declare wgr author "Julius O. Smith III";
declare wgr copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare wgr license "MIT-style STK-4.3 license";
wgr(f,r,x) = (*(G),_<:_,((+:*(C))<:_,_),_:+,_,_:+(x),-) ~ cross : _,*(0-gi)
with {
  C = cos(2*ma.PI*f/ma.SR);
  gi = sqrt(max(0,(1+C)/(1-C))); // compensate amplitude (only needed when
  G = r*(1-1' + gi')/gi;         // frequency changes substantially)
  cross = _,_ <: !,_,_,!;
};

//-----------------------------`(fi.)nlf2`--------------------------------
// Second order normalized digital waveguide resonator.
//
// #### Usage
//
// ```
// _ : nlf2(f,r) : _
// ```
//
// Where:
//
// * `f`: resonance frequency (Hz)
// * `r`: loss factor for exponential decay (set to 1 to make a sinusoidal oscillator)
//
// #### Reference
// <https://ccrma.stanford.edu/~jos/pasp/Power_Normalized_Waveguide_Filters.html>
//------------------------------------------------------------
declare nlf2 author "Julius O. Smith III";
declare nlf2 copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare nlf2 license "MIT-style STK-4.3 license";
nlf2(f,r,x) = ((_<:_,_),(_<:_,_) : (*(s),*(c),*(c),*(0-s)) :>
              (*(r),+(x))) ~ cross
with {
  th = 2*ma.PI*f/ma.SR;
  c = cos(th);
  s = sin(th);
  cross = _,_ <: !,_,_,!;
};


//------------`(fi.)apnl`---------------
// Passive Nonlinear Allpass based on Pierce switching springs idea.
// Switch between allpass coefficient `a1` and `a2` at signal zero crossings.
//
// #### Usage
//
// ```
// _ : apnl(a1,a2) : _
// ```
//
// Where:
//
// * `a1` and `a2`: allpass coefficients
//
// #### Reference
// * "A Passive Nonlinear Digital Filter Design ..." by John R. Pierce and Scott
// A. Van Duyne, JASA, vol. 101, no. 2, pp. 1120-1126, 1997
//------------------------------------------------------------
declare apnl author "Julius O. Smith III";
declare apnl copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare apnl license "MIT-style STK-4.3 license";
apnl(a1,a2,x) = nonLinFilter
with {
   condition = _>0;
   nonLinFilter = (x - _ <: _*(condition*a1 + (1-condition)*a2),_')~_ :> +;
};


//============================Ladder/Lattice Allpass Filters==============================
// An allpass filter has gain 1 at every frequency, but variable phase.
// Ladder/lattice allpass filters are specified by reflection coefficients.
// They are defined here as nested allpass filters, hence the names allpassn*.
//
// #### References
// * <https://ccrma.stanford.edu/~jos/pasp/Conventional_Ladder_Filters.html>
// * <https://ccrma.stanford.edu/~jos/pasp/Nested_Allpass_Filters.html>
// * Linear Prediction of Speech, Markel and Gray, Springer Verlag, 1976
//========================================================================================

//---------------`(fi.)allpassn`-----------------
// Two-multiply lattice - each section is two multiply-adds.
//
// #### Usage:
//
// ```
// _ : allpassn(n,sv) : _
// ```
// #### Where:
//
// * `n`: the order of the filter
// * `sv`: the reflection coefficients (-1 1)
//
// #### References
// * J. O. Smith and R. Michon, "Nonlinear Allpass Ladder Filters in FAUST", in
// Proceedings of the 14th International Conference on Digital Audio Effects
// (DAFx-11), Paris, France, September 19-23, 2011.
//----------------------------------------------
declare allpassn author "Julius O. Smith III and Romain Michon";
declare allpassn copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu> and Romain Michon <rmichon@ccrma.stanford.edu>";
declare allpassn license "MIT-style STK-4.3 license";
allpassn(0,sv) = _;
allpassn(n,sv) = _ <: ((+ <: (allpassn(n-1,sv)),*(s))~(*(-s))) : _',_ :+
with { s = ba.take(n,sv); };

//---------------`(fi.)allpassnn`-----------------
// Normalized form - four multiplies and two adds per section,
// but coefficients can be time varying and nonlinear without
// "parametric amplification" (modulation of signal energy).
//
// #### Usage:
//
// ```
// _ : allpassnn(n,tv) : _
// ```
//
// Where:
//
// * `n`: the order of the filter
// * `tv`: the reflection coefficients (-PI PI)
//----------------------------------------------
// power-normalized (reflection coefficients s = sin(t)):
declare allpassnn author "Julius O. Smith III";
declare allpassnn copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare allpassnn license "MIT-style STK-4.3 license";
allpassnn(0,tv) = _;
allpassnn(n,tv) = _ <: *(s), (*(c) : (+
        : allpassnn(n-1,tv))~(*(-s))) : _, mem*c : +
with { c = cos(ba.take(n,tv));  s = sin(ba.take(n,tv)); };

//---------------`(fi.)allpasskl`-----------------
// Kelly-Lochbaum form - four multiplies and two adds per
// section, but all signals have an immediate physical
// interpretation as traveling pressure waves, etc.
//
// #### Usage:
//
// ```
// _ : allpassnkl(n,sv) : _
// ```
//
// Where:
//
// * `n`: the order of the filter
// * `sv`: the reflection coefficients (-1 1)
//----------------------------------------------
// Kelly-Lochbaum:
declare allpassnnkl author "Julius O. Smith III";
declare allpassnnkl copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare allpassnnkl license "MIT-style STK-4.3 license";
allpassnkl(0,sv) = _;
allpassnkl(n,sv) = _ <: *(s),(*(1+s) : (+
                   : allpassnkl(n-1,sv))~(*(-s))) : _, mem*(1-s) : +
with { s = ba.take(n,sv); };

//---------------`(fi.)allpass1m`-----------------
// One-multiply form - one multiply and three adds per section.
// Normally the most efficient in special-purpose hardware.
//
// #### Usage:
//
// ```
// _ : allpassn1m(n,sv) : _
// ```
//
// Where:
//
// * `n`: the order of the filter
// * `sv`: the reflection coefficients (-1 1)
//----------------------------------------------
// one-multiply:
declare allpassn1m author "Julius O. Smith III";
declare allpassn1m copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare allpassn1m license "MIT-style STK-4.3 license";
allpassn1m(0,sv) = _;
allpassn1m(n,sv) = _ <: _,_ : ((+:*(s) <: _,_),_ : _,+ : cross
		  : allpassn1m(n-1,sv),_)~(*(-1)) : _',_ : +
with { s = ba.take(n,sv); cross = _,_ <: !,_,_,!; };

//===========Digital Filter Sections Specified as Analog Filter Sections==================
//========================================================================================

//-------------------------`(fi.)tf2s` and `(fi.)tf2snp`--------------------------------
// Second-order direct-form digital filter,
// specified by ANALOG transfer-function polynomials B(s)/A(s),
// and a frequency-scaling parameter. Digitization via the
// bilinear transform is built in.
//
// #### Usage
//
// ```
// _ : tf2s(b2,b1,b0,a1,a0,w1) : _
// ```
// Where:
//
// ```
//         b2 s^2 + b1 s + b0
// H(s) = --------------------
//            s^2 + a1 s + a0
// ```
//
// and `w1` is the desired digital frequency (in radians/second)
// corresponding to analog frequency 1 rad/sec (i.e., `s = j`).
//
// #### Example
//
// A second-order ANALOG Butterworth lowpass filter,
// normalized to have cutoff frequency at 1 rad/sec,
// has transfer function:
//
// ```
//              1
// H(s) = -----------------
//         s^2 + a1 s + 1
// ```
//
// where `a1 = sqrt(2)`.  Therefore, a DIGITAL Butterworth lowpass
// cutting off at `SR/4` is specified as `tf2s(0,0,1,sqrt(2),1,PI*SR/2);`
//
// #### Method
//
// Bilinear transform scaled for exact mapping of w1.
//
// #### Reference
// <https://ccrma.stanford.edu/~jos/pasp/Bilinear_Transformation.html>
//----------------------------------------------
declare tf2s author "Julius O. Smith III";
declare tf2s copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare tf2s license "MIT-style STK-4.3 license";
tf2s(b2,b1,b0,a1,a0,w1) = tf2(b0d,b1d,b2d,a1d,a2d)
with {
  c   = 1/tan(w1*0.5/ma.SR); // bilinear-transform scale-factor
  csq = c*c;
  d   = a0 + a1 * c + csq;
  b0d = (b0 + b1 * c + b2 * csq)/d;
  b1d = 2 * (b0 - b2 * csq)/d;
  b2d = (b0 - b1 * c + b2 * csq)/d;
  a1d = 2 * (a0 - csq)/d;
  a2d = (a0 - a1*c + csq)/d;
};

// tf2snp = tf2s but using a protected normalized ladder filter for tf2:
tf2snp(b2,b1,b0,a1,a0,w1) = tf2np(b0d,b1d,b2d,a1d,a2d)
with {
  c   = 1/tan(w1*0.5/ma.SR); // bilinear-transform scale-factor
  csq = c*c;
  d   = a0 + a1 * c + csq;
  b0d = (b0 + b1 * c + b2 * csq)/d;
  b1d = 2 * (b0 - b2 * csq)/d;
  b2d = (b0 - b1 * c + b2 * csq)/d;
  a1d = 2 * (a0 - csq)/d;
  a2d = (a0 - a1*c + csq)/d;
};

//-----------------------------`(fi.)tf1snp`-------------------------------
// First-order special case of tf2snp above.
//
// #### Usage
//
// ```
// _ : tf1snp(b1,b0,a0) : _
// ```
//----------------------------------------------
declare tf1snp author "Julius O. Smith III";
declare tf1snp copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare tf1snp license "MIT-style STK-4.3 license";
tf1snp(b1,b0,a0,w1) = fi.tf2snp(b1,b0,0,a0,0,w1); // FIXME: Faust compiler does not fully optimize - does C++?

//-----------------------------`(fi.)tf3slf`-------------------------------
// Analogous to tf2s above, but third order, and using the typical
// low-frequency-matching bilinear-transform constant 2/T ("lf" series)
// instead of the specific-frequency-matching value used in tf2s and tf1s.
// Note the lack of a "w1" argument.
//
// #### Usage
//
// ```
// _ : tf3slf(b3,b2,b1,b0,a3,a2,a1,a0) : _
// ```
//----------------------------------------------
declare tf3slf author "Julius O. Smith III";
declare tf3slf copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare tf3slf license "MIT-style STK-4.3 license";
tf3slf(b3,b2,b1,b0,a3,a2,a1,a0) = tf3(b0d,b1d,b2d,b3d,a1d,a2d,a3d) with {
  c   = 2.0 * ma.SR; // bilinear-transform scale-factor ("lf" case)
  csq = c*c;
  cc  = csq*c;
  // Thank you maxima:
  b3d = (b3*c^3-b2*c^2+b1*c-b0)/d;
  b2d = (-3*b3*c^3+b2*c^2+b1*c-3*b0)/d;
  b1d = (3*b3*c^3+b2*c^2-b1*c-3*b0)/d;
  b0d = (-b3*c^3-b2*c^2-b1*c-b0)/d;
  a3d = (a3*c^3-a2*c^2+a1*c-a0)/d;
  a2d = (-3*a3*c^3+a2*c^2+a1*c-3*a0)/d;
  a1d = (3*a3*c^3+a2*c^2-a1*c-3*a0)/d;
  d = (-a3*c^3-a2*c^2-a1*c-a0);
};

//-----------------------------`(fi.)tf1s`--------------------------------
// First-order direct-form digital filter,
// specified by ANALOG transfer-function polynomials B(s)/A(s),
// and a frequency-scaling parameter.
//
// #### Usage
//
// ```
// _ : tf1s(b1,b0,a0,w1) : _
// ```
// Where:
//
//        b1 s + b0
// H(s) = ----------
//           s + a0
//
// and `w1` is the desired digital frequency (in radians/second)
// corresponding to analog frequency 1 rad/sec (i.e., `s = j`).
//
// #### Example
// A first-order ANALOG Butterworth lowpass filter,
// normalized to have cutoff frequency at 1 rad/sec,
// has transfer function:
//
//           1
// H(s) = -------
//         s + 1
//
// so `b0 = a0 = 1` and `b1 = 0`.  Therefore, a DIGITAL first-order
// Butterworth lowpass with gain -3dB at `SR/4` is specified as
//
// ```
// tf1s(0,1,1,PI*SR/2); // digital half-band order 1 Butterworth
// ```
//
// #### Method
//
// Bilinear transform scaled for exact mapping of w1.
//
// #### Reference
// <https://ccrma.stanford.edu/~jos/pasp/Bilinear_Transformation.html>
//----------------------------------------------
declare tf1s author "Julius O. Smith III";
declare tf1s copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare tf1s license "MIT-style STK-4.3 license";
tf1s(b1,b0,a0,w1) = tf1(b0d,b1d,a1d)
with {
  c   = 1/tan(w1*0.5/ma.SR); // bilinear-transform scale-factor
  d   = a0 + c;
  b1d = (b0 - b1*c) / d;
  b0d = (b0 + b1*c) / d;
  a1d = (a0 - c) / d;
};

//-----------------------------`(fi.)tf2sb`--------------------------------
// Bandpass mapping of `tf2s`: In addition to a frequency-scaling parameter
// `w1` (set to HALF the desired passband width in rad/sec),
// there is a desired center-frequency parameter wc (also in rad/s).
// Thus, `tf2sb` implements a fourth-order digital bandpass filter section
// specified by the coefficients of a second-order analog lowpass prototype
// section.  Such sections can be combined in series for higher orders.
// The order of mappings is (1) frequency scaling (to set lowpass cutoff w1),
// (2) bandpass mapping to wc, then (3) the bilinear transform, with the
// usual scale parameter `2*SR`.  Algebra carried out in maxima and pasted here.
//
// #### Usage
//
// ```
// _ : tf2sb(b2,b1,b0,a1,a0,w1,wc) : _
// ```
//----------------------------------------------
declare tf2sb author "Julius O. Smith III";
declare tf2sb copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare tf2sb license "MIT-style STK-4.3 license";
tf2sb(b2,b1,b0,a1,a0,w1,wc) =
  iir((b0d/a0d,b1d/a0d,b2d/a0d,b3d/a0d,b4d/a0d),(a1d/a0d,a2d/a0d,a3d/a0d,a4d/a0d)) with {
  T = 1.0/float(ma.SR);
  b0d = (4*b0*w1^2+8*b2*wc^2)*T^2+8*b1*w1*T+16*b2;
  b1d = 4*b2*wc^4*T^4+4*b1*wc^2*w1*T^3-16*b1*w1*T-64*b2;
  b2d = 6*b2*wc^4*T^4+(-8*b0*w1^2-16*b2*wc^2)*T^2+96*b2;
  b3d = 4*b2*wc^4*T^4-4*b1*wc^2*w1*T^3+16*b1*w1*T-64*b2;
  b4d = (b2*wc^4*T^4-2*b1*wc^2*w1*T^3+(4*b0*w1^2+8*b2*wc^2)*T^2-8*b1*w1*T+16*b2)
        + b2*wc^4*T^4+2*b1*wc^2*w1*T^3;
  a0d = wc^4*T^4+2*a1*wc^2*w1*T^3+(4*a0*w1^2+8*wc^2)*T^2+8*a1*w1*T+16;
  a1d = 4*wc^4*T^4+4*a1*wc^2*w1*T^3-16*a1*w1*T-64;
  a2d = 6*wc^4*T^4+(-8*a0*w1^2-16*wc^2)*T^2+96;
  a3d = 4*wc^4*T^4-4*a1*wc^2*w1*T^3+16*a1*w1*T-64;
  a4d = wc^4*T^4-2*a1*wc^2*w1*T^3+(4*a0*w1^2+8*wc^2)*T^2-8*a1*w1*T+16;
};

//-----------------------------`(fi.)tf1sb`--------------------------------
// First-to-second-order lowpass-to-bandpass section mapping,
// analogous to tf2sb above.
//
// #### Usage
//
// ```
// _ : tf1sb(b1,b0,a0,w1,wc) : _
// ```
//----------------------------------------------
declare tf1sb author "Julius O. Smith III";
declare tf1sb copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare tf1sb license "MIT-style STK-4.3 license";
tf1sb(b1,b0,a0,w1,wc) = tf2(b0d/a0d,b1d/a0d,b2d/a0d,a1d/a0d,a2d/a0d) with {
  T = 1.0/float(ma.SR);
  a0d = wc^2*T^2+2*a0*w1*T+4;
  b0d = b1*wc^2*T^2 +2*b0*w1*T+4*b1;
  b1d = 2*b1*wc^2*T^2-8*b1;
  b2d = b1*wc^2*T^2-2*b0*w1*T+4*b1;
  a1d = 2*wc^2*T^2-8;
  a2d = wc^2*T^2-2*a0*w1*T+4;
};

//==============================Simple Resonator Filters==================================
//========================================================================================

//------------------`(fi.)resonlp`-----------------
// Simple resonant lowpass filter based on `tf2s` (virtual analog).
// `resonlp` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : resonlp(fc,Q,gain) : _
// _ : resonhp(fc,Q,gain) : _
// _ : resonbp(fc,Q,gain) : _
//
// ```
//
// Where:
//
// * `fc`: center frequency (Hz)
// * `Q`: q
// * `gain`: gain (0-1)
//---------------------------------------------------------------------
// resonlp = 2nd-order lowpass with corner resonance:
declare resonlp author "Julius O. Smith III";
declare resonlp copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare resonlp license "MIT-style STK-4.3 license";
resonlp(fc,Q,gain) = tf2s(b2,b1,b0,a1,a0,wc)
with {
     wc = 2*ma.PI*fc;
     a1 = 1/Q;
     a0 = 1;
     b2 = 0;
     b1 = 0;
     b0 = gain;
};


//------------------`(fi.)resonhp`-----------------
// Simple resonant highpass filters based on `tf2s` (virtual analog).
// `resonhp` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : resonlp(fc,Q,gain) : _
// _ : resonhp(fc,Q,gain) : _
// _ : resonbp(fc,Q,gain) : _
//
// ```
//
// Where:
//
// * `fc`: center frequency (Hz)
// * `Q`: q
// * `gain`: gain (0-1)
//---------------------------------------------------------------------
// resonhp = 2nd-order highpass with corner resonance:
declare resonhp author "Julius O. Smith III";
declare resonhp copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare resonhp license "MIT-style STK-4.3 license";
resonhp(fc,Q,gain,x) = gain*x-resonlp(fc,Q,gain,x);


//------------------`(fi.)resonbp`-----------------
// Simple resonant bandpass filters based on `tf2s` (virtual analog).
// `resonbp` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : resonlp(fc,Q,gain) : _
// _ : resonhp(fc,Q,gain) : _
// _ : resonbp(fc,Q,gain) : _
//
// ```
//
// Where:
//
// * `fc`: center frequency (Hz)
// * `Q`: q
// * `gain`: gain (0-1)
//---------------------------------------------------------------------
// resonbp = 2nd-order bandpass
declare resonbp author "Julius O. Smith III";
declare resonbp copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare resonbp license "MIT-style STK-4.3 license";
resonbp(fc,Q,gain) = tf2s(b2,b1,b0,a1,a0,wc)
with {
     wc = 2*ma.PI*fc;
     a1 = 1/Q;
     a0 = 1;
     b2 = 0;
     b1 = gain;
     b0 = 0;
};


//======================Butterworth Lowpass/Highpass Filters==============================
//========================================================================================

//----------------`(fi.)lowpass`--------------------
// Nth-order Butterworth lowpass filter.
// `lowpass` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : lowpass(N,fc) : _
// ```
//
// Where:
//
// * `N`: filter order (number of poles) [nonnegative constant numerical expression]
// * `fc`: desired cut-off frequency (-3dB frequency) in Hz
//
// #### References
// * <https://ccrma.stanford.edu/~jos/filters/Butterworth_Lowpass_Design.html>
// * `butter` function in Octave `("[z,p,g] = butter(N,1,'s');")`
//------------------------------
declare lowpass author "Julius O. Smith III";
declare lowpass copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare lowpass license "MIT-style STK-4.3 license";
lowpass(N,fc) = lowpass0_highpass1(0,N,fc);


//----------------`(fi.)highpass`--------------------
// Nth-order Butterworth highpass filters.
// `highpass` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : highpass(N,fc) : _
// ```
//
// Where:
//
// * `N`: filter order (number of poles) [nonnegative constant numerical expression]
// * `fc`: desired cut-off frequency (-3dB frequency) in Hz
//
// #### References
// * <https://ccrma.stanford.edu/~jos/filters/Butterworth_Lowpass_Design.html>
// * `butter` function in Octave `("[z,p,g] = butter(N,1,'s');")`
//------------------------------
declare highpass author "Julius O. Smith III";
declare highpass copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare higpass license "MIT-style STK-4.3 license";
highpass(N,fc) = lowpass0_highpass1(1,N,fc);


//-------------`(fi.)lowpass0_highpass1`--------------
declare lowpass0_highpass1 author "Julius O. Smith III";
declare lowpass0_highpass1 "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare lowpass0_highpass1 "MIT-style STK-4.3 license";
lowpass0_highpass1(s,N,fc) = lphpr(s,N,N,fc)
with {
  lphpr(s,0,N,fc) = _;
  lphpr(s,1,N,fc) = tf1s(s,1-s,1,2*ma.PI*fc);
  lphpr(s,O,N,fc) = lphpr(s,(O-2),N,fc) : tf2s(s,0,1-s,a1s,1,w1) with {
    parity = N % 2;
    S = (O-parity)/2; // current section number
    a1s = -2*cos((ma.PI)*-1 + (1-parity)*ma.PI/(2*N) + (S-1+parity)*ma.PI/N);
    w1 = 2*ma.PI*fc;
  };
};


//================Special Filter-Bank Delay-Equalizing Allpass Filters====================
// These special allpass filters are needed by filterbank et al. below.
// They are equivalent to (`lowpass(N,fc)` +|- `highpass(N,fc))/2`, but with
// canceling pole-zero pairs removed (which occurs for odd N).
//========================================================================================

//--------------------`(fi.)lowpass_plus`|`minus_highpass`----------------
declare highpass_plus_lowpass author "Julius O. Smith III";
declare highpass_plus_lowpass copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare highpass_plus_lowpass license "MIT-style STK-4.3 license";
highpass_plus_lowpass(1,fc) = _;
highpass_plus_lowpass(3,fc) = tf2s(1,-1,1,1,1,w1) with { w1 = 2*ma.PI*fc; };
highpass_plus_lowpass(5,fc) = tf2s(1,-a11,1,a11,1,w1)
with {
  a11 = 1.618033988749895;
  w1 = 2*ma.PI*fc;
};

// Catch-all definitions for generality - even order is done:
highpass_plus_lowpass(N,fc) = _ <: switch_odd_even(N%2,N,fc) with {
  switch_odd_even(0,N,fc) = highpass_plus_lowpass_even(N,fc);
  switch_odd_even(1,N,fc) = highpass_plus_lowpass_odd(N,fc);
};

declare highpass_minus_lowpass author "Julius O. Smith III";
declare highpass_minus_lowpass copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare highpass_minus_lowpass license "MIT-style STK-4.3 license";
highpass_minus_lowpass(3,fc) = tf1s(-1,1,1,w1) with { w1 = 2*ma.PI*fc; };
highpass_minus_lowpass(5,fc) = tf1s(1,-1,1,w1) : tf2s(1,-a12,1,a12,1,w1)
with {
  a12 = 0.618033988749895;
  w1 = 2*ma.PI*fc;
};

// Catch-all definitions for generality - even order is done:
highpass_minus_lowpass(N,fc) = _ <: switch_odd_even(N%2,N,fc) with {
  switch_odd_even(0,N,fc) = highpass_minus_lowpass_even(N,fc);
  switch_odd_even(1,N,fc) = highpass_minus_lowpass_odd(N,fc);
};

declare highpass_plus_lowpass_even author "Julius O. Smith III";
declare highpass_plus_lowpass_even copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare highpass_plus_lowpass_even license "MIT-style STK-4.3 license";
highpass_plus_lowpass_even(N,fc) = highpass(N,fc) + lowpass(N,fc);

declare highpass_minus_lowpass_even author "Julius O. Smith III";
declare highpass_minus_lowpass_even copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare highpass_plus_lowpass_even license "MIT-style STK-4.3 license";
highpass_minus_lowpass_even(N,fc) = highpass(N,fc) - lowpass(N,fc);

declare highpass_plus_lowpass_odd author "Julius O. Smith III";
declare highpass_plus_lowpass_odd copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare highpass_plus_lowpass_odd license "MIT-style STK-4.3 license";
// FIXME: Rewrite the following, as for orders 3 and 5 above,
//        to eliminate pole-zero cancellations:
highpass_plus_lowpass_odd(N,fc) = highpass(N,fc) + lowpass(N,fc);

declare highpass_minus_lowpass_odd author "Julius O. Smith III";
declare highpass_minus_lowpass_odd copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare highpass_plus_lowpass_odd license "MIT-style STK-4.3 license";
// FIXME: Rewrite the following, as for orders 3 and 5 above,
//        to eliminate pole-zero cancellations:
highpass_minus_lowpass_odd(N,fc) = highpass(N,fc) - lowpass(N,fc);


//==========================Elliptic (Cauer) Lowpass Filters==============================
// Elliptic (Cauer) Lowpass Filters
//
// #### References
// * <http://en.wikipedia.org/wiki/Elliptic_filter>
// * functions `ncauer` and `ellip` in Octave.
//========================================================================================

//-----------------------------`(fi.)lowpass3e`-----------------------------
// Third-order Elliptic (Cauer) lowpass filter.
//
// #### Usage
//
// ```
// _ : lowpass3e(fc) : _
// ```
//
// Where:
//
// * `fc`: -3dB frequency in Hz
//
// #### Design
//
// For spectral band-slice level display (see `octave_analyzer3e`):
//
// ```
// [z,p,g] = ncauer(Rp,Rs,3);  % analog zeros, poles, and gain, where
// Rp = 60  % dB ripple in stopband
// Rs = 0.2 % dB ripple in passband
// ```
//---------------------------------------------------------------------
declare lowpass3e author "Julius O. Smith III";
declare lowpass3e copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare lowpass3e license "MIT-style STK-4.3 license";
lowpass3e(fc) = tf2s(b21,b11,b01,a11,a01,w1) : tf1s(0,1,a02,w1)
with {
  a11 = 0.802636764161030; // format long; poly(p(1:2)) % in octave
  a01 = 1.412270893774204;
  a02 = 0.822445908998816; // poly(p(3)) % in octave
  b21 = 0.019809144837789; // poly(z)
  b11 = 0;
  b01 = 1.161516418982696;
  w1 = 2*ma.PI*fc;
};

//-----------------------------`(fi.)lowpass6e`-----------------------------
// Sixth-order Elliptic/Cauer lowpass filter.
//
// #### Usage
//
// ```
// _ : lowpass6e(fc) : _
// ```
//
// Where:
//
// * `fc`: -3dB frequency in Hz
//
// #### Design
//
// For spectral band-slice level display (see octave_analyzer6e):
//
// ```
// [z,p,g] = ncauer(Rp,Rs,6);  % analog zeros, poles, and gain, where
//  Rp = 80  % dB ripple in stopband
//  Rs = 0.2 % dB ripple in passband
// ```
//----------------------------------------------------------------------
declare lowpass6e author "Julius O. Smith III";
declare lowpass6e copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare lowpass6e license "MIT-style STK-4.3 license";
lowpass6e(fc) =
              tf2s(b21,b11,b01,a11,a01,w1) :
              tf2s(b22,b12,b02,a12,a02,w1) :
              tf2s(b23,b13,b03,a13,a03,w1)
with {
  b21 = 0.000099999997055;
  a21 = 1;
  b11 = 0;
  a11 = 0.782413046821645;
  b01 = 0.000433227200555;
  a01 = 0.245291508706160;
  b22 = 1;
  a22 = 1;
  b12 = 0;
  a12 = 0.512478641889141;
  b02 = 7.621731298870603;
  a02 = 0.689621364484675;
  b23 = 1;
  a23 = 1;
  b13 = 0;
  a13 = 0.168404871113589;
  b03 = 53.536152954556727;
  a03 = 1.069358407707312;
  w1 = 2*ma.PI*fc;
};


//=========================Elliptic Highpass Filters======================================
//========================================================================================

//-----------------------------`(fi.)highpass3e`-----------------------------
// Third-order Elliptic (Cauer) highpass filter. Inversion of `lowpass3e` wrt unit
// circle in s plane (s <- 1/s).
//
// #### Usage
//
// ```
// _ : highpass3e(fc) : _
// ```
//
// Where:
//
// * `fc`: -3dB frequency in Hz
//-------------------------------------------------------------------------
declare highpass3e author "Julius O. Smith III";
declare highpass3e copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare highpass3e license "MIT-style STK-4.3 license";
highpass3e(fc) = tf2s(b01/a01,b11/a01,b21/a01,a11/a01,1/a01,w1) :
                 tf1s(1/a02,0,1/a02,w1)
with {
  a11 = 0.802636764161030;
  a01 = 1.412270893774204;
  a02 = 0.822445908998816;
  b21 = 0.019809144837789;
  b11 = 0;
  b01 = 1.161516418982696;
  w1 = 2*ma.PI*fc;
};

//-----------------------------`(fi.)highpass6e`-----------------------------
// Sixth-order Elliptic/Cauer highpass filter. Inversion of lowpass3e wrt unit
// circle in s plane (s <- 1/s).
//
// #### Usage
//
// ```
// _ : highpass6e(fc) : _
// ```
//
// Where:
//
// * `fc`: -3dB frequency in Hz
//-------------------------------------------------------------------------
declare highpass6e author "Julius O. Smith III";
declare highpass6e copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare highpass6e license "MIT-style STK-4.3 license";
highpass6e(fc) =
              tf2s(b01/a01,b11/a01,b21/a01,a11/a01,1/a01,w1) :
              tf2s(b02/a02,b12/a02,b22/a02,a12/a02,1/a02,w1) :
              tf2s(b03/a03,b13/a03,b23/a03,a13/a03,1/a03,w1)
with {
  b21 = 0.000099999997055;
  a21 = 1;
  b11 = 0;
  a11 = 0.782413046821645;
  b01 = 0.000433227200555;
  a01 = 0.245291508706160;
  b22 = 1;
  a22 = 1;
  b12 = 0;
  a12 = 0.512478641889141;
  b02 = 7.621731298870603;
  a02 = 0.689621364484675;
  b23 = 1;
  a23 = 1;
  b13 = 0;
  a13 = 0.168404871113589;
  b03 = 53.536152954556727;
  a03 = 1.069358407707312;
  w1 = 2*ma.PI*fc;
};


//========================Butterworth Bandpass/Bandstop Filters===========================
//========================================================================================

//--------------------`(fi.)bandpass`----------------
// Order 2*Nh Butterworth bandpass filter made using the transformation
// `s <- s + wc^2/s` on `lowpass(Nh)`, where `wc` is the desired bandpass center
// frequency.  The `lowpass(Nh)` cutoff `w1` is half the desired bandpass width.
// `bandpass` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : bandpass(Nh,fl,fu) : _
// ```
//
// Where:
//
// * `Nh`: HALF the desired bandpass order (which is therefore even)
// * `fl`: lower -3dB frequency in Hz
// * `fu`: upper -3dB frequency in Hz
// Thus, the passband width is `fu-fl`,
//       and its center frequency is `(fl+fu)/2`.
//
// #### Reference
// <http://cnx.org/content/m16913/latest/>
//-------------------------------------------------------------------------
declare bandpass author "Julius O. Smith III";
declare bandpass copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare bandpass license "MIT-style STK-4.3 license";
bandpass(Nh,fl,fu) = bandpass0_bandstop1(0,Nh,fl,fu);


//--------------------`(fi.)bandstop`----------------
// Order 2*Nh Butterworth bandstop filter made using the transformation
// `s <- s + wc^2/s` on `highpass(Nh)`, where `wc` is the desired bandpass center
// frequency.  The `highpass(Nh)` cutoff `w1` is half the desired bandpass width.
// `bandstop` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : bandstop(Nh,fl,fu) : _
// ```
// Where:
//
// * `Nh`: HALF the desired bandstop order (which is therefore even)
// * `fl`: lower -3dB frequency in Hz
// * `fu`: upper -3dB frequency in Hz
// Thus, the passband (stopband) width is `fu-fl`,
//       and its center frequency is `(fl+fu)/2`.
//
// #### Reference
// <http://cnx.org/content/m16913/latest/>
//-------------------------------------------------------------------------
declare bandstop author "Julius O. Smith III";
declare bandstop copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare bandstop license "MIT-style STK-4.3 license";
bandstop(Nh,fl,fu) = bandpass0_bandstop1(1,Nh,fl,fu);

declare bandpass0_bandstop1 author "Julius O. Smith III";
declare bandpass0_bandstop1 copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare bandpass0_bandstop1 license "MIT-style STK-4.3 license";
bandpass0_bandstop1(s,Nh,fl,fu) = bpbsr(s,Nh,Nh,fl,fu)
with {
  wl = 2*ma.PI*fl; // digital (z-plane) lower passband edge
  wu = 2*ma.PI*fu; // digital (z-plane) upper passband edge

  c = 2.0*ma.SR; // bilinear transform scaling used in tf2sb, tf1sb
  wla = c*tan(wl/c); // analog (s-plane) lower cutoff
  wua = c*tan(wu/c); // analog (s-plane) upper cutoff

  wc = sqrt(wla*wua); // s-plane center frequency
  w1 = wua - wc^2/wua; // s-plane lowpass prototype cutoff

  bpbsr(s,0,Nh,fl,fu) = _;
  bpbsr(s,1,Nh,fl,fu) = tf1sb(s,1-s,1,w1,wc);
  bpbsr(s,O,Nh,fl,fu) = bpbsr(s,O-2,Nh,fl,fu) : tf2sb(s,0,(1-s),a1s,1,w1,wc)
  with {
    parity = Nh % 2;
    S = (O-parity)/2; // current section number
    a1s = -2*cos(-1*ma.PI + (1-parity)*ma.PI/(2*Nh) + (S-1+parity)*ma.PI/Nh);
  };
};


//===========================Elliptic Bandpass Filters====================================
//========================================================================================

//---------------------`(fi.)bandpass6e`-----------------------------
// Order 12 elliptic bandpass filter analogous to `bandpass(6)`.
//--------------------------------------------------------------
declare bandpass6e author "Julius O. Smith III";
declare bandpass6e copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare bandpass6e license "MIT-style STK-4.3 license";
bandpass6e(fl,fu) = tf2sb(b21,b11,b01,a11,a01,w1,wc) : tf1sb(0,1,a02,w1,wc)
with {
  a11 = 0.802636764161030; // In octave: format long; poly(p(1:2))
  a01 = 1.412270893774204;
  a02 = 0.822445908998816; // poly(p(3))
  b21 = 0.019809144837789; // poly(z)
  b11 = 0;
  b01 = 1.161516418982696;

  wl = 2*ma.PI*fl; // digital (z-plane) lower passband edge
  wu = 2*ma.PI*fu; // digital (z-plane) upper passband edge

  c = 2.0*ma.SR; // bilinear transform scaling used in tf2sb, tf1sb
  wla = c*tan(wl/c); // analog (s-plane) lower cutoff
  wua = c*tan(wu/c); // analog (s-plane) upper cutoff

  wc = sqrt(wla*wua); // s-plane center frequency
  w1 = wua - wc^2/wua; // s-plane lowpass cutoff
};

//----------------------`(fi.)bandpass12e`---------------------------
// Order 24 elliptic bandpass filter analogous to `bandpass(6)`.
//--------------------------------------------------------------
declare bandpass12e author "Julius O. Smith III";
declare bandpass12e copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare bandpass12e license "MIT-style STK-4.3 license";
bandpass12e(fl,fu) =
              tf2sb(b21,b11,b01,a11,a01,w1,wc) :
              tf2sb(b22,b12,b02,a12,a02,w1,wc) :
              tf2sb(b23,b13,b03,a13,a03,w1,wc)
with { // octave script output:
  b21 = 0.000099999997055;
  a21 = 1;
  b11 = 0;
  a11 = 0.782413046821645;
  b01 = 0.000433227200555;
  a01 = 0.245291508706160;
  b22 = 1;
  a22 = 1;
  b12 = 0;
  a12 = 0.512478641889141;
  b02 = 7.621731298870603;
  a02 = 0.689621364484675;
  b23 = 1;
  a23 = 1;
  b13 = 0;
  a13 = 0.168404871113589;
  b03 = 53.536152954556727;
  a03 = 1.069358407707312;

  wl = 2*ma.PI*fl; // digital (z-plane) lower passband edge
  wu = 2*ma.PI*fu; // digital (z-plane) upper passband edge

  c = 2.0*ma.SR; // bilinear transform scaling used in tf2sb, tf1sb
  wla = c*tan(wl/c); // analog (s-plane) lower cutoff
  wua = c*tan(wu/c); // analog (s-plane) upper cutoff

  wc = sqrt(wla*wua); // s-plane center frequency
  w1 = wua - wc^2/wua; // s-plane lowpass cutoff
};

//------------------------`(fi.)pospass`---------------------------
// Positive-Pass Filter (single-side-band filter).
//
// #### Usage
//
// ```
// _ : pospass(N,fc) : _,_
// ```
//
// where
//
// * `N`: filter order (Butterworth bandpass for positive frequencies).
// * `fc`: lower bandpass cutoff frequency in Hz.
//   - Highpass cutoff frequency at ma.SR/2 - fc Hz.
//
// #### Example
//
// * See dm.pospass_demo
// * Look at frequency response
//
// #### Method
//
// A filter passing only positive frequencies can be made from a
// half-band lowpass by modulating it up to the positive-frequency range.
// Equivalently, down-modulate the input signal using a complex sinusoid at -SR/4 Hz,
// lowpass it with a half-band filter, and modulate back up by SR/4 Hz.
// In Faust/math notation:
// pospass(N) = \(\ast(e^{-j\frac{\pi}{2}n}) : \mbox{lowpass(N,SR/4)} : \ast(e^{j\frac{\pi}{2}n})\)
//
// An approximation to the Hilbert transform is given by the
// imaginary output signal:
//
// ```
// hilbert(N) = pospass(N) : !,*(2);
// ```
//
// #### References
// * <https://ccrma.stanford.edu/~jos/mdft/Analytic_Signals_Hilbert_Transform.html>
// * <https://ccrma.stanford.edu/~jos/sasp/Comparison_Optimal_Chebyshev_FIR_I.html>
// * <https://ccrma.stanford.edu/~jos/sasp/Hilbert_Transform.html>
//------------------------------------------------------------
declare pospass author "Julius O. Smith III";
declare pospass copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare pospass license "MIT-style STK-4.3 license";
pospass(N,fc) = fi.pospass0(lpf) with {
  fcs = ma.SR/4 - fc; // Upper lowpass cutoff = (SR/2 - fc) - SR/4
  lpf = fi.lowpass(N,fcs); // Butterworth lowpass
};

declare pospass6e author "Julius O. Smith III";
declare pospass6e copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare pospass6e license "MIT-style STK-4.3 license";
pospass6e(fc) = fi.pospass0(lpf) with {
  lpf = fi.lowpass6e(ma.SR/4 - fc); // Elliptic lowpass, order 6
};

declare pospass0 author "Julius O. Smith III";
declare pospass0 copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare pospass0 license "MIT-style STK-4.3 license";
pospass0(lpf) = unmodulate : lpf, lpf : modulate with {
  c = 1-1' : +~(*(-1):mem); // complex sinusoid rotating at SR/4
  s = c'; // ||: 0, 1, 0, -1 :||
  unmodulate = _ <: *(c),*(-s); // subtract SR/4 from all input frequencies
  modulate(x,y) = c*x-s*y, c*y + s*x; // add SR/4 to all frequencies
};


//=================Parametric Equalizers (Shelf, Peaking)=================================
// Parametric Equalizers (Shelf, Peaking).
//
// #### References
// * <http://en.wikipedia.org/wiki/Equalization>
// * <https://webaudio.github.io/Audio-EQ-Cookbook/Audio-EQ-Cookbook.txt>
// * Digital Audio Signal Processing, Udo Zolzer, Wiley, 1999, p. 124
// * <https://ccrma.stanford.edu/~jos/filters/Low_High_Shelving_Filters.html>
// * <https://ccrma.stanford.edu/~jos/filters/Peaking_Equalizers.html>
// * maxmsp.lib in the Faust distribution
// * bandfilter.dsp in the faust2pd distribution
//========================================================================================

//----------------------`(fi.)low_shelf`----------------------
// First-order "low shelf" filter (gain boost|cut between dc and some frequency)
// `low_shelf` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : lowshelf(N,L0,fx) : _
// _ : low_shelf(L0,fx) : _ // default case (order 3)
// _ : lowshelf_other_freq(N,L0,fx) : _
// ```
//
// Where:
// * `N`: filter order 1, 3, 5, ... (odd only, default should be 3, a constant numerical expression)
// * `L0`: desired level (dB) between dc and fx (boost `L0>0` or cut `L0<0`)
// * `fx`: -3dB frequency of lowpass band (`L0>0`) or upper band (`L0<0`)
//       (see "SHELF SHAPE" below).
//
// The gain at SR/2 is constrained to be 1.
// The generalization to arbitrary odd orders is based on the well known
// fact that odd-order Butterworth band-splits are allpass-complementary
// (see filterbank documentation below for references).
//
// #### Shelf Shape
// The magnitude frequency response is approximately piecewise-linear
// on a log-log plot ("BODE PLOT").  The Bode "stick diagram" approximation
// L(lf) is easy to state in dB versus dB-frequency lf = dB(f):
//
// * L0 > 0:
// 	* L(lf) = L0, f between 0 and fx = 1st corner frequency;
// 	* L(lf) = L0 - N * (lf - lfx), f between fx and f2 = 2nd corner frequency;
// 	* L(lf) = 0, lf > lf2.
// 	* lf2 = lfx + L0/N = dB-frequency at which level gets back to 0 dB.
// * L0 < 0:
// 	* L(lf) = L0, f between 0 and f1 = 1st corner frequency;
// 	* L(lf) = - N * (lfx - lf), f between f1 and lfx = 2nd corner frequency;
// 	* L(lf) = 0, lf > lfx.
// 	* lf1 = lfx + L0/N = dB-frequency at which level goes up from L0.
//
//  See `lowshelf_other_freq`.
//
// #### References
// See "Parametric Equalizers" above for references regarding
// `low_shelf`, `high_shelf`, and `peak_eq`.
//
//--------------------------------------------------------------
declare lowshelf author "Julius O. Smith III";
declare lowshelf copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare lowshelf license "MIT-style STK-4.3 license";
lowshelf(N,L0,fx) = filterbank(N,(fx)) : _, *(ba.db2linear(L0)) :> _;

// Special cases and optimization:
declare low_shelf author "Julius O. Smith III";
declare low_shelf copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare low_shelf license "MIT-style STK-4.3 license";
low_shelf  = lowshelf(3); // default = 3rd order Butterworth

declare low_shelf1 author "Julius O. Smith III";
declare low_shelf1 copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare low_shelf1 license "MIT-style STK-4.3 license";
low_shelf1(L0,fx,x) = x + (ba.db2linear(L0)-1)*lowpass(1,fx,x); // optimized

declare low_shelf1_l author "Julius O. Smith III";
declare low_shelf1_l copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare low_shelf1_l license "MIT-style STK-4.3 license";
low_shelf1_l(G0,fx,x) = x + (G0-1)*lowpass(1,fx,x); // optimized

declare lowshelf_other_freq author "Julius O. Smith III";
declare lowshelf_other_freq copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare lowshelf_other_freq license "MIT-style STK-4.3 license";
lowshelf_other_freq(N, L0, fx) = ba.db2linear(ba.linear2db(fx) + L0/N); // convenience

//-------------`(fi.)high_shelf`--------------
// First-order "high shelf" filter (gain boost|cut above some frequency).
// `high_shelf` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : highshelf(N,Lpi,fx) : _
// _ : high_shelf(L0,fx) : _ // default case (order 3)
// _ : highshelf_other_freq(N,Lpi,fx) : _
// ```
//
// Where:
//
// * `N`: filter order 1, 3, 5, ... (odd only, a constant numerical expression).
// * `Lpi`: desired level (dB) between fx and SR/2 (boost Lpi>0 or cut Lpi<0)
// * `fx`: -3dB frequency of highpass band (L0>0) or lower band (L0<0)
//        (Use highshelf_other_freq() below to find the other one.)
//
// The gain at dc is constrained to be 1.
// See `lowshelf` documentation above for more details on shelf shape.
//
// #### References
// See "Parametric Equalizers" above for references regarding
// `low_shelf`, `high_shelf`, and `peak_eq`.
//
//--------------------------------------------------------------
declare highshelf author "Julius O. Smith III";
declare highshelf copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare highshelf license "MIT-style STK-4.3 license";
highshelf(N,Lpi,fx) = filterbank(N,(fx)) : *(ba.db2linear(Lpi)), _ :> _;
// Special cases and optimization:
high_shelf = highshelf(3); // default = 3rd order Butterworth

declare high_shelf1 author "Julius O. Smith III";
declare high_shelf1 copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare high_shelf1 license "MIT-style STK-4.3 license";
high_shelf1(Lpi,fx,x) = x + (ba.db2linear(Lpi)-1)*highpass(1,fx,x); // optimized

declare high_shelf1_l author "Julius O. Smith III";
declare high_shelf1_l copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare high_shelf1_l license "MIT-style STK-4.3 license";
high_shelf1_l(Gpi,fx,x) = x + (Gpi-1)*highpass(1,fx,x); //optimized

// shelf transitions between frequency fx and this one:
declare highshelf_other_freq author "Julius O. Smith III";
declare highshelf_other_freq copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare highshelf_other_freq license "MIT-style STK-4.3 license";
highshelf_other_freq(N, Lpi, fx) = ba.db2linear(ba.linear2db(fx) - Lpi/N);


//-------------------`(fi.)peak_eq`------------------------------
// Second order "peaking equalizer" section (gain boost or cut near some frequency)
// Also called a "parametric equalizer" section.
// `peak_eq` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : peak_eq(Lfx,fx,B) : _
// ```
//
// Where:
//
// * `Lfx`: level (dB) at fx (boost Lfx>0 or cut Lfx<0)
// * `fx`: peak frequency (Hz)
// * `B`: bandwidth (B) of peak in Hz
//
// #### References
// See "Parametric Equalizers" above for references regarding
// `low_shelf`, `high_shelf`, and `peak_eq`.
//
//--------------------------------------------------------------
declare peak_eq author "Julius O. Smith III";
declare peak_eq copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare peak_eq license "MIT-style STK-4.3 license";
peak_eq(Lfx,fx,B) = tf2s(1,b1s,1,a1s,1,wx) with {
  T = float(1.0/ma.SR);
  Bw = B*T/sin(wx*T); // prewarp s-bandwidth for more accuracy in z-plane
  a1 = ma.PI*Bw;
  b1 = g*a1;
  g = ba.db2linear(abs(Lfx));
  b1s = select2(Lfx>0,a1,b1); // When Lfx>0, pole dominates bandwidth
  a1s = select2(Lfx>0,b1,a1); // When Lfx<0, zero dominates
  wx = 2*ma.PI*fx;
};

//--------------------`(fi.)peak_eq_cq`----------------------------
// Constant-Q second order peaking equalizer section.
//
// #### Usage
//
// ```
// _ : peak_eq_cq(Lfx,fx,Q) : _
// ```
//
// Where:
//
// * `Lfx`: level (dB) at fx
// * `fx`: boost or cut frequency (Hz)
// * `Q`: "Quality factor" = fx/B where B = bandwidth of peak in Hz
//
// #### References
// See "Parametric Equalizers" above for references regarding
// `low_shelf`, `high_shelf`, and `peak_eq`.
//
//------------------------------------------------------------
declare peak_eq_cq author "Julius O. Smith III";
declare peak_eq_cq copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare peak_eq_cq license "MIT-style STK-4.3 license";
peak_eq_cq(Lfx,fx,Q) = peak_eq(Lfx,fx,fx/Q);

//-------------------`(fi.)peak_eq_rm`--------------------------
// Regalia-Mitra second order peaking equalizer section.
//
// #### Usage
//
// ```
// _ : peak_eq_rm(Lfx,fx,tanPiBT) : _
// ```
//
// Where:
//
// * `Lfx`: level (dB) at fx
// * `fx`: boost or cut frequency (Hz)
// * `tanPiBT`: `tan(PI*B/SR)`, where B = -3dB bandwidth (Hz) when 10^(Lfx/20) = 0
//         ~ PI*B/SR for narrow bandwidths B
//
// #### Reference
// P.A. Regalia, S.K. Mitra, and P.P. Vaidyanathan,
// "The Digital All-Pass Filter: A Versatile Signal Processing Building Block"
// Proceedings of the IEEE, 76(1):19-37, Jan. 1988.  (See pp. 29-30.)
// See also "Parametric Equalizers" above for references on shelf
// and peaking equalizers in general.
//
//------------------------------------------------------------
declare peak_eq_rm author "Julius O. Smith III";
declare peak_eq_rm copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare peak_eq_rm license "MIT-style STK-4.3 license";
peak_eq_rm(Lfx,fx,tanPiBT) = _ <: _,A,_ : +,- : *(0.5),*(K/2.0) : + with {
  A = tf2(k2, k1*(1+k2), 1, k1*(1+k2), k2) <: _,_; // allpass
  k1 = 0.0 - cos(2.0*ma.PI*fx/ma.SR);
  k2 = (1.0 - tanPiBT)/(1.0 + tanPiBT);
  K = ba.db2linear(Lfx);
};


//---------------------`(fi.)spectral_tilt`-------------------------
// Spectral tilt filter, providing an arbitrary spectral rolloff factor
// alpha in (-1,1), where
//  -1 corresponds to one pole (-6 dB per octave), and
//  +1 corresponds to one zero (+6 dB per octave).
// In other words, alpha is the slope of the ln magnitude versus ln frequency.
// For a "pinking filter" (e.g., to generate 1/f noise from white noise),
// set alpha to -1/2.
//
// #### Usage
//
// ```
// _ : spectral_tilt(N,f0,bw,alpha) : _
// ```
// Where:
//
// * `N`: desired integer filter order (fixed at compile time)
// * `f0`: lower frequency limit for desired roll-off band > 0
// * `bw`: bandwidth of desired roll-off band
// * `alpha`: slope of roll-off desired in nepers per neper,
//         between -1 and 1 (ln mag / ln radian freq)
//
// #### Examples
// See `dm.spectral_tilt_demo` and the documentation for `no.pink_noise`.
//
// #### Reference
// J.O. Smith and H.F. Smith,
// "Closed Form Fractional Integration and Differentiation via Real Exponentially Spaced Pole-Zero Pairs",
// arXiv.org publication arXiv:1606.06154 [cs.CE], June 7, 2016,
// <http://arxiv.org/abs/1606.06154>
//
//------------------------------------------------------------
declare spectral_tilt author "Julius O. Smith III";
declare spectral_tilt copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare spectral_tilt license "MIT-style STK-4.3 license";
spectral_tilt(N,f0,bw,alpha) = seq(i,N,sec(i)) with {
  sec(i) = g * tf1s(b1,b0,a0,1) with {
    g = a0/b0; // unity dc-gain scaling
    b1 = 1.0;
    b0 = mzh(i);
    a0 = mph(i);
    mzh(i) = prewarp(mz(i),ma.SR,w0); // prewarping for bilinear transform
    mph(i) = prewarp(mp(i),ma.SR,w0);
    prewarp(w,SR,wp) = wp * tan(w*T/2) / tan(wp*T/2) with { T = 1/ma.SR; };
    mz(i) = w0 * r ^ (-alpha+i); // minus zero i in s plane
    mp(i) = w0 * r ^ i; // minus pole i in s plane
    f0p = max(f0,ma.EPSILON); // cannot go to zero
    w0 = 2 * ma.PI * f0p; // radian frequency of first pole
    f1 = f0p + bw; // upper band limit
    r = (f1/f0p)^(1.0/float(N-1)); // pole ratio (2 => octave spacing)
  };
};


//----------------------`(fi.)levelfilter`----------------------
// Dynamic level lowpass filter.
// `levelfilter` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : levelfilter(L,freq) : _
// ```
//
// Where:
//
// * `L`: desired level (in dB) at Nyquist limit (SR/2), e.g., -60
// * `freq`: corner frequency (-3dB point) usually set to fundamental freq
// * `N`: Number of filters in series where L = L/N
//
// #### Reference
// <https://ccrma.stanford.edu/realsimple/faust_strings/Dynamic_Level_Lowpass_Filter.html>
//------------------------------------------------------------
declare levelfilter author "Julius O. Smith III";
declare levelfilter copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare levelfilter license "MIT-style STK-4.3 license";
levelfilter(L,freq,x) = (L * L0 * x) + ((1.0-L) * lp2out(x))
with {
  L0 = pow(L,1/3);
  Lw = ma.PI*freq/ma.SR; // = w1 T / 2
  Lgain = Lw / (1.0 + Lw);
  Lpole2 = (1.0 - Lw) / (1.0 + Lw);
  lp2out = *(Lgain) : + ~ *(Lpole2);
};


//----------------------`(fi.)levelfilterN`----------------------
// Dynamic level lowpass filter.
//
// #### Usage
//
// ```
// _ : levelfilterN(N,freq,L) : _
// ```
//
// Where:
//
// * `N`: Number of filters in series where L = L/N, a constant numerical expression
// * `freq`: corner frequency (-3dB point) usually set to fundamental freq
// * `L`: desired level (in dB) at Nyquist limit (SR/2), e.g., -60
//
// #### Reference
// <https://ccrma.stanford.edu/realsimple/faust_strings/Dynamic_Level_Lowpass_Filter.html>
//------------------------------------------------------------
declare levelfilterN author "Julius O. Smith III";
declare levelfilterN copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare levelfilterN license "MIT-style STK-4.3 license";
levelfilterN(N,freq,L) = seq(i,N,levelfilter((L/N),freq));


//=================================Mth-Octave Filter-Banks================================
// Mth-octave filter-banks split the input signal into a bank of parallel signals, one
// for each spectral band. They are related to the Mth-Octave Spectrum-Analyzers in
// `analysis.lib`.
// The documentation of this library contains more details about the implementation.
// The parameters are:
//
// * `M`: number of band-slices per octave (>1), a constant numerical expression
// * `N`: total number of bands (>2), a constant numerical expression
// * `ftop`: upper bandlimit of the Mth-octave bands (<SR/2)
//
// In addition to the Mth-octave output signals, there is a highpass signal
// containing frequencies from ftop to SR/2, and a "dc band" lowpass signal
// containing frequencies from 0 (dc) up to the start of the Mth-octave bands.
// Thus, the N output signals are
//
// ```
// highpass(ftop), MthOctaveBands(M,N-2,ftop), dcBand(ftop*2^(-M*(N-1)))
// ```
//
// A Filter-Bank is defined here as a signal bandsplitter having the
// property that summing its output signals gives an allpass-filtered
// version of the filter-bank input signal.  A more conventional term for
// this is an "allpass-complementary filter bank".  If the allpass filter
// is a pure delay (and possible scaling), the filter bank is said to be
// a "perfect-reconstruction filter bank" (see Vaidyanathan-1993 cited
// below for details).  A "graphic equalizer", in which band signals
// are scaled by gains and summed, should be based on a filter bank.
//
// The filter-banks below are implemented as Butterworth or Elliptic
// spectrum-analyzers followed by delay equalizers that make them
// allpass-complementary.
//
// #### Increasing Channel Isolation
//
// Go to higher filter orders - see Regalia et al. or Vaidyanathan (cited
// below) regarding the construction of more aggressive recursive
// filter-banks using elliptic or Chebyshev prototype filters.
//
// #### References
// * "Tree-structured complementary filter banks using all-pass sections",
//   Regalia et al., IEEE Trans. Circuits & Systems, CAS-34:1470-1484, Dec. 1987
// * "Multirate Systems and Filter Banks", P. Vaidyanathan, Prentice-Hall, 1993
// * Elementary filter theory: <https://ccrma.stanford.edu/~jos/filters/>
//========================================================================================

//------------------------`(fi.)mth_octave_filterbank[n]`-------------------------
// Allpass-complementary filter banks based on Butterworth band-splitting.
// For Butterworth band-splits, the needed delay equalizer is easily found.
//
// #### Usage
//
// ```
// _ : mth_octave_filterbank(O,M,ftop,N) : par(i,N,_)     // Oth-order
// _ : mth_octave_filterbank_alt(O,M,ftop,N) : par(i,N,_) // dc-inverted version
// ```
//
// Also for convenience:
//
// ```
// _ : mth_octave_filterbank3(M,ftop,N) : par(i,N,_) // 3rd-order Butterworth
// _ : mth_octave_filterbank5(M,ftop,N) : par(i,N,_) // 5th-order Butterworth
// mth_octave_filterbank_default = mth_octave_filterbank5;
// ```
//
// Where:
//
// * `O`: order of filter used to split each frequency band into two, a constant numerical expression
// * `M`: number of band-slices per octave, a constant numerical expression
// * `ftop`: highest band-split crossover frequency (e.g., 20 kHz)
// * `N`: total number of bands (including dc and Nyquist), a constant numerical expression
//------------------------------------------------------------
declare mth_octave_filterbank author "Julius O. Smith III";
declare mth_octave_filterbank copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare mth_octave_filterbank license "MIT-style STK-4.3 license";
mth_octave_filterbank(O,M,ftop,N) = an.mth_octave_analyzer(O,M,ftop,N) : delayeq(N) 
with {
   fc(n) = ftop * 2^(float(n-N+1)/float(M)); // -3dB crossover frequencies
   ap(n) = highpass_plus_lowpass(O,fc(n));   // delay-equalizing allpass
   delayeq(N) = par(i,N-2,apchain(i+1)), _, _;
   apchain(i) = seq(j,N-1-i,ap(j+1));
};

// dc-inverted version. This reduces the delay-equalizer order for odd O.
// Negating the input signal makes the dc band noninverting
// and all higher bands sign-inverted (if preferred).
declare mth_octave_filterbank_alt author "Julius O. Smith III";
declare mth_octave_filterbank_alt copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare mth_octave_filterbank_alt license "MIT-style STK-4.3 license";
mth_octave_filterbank_alt(O,M,ftop,N) = an.mth_octave_analyzer(O,M,ftop,N) : delayeqi(O,N) 
with {
    fc(n) = ftop * 2^(float(n-N+1)/float(M)); // -3dB crossover frequencies
    ap(n) = highpass_minus_lowpass(O,fc(n)); // half the order of 'plus' case
    delayeqi(N) = par(i,N-2,apchain(i+1)), _, *(-1.0);
    apchain(i) = seq(j,N-1-i,ap(j+1));
};

// Note that even-order cases require complex coefficients.
// See Vaidyanathan 1993 and papers cited there for more info.
declare mth_octave_filterbank3 author "Julius O. Smith III";
declare mth_octave_filterbank3 copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare mth_octave_filterbank3 license "MIT-style STK-4.3 license";
mth_octave_filterbank3(M,ftop,N) = mth_octave_filterbank_alt(3,M,ftop,N);

declare mth_octave_filterbank5 author "Julius O. Smith III";
declare mth_octave_filterbank5 copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare mth_octave_filterbank5 license "MIT-style STK-4.3 license";
mth_octave_filterbank5(M,ftop,N) = mth_octave_filterbank(5,M,ftop,N);

declare mth_octave_filterbank_default author "Julius O. Smith III";
declare mth_octave_filterbank_default copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare mth_octave_filterbank_default license "MIT-style STK-4.3 license";
mth_octave_filterbank_default = mth_octave_filterbank5;


//===============Arbitrary-Crossover Filter-Banks and Spectrum Analyzers==================
// These are similar to the Mth-octave analyzers above, except that the
// band-split frequencies are passed explicitly as arguments.
//========================================================================================

// ACKNOWLEDGMENT
// Technique for processing a variable number of signal arguments due
// to Yann Orlarey (as is the entire Faust framework!)

//---------------`(fi.)filterbank`--------------------------
// Filter bank.
// `filterbank` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : filterbank (O,freqs) : par(i,N,_) // Butterworth band-splits
// ```
// Where:
//
// * `O`: band-split filter order (odd integer required for filterbank[i], a constant numerical expression)
// * `freqs`: (fc1,fc2,...,fcNs) [in numerically ascending order], where
//           Ns=N-1 is the number of octave band-splits
//           (total number of bands N=Ns+1).
//
// If frequencies are listed explicitly as arguments, enclose them in parens:
//
// ```
// _ : filterbank(3,(fc1,fc2)) : _,_,_
// ```
//---------------------------------------------------
declare filterbank author "Julius O. Smith III";
declare filterbank copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare filterbank license "MIT-style STK-4.3 license";
filterbank(O,lfreqs) = an.analyzer(O,lfreqs) : delayeq(nb) 
with {
   nb = ba.count(lfreqs);
   fc(n) = ba.take(n, lfreqs);
   ap(n) = highpass_plus_lowpass(O,fc(n));
   delayeq(1) = _,_; // par(i,0,...) does not fly
   delayeq(nb) = par(i,nb-1,apchain(nb-1-i)),_,_;
   apchain(0) = _;
   apchain(i) = ap(i) : apchain(i-1);
};

//-----------------`(fi.)filterbanki`----------------------
// Inverted-dc filter bank.
//
// #### Usage
//
// ```
// _ : filterbanki(O,freqs) : par(i,N,_) // Inverted-dc version
// ```
//
// Where:
//
// * `O`: band-split filter order (odd integer required for `filterbank[i]`, a constant numerical expression)
// * `freqs`: (fc1,fc2,...,fcNs) [in numerically ascending order], where
//           Ns=N-1 is the number of octave band-splits
//           (total number of bands N=Ns+1).
//
// If frequencies are listed explicitly as arguments, enclose them in parens:
//
// ```
// _ : filterbanki(3,(fc1,fc2)) : _,_,_
// ```
//---------------------------------------------------
declare filterbanki author "Julius O. Smith III";
declare filterbanki copyright "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare filterbanki license "MIT-style STK-4.3 license";
filterbanki(O,lfreqs) = _ <: bsplit(nb) 
with {
   nb = ba.count(lfreqs);
   fc(n) = ba.take(n, lfreqs);
   lp(n) = lowpass(O,fc(n));
   hp(n) = highpass(O,fc(n));
   ap(n) = highpass_minus_lowpass(O,fc(n));
   bsplit(0) = *(-1.0);
   bsplit(i) = (hp(i) : delayeq(i-1)), (lp(i) <: bsplit(i-1));
   delayeq(0) = _; // moving the *(-1) here inverts all outputs BUT dc
   delayeq(i) = ap(i) : delayeq(i-1);
};


//===============SVF Filters=========================================================
// #### References 
// Solving the continuous SVF equations using trapezoidal integration
// <https://cytomic.com/files/dsp/SvfLinearTrapOptimised2.pdf>
//========================================================================================

//-----------------`(fi.)svf`----------------------
// An environment with `lp`, `bp`, `hp`, `notch`, `peak`, `ap`, `bell`, `ls`, `hs` SVF based filters. 
// All filters have `freq` and `Q` parameters, the `bell`, `ls`, `hs` ones also have a `gain` third parameter.
//
// #### Usage
//
// ```
// _ : svf.xx(freq, Q, [gain]) : _
// ```
//
// Where:
//
// * `freq`: cut frequency
// * `Q`: quality factor
// * `[gain]`: gain in dB
//
/// ```
//---------------------------------------------------
declare svf author "Oleg Nesterov";
declare svf copyright "Copyright (C) 2020 Oleg Nesterov <oleg@redhat.com>";
declare svf license "MIT-style STK-4.3 license";

svf = environment {

	// Internal implementation
	svf(T,F,Q,G) = tick ~ (_,_) : !,!,si.dot(3, mix)
	with {
		tick(ic1eq, ic2eq, v0) =
			2*v1 - ic1eq,
			2*v2 - ic2eq,
			v0, v1, v2
		with {
			v1 = ic1eq + g *(v0-ic2eq) : /(1 + g*(g+k));
			v2 = ic2eq + g * v1;
		};

		A = pow(10.0, G/40.0);

		g = tan(F * ma.PI/ma.SR) : case {
			(7) => /(sqrt(A));
			(8) => *(sqrt(A));
			(t) => _;
		} (T);

		k = case {
			(6) => 1/(Q*A);
			(t) => 1/Q;
		} (T);

		mix = case {
			(0) => 0, 0, 1;
			(1) => 0, 1, 0;
			(2) => 1, -k, -1;
			(3) => 1, -k, 0;
			(4) => 1, -k, -2;
			(5) => 1, -2*k, 0;
			(6) => 1, k*(A*A-1), 0;
			(7) => 1, k*(A-1), A*A-1;
			(8) => A*A, k*(1-A)*A, 1-A*A;
		} (T);
	};

	// External API 
	lp(f,q)     = svf(0, f, q, 0);
	bp(f,q)     = svf(1, f, q, 0);
	hp(f,q)     = svf(2, f, q, 0);
	notch(f,q)  = svf(3, f, q, 0);
	peak(f,q)   = svf(4, f, q, 0);
	ap(f,q)     = svf(5, f, q, 0);
	bell(f,q,g) = svf(6, f, q, g);
	ls(f,q,g)   = svf(7, f, q, g);
	hs(f,q,g)   = svf(8, f, q, g);
};


//============================Averaging Functions==============================
//=============================================================================
//
// These are a set of samplerate independent averaging functions based on
// moving-average and one-pole filters with specific response characteristics.

//----------------------------`(fi.)avg_rect`----------------------------------
// Moving average.
//
// #### Usage
//
// ```
// _ : avg_rect(period) : _
// ```
//
// Where:
//
// * `period` is the averaging frame in seconds
//-----------------------------------------------------------------------------
declare avg_rect author "Dario Sanfilippo and Julius O. Smith III";
declare avg_rect copyright "Copyright (C) 2020 Dario Sanfilippo 
      <sanfilippo.dario@gmail.com> and 
       2003-2020 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare avg_rect license "MIT-style STK-4.3 license";
avg_rect(period, x) = x : ba.slidingMean(rint(period * ma.SR));


//----------------------------(fi.)avg_tau-------------------------------------
// Averaging function based on a one-pole filter and the tau response time.
// Tau represents the effective length of the one-pole impulse response,
// that is, tau is the integral of the filter's impulse response. This
// response is slower to reach the final value but has less ripples in
// non-steady signals.
// 
// #### Usage
//
// ```
// _ : avg_tau(period) : _
// ```
//
// Where:
//
// * `period` is the time, in seconds, for the system to decay by 1/e, 
// or to reach 1-1/e of its final value.
//
// #### Reference
//
// <https://ccrma.stanford.edu/~jos/mdft/Exponentials.html>
//-----------------------------------------------------------------------------
declare avg_tau author "Dario Sanfilippo and Julius O. Smith III";
declare avg_tau copyright "Copyright (C) 2020 Dario Sanfilippo 
      <sanfilippo.dario@gmail.com> and 
       2003-2020 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare avg_tau license "MIT-style STK-4.3 license";
avg_tau(period, x) = fi.lptau(period, x);


//----------------------------(fi.)avg_t60-------------------------------------
// Averaging function based on a one-pole filter and the t60 response time.
// This response is particularly useful when the system is required to 
// reach the final value after about `period` seconds.
// 
// #### Usage
//
// ```
// _ : avg_t60(period) : _
// ```
//
// Where:
//
// * `period` is the time, in seconds, for the system to decay by 1/1000, 
// or to reach 1-1/1000 of its final value.
//
// #### Reference
//
// <https://ccrma.stanford.edu/~jos/mdft/Audio_Decay_Time_T60.html>
//-----------------------------------------------------------------------------
declare avg_t60 author "Dario Sanfilippo and Julius O. Smith III";
declare avg_t60 copyright "Copyright (C) 2020 Dario Sanfilippo 
      <sanfilippo.dario@gmail.com> and 
       2003-2020 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare avg_t60 license "MIT-style STK-4.3 license";
avg_t60(period, x) = fi.lpt60(period, x);


//----------------------------(fi.)avg_t19-------------------------------------
// Averaging function based on a one-pole filter and the t19 response time.
// This response is close to the moving-average algorithm as it roughly reaches
// the final value after `period` seconds and shows about the same
// oscillations for non-steady signals.
//
// #### Usage
//
// ```
// _ : avg_t19(period) : _
// ```
//
// Where:
//
// * `period` is the time, in seconds, for the system to decay by 1/e^2.2, 
// or to reach 1-1/e^2.2 of its final value.
//
// #### Reference
// Zölzer, U. (2008). Digital audio signal processing (Vol. 9). New York: Wiley.
//-----------------------------------------------------------------------------
declare avg_t19 author "Dario Sanfilippo and Julius O. Smith III";
declare avg_t19 copyright "Copyright (C) 2020 Dario Sanfilippo
      <sanfilippo.dario@gmail.com> and
       2003-2020 by Julius O. Smith III <jos@ccrma.stanford.edu>";
declare avg_t19 license "MIT-style STK-4.3 license";
avg_t19(period, x) = fi.lpt19(period, x); 


/*******************************************************************************
# Licenses

## STK 4.3 License

Permission is hereby granted, free of charge, to any person obtaining a copy of 
this software and associated documentation files (the "Software"), to deal in 
the Software without restriction, including without limitation the rights to 
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies 
of the Software, and to permit persons to whom the Software is furnished to do 
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all 
copies or substantial portions of the Software.

Any person wishing to distribute modifications to the Software is asked to send 
the modifications to the original developer so that they can be incorporated 
into the canonical version.  For software copyrighted by Julius O. Smith III, 
email your modifications to <jos@ccrma.stanford.edu>.  This is, however, not a 
binding provision of this license.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE 
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
SOFTWARE.

--------------------------------------------------------------------------------

## LGPL License

This program is free software; you can redistribute it and/or modify it under 
the terms of the GNU Lesser General Public License as published by the Free 
Software Foundation; either version 2.1 of the License, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along 
with the GNU C Library; if not, write to the Free Software Foundation, Inc., 
59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
*******************************************************************************/
//#################################### signals.lib ########################################
// A library of basic elements to handle signals in Faust. Its official prefix is `si`.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/signals.lib>
//########################################################################################

/************************************************************************
************************************************************************
FAUST library file, GRAME section

Except where noted otherwise, Copyright (C) 2003-2017 by GRAME,
Centre National de Creation Musicale.

----------------------------------------------------------------------
GRAME LICENSE

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

ba = library("basics.lib");
ro = library("routes.lib");
ma = library("maths.lib");
si = library("signals.lib");

declare name "Faust Signal Routing Library";
declare version "0.1";

//=============================Functions Reference========================================
//========================================================================================

//--------------------------------`(si.)bus`-------------------------------------
// Put N cables in parallel.
// `bus` is a standard Faust function.
//
// #### Usage
//
// ```
// bus(N)
// bus(4) : _,_,_,_
// ```
//
// Where:
//
// * `N`: is an integer known at compile time that indicates the number of parallel cables
//-----------------------------------------------------------------------------
bus(2) = _,_; // avoids a lot of "bus(1)" labels in block diagrams
bus(N) = par(i, N, _);

//--------------`(si.)block`--------------
// Block - terminate N signals.
// `block` is a standard Faust function.
//
// #### Usage
//
// ```
// _,_,... : block(N) : _,...
// ```
//
// Where:
//
// * `N`: the number of signals to be blocked known at compile time 
//--------------------------------------
block(N) = par(i, N, !);

//-----------------------------`(si.)interpolate`-------------------------------
// Linear interpolation between two signals.
//
// #### Usage
//
// ```
// _,_ : interpolate(i) : _
// ```
//
// Where:
//
// * `i`: interpolation control between 0 and 1 (0: first input; 1: second input)
//-----------------------------------------------------------------------------
interpolate(i,x,y) = x + i*(y-x);  

//------------------------`(si.)smoo`---------------------------------------
// Smoothing function based on `smooth` ideal to smooth UI signals
// (sliders, etc.) down. Approximately, this is a 7 Hz one-pole
// low-pass considering the coefficient calculation:
//    exp(-2pi*CF/SR).
//
// `smoo` is a standard Faust function.
//
// #### Usage
//
// ```
// hslider(...) : smoo;
// ```
//---------------------------------------------------------------------
smoo = si.smooth(1 - 44.1 / ma.SR);

//-----------------------`(si.)polySmooth`--------------------------------
// A smoothing function based on `smooth` that doesn't smooth when a
// trigger signal is given. This is very useful when making
// polyphonic synthesizer to make sure that the value of the parameter
// is the right one when the note is started.
//
// #### Usage
//
// ```
// hslider(...) : si.polySmooth(g,s,d) : _
// ```
//
// Where:
//
// * `g`: the gate/trigger signal used when making polyphonic synths
// * `s`: the smoothness (see `smooth`)
// * `d`: the number of samples to wait before the signal start being
// 		smoothed after `g` switched to 1
//-------------------------------------------------------------------
polySmooth(g,s,d) = si.smooth(s*((g==(g@d)) | (g == 0)));

//-----------------------`(si.)smoothAndH`--------------------------------
// A smoothing function based on `smooth` that holds its output
// signal when a trigger is sent to it. This feature is convenient
// when implementing polyphonic instruments to prevent some
// smoothed parameter to change when a note-off event is sent.
//
// #### Usage
//
// ```
// hslider(...) : smoothAndH(g,s) : _
// ```
//
// Where:
//
// * `g`: the hold signal (0 for hold, 1 for bypass)
// * `s`: the smoothness (see `smooth`)
//-------------------------------------------------------------------
smoothAndH(t,s) = si.smooth(s*t) : ba.sAndH(t);

//-----------------------------`(si.)bsmooth`------------------------------
// Block smooth linear interpolation during a block of samples.
//
// #### Usage
//
// ```
// hslider(...) : bsmooth : _
// ```
//-----------------------------------------------------------------------
bsmooth(c) = +(i) ~ _
with {
	i = (c-c@n)/n;
	n = min(4096, max(1, ma.BS));
};

//-------------------------------`(si.)dot`--------------------------------------
// Dot product for two vectors of size N.
//
// #### Usage
//
// ```
// _,_,_,_,_,_ : dot(N) : _
// ```
//
// Where:
//
// * `N`: size of the vectors (int, must be known at compile time)
//-----------------------------------------------------------------------------
dot(N) = ro.interleave(N,2) : par(i,N,*) :> _;

// end GRAME section
//########################################################################################
/************************************************************************
FAUST library file, jos section

Except where noted otherwise, The Faust functions below in this
section are Copyright (C) 2003-2017 by Julius O. Smith III <jos@ccrma.stanford.edu>
([jos](http://ccrma.stanford.edu/~jos/)), and released under the
(MIT-style) [STK-4.3](#stk-4.3-license) license.

All MarkDown comments in this section are Copyright 2016-2017 by Romain
Michon and Julius O. Smith III, and are released under the
[CCA4I](https://creativecommons.org/licenses/by/4.0/) license (TODO: if/when Romain agrees!)

************************************************************************/
//-------------------`(si.)smooth`-----------------------------------
// Exponential smoothing by a unity-dc-gain one-pole lowpass.
// `smooth` is a standard Faust function.
//
// #### Usage:
//
// ```
// _ : si.smooth(ba.tau2pole(tau)) : _
// ```
//
// Where:
//
// * `tau`: desired smoothing time constant in seconds, or
//
// ```
// hslider(...) : si.smooth(s) : _
// ```
//
// Where:
//
// * `s`: smoothness between 0 and 1. s=0 for no smoothing, s=0.999 is "very smooth",
// s>1 is unstable, and s=1 yields the zero signal for all inputs.
// The exponential time-constant is approximately 1/(1-s) samples, when s is close to
// (but less than) 1.
//
// #### References:
//
// * <https://ccrma.stanford.edu/~jos/mdft/Convolution_Example_2_ADSR.html>
// * <https://ccrma.stanford.edu/~jos/aspf/Appendix_B_Inspecting_Assembly.html>
//-------------------------------------------------------------

// See [grame-cncm/faustlibraries]: Minor improvement to si.smoo. (Discussion #106)

smooth_imp = case { 
  // y[n] = (1 - s) * x[n] + s * y[n - 1]
  (0,s) => \(x).(fb ~ _ with { fb(y) = (1.0 - s) * x + s * y; });
  
  // y[n] = s * (y[n - 1] - x[n]) + x[n]
  (1,s) => \(x).(fb ~ _ with { fb(y) = s * (y - x) + x; });
  
  // y[n] = y[n - 1] + (1 - s) * (x[n] - y[n - 1])
  (2,s) => \(x).(fb ~ _ with { fb(y) = y + (1.0 - s) * (x - y); });
};

// The best compromise on modern CPUs where two independent multiplications can be done in parallel.
// Other versions could possibly be faster on embedded devices. 
smooth = smooth_imp(0);

//--------------------------------`(si.)cbus`-------------------------------------
// N parallel cables for complex signals.
// `cbus` is a standard Faust function.
//
// #### Usage
//
// ```
// cbus(n)
// cbus(4) : (r0,i0), (r1,i1), (r2,i2), (r3,i3)
// ```
//
// Where:
//
// * `N`: is an integer known at compile time that indicates the number of parallel cables.
// * each complex number is represented by two real signals as (real,imag)
//-----------------------------------------------------------------------------
cbus(1) = (_,_);
cbus(N) = par(i, N, (_,_));

//--------------------------------`(si.)cmul`-------------------------------------
// multiply two complex signals pointwise.
// `cmul` is a standard Faust function.
//
// #### Usage
//
// ```
// (r1,i1) : cmul(r2,i2) : (_,_)
// ```
//
// Where:
//
// * Each complex number is represented by two real signals as (real,imag), so
// - `(r1,i1)` = real and imaginary parts of signal 1
// - `(r2,i2)` = real and imaginary parts of signal 2
//-----------------------------------------------------------------------------
cmul(r1,i1,r2,i2) = (r1*r2 - i1*i2), (r1*i2 + r2*i1);

//--------------------------------`(si.)cconj`-------------------------------------
// complex conjugation of a (complex) signal.
// `cconj` is a standard Faust function.
//
// #### Usage
//
// ```
// (r1,i1) : cconj : (_,_)
// ```
//
// Where:
//
// * Each complex number is represented by two real signals as (real,imag), so
// - `(r1,i1)` = real and imaginary parts of the input signal
// - `(r1,-i1)` = real and imaginary parts of the output signal
//-----------------------------------------------------------------------------
cconj = _, *(-1);

// end jos section
/************************************************************************
FAUST library file, further contributions section
All contributions below should indicate both the contributor and terms
of license.  If no such indication is found, "git blame" will say who
last edited each line, and that person can be emailed to inquire about
license disposition, if their license choice is not already indicated
elsewhere among the libraries.  It is expected that all software will be
released under LGPL, STK-4.3, MIT, BSD, or a similar FOSS license.
************************************************************************/

//-------------`(si.)lag_ud`---------------
// Lag filter with separate times for up and down.
//
// #### Usage
//
// ```
// _ : lag_ud(up, dn) : _
// ```
//----------------------------------------------------
// Author: Jonatan Liljedahl
// License: STK-4.3
// MarkDown: Romain Michon
lag_ud(up,dn) = _ <: ((>,ba.tau2pole(up),ba.tau2pole(dn):select2),_:si.smooth) ~ _;

// end further further contributions section

//-------------`(si.)rev`---------------
// Reverse the input signal by blocks of N>0 samples. `rev(1)` is the indentity
// function. `rev(N)` has a latency of `N-1` samples.
//
// #### Usage
//
// ```
// _ : rev(N) : _
// ```
//
// Where:
//
// * `N`: the block size
//----------------------------------------------------
// Author: Yann Orlarey
rev(N) = @(phase(N)*2) 
with {
    phase(n) = 1 : (+ : %(n)) ~ _ : max(0) : min(n-1);
};
//instruments.lib - Faust function of various types useful for building physical model instruments

no = library("noises.lib");
en = library("envelopes.lib");
ma = library("maths.lib");
ba = library("basics.lib");
de = library("delays.lib");
si = library("signals.lib");
fi = library("filters.lib");
os = library("oscillators.lib");
re = library("reverbs.lib");

declare name "Faust-STK Tools Library";
declare author "Romain Michon (rmichon@ccrma.stanford.edu)";
declare copyright "Romain Michon";
declare version "1.0";
declare licence "STK-4.3"; // Synthesis Tool Kit 4.3 (MIT style license);


//========================= ENVELOPE GENERATORS ===============================

//----------------------- VIBRATO ENVELOPE ----------------------------
// 4 phases envelope to control vibrato gain
//
// USAGE:
//   _ : *(envVibrato(b,a,s,r,t)) : _
// where
//   b = beginning duration (silence) in seconds
//   a = attack duration in seconds
//   s = sustain as a percentage of the amplitude to be modified
//   r = release duration in seconds
//   t = trigger signal

envVibrato(b,a,s,r,t) = env ~ (_,_,_) : (!,!,_) // the 3 'state' signals are fed back
    with {
        env(p2,cnt,y) =
            (t>0) & (p2|(y>=1)),
            (cnt + 1)*(t>0), // counter for the first step "b"
            (y + p1*p3*u*(s/100) - p4*w*y)*((p4==0)|(y>=eps))	// y  = envelop signal
            //*(y>=eps) // cut off tails to prevent denormals
        with {
        	p1 = (p2==0) & (t>0) & (y<1) & (cnt>(b*ma.SR)); // p1 = attack phase
        	p3 = 1-(cnt<(nb)); // p3 = beginning phase
        	p4 = (t<=0) & (y>0);  // p4 = release phase
        	// #samples in attack, release, must be >0
        	nb = ma.SR*b+(b==0.0) ; na = ma.SR*a+(a==0.0); nr = ma.SR*r+(r==0.0);
        	// attack and (-60dB) release rates
        	z = s+(s==0.0)*ba.db2linear(-60);
        	u = 1/na; w = 1-1/pow(z*ba.db2linear(60), 1/nr);
        	// values below this threshold are considered zero in the release phase
        	eps = ba.db2linear(-120);
        };
    };

//----------------------- ASYMPT60 ----------------------------
// Envelope generator which asymptotically approaches a target value.
//
// USAGE:
//   asympT60(value,trgt,T60,trig) : _
// where
//   value = starting value
//   trgt = target value
//   T60 = ramping time
//   trig = trigger signal

asympT60(value,trgt,T60,trig) = (_*factor + constant)~_
    with {
        cntSample = *(trig) + 1~_ : -(1);
        attDur = float(2);
        cndFirst = ((cntSample < attDur) & (trig > 0));
        target = value*cndFirst + trgt*(cndFirst < 1);
        factorAtt = exp(-7/attDur);
        factorT60 = exp(-7/(T60*float(ma.SR)));
        factor = factorAtt*((cntSample < attDur) & (trig > 0)) +
               ((cntSample >= attDur) | (trig < 1))*factorT60;
        constant = (1 - factor)*target;
    };

//========================= TABLES ===============================

//----------------------- CLIPPING FUNCTION ----------------------------
// Positive and negative clipping functions.
//
// USAGE:
//   _ : saturationPos : _
//   _ : saturationNeg : _
//   _ : saturationPos : saturationNeg : _

saturationPos(x) = x <: (_>1),(_<=1 : *(x)) :> +;
saturationNeg(x) = x <: (_<-1),(_>=-1 : *(x)) :> *(-1) + _;

//----------------------- BOW TABLE ----------------------------
// Simple bow table.
//
// USAGE:
//   index : bow(offset,slope) : _
// where
//   0 <= index <= 1

bow(offset,slope) = pow(abs(sample) + 0.75, -4) : saturationPos
    with {
        sample(y) = (y + offset)*slope;
    };

//----------------------- REED TABLE ----------------------------
// Simple reed table to be used with waveguide models of clarinet, saxophone, etc.
//
// USAGE:
//   _ : reed(offset,slope) : _
// where
//   offset = offset between 0 and 1
//   slope = slope between 0 and 1
// REFERENCE:
//   <https://ccrma.stanford.edu/~jos/pasp/View_Single_Reed_Oscillation.html>

reed(offset,slope) = reedTable : saturationPos : saturationNeg
    with {
        reedTable = offset + (slope*_);
    };

//========================= FILTERS ===============================

//----------------------- ONE POLE ----------------------------

onePole(b0,a1,x) = (b0*x - a1*_)~_;

//----------------------- ONE POLE SWEPT ----------------------------

onePoleSwep(a1,x) = (1 + a1)*x - a1*x';

//----------------------- POLE ZERO ----------------------------

poleZero(b0,b1,a1,x) = (b0*x + b1*x' - a1*_)~_;

//----------------------- ONE ZEROS ----------------------------
// Simple One zero and One zero recursive filters
//
// USAGE:
//   _ : oneZero0(b0,b1) : _
//   _ : oneZero1(b0,b1) : _
// REFERENCE:
//   <https://ccrma.stanford.edu/~jos/fp2/One_Zero.html>

oneZero0(b0,b1,x) = (*(b1) + x*b0)~_;
oneZero1(b0,b1,x) = (x'*b1 + x*b0);

//----------------------- BANDPASS FILTER WITH CONSTANT UNITY PEAK GAIN BASED ON A BIQUAD ----------------------------

bandPass(resonance,radius) = fi.TF2(b0,b1,b2,a1,a2)
	with {
		a2 = radius*radius;
		a1 = -2*radius*cos(ma.PI*2*resonance/ma.SR);
		b0 = 0.5-0.5*a2;
		b1 = 0;
		b2 = -b0;
	};

//----------------------- BANDPASS FILTER BASED ON A BIQUAD ----------------------------
// Band pass filter using a biquad (TF2 is declared in filter.lib)
//
// USAGE:
//   _ : bandPassH(resonance,radius) : _
// where
//   resonance = center frequency
//   radius = radius

bandPassH(resonance,radius) = fi.TF2(b0,b1,b2,a1,a2)
	with {
		a2 = radius*radius;
		a1 = -2*radius*cos(ma.PI*2*resonance/ma.SR);
		b0 = 1;
		b1 = 0;
		b2 = 0;
	};

//----------------------- FLUE JET NON-LINEAR FUNCTION ----------------------------
// Jet Table: flue jet non-linear function, computed by a polynomial calculation

jetTable(x) = x <: _*(_*_-1) : saturationPos : saturationNeg;

//----------------------- NON LINEAR MODULATOR ----------------------------
// nonLinearModulator adapts the function allpassnn from filter.lib for using it with waveguide instruments (see the corresponding DAFx paper: <https://ccrma.stanford.edu/~rmichon/publications/doc/DAFx11-Faust-STK.pdf> (Faust-STK: a Set of Linear and Nonlinear Physical Models for the Faust Programming Language) for more details).
//
// USAGE:
//   _ : nonLinearModulator(nonlinearity,env,freq,typeMod,freqMod,order) : _
// where
//   nonlinearity = nonlinearity coefficient between 0 and 1
//   env = input to connect any kind of envelope
//   freq = current tone frequency
//   typeMod = if 0: theta is modulated by the incoming signal;
//	       if 1: theta is modulated by the averaged incoming signal;
//	       if 2: theta is modulated by the squared incoming signal;
//	       if 3: theta is modulated by a sine wave of frequency freqMod;
//	       if 4: theta is modulated by a sine wave of frequency freq;
//   freqMod = frequency of the sine wave modulation
//   order = order of the filter

nonLinearModulator(nonlinearity,env,freq,typeMod,freqMod,order) =
	//theta is modulated by a sine wave
	_ <: nonLinearFilterOsc*(typeMod >= 3),
	//theta is modulated by the incoming signal
	     (_ <: nonLinearFilterSig*nonlinearity,_*(1 - nonlinearity) :> +)*(typeMod < 3)
	:> +
	with {
		//which frequency to use for the sine wave oscillator?
		freqOscMod = (typeMod == 4)*freq + (typeMod != 4)*freqMod;

		//the incoming signal is scaled and the envelope is applied
		tsignorm(x) = nonlinearity*ma.PI*x*env;
		tsigsquared(x) = nonlinearity*ma.PI*x*x*env; //incoming signal is squared
		tsigav(x) = nonlinearity*ma.PI*((x + x')/2)*env; //incoming signal is averaged with its previous sample

		//select which version of the incoming signal of theta to use
		tsig(x) = tsignorm(x)*(typeMod == 0) + tsigav(x)*(typeMod == 1)
			  + tsigsquared(x)*(typeMod == 2);

		//theta is modulated by a sine wave generator
		tosc = nonlinearity*ma.PI*os.osc(freqOscMod)*env;

		//incoming signal is sent to the nonlinear passive allpass ladder filter
		nonLinearFilterSig(x) = x <: fi.allpassnn(order,(par(i,order,tsig(x))));
		nonLinearFilterOsc = _ <: fi.allpassnn(order,(par(i,order,tosc)));
	};

//========================= TOOLS ===============================

//----------------------- STEREOIZER ----------------------------
// This function takes a mono input signal and spacialize it in stereo
// in function of the period duration of the tone being played.
//
// USAGE:
//   _ : stereo(periodDuration) : _,_
// where
//   periodDuration = period duration of the tone being played in number of samples
// REFERENCE:
//   <https://ccrma.stanford.edu/realsimple/faust_strings/>

stereoizer(periodDuration) = _ <: _,widthdelay : stereopanner
    with {
        W = hslider("v:Spat/spatial width", 0.5, 0, 1, 0.01);
        A = hslider("v:Spat/pan angle", 0.6, 0, 1, 0.01);
        widthdelay = de.delay(4096,W*periodDuration/2);
        stereopanner = _,_ : *(1.0-A), *(A);
    };

//----------------------- INSTRREVERB ----------------------------
// GUI for zita_rev1_stereo from reverbs.lib
//
// USAGE:
//  _,_ : instrRerveb

instrReverb = _,_ <: *(reverbGain),*(reverbGain),*(1 - reverbGain),*(1 - reverbGain) :
re.zita_rev1_stereo(rdel,f1,f2,t60dc,t60m,fsmax),_,_ <: _,!,_,!,!,_,!,_ : +,+
    with {
        reverbGain = hslider("v:Reverb/reverbGain",0.137,0,1,0.01) : si.smoo;
        roomSize = hslider("v:Reverb/roomSize",0.72,0.01,2,0.01);
        rdel = 20;
        f1 = 200;
        f2 = 6000;
        t60dc = roomSize*3;
        t60m = roomSize*2;
        fsmax = 48000;
    };
//##################################### quantizers.lib ########################################
// Faust Frequency Quantization Library. Its official prefix is `qu`.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/quantizers.lib>
//########################################################################################

ba = library("basics.lib");
it = library("interpolators.lib");

declare name "Faust Frequency Quantization Library";
declare version "0.1";

//=============================Functions Reference========================================
//========================================================================================

/************************************************************************
************************************************************************
This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to <http://unlicense.org/>
************************************************************************
************************************************************************/

MinFreq = 8;
MaxFreq = 20000;
TableSize = 256;

qLog(x) = ba.tabulate(1,log(_),TableSize,MinFreq,MaxFreq,x).cub;
qSmooth(x) = ba.tabulate(1,0.5*atan(_*20-10)/1.4711+0.5,TableSize,0,1,x).cub;


//-------`(qu.)quantize`----------
// Configurable frequency quantization tool. Output only the frequencies that are part of the specified scale.
// Works for positive audio frequencies.
//
// #### Usage
//
// ```
// _ : quantize(rf,nl) : _
// ```
// Where :
//
// * `rf` : frequency of the root note of the scale
// * `nl` : list of the ratio of the frequencies of each note in relation to the root frequency
//------------------------
quantize(rf,nl) = _<: octave,_ <: _,!,noteRatio(nN) : rf*_*_
with{
    octave = (qLog(_)-log(rf))/log(2)<:
        (_<0)*(1/(1<<(-1*(_-1)):int))+
        (_>=0)*(1<<(_:int));
    nN = ba.count(nl);
    noteRatio(1,oct) = 1;
    noteRatio(n,oct) = _ <: (ba.take(n,nl)<=((_/oct)/rf))*ba.take(n,nl)+
                            (ba.take(n,nl)>((_/oct)/rf))*(noteRatio(n-1,oct));
};


//-------`(qu.)quantizeSmoothed`----------
// Configurable frequency quantization tool. Output frequencies that are closer to the frequencies of the specified scale notes.
// Works for positive audio frequencies.
//
//
// #### Usage
//
// ```
// _ : quantizeSmoothed(rf,nl) : _
// nl = (1,1.2,1.4,1.7);
// ```
// Where :
//
// * `rf` : frequency of the root note of the scale
// * `nl` : list of the ratio of the frequencies of each note in relation to the root frequency
//------------------------
quantizeSmoothed(rf,nl) = _<: octave,_ <: _,!,noteRatio(nN) : rf*_*_
with{
    octave = (qLog(_)-log(rf))/log(2)<:
        (_<0)*(1/(1<<(-1*(_-1)):int))+
        (_>0)*(1<<(_:int))+
		(_==0)*2;
    nN = ba.count(nl);
    noteRatio(1,oct) = findValue(1,oct);
    noteRatio(n,oct) = _ <: (ba.take(n,nl)<=((_/oct)/rf))*findValue(n,oct)+
                            (ba.take(n,nl)>((_/oct)/rf))*(noteRatio(n-1,oct));

    findValue(n,oct) = _<: (n<nN)*
            (((_/oct)/rf)-ba.take(n,nl))/((ba.take(min(n+1,nN)-(n==nN),nl)-ba.take(n,nl)))
                    +(n==nN)*
            (((_/oct)/rf)-ba.take(n,nl))/(2-ba.take(n,nl)):       
            qSmooth :  //smoothing curve
            _*((n<nN)*(ba.take(min(n+1,nN)-(n==nN),nl)-ba.take(n,nl))+
                (n==nN)*(2-ba.take(n,nl))
            )+ba.take(n,nl);
};


//---------------------`(qu.)ionian`--------------------------
// List of the frequency ratios of the notes of the ionian mode.
//
// #### Usage
// ```
// _ : quantize(rf,ionian) : _
// ```
//
// Where:
//
// * `rf`: frequency of the root note of the scale
//-------------------------------------------------------------
ionian = (1,pow(2,2/12),pow(2,4/12),pow(2,5/12),pow(2,7/12),pow(2,9/12),pow(2,11/12));


//---------------------`(qu.)dorian`--------------------------
// List of the frequency ratios of the notes of the dorian mode.
//
// #### Usage
// ```
// _ : quantize(rf,dorian) : _
// ```
//
// Where:
//
// * `rf`: frequency of the root note of the scale
//-------------------------------------------------------------
dorian = (1,pow(2,2/12),pow(2,3/12),pow(2,5/12),pow(2,7/12),pow(2,8/12),pow(2,10/12));


//---------------------`(qu.)phrygian`--------------------------
// List of the frequency ratios of the notes of the phrygian mode.
//
// #### Usage
// ```
// _ : quantize(rf,phrygian) : _
// ```
//
// Where:
//
// * `rf`: frequency of the root note of the scale
//-------------------------------------------------------------
phrygian = (1,pow(2,1/12),pow(2,3/12),pow(2,5/12),pow(2,7/12),pow(2,8/12),pow(2,10/12));


//---------------------`(qu.)lydian`--------------------------
// List of the frequency ratios of the notes of the lydian mode.
//
// #### Usage
// ```
// _ : quantize(rf,lydian) : _
// ```
//
// Where:
//
// * `rf`: frequency of the root note of the scale
//-------------------------------------------------------------
lydian = (1,pow(2,2/12),pow(2,4/12),pow(2,6/12),pow(2,7/12),pow(2,9/12),pow(2,11/12));


//---------------------`(qu.)mixo`--------------------------
// List of the frequency ratios of the notes of the mixolydian mode.
//
// #### Usage
// ```
// _ : quantize(rf,mixo) : _
// ```
//
// Where:
//
// * `rf`: frequency of the root note of the scale
//-------------------------------------------------------------
mixo = (1,pow(2,2/12),pow(2,4/12),pow(2,5/12),pow(2,7/12),pow(2,9/12),pow(2,10/12));


//---------------------`(qu.)eolian`--------------------------
// List of the frequency ratios of the notes of the eolian mode.
//
// #### Usage
// ```
// _ : quantize(rf,eolian) : _
// ```
//
// Where:
//
// * `rf`: frequency of the root note of the scale
//-------------------------------------------------------------
eolian = (1,pow(2,2/12),pow(2,3/12),pow(2,5/12),pow(2,7/12),pow(2,8/12),pow(2,10/12));


//---------------------`(qu.)locrian`--------------------------
// List of the frequency ratios of the notes of the locrian mode.
//
// #### Usage
// ```
// _ : quantize(rf,locrian) : _
// ```
//
// Where:
//
// * `rf`: frequency of the root note of the scale
//-------------------------------------------------------------
locrian = (1,pow(2,1/12),pow(2,3/12),pow(2,5/12),pow(2,6/12),pow(2,8/12),pow(2,10/12));


//---------------------`(qu.)pentanat`--------------------------
// List of the frequency ratios of the notes of the pythagorean tuning for the minor pentatonic scale.
//
// #### Usage
// ```
// _ : quantize(rf,pentanat) : _
// ```
//
// Where:
//
// * `rf`: frequency of the root note of the scale
//-------------------------------------------------------------
pentanat = (1,32/27,4/3,3/2,16/9);


//---------------------`(qu.)kumoi`--------------------------
// List of the frequency ratios of the notes of the kumoijoshi, the japanese pentatonic scale.
//
// #### Usage
// ```
// _ : quantize(rf,kumoi) : _
// ```
//
// Where:
//
// * `rf`: frequency of the root note of the scale
//-------------------------------------------------------------
kumoi = (1,16/15,4/3,3/2,8/5);


//---------------------`(qu.)natural`--------------------------
// List of the frequency ratios of the notes of the natural major scale.
//
// #### Usage
// ```
// _ : quantize(rf,natural) : _
// ```
//
// Where:
//
// * `rf`: frequency of the root note of the scale
//-------------------------------------------------------------
natural = (1,9/8,5/4,4/3,3/2,5/3,15/8);


//---------------------`(qu.)dodeca`--------------------------
// List of the frequency ratios of the notes of the dodecaphonic scale.
//
// #### Usage
// ```
// _ : quantize(rf,dodeca) : _
// ```
//
// Where:
//
// * `rf`: frequency of the root note of the scale
//-------------------------------------------------------------
dodeca = (1,pow(2,1/12),pow(2,2/12),pow(2,3/12),pow(2,4/12),pow(2,5/12),pow(2,6/12),pow(2,7/12),pow(2,8/12),pow(2,9/12),pow(2,10/12),pow(2,11/12));


//---------------------`(qu.)dimin`--------------------------
// List of the frequency ratios of the notes of the diminished scale.
//
// #### Usage
// ```
// _ : quantize(rf,dimin) : _
// ```
//
// Where:
//
// * `rf`: frequency of the root note of the scale
//-------------------------------------------------------------
dimin = (1,pow(2,1/12),pow(2,3/12),pow(2,4/12),pow(2,6/12),pow(2,7/12),pow(2,9/12),pow(2,10/12));


//---------------------`(qu.)penta`--------------------------
// List of the frequency ratios of the notes of the minor pentatonic scale.
//
// #### Usage
// ```
// _ : quantize(rf,penta) : _
// ```
//
// Where:
//
// * `rf`: frequency of the root note of the scale
//-------------------------------------------------------------
penta = (1,pow(2,3/12),pow(2,5/12),pow(2,7/12),pow(2,10/12));
//##################################### noises.lib ########################################
// Faust Noise Generator Library. Its official prefix is `no`.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/noises.lib>
//########################################################################################

ma = library("maths.lib");
ba = library("basics.lib");
fi = library("filters.lib");
os = library("oscillators.lib");
no = library("noises.lib"); // for compatible copy/paste out of this file

declare name "Faust Noise Generator Library";
declare version "0.2";

//=============================Functions Reference========================================
//========================================================================================

/************************************************************************
************************************************************************
FAUST library file, GRAME section

Except where noted otherwise, Copyright (C) 2003-2017 by GRAME,
Centre National de Creation Musicale.
----------------------------------------------------------------------
GRAME LICENSE

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

noise_env(seed) = environment {

	RANDMAX	= 2147483647.0; // = 2^31-1 = MAX_SIGNED_INT in 32 bits
	
	noise = random / RANDMAX
	with {
		mask = 4294967295; // 2^32-1
		random = +(seed) ~ *(1103515245) & mask; // "linear congruential"
	};	
	
	multirandom(N) = randomize(N) ~_
	with {
		randomize(1) = +(seed) : *(1103515245);
		randomize(N) = randomize(1) <: randomize(N-1),_;
	};
	
	multinoise(N) = multirandom(N) : par(i, N, /(RANDMAX)) : par(i, N, float);
	
	noises(N,i) = multinoise(N) : ba.selector(i,N);

};


//-------`(no.)noise`----------
// White noise generator (outputs random number between -1 and 1).
// `noise` is a standard Faust function.
//
// #### Usage
//
// ```
// noise : _
// ```
//------------------------
noise = noise_env(12345).noise;


//---------------------`(no.)multirandom`--------------------------
// Generates multiple decorrelated random numbers in parallel.
//
// #### Usage
// ```
// multirandom(N) : si.bus(N)
// ```
//
// Where:
//
// * `N`: the number of decorrelated random numbers in parallel, a constant numerical expression
//-------------------------------------------------------------
multirandom(N) = noise_env(12345).multirandom(N);


//-----------------------`(no.)multinoise`------------------------
// Generates multiple decorrelated noises in parallel.
//
// #### Usage
//
// ```
// multinoise(N) : si.bus(N)
// ```
//
// Where:
//
// * `N`: the number of decorrelated random numbers in parallel, a constant numerical expression
//------------------------------------------------------------
multinoise(N) = noise_env(12345).multinoise(N);


//-----------------------`(no.)noises`------------------------
// A convenient wrapper around multinoise.
//
// #### Usage
//
// ```
// noises(N,i) : _
// ```
//
// Where:
//
// * `N`: the number of decorrelated random numbers in parallel, a constant numerical expression
// * `i`: the selected random number (i in [0..N[)
//----------------------------------------------------------
noises(N,i) = noise_env(12345).noises(N,i);


//-----------------------`(no.)randomseed`------------------------
// A random seed based on the foreign function `arc4random`
// (see man arc4random). Used in `rnoise`, `rmultirandom`, etc. to 
// avoid having the same pseudo random sequence at each run.
//
// WARNING: using the foreign function `arc4random`, so only available in C/C++ and LLVM backends.
//
// #### Usage
//
// ```
// randomseed : _
// ```
//
//------------------------------------------------------------
randomseed = ffunction(int arc4random(), <math.h>, ""), 12345 : select2(1');


//-----------------------`(no.)rnoise`-----------------------
// A randomized white noise generator (outputs random number between -1 and 1).
//
// WARNING: using the foreign function `arc4random`, so only available in C/C++ and LLVM backends.
//
// #### Usage
//
// ```
// rnoise : _
// ```
//------------------------
rnoise = noise_env(randomseed).noise;


//---------------------`(no.)rmultirandom`--------------------------
// Generates multiple decorrelated random numbers in parallel.
//
// WARNING: using the foreign function `arc4random`, so only available in C/C++ and LLVM backends.
//
// #### Usage
// ```
// rmultirandom(N) : _
// ```
//
// Where:
//
// * `N`: the number of decorrelated random numbers in parallel, a constant numerical expression
//-------------------------------------------------------------
rmultirandom(N) = noise_env(randomseed).multirandom(N);


//-----------------------`(no.)rmultinoise`------------------------
// Generates multiple decorrelated noises in parallel.
//
// WARNING: using the foreign function `arc4random`, so only available in C/C++ and LLVM backends.
//
// #### Usage
//
// ```
// rmultinoise(N) : _
// ```
//
// Where:
//
// * `N`: the number of decorrelated random numbers in parallel, a constant numerical expression
//------------------------------------------------------------
rmultinoise(N) = noise_env(randomseed).multinoise(N);


//-----------------------`(no.)rnoises`------------------------
// A convenient wrapper around rmultinoise.
//
// WARNING: using the foreign function `arc4random`, so only available in C/C++ and LLVM backends.
//
// #### Usage
//
// ```
// rnoises(N,i) : _
// ```
//
// Where:
//
// * `N`: the number of decorrelated random numbers in parallel
// * `i`: the selected random number (i in [0..N[)
//----------------------------------------------------------
rnoises(N,i) = noise_env(randomseed).noises(N,i);


//########################################################################################
/************************************************************************
FAUST library file, jos section

Except where noted otherwise, The Faust functions below in this
section are Copyright (C) 2003-2017 by Julius O. Smith III <jos@ccrma.stanford.edu>
([jos](http://ccrma.stanford.edu/~jos/)), and released under the
(MIT-style) [STK-4.3](#stk-4.3-license) license.

All MarkDown comments in this section are Copyright 2016-2017 by Romain
Michon and/or Julius O. Smith III, and are released under the
[CCA4I](https://creativecommons.org/licenses/by/4.0/) license (TODO: if/when Romain agrees)

************************************************************************/

//---------------------------`(no.)pink_noise`--------------------------
// Pink noise (1/f noise) generator (third-order approximation covering the audio band well).
// `pink_noise` is a standard Faust function.
//
// #### Usage
// ```
// pink_noise : _
// ```
//
// #### Reference
// <https://ccrma.stanford.edu/~jos/sasp/Example_Synthesis_1_F_Noise.html>
//
// #### Alternatives
// Higher-order approximations covering any frequency band can be obtained using
// ```
// no.noise : fi.spectral_tilt(order,lowerBandLimit,Bandwidth,p)
// ```
// where `p=-0.5` means filter rolloff `f^(-1/2)` which gives 1/f rolloff in the
// power spectral density, and can be changed to other real values.
//
// #### Example
// // pink_noise_compare.dsp - compare three pinking filters
// ```
// process = pink_noises with {
//     f0 = 35; // Lower bandlimit in Hz
//     bw3 = 0.7 * ma.SR/2.0 - f0; // Bandwidth in Hz, 3rd order case
//     bw9 = 0.8 * ma.SR/2.0 - f0; // Bandwidth in Hz, 9th order case
//     pink_tilt_3 = fi.spectral_tilt(3,f0,bw3,-0.5);
//     pink_tilt_9 = fi.spectral_tilt(9,f0,bw9,-0.5);
//     pink_noises = 1-1' <:
//       no.pink_filter, // original designed by invfreqz in Octave
//       pink_tilt_3,    // newer method using the same filter order
//       pink_tilt_9;    // newer method using a higher filter order
// };
// ```
//
// #### Output of Example
// ```
// faust2octave pink_noise_compare.dsp
// Octave:1> semilogx(20*log10(abs(fft(faustout,8192))(1:4096,:)));
// ...
// ```
// <img alt="pink_noise_demo figure" src="https://ccrma.stanford.edu/wiki/Images/8/86/Tpinkd.jpg" width="600" />
//------------------------------------------------------------
pink_filter = fi.iir((0.049922035, -0.095993537, 0.050612699, -0.004408786),
                    (-2.494956002, 2.017265875, -0.522189400));

pink_noise = noise : pink_filter;

pink_noise_m = pink_noise * 12.5; // Equalizes loudness to that of no.noise (thanks Mykle Hansen) - beware of clipping


//-------------------------`(no.)pink_noise_vm`-------------------
// Multi pink noise generator.
//
// #### Usage
//
// ```
// pink_noise_vm(N) : _
// ```
//
// Where:
//
// * `N`: number of latched white-noise processes to sum,
// 	not to exceed sizeof(int) in C++ (typically 32).
//
// #### References
//
// * <http://www.dsprelated.com/showarticle/908.php>
// * <http://www.firstpr.com.au/dsp/pink-noise/#Voss-McCartney>
//------------------------------------------------------------
pink_noise_vm(N) = noise <: _,par(i,N,ba.latch(clock(i))) :> _
with {
	clock(i) = (ba.time>>i)&1; // i'th latch clock signal
};


//--------------------`(no.)lfnoise`, `(no.)lfnoise0` and `(no.)lfnoiseN`-----------------
// Low-frequency noise generators (Butterworth-filtered downsampled white noise).
//
// #### Usage
//
// ```
// lfnoise0(rate) : _   // new random number every int(SR/rate) samples or so
// lfnoiseN(N,rate) : _ // same as "lfnoise0(rate) : lowpass(N,rate)" [see filters.lib]
// lfnoise(rate) : _    // same as "lfnoise0(rate) : seq(i,5,lowpass(N,rate))" (no overshoot)
// ```
//
// #### Example
//
// (view waveforms in faust2octave):
//
// ```
// rate = SR/100.0; // new random value every 100 samples (SR from music.lib)
// process = lfnoise0(rate),   // sampled/held noise (piecewise constant)
//           lfnoiseN(3,rate), // lfnoise0 smoothed by 3rd order Butterworth LPF
//           lfnoise(rate);    // lfnoise0 smoothed with no overshoot
// ```
//------------------------------------------------------------
lfnoise0(freq) = noise : ba.latch(os.oscrs(freq));
lfnoiseN(N,freq) = lfnoise0(freq) : fi.lowpass(N,freq); // Nth-order Butterworth lowpass
lfnoise(freq) = lfnoise0(freq) : seq(i,5,fi.lowpass(1,freq)); // non-overshooting lowpass


//-------------------------`(no.)sparse_noise_vm`-------------------
// sparse noise generator.
//
// #### Usage
//
// ```
// sparse_noise(f0) : _
// ```
//
// Where:
//
// * ` f0`: average frequency of noise impulses per second
//
// Random impulses in the amplitude range -1 to 1 are generated
// at an average rate of f0 impulses per second.
//
// #### Reference
//
// * See velvet_noise
//------------------------------------------------------------
sparse_noise(f0) = sn
with {
    saw = os.lf_sawpos(f0);
    sawdiff = saw - saw';
    e = float(no.noise); // float() keeps 4.656613e-10f scaling here instead of later
    eHeld = e : ba.latch(sawdiff);
    eHeldPos = 0.5 + 0.5 * eHeld;
    crossed = (saw >= eHeldPos) * (saw' < eHeldPos);
    sn = e' * float(crossed);
};


//-------------------------`(no.)velvet_noise_vm`-------------------
// velvet noise generator.
//
// #### Usage
//
// ```
// velvet_noise(amp, f0) : _
// ```
//
// Where:
//
// * `amp`: amplitude of noise impulses (positive and negative)
// * ` f0`: average frequency of noise impulses per second
//
// #### Reference
//
// * Matti Karjalainen and Hanna Jarvelainen,
//   "Reverberation Modeling Using Velvet Noise",
//   in Proc. 30th Int. Conf. Intelligent Audio Environments (AES07),
//   March 2007.
//
//------------------------------------------------------------
velvet_noise(amp, f0) = vn
with {
    sn = no.sparse_noise(f0);
    vn = amp * ma.signum(sn);
};


//----------------------------`(no.)gnoise`------------------------
// approximate zero-mean, unit-variance Gaussian white noise generator.
//
// #### Usage
//
// ```
// gnoise(N) : _
// ```
//
// Where:
//
// * `N`: number of uniform random numbers added to approximate Gaussian white noise
//
// #### Reference
//
// * See Central Limit Theorem
//
//------------------------------------------------------------
gnoise(N) = uvgwn
with {
    uwn = no.multinoise(N); // uniform white noise in [-1,1] on N channels
    gwn = uwn :> _;         // sum of uniform approaches Gaussian by centeral limit thm
    sigma = sqrt(N/3.0);    // rms of each uwn channel
    uvgwn = gwn / sigma;	// approaches zero-mean, unit-variance Gaussian white noise, for large N
};

gnoisem(N) = gnoise(N) * 0.625; // Equalizes loudness to that of no.noise (thanks Mykle Hansen)


/*** END jos section ***/

//########################################################################################
/************************************************************************
FAUST library file, further contributions section

All contributions below should indicate both the contributor and terms
of license.  If no such indication is found, "git blame" will say who
last edited each line, and that person can be emailed to inquire about
license disposition, if their license choice is not already indicated
elsewhere among the libraries.  It is expected that all software will be
released under LGPL, STK-4.3, MIT, BSD, or a similar FOSS license.
************************************************************************/
//////////////////////////////////////////////////////////////////////////////////////////
// WARNING: Deprecated Library!!
// Read the README file in /libraries for more information
//////////////////////////////////////////////////////////////////////////////////////////

declare name "Faust Oscillator Library";
declare author "Julius O. Smith (jos at ccrma.stanford.edu)";
declare copyright "Julius O. Smith III";
declare version "1.11";
declare license "STK-4.3"; // Synthesis Tool Kit 4.3 (MIT style license)
declare deprecated "This library is deprecated and is not maintained anymore. It will be removed in August 2017."; 

ml = library("music.lib");  // SR, db2linear, frac, PI, noise, ...
fl = library("filter.lib"); // wgr, nlf2, tf2, smooth, tau2pole, iir, ...

//--------------------Oscillator library for Faust--------------------------
// Virtual analog oscillators and filter-based oscillators.
// For wavetable-based oscillators, see osc* in ./music.lib
//
// Low-frequency oscillators have prefix "lf_"
// (no aliasing suppression, signal-means not necessarily zero)

//-------- LF Impulse and Pulse Trains, Square and Triangle Waves ----------
// lf_imptrain, lf_pulsetrainpos, lf_squarewavepos, lf_squarewave, lf_trianglepos
// ### USAGE:
//     lf_wavetype : _
// ### NOTES:
// + Suffix 'pos' means the function is nonnegative, otherwise ~ zero mean
// + All impulse and pulse trains jump to 1 at time 0

// Unit-amplitude low-frequency impulse train:
lf_imptrain(freq) = lf_sawpos(freq)<:-(mem)<0; // definition below

// Unit-amplitude nonnegative LF pulse train, duty cycle between 0 and 1:
lf_pulsetrainpos(freq,duty) = float(lf_sawpos(freq) < duty);
//pulsetrainpos = lf_pulsetrainpos; // for backward compatibility

// Positive LF square wave in [0,1]:
lf_squarewavepos(freq) = lf_pulsetrainpos(freq,0.5);
// squarewavepos = lf_squarewavepos; // for backward compatibility

// Zero-mean unit-amplitude LF square wave:
lf_squarewave(freq) = 2*lf_squarewavepos(freq) - 1;
// squarewave = lf_squarewave; // for backward compatibility

// Positive unit-amplitude LF triangle wave:
lf_trianglepos(freq) = 1-abs(saw1(freq)); // saw1 defined below

//---------- LF Sawtooths: lf_rawsaw, lf_sawpos, saw1 -------------------
//
// Sawtooth waveform oscillators for virtual analog synthesis et al.
// The 'simple' versions (lf_rawsaw, lf_sawpos, saw1), are mere samplings of
// the ideal continuous-time ("analog") waveforms.  While simple, the
// aliasing due to sampling is quite audible.  The differentiated
// polynomial waveform family (saw2, sawN, and derived functions)
// do some extra processing to suppress aliasing (not audible for
// very low fundamental frequencies).  According to Lehtonen et al.
// (JASA 2012), the aliasing of saw2 should be inaudible at fundamental
// frequencies below 2 kHz or so, for a 44.1 kHz sampling rate and 60 dB SPL
// presentation level;  fundamentals 415 and below required no aliasing
// suppression (i.e., saw1 is ok).

// --- lf_rawsaw ---
// simple sawtooth waveform oscillator between 0 and period in samples:
lf_rawsaw(periodsamps) = (_,periodsamps : fmod) ~ +(1.0);

fracPart(x) = x - floor(x);

// --- lf_sawpos ---
// simple sawtooth waveform oscillator between 0 and 1
lf_sawpos(freq) = fracPart ~ +(freq/ml.SR); // Bart Brouns versions
lf_sawpos_phase(phase,freq) = (+(phase-phase') : fracPart ) ~ +(freq/ml.SR);

// --- saw1 ---
//
// simple sawtooth waveform oscillator between -1 and 1
saw1(freq) = 2.0 * lf_sawpos(freq) - 1.0; // zero-mean in [-1,1)
// no lf prefix because order 1 explicit called for here

//---------------- Bandlimited Sawtooth sawN, saw2, ... ------------------
//
// ### METHOD 1 (saw2):
// Polynomial Transition Regions (PTR) (for aliasing suppression)
// ### REFERENCE:
// Kleimola, J.; Valimaki, V., "Reducing Aliasing from Synthetic Audio
// Signals Using Polynomial Transition Regions," in Signal Processing
// Letters, IEEE , vol.19, no.2, pp.67-70, Feb. 2012
// https://aaltodoc.aalto.fi/bitstream/handle/123456789/7747/publication6.pdf?sequence=9
// http://research.spa.aalto.fi/publications/papers/spl-ptr/
//
// ### METHOD 2 (sawN):
// Differentiated Polynomial Waves (DPW) (for aliasing suppression)
// ### REFERENCE:
// "Alias-Suppressed Oscillators based on Differentiated Polynomial Waveforms",
// Vesa Valimaki, Juhan Nam, Julius Smith, and Jonathan Abel,
// IEEE Tr. Acoustics, Speech, and Language Processing (IEEE-ASLP),
// Vol. 18, no. 5, May 2010.

// --- sawN for N = 1 to 6 ---
//We can do 6, but 5 and 6 have noise at low fundamentals: MAX_SAW_ORDER = 6; MAX_SAW_ORDER_NEXTPOW2 = 8;
MAX_SAW_ORDER = 4; MAX_SAW_ORDER_NEXTPOW2 = 8; // par cannot handle the case of 0 elements
sawN(N,freq) = saw1l : poly(Nc) : D(Nc-1) : gate(Nc-1)
with {
  Nc = max(1,min(N,MAX_SAW_ORDER));
  clippedFreq = max(20.0,abs(freq)); // use lf_sawpos(freq) for LFOs (freq < 20 Hz)
  saw1l = 2*lf_sawpos(clippedFreq) - 1; // zero-mean, amplitude +/- 1
  // Also note the availability of lf_sawpos_phase above.
  poly(1,x) =  x;
  poly(2,x) =  x*x;
  poly(3,x) =  x*x*x - x;
  poly(4,x) =  x*x*(x*x - 2.0);
  poly(5,x) =  x*(7.0/3 + x*x*(-10.0/3.0 + x*x));
  poly(6,x) =  x*x*(7.0 + x*x*(-5.0 + x*x));
  p0n = float(ml.SR)/clippedFreq; // period in samples
  diff1(x) =  (x - x')/(2.0/p0n);
  diff(N) = seq(n,N,diff1); // N diff1s in series
  factorial(0) = 1;
  factorial(i) = i * factorial(i-1);
  D(0) = _;
  D(i) = diff(i)/factorial(i+1);
  gate(N) = *(1@(N)); // delayed step for blanking startup glitch
};

// --- sawNp for N = 1 to 6 ---
// Phase offset = delay (max 8191 samples is more than one period of audio):
sawNp(N,freq,phase) = sawN(N,freq) : @(max(0,min(8191,int(phase*ml.SR/freq))));

// Special named cases:

// --- sawN ---
saw2dpw(freq) = saw1(freq) <: * <: -(mem) : *(0.25'*ml.SR/freq); // inferior to saw2 below
saw3 = sawN(3); saw4 = sawN(4); saw5 = sawN(5); saw6 = sawN(6);


saw2(freq) = y with { // newer PTR version (stateless - freq can vary at any speed)
  p0 = float(ml.SR)/float(max(ma.EPSILON,abs(freq))); // period in samples
  t0 = 1.0/p0; // phase increment
  p = ((_<:(-(1)<:_,_),_) <: selector1,selector2) ~(+(t0)):!,_;
  selector1 = select2(<(0)); // for feedback
  selector2 = select2(<(0), (_<:_,(*(1-p0):+(1)):+), _); // for output
  y = 2*p-1;
};

// --- sawtooth ---
sawtooth = saw2; // default choice for sawtooth signal - see also sawN

// --- Correction-filtered versions of saw2: saw2f2, saw2f4 ----
// The correction filter compensates "droop" near half the sampling rate.
// See reference for sawN.

saw2f2 = saw2 : cf2 with {
  cf2 = fl.tf2(1.155704605878911, 0.745184288225518,0.040305967265900,
        0.823765146386639, 0.117420665547108);
};

saw2f4 = saw2 : cf4 with {
  cf4 = fl.iir((1.155727435125014, 2.285861038554662,
        1.430915027294021, 0.290713280893317, 0.008306401748854),
        (2.156834679164532, 1.559532244409321, 0.423036498118354,
        0.032080681130972));
};

//-------------------------- sawtooth_demo ---------------------------
//
// ### USAGE:  sawtooth_demo : _

sawtooth_demo = signal with {
  osc_group(x) = vgroup("[0] SAWTOOTH OSCILLATOR
    [tooltip: See Faust's oscillator.lib for documentation and references]",x);
  knob_group(x)  = osc_group(hgroup("[1]", x));
  ampdb  = knob_group(vslider("[1] Amplitude [unit:dB] [style:knob]
    [tooltip: Sawtooth waveform amplitude]",
    -20,-120,10,0.1));
  amp = ampdb : ml.db2linear : fl.smooth(0.999);
  freq = knob_group(
  vslider("[2] Frequency [unit:PK] [style:knob]
    [tooltip: Sawtooth frequency as a Piano Key (PK) number (A440 = key 49)]",
    49,1,88,0.01) : pianokey2hz);
  pianokey2hz(x) = 440.0*pow(2.0, (x-49.0)/12); // piano key 49 = A440 (also defined in effect.lib)
  detune1 = 1 + 0.01 * knob_group(
    vslider("[3] Detuning 1 [unit:%%] [style:knob]
      [tooltip: Percentage frequency-shift up or down for second oscillator]",
      -0.1,-10,10,0.01));
  detune2 = 1 + 0.01 * knob_group(
    vslider("[4] Detuning 2 [unit:%%] [style:knob]
[tooltip: Percentage frequency-shift up or down for third detuned oscillator]",
    +0.1,-10,10,0.01));
  portamento = knob_group(
    vslider("[5] Portamento [unit:sec] [style:knob] [scale:log]
      [tooltip: Portamento (frequency-glide) time-constant in seconds]",
      0.1,0.001,10,0.001));
  sfreq = freq : fl.smooth(fl.tau2pole(portamento));
  saworder = knob_group(nentry("[6] Saw Order [tooltip: Order of sawtootn aliasing suppression]",2,1,MAX_SAW_ORDER,1));
  sawchoice = _ <: par(i,MAX_SAW_ORDER,sawN(i+1)) : ml.selectn(int(MAX_SAW_ORDER), int(saworder-1)); // when max is pwr of 2
  tone = (amp/3) * (sawchoice(sfreq) + sawchoice(sfreq*detune1) + sawchoice(sfreq*detune2));
  signal = amp * select2(ei, select2(ss, tone, white_or_pink_noise), _);
  white_or_pink_noise = select2(wp,ml.noise,pink_noise);
  checkbox_group(x) = knob_group(vgroup("[7] Alternate Signals",x));
  ss = checkbox_group(checkbox("[0] Noise (White or Pink - uses only Amplitude control on the left)"));
  wp = checkbox_group(checkbox("[1] Pink instead of White Noise (also called 1/f Noise) [tooltip: Pink Noise (or 1/f noise) is Constant-Q Noise, meaning that it has the same total power in every octave]"));
  ei = checkbox_group(checkbox("[2] External Signal Input (overrides Sawtooth/Noise selection above)"));
};

//---------- Bandlimited Pulse, Square, and Impulse Trains -------------
// pulsetrain[N], square[N], imptrain[N], triangle[N]
//
// All are zero-mean and meant to oscillate in the audio frequency range.
// Use simpler sample-rounded lf_* versions above for LFOs.

pulsetrainN(N,freq,duty) = diffdel(sawN(N,freqC),del) with {
 // non-interpolated-delay version: diffdel(x,del) = x - x@int(del+0.5);
 // linearly interpolated delay version (sounds good to me):
    diffdel(x,del) = x-x@int(del)*(1-ml.frac(del))-x@(int(del)+1)*ml.frac(del);
 // Third-order Lagrange interpolated-delay version (see filter.lib):
 // diffdel(x,del) = x - fl.fdelay3(DELPWR2,max(1,min(DELPWR2-2,ddel)));
 DELPWR2 = 2048; // Needs to be a power of 2 when fdelay*() used above.
 delmax = DELPWR2-1; // arbitrary upper limit on diff delay (duty=0.5)
 SRmax = 96000.0; // assumed upper limit on sampling rate
 fmin = SRmax / float(2.0*delmax); // 23.4 Hz (audio freqs only)
 freqC = max(freq,fmin); // clip frequency at lower limit
 period = (float(ml.SR) / freqC); // actual period
 ddel = duty * period; // desired delay
 del = max(0,min(delmax,ddel));
};
pulsetrain = pulsetrainN(2);

squareN(N,freq) = pulsetrainN(N,freq,0.5);
square = squareN(2);

diffn(x) = x' - x; // negated first-order difference

impulse = 1-1';
imptrainN(N,freq) = impulse + 0.5*diffn(sawN(N,freq));
imptrain = imptrainN(2); // default based on saw2

triangleN(N,freq) = squareN(N,freq) : fl.pole(p) : *(gain) with {
  gain = 4.0*freq/ml.SR; // for aproximate unit peak amplitude
  p = 0.999;
};
triangle = triangleN(2); // default based on saw2

//---------------------- virtual_analog_oscillator_demo ----------------------
// ### USAGE:  virtual_analog_oscillator_demo : _

virtual_analog_oscillator_demo = signal with {
  osc_group(x) = vgroup("[0] VIRTUAL ANALOG OSCILLATORS
    [tooltip: See Faust's oscillator.lib for documentation and references]",x);

  // Signals
  sawchoice = _ <:
    // When MAX_SAW_ORDER is a power of 2:
    par(i,MAX_SAW_ORDER,sawN(i+1)) : ml.selectn(int(MAX_SAW_ORDER), int(saworder-1));
    // When MAX_SAW_ORDER is NOT a power of 2:
    // (par(i,MAX_SAW_ORDER,sawN(i+1)), par(j,MAX_SAW_ORDER_NEXTPOW2-MAX_SAW_ORDER,_))
    //   : ml.selectn(MAX_SAW_ORDER_NEXTPOW2, saworder-1);
  saw = (amp/3) *
    (sawchoice(sfreq) + sawchoice(sfreq*detune1) + sawchoice(sfreq*detune2));
  sq = (amp/3) *
    (square(sfreq) + square(sfreq*detune1) + square(sfreq*detune2));
  tri = (amp/3) *
    (triangle(sfreq) + triangle(sfreq*detune1) + triangle(sfreq*detune2));
  pt = (amp/3) * (pulsetrain(sfreq,ptd)
                + pulsetrain(sfreq*detune1,ptd)
                + pulsetrain(sfreq*detune2,ptd));
  ptN = (amp/3) * (pulsetrainN(N,sfreq,ptd)
                + pulsetrainN(N,sfreq*detune1,ptd)
                + pulsetrainN(N,sfreq*detune2,ptd)) with {N=3;};
  pn = amp * pink_noise;

  signal = ssaw*saw + ssq*sq + stri*tri
           + spt*((ssptN*ptN)+(1-ssptN)*pt)
           + spn*pn + sei*_;

  // Signal controls:
  signal_group(x) = osc_group(hgroup("[0] Signal Levels",x));
  ssaw = signal_group(vslider("[0] Sawtooth [style:vslider]",1,0,1,0.01));

  pt_group(x) = signal_group(vgroup("[1] Pulse Train",x));
  ssptN = pt_group(checkbox("[0] Order 3
    [tooltip: When checked, use 3rd-order aliasing suppression (up from 2)
     See if you can hear a difference with the freq high and swept]"));
  spt = pt_group(vslider("[1] [style:vslider]",0,0,1,0.01));
  ptd = pt_group(vslider("[2] Duty Cycle [style:knob]",0.5,0,1,0.01))
        : fl.smooth(0.99);

  ssq = signal_group(vslider("[2] Square [style:vslider]",0,0,1,0.01));
  stri = signal_group(vslider("[3] Triangle [style:vslider]",0,0,1,0.01));
  spn = signal_group(vslider(
      "[4] Pink Noise [style:vslider]
       [tooltip: Pink Noise (or 1/f noise) is Constant-Q Noise, meaning that it has the same total power in every octave (uses only amplitude controls)]",0,0,1,0.01));
  sei = signal_group(vslider("[5] Ext Input [style:vslider]",0,0,1,0.01));

  // Signal Parameters
  knob_group(x) = osc_group(hgroup("[1] Signal Parameters", x));
  af_group(x) = knob_group(vgroup("[0]", x));
  ampdb  = af_group(hslider("[1] Mix Amplitude [unit:dB] [style:hslider]
    [tooltip: Sawtooth waveform amplitude]",
    -20,-120,10,0.1));
  amp = ampdb : ml.db2linear : fl.smooth(0.999);
  freq = af_group(hslider("[2] Frequency [unit:PK] [style:hslider]
    [tooltip: Sawtooth frequency as a Piano Key (PK) number (A440 = key 49)]",
    49,1,88,0.01) : pianokey2hz);
  pianokey2hz(x) = 440.0*pow(2.0, (x-49.0)/12); // piano key 49 = A440 (also defined in effect.lib)

  detune1 = 1 - 0.01 * knob_group(
    vslider("[3] Detuning 1 [unit:%%] [style:knob]
      [tooltip: Percentage frequency-shift up or down for second oscillator]",
      -0.1,-10,10,0.01));
  detune2 = 1 + 0.01 * knob_group(
    vslider("[4] Detuning 2 [unit:%%] [style:knob]
      [tooltip: Percentage frequency-shift up or down for third detuned oscillator]",
    +0.1,-10,10,0.01));
  portamento = knob_group(
    vslider("[5] Portamento [unit:sec] [style:knob] [scale:log]
      [tooltip: Portamento (frequency-glide) time-constant in seconds]",
      0.1,0.001,10,0.001));
  saworder = knob_group(nentry("[6] Saw Order [tooltip: Order of sawtooth aliasing suppression]",2,1,MAX_SAW_ORDER,1));
  sfreq = freq : fl.smooth(fl.tau2pole(portamento));
};

//----------------------- Filter-Based Oscillators ------------------------

// ### USAGE: osc[b|r|rs|rc|s|w](f), where f = frequency in Hz.
// ### REFERENCES:
//  http://lac.linuxaudio.org/2012/download/lac12-slides-jos.pdf
//  https://ccrma.stanford.edu/~jos/pdf/lac12-paper-jos.pdf

//-------------------------- oscb --------------------------------
// Sinusoidal oscillator based on the biquad
//
oscb(f) = impulse : fl.tf2(1,0,0,a1,1)
with {
  a1 = -2*cos(2*ml.PI*f/ml.SR);
};

//-------------------------- oscr --------------------------------
// Sinusoidal oscillator based on 2D vector rotation,
//  = undamped "coupled-form" resonator
//  = lossless 2nd-order normalized ladder filter
//
// ### Reference:
// https://ccrma.stanford.edu/~jos/pasp/Normalized_Scattering_Junctions.html
//
oscrq(f) = impulse : fl.nlf2(f,1); // sine and cosine outputs
oscrs(f) = impulse : fl.nlf2(f,1) : _,!; // sine
oscrc(f) = impulse : fl.nlf2(f,1) : !,_; // cosine
oscrp(f,p) = oscrq(f) : *(cos(p)), *(sin(p)) : + ; // p=0 for sine, p=PI/2 for cosine, etc.
oscr = oscrs; // default = sine (starts without a pop)

//-------------------------- oscs --------------------------------
// Sinusoidal oscillator based on the state variable filter
// = undamped "modified-coupled-form" resonator
// = "magic circle" algorithm used in graphics
//
oscs(f) =  (*(-1) : sint(wn) : sintp(wn,impulse)) ~ _
with {
  wn = 2*ml.PI*f/ml.SR; // approximate
  // wn = 2*sin(ml.PI*f/ml.SR); // exact
  sub(x,y) = y-x;
  sint(x) = *(x) : + ~ _ ; // frequency-scaled integrator
  sintp(x,y) = *(x) : +(y): + ~ _ ; // same + state input
};

//----------------- oscw, oscwq, oscwc, oscws --------------------
// Sinusoidal oscillator based on the waveguide resonator wgr
//
// oscwc - unit-amplitude cosine oscillator
// oscws - unit-amplitude sine oscillator
// oscq  - unit-amplitude cosine and sine (quadrature) oscillator
// oscw  - default = oscwc for maximum speed
//
// ### Reference:
// https://ccrma.stanford.edu/~jos/pasp/Digital_Waveguide_Oscillator.html
//
oscwc(fr) = impulse : fl.wgr(fr,1) : _,!; // cosine (cheapest at 1 mpy/sample)
oscws(fr) = impulse : fl.wgr(fr,1) : !,_; // sine (needs a 2nd scaling mpy)
oscq(fr)  = impulse : fl.wgr(fr,1);       // phase quadrature outputs
oscw = oscwc;

//-------------------------- oscrs_demo ---------------------------

oscrs_demo = signal with {
  osc_group(x) = vgroup("[0] SINE WAVE OSCILLATOR oscrs
    [tooltip: Sine oscillator based on 2D vector rotation]",x);
  ampdb  = osc_group(hslider("[1] Amplitude [unit:dB]
    [tooltip: Sawtooth waveform amplitude]",
    -20,-120,10,0.1));
  amp = ampdb : ml.db2linear : fl.smooth(0.999);
  freq = osc_group(
  hslider("[2] Frequency [unit:PK]
     [tooltip: Sine wave frequency as a Piano Key (PK) number (A440 = 49 PK)]",
     49,1,88,0.01) : pianokey2hz);
  pianokey2hz(x) = 440.0*pow(2.0, (x-49.0)/12); // (also defined in effect.lib)
  portamento = osc_group(
    hslider("[3] Portamento [unit:sec] [scale:log]
      [tooltip: Portamento (frequency-glide) time-constant in seconds]",
      0.1,0.001,10,0.001));
  sfreq = freq : fl.smooth(fl.tau2pole(portamento));
  signal = amp * oscrs(sfreq);
};

oscr_demo = oscrs_demo; // synonym

//--------------------------- pink_noise --------------------------
// Pink noise (1/f noise) generator (third-order approximation)
//
// ### USAGE: pink_noise : _;
//
// ### Reference:
//  https://ccrma.stanford.edu/~jos/sasp/Example_Synthesis_1_F_Noise.html
//

pink_filter = fl.iir((0.049922035, -0.095993537, 0.050612699, -0.004408786),
                    (-2.494956002, 2.017265875, -0.522189400));

pink_noise = ml.noise : pink_filter;

// ### USAGE: pink_noise_vm(N) : _;
// where N = number of latched white-noise processes to sum,
//       not to exceed sizeof(int) in C++ (typically 32).
//
// ### References:
//  http://www.dsprelated.com/showarticle/908.php
//  http://www.firstpr.com.au/dsp/pink-noise/#Voss-McCartney

pink_noise_vm(N) = ml.noise <: _,par(i,N,fl.latch(clock(i))) :> _
with {
  clock(i) = (counter>>i)&1; // i'th latch clock signal
  counter = (+(1)~_) - 1;
};

//----------------------- lfnoise, lfnoise0, lfnoiseN ---------------------
// Low-frequency noise generators
// (Butterworth-filtered downsampled white noise)
// Require: music.lib, filter.lib
//
// ### USAGE:
//   lfnoise0(rate) : _;   // new random number every int(SR/rate) samples or so
//   lfnoiseN(N,rate) : _; // same as "lfnoise0(rate) : lowpass(N,rate)" [see filter.lib]
//   lfnoise(rate) : _;    // same as "lfnoise0(rate) : seq(i,5,lowpass(N,rate))" (no overshoot)
//
// EXAMPLES (view waveforms in faust2octave):
//   rate = SR/100.0; // new random value every 100 samples (SR from music.lib)
//   process = lfnoise0(rate),   // sampled/held noise (piecewise constant)
//             lfnoiseN(3,rate), // lfnoise0 smoothed by 3rd order Butterworth LPF
//             lfnoise(rate);    // lfnoise0 smoothed with no overshoot

lfnoise0(freq) = ml.noise : fl.latch(oscrs(freq));
lfnoiseN(N,freq) = lfnoise0(freq) : fl.lowpass(N,freq); // Nth-order Butterworth lowpass
lfnoise(freq) = lfnoise0(freq) : seq(i,5,fl.lowpass(1,freq)); // non-overshooting lowpass
//#################################### interpolators.lib ########################################
// A library to handle interpolation. Its official prefix is `it`.
//
// This library provides several basic interpolation functions as well as interpolators 
// taking a `gen` circuit of N outputs producing values to be interpolated, triggered
// by a `idv` read index signal. Two points and four points interpolations are implemented.
//
// The `idv` parameter is to be used as a read index. In float (= singleprecision) mode, 
// a technique based on 2 signals with the pure integer index and a fractional part in the [0,1] 
// range is used to avoid accumulating errors. In -double (= doubleprecision)/-quad (= quadprecision) modes, 
// a standard implementation with a single fractional index signal is used. 
// Three functions `int_part`, `frac_part` and `mak_idv` are available to manipule the read index signal.
//
// Use-case with `waveform`. Here the signal given to `interpolator_XXX` uses the `idv` model.
// 
// ```
// waveform_interpolator(wf, step, interp) = interp(gen, idv)
// with {
//    gen(idx) = wf, (idx:max(0):min(size-1)) : rdtable with { size = wf:(_,!); };   /* waveform size */
//    index = (+(step)~_)-step;  /* starting from 0 */
//    idv = it.make_idv(index);  /* build the signal for interpolation in a generic way */
// };
// 
// waveform_linear(wf, step) = waveform_interpolator(wf, step, it.interpolator_linear);
// waveform_cosine(wf, step) = waveform_interpolator(wf, step, it.interpolator_cosine);
// waveform_cubic(wf, step) = waveform_interpolator(wf, step, it.interpolator_cubic);
// 
// waveform_interp(wf, step, selector) = waveform_interpolator(wf, step, interp_select(selector))
// with {
//    /* adapts the argument order */
//    interp_select(sel, gen, idv) = it.interpolator_select(gen, idv, sel);
// };
// 
// waveform and index 
// waveform_interpolator1(wf, idv, interp) = interp(gen, idv)
// with {
//    gen(idx) = wf, (idx:max(0):min(size-1)) : rdtable with { size = wf:(_,!); };   /* waveform size */
// };
// 
// waveform_linear1(wf, idv) = waveform_interpolator1(wf, idv, it.interpolator_linear);
// waveform_cosine1(wf, idv) = waveform_interpolator1(wf, idv, it.interpolator_cosine);
// waveform_cubic1(wf, idv) = waveform_interpolator1(wf, idv, it.interpolator_cubic);
// 
// waveform_interp1(wf, idv, selector) = waveform_interpolator1(wf, idv, interp_select(selector))
// with {
//    /* adapts the argument order */
//    interp_select(sel, gen, idv) = it.interpolator_select(gen, idv, sel);
// };
// ```
// 
// Some tests here:
// 
// ```
// wf = waveform {0.0, 10.0, 20.0, 30.0, 40.0, 50.0, 60.0, 50.0, 40.0, 30.0, 20.0, 10.0, 0.0};
// 
// process = waveform_linear(wf, step), waveform_cosine(wf, step), waveform_cubic(wf, step) with { step = 0.25; };
// 
// process = waveform_interp(wf, 0.25, nentry("algo", 0, 0, 3, 1));
// 
// process = waveform_interp1(wf, idv, nentry("algo", 0, 0, 3, 1))
// with {
//    step = 0.1;
//    idv_aux = (+(step)~_)-step;  /* starting from 0 */
//    idv = it.make_idv(idv_aux);  /* build the signal for interpolation in a generic way */
// };
// 
// /* Test linear interpolation between 2 samples with a `(idx,dv)` signal built using a waveform */
// linear_test = (idx,dv), it.interpolator_linear(gen, (idx,dv))
// with {
//    /* signal to interpolate (only 2 points here) */
//    gen(id) = waveform {3.0, -1.0}, (id:max(0)) : rdtable;
//    dv = waveform {0.0, 0.25, 0.50, 0.75, 1.0}, index : rdtable;
//    idx = 0; 
//    /* test index signal */
//    index = (+(1)~_)-1;   /* starting from 0 */
// };
// 
// /* Test cosine interpolation between 2 samples with a `(idx,dv)` signal built using a waveform */
// cosine_test = (idx,dv), it.interpolator_cosine(gen, (idx,dv))
// with {
//    /* signal to interpolate (only 2 points here) */
//    gen(id) = waveform {3.0, -1.0}, (id:max(0)) : rdtable;
//    dv = waveform {0.0, 0.25, 0.50, 0.75, 1.0}, index : rdtable;
//    idx = 0;
//    /* test index signal */
//    index = (+(1)~_)-1;   /* starting from 0 */
// };
// 
// /* Test cubic interpolation between 4 samples with a `(idx,dv)` signal built using a waveform */
// cubic_test = (idx,dv), it.interpolator_cubic(gen, (idx,dv))
// with {
//    /* signal to interpolate (only 4 points here) */
//    gen(id) = waveform {-1.0, 2.0, 1.0, 4.0}, (id:max(0)) : rdtable;
//    dv = waveform {0.0, 0.25, 0.50, 0.75, 1.0}, index : rdtable;
//    idx = 0;
//    /* test index signal */
//    index = (+(1)~_)-1;   /* starting from 0 */
// };
// ```
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/interpolators.lib>
//########################################################################################

/************************************************************************
************************************************************************
FAUST library file
Copyright (C) 2019-2020 GRAME, Centre National de Creation Musicale
----------------------------------------------------------------------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

ba = library("basics.lib");
ro = library("routes.lib");
ma = library("maths.lib");
si = library("signals.lib");

declare name "Faust Interpolator Library";
declare version "0.3";

reset(trig) = (trig-trig') <= 0;
 
// The following 3 functions allow to adapt a 'single signal' fractional idv in this [idx, dv] model.

singleprecision int_part(idv) = idv : _,!;
singleprecision frac_part(idv) = idv : !,_;
singleprecision make_idv(id) = int(id), ma.frac(id);

// Infinite raising index
singleprecision raise(trig, step, length) = id, dv
letrec {
    'id = (id + int(step) + int(dv + ma.frac(step))) * reset(trig);
    'dv = ma.frac(dv + ma.frac(step)) * reset(trig);
};

// Modulo based raising index
singleprecision raise_modulo(trig, step, length) = id, dv
letrec {
    'id = fmod(id + int(step) + int(dv + ma.frac(step)), length) * reset(trig);
    'dv = ma.frac(dv + ma.frac(step)) * reset(trig);
};

// Decreasing index starting at 'length'
singleprecision decrease(trig, step, length) = raise(trig, -step, length) : (+(length), _);

// Modulo decreasing index starting at 'length'
singleprecision decrease_modulo(trig, step, length) = raise_modulo(trig, -step, length) : (+(length), _);

// The following 3 functions allow to adapt a 'single signal' fractional idv in this [idx, dv] model.

doubleprecision quadprecision int_part(idv) = int(idv);
doubleprecision quadprecision frac_part(idv) = ma.frac(idv);
doubleprecision quadprecision make_idv(id) = id;

// Infinite raising index
doubleprecision quadprecision raise(trig, step, length) = idv
letrec {
    'idv = (idv + step) * reset(trig);
};

// Modulo based raising index
doubleprecision quadprecision raise_modulo(trig, step, length) = idv
letrec {
    'idv = fmod(idv + step, length) * reset(trig);
};

// Decreasing index starting at 'length'
doubleprecision quadprecision decrease(trig, step, length) = raise(trig, -step, length) + length;

// Modulo decreasing index starting at 'length'
doubleprecision quadprecision decrease_modulo(trig, step, length) = raise_modulo(trig, -step, length) + length;
 
//=========================Two points interpolation functions=============================
//========================================================================================

//-------`(it.)interpolate_linear`----------
// Linear interpolation between 2 values.
//
// #### Usage
//
// ```
// interpolate_linear(dv,v0,v1) : _
// ```
//
// Where:
//
// * `dv`: in the fractional value in [0..1] range
// * `v0`: is the first value
// * `v1`: is the second value
//
//
// #### Reference:
//
// <https://github.com/jamoma/JamomaCore/blob/master/Foundation/library/includes/TTInterpolate.h>
//
//--------------------------------------------

interpolate_linear(dv,v0,v1) = v0 + dv*(v1-v0);  // (faster than v0*(1-dv)+v1*dv which is currently not optimized...)


//-------`(it.)interpolate_cosine`----------
// Cosine interpolation between 2 values.
//
// #### Usage
//
// ```
// interpolate_cosine(dv,v0,v1) : _
// ```
//
// Where:
//
// * `dv`: in the fractional value in [0..1] range
// * `v0`: is the first value
// * `v1`: is the second value
//
//
// #### Reference:
//
// <https://github.com/jamoma/JamomaCore/blob/master/Foundation/library/includes/TTInterpolate.h>
//
//--------------------------------------------

interpolate_cosine(dv,v0,v1) = v0 + a2*(v1-v0) with { a2 = 0.5 * (1.0 - cos(dv*ma.PI)); };


//=========================Four points interpolation functions============================
//========================================================================================

//-------`(it.)interpolate_cubic`----------
// Cubic interpolation between 4 values.
//
// #### Usage
//
// ```
// interpolate_cubic(dv,v0,v1,v2,v3) : _
// ```
//
// Where:
//
// * `dv`: in the fractional value in [0..1] range
// * `v0`: is the first value
// * `v1`: is the second value
// * `v2`: is the third value
// * `v3`: is the fourth value
//
//
// #### Reference:
//
// <https://www.paulinternet.nl/?page=bicubic>
//
//--------------------------------------------

interpolate_cubic(dv,v0,v1,v2,v3) 
	= v1 + 0.5*dv*(v2 - v0 + dv*(2.0*v0 - 5.0*v1 + 4.0*v2 - v3 + dv*(3.0*(v1 - v2) + v3 - v0)));


//=========================Two points interpolators=======================================
//========================================================================================

//-------`(it.)interpolator_two_points`----------
// Generic interpolator on two points (current and next index), assuming an increasing index.
//
// #### Usage
//
// ```
// interpolator_two_points(gen, idv, interpolate_two_points) : si.bus(outputs(gen))
// ```
//
// Where:
//
// * `gen`: a circuit with an 'idv' reader input that produces N outputs
// * `idv`: a fractional read index expressed as a float value, or a (int,frac) pair
// * `interpolate_two_points`: a two points interpolation function
//
//--------------------------------------------

interpolator_two_points(gen, idv, interpolate_two_points) = (gen(id0), gen(id1))
                                                            : ro.interleave(outputs(gen), 2)
                                                            : par(i, outputs(gen), interpolate_two_points(dv))
with {
    id0 = int_part(idv); // index integer part
    id1 = id0 + 1;       // next index
    dv = frac_part(idv); // index fractional part in [0..1]
};


//-------`(it.)interpolator_linear`----------
// Linear interpolator for a 'gen' circuit triggered by an 'idv' input to generate values.
//
// #### Usage
//
// ```
// interpolator_linear(gen, idv) : si.bus(outputs(gen))
// ```
//
// Where:
//
// * `gen`: a circuit with an 'idv' reader input that produces N outputs
// * `idv`: a fractional read index expressed as a float value, or a (int,frac) pair
//
//--------------------------------------------

interpolator_linear(gen, idv) = interpolator_two_points(gen, idv, interpolate_linear);


//-------`(it.)interpolator_cosine`----------
// Cosine interpolator for a 'gen' circuit triggered by an 'idv' input to generate values.
//
// #### Usage
//
// ```
// interpolator_cosine(gen, idv) : si.bus(outputs(gen))
// ```
//
// Where:
//
// * `gen`: a circuit with an 'idv' reader input that produces N outputs
// * `idv`: a fractional read index expressed as a float value, or a (int,frac) pair
//
//--------------------------------------------

interpolator_cosine(gen, idv) = interpolator_two_points(gen, idv, interpolate_cosine);


// To be used in 'interpolator_select'
interpolator_null(gen, idv) = interpolator_two_points(gen, idv, \(dv,v0,v1).(v0));


//=========================Four points interpolators======================================
//========================================================================================

//-------`(it.)interpolator_two_points`----------
// Generic interpolator on interpolator_four_points points (previous, current and two next indexes), assuming an increasing index.
//
// #### Usage
//
// ```
// interpolator_four_points(gen, idv, interpolate_four_points) : si.bus(outputs(gen))
// ```
//
// Where:
//
// * `gen`: a circuit with an 'idv' reader input that produces N outputs
// * `idv`: a fractional read index expressed as a float value, or a (int,frac) pair
// * `interpolate_four_points`: a four points interpolation function
//
//--------------------------------------------

interpolator_four_points(gen, idv, interpolate_four_points) = (gen(id0), gen(id1), gen(id2), gen(id3))
                                                            : ro.interleave(outputs(gen), 4)
                                                            : par(i, outputs(gen), interpolate_four_points(dv))
with {
    id0 = id1 - 1;       // previous index
    id1 = int_part(idv); // index integer part
    id2 = id1 + 1;       // next index
    id3 = id2 + 1;       // next index
    dv = frac_part(idv); // index fractional part in [0..1]
};


//-------`(it.)interpolator_cubic`----------
// Cubic interpolator for a 'gen' circuit triggered by an 'idv' input to generate values
//
// #### Usage
//
// ```
// interpolator_cubic(gen, idv) : si.bus(outputs(gen))
// ```
//
// Where:
//
// * `gen`: a circuit with an 'idv' reader input that produces N outputs
// * `idv`: a fractional read index expressed as a float value, or a (int,frac) pair
//
//--------------------------------------------

interpolator_cubic(gen, idv) = interpolator_four_points(gen, idv, interpolate_cubic);

// Enum of interpolation algorithms
MAX_INTER = 4;

linear = 0;
cosine = 1;
cubic  = 2;
nointerp = MAX_INTER-1;


//-------`(it.)interpolator_select`----------
// Generic configurable interpolator (with selector between in [0..3]). The value 3 is used for no interpolation.
//
// #### Usage
//
// ```
// interpolator_select(gen, idv, sel) : _,_... (equal to N = outputs(gen))
// ```
//
// Where:
//
// * `gen`: a circuit with an 'idv' reader input that produces N outputs
// * `idv`: a fractional read index expressed as a float value, or a (int,frac) pair
// * `sel`: an interpolation algorithm selector in [0..3] (0 = linear, 1 = cosine, 2 = cubic, 3 = nointerp)
//
//--------------------------------------------

interpolator_select(gen, idv, sel) = ba.selectmulti(ma.SR/10, interpolators, sel)
with {
	interpolators = (interpolator_linear(gen, idv),
                    interpolator_cosine(gen, idv),
                    interpolator_cubic(gen, idv),
                    interpolator_null(gen, idv));
};

//=========================Lagrange based interpolators====================================
//========================================================================================

//-------`(it.)lagrangeCoeffs(N, xCoordsList)` ---------------------------------------------
//
// This is a function to generate N + 1 coefficients for an Nth-order Lagrange
// basis polynomial with arbitrary spacing of the points.
//
// #### Usage
//
// ```
// lagrangeCoeffs(N, xCoordsList, x) : si.bus(N + 1)
// ```
//
// Where:
//
// * `N`: order of the interpolation filter, known at compile-time;
// * `xCoordsList`: a list of N + 1 elements determining the x-axis coordinates of N + 1 values, known at compile-time;
// * `x`: a fractional position on the x-axis to obtain the interpolated y-value.
//
// #### Reference
//
// <https://ccrma.stanford.edu/~jos/pasp/Lagrange_Interpolation.html>
// <https://en.wikipedia.org/wiki/Lagrange_polynomial>
//------------------------------------------------------------

declare lagrangeCoeffs author "Dario Sanfilippo";
declare lagrangeCoeffs copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare lagrangeCoeffs license "MIT license";
lagrangeCoeffs(N, xCoords, x) = par(n, N + 1, prod(k, N + 1, f(n, k)))
    with {
        xVals(i) = ba.take(i + 1, xCoords);
        f(n, k) =   ((x - xVals(k)) * (n != k) + (n == k)) / 
                    ((xVals(n) - xVals(k)) + (n == k));
    };
// The following definition for uniformely-spaced points interpolation is kept for back-compatibility
lagrange_h(N, x) = lagrangeCoeffs(N, xCoord, x)
    with {
        xCoord = par(i, N + 1, i);
    };

//-------`(it.)lagrangeInterpolation(N, xCoordsList)` --------------------------------------
//
// Nth-order Lagrange interpolator to interpolate between a set of arbitrarily spaced N + 1 points.
//
// #### Usage
//
// ```
// x , yCoords : lagrangeInterpolation(N, xCoordsList) : _
// ```
//
// Where:
//
// * `N`: order of the interpolator, known at compile-time;
// * `xCoordsList`: a list of N + 1 elements determining the x-axis spacing of the points, known at compile-time;
// * `x`: an x-axis position to interpolate between the y-values.
// * `yCoords`: N + 1 elements determining the values of the interpolation points
//
// Example: find the centre position of a four-point set using an order-3
// Lagrange function fitting the equally-spaced points [2, 5, -1, 3]:
//
// ```
// N = 3;
// xCoordsList = (0, 1, 2, 3);
// x = N / 2.0;
// yCoords = 2 , 5 , -1 , 3;
// process = x , yCoords : lagrangeInterpolation(N, xCoordsList);
// ```
//
// which outputs ~1.938.
//
// Example: output the dashed curve showed on the Wikipedia page (top figure, https://en.wikipedia.org/wiki/Lagrange_polynomial):
//
// ```
// N = 3;
// xCoordsList = (-9, -4, -1, 7);
// x = os.phasor(16, 1) - 9;
// yCoords = 5 , 2 , -2 , 9;
// process = x , yCoords : lagrangeInterpolation(N, xCoordsList);
// ```
//
// #### Reference
// 
// <https://ccrma.stanford.edu/~jos/pasp/Lagrange_Interpolation.html>
// Sanfilippo and Parker 2021, "Combining zeroth and first‐order analysis with Lagrange polynomials to reduce artefacts in live concatenative granular processing." Proceedings of the DAFx conference 2021, Vienna, Austria.
// <https://dafx2020.mdw.ac.at/proceedings/papers/DAFx20in21_paper_38.pdf>
//------------------------------------------------------------

declare lagrangeInterpolation author "Dario Sanfilippo";
declare lagrangeInterpolation copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare lagrangeInterpolation license "MIT license";
lagrangeInterpolation(N, xCoords, x) = si.dot(N + 1, lagrangeCoeffs(N, xCoords, x));
// The following definition for uniformely-spaced points interpolation is kept for back-compatibility
lagrangeN(N, x) = si.dot(N + 1, lagrange_h(N, x));

//-------`(it.)frdtable(N, S)` --------------------------------------------
//
// Look-up circular table with Nth-order Lagrange interpolation for fractional
// indexes. The index is wrapped-around and the table is cycles for an index
// span of size S, which is the table size in samples.
//
// #### Usage
//
// ```
// frdtable(N, S, init, idx) : _
// ```
//
// Where:
//
// * `N`: Lagrange interpolation order, known at compile-time
// * `S`: table size in samples, known at compile-time
// * `init`: signal for table initialisation
// * `idx`: fractional index wrapped-around 0 and S
//
// Example: test the effectiveness of the 5th-order interpolation scheme by 
// creating a table look-up oscillator using only 16 points of a sinewave; 
// compare the result with a non-interpolated version:
//
// ```
// N = 5;
// S = 16;
// index = os.phasor(S, 1000);
// process = rdtable(S, os.sinwaveform(S), int(index)) ,
//           it.frdtable(N, S, os.sinwaveform(S), index);
// ```
//------------------------------------------------------------

declare frdtable author "Dario Sanfilippo";
declare frdtable copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare frdtable license "LGPL v3.0 license";
frdtable(N, S, init, idx) =
    lagrangeN(N, f_idx, par(i, N + 1, table(i_idx - int(N / 2) + i)))
    with {
        table(j) = rdtable(S, init, int(ma.modulo(j, S)));
        f_idx = ma.frac(idx) + int(N / 2);
        i_idx = int(idx);
    };


//-------`(it.)frwtable(N, S)` --------------------------------------------
//
// Look-up updatable circular table with Nth-order Lagrange interpolation for
// fractional indexes. The index is wrapped-around and the table is circular
// indexes ranging from 0 to S, which is the table size in samples.
//
// #### Usage
//
// ```
// frwtable(N, S, init, w_idx, x, r_idx) : _
// ```
//
// Where:
//
// * `N`: Lagrange interpolation order, known at compile-time
// * `S`: table size in samples, known at compile-time
// * `init`: constant for table initialisation, known at compile-time
// * `w_idx`: it should be an INT between 0 and S - 1
// * `x`: input signal written on the w_idx positions
// * `r_idx`: fractional index wrapped-around 0 and S
//
// Example: test the effectiveness of the 5th-order interpolation scheme by
// creating a table look-up oscillator using only 16 points of a sinewave;
// compare the result with a non-interpolated version:
//
// ```
// N = 5;
// S = 16;
// rIdx = os.phasor(S, 300);
// wIdx = ba.period(S);
// process =   rwtable(S, os.sinwaveform(S), wIdx, os.sinwaveform(S), int(rIdx)) ,
//             frwtable(N, S, os.sinwaveform(S), wIdx, os.sinwaveform(S), rIdx);
// ```
//------------------------------------------------------------

declare frwtable author "Dario Sanfilippo";
declare frwtable copyright "Copyright (C) 2021 Dario Sanfilippo
    <sanfilippo.dario@gmail.com>";
declare frwtable license "LGPL v3.0 license";
frwtable(N, S, init, w_idx, x, r_idx) =
    lagrangeN(N, f_idx, par(i, N + 1, table(i_idx - int(N / 2) + i)))
    with {
        table(j) = rwtable(S, init, w_idx, x, int(ma.modulo(j, S)));
        f_idx = ma.frac(r_idx) + int(N / 2);
        i_idx = int(r_idx);
    };
//#################################### demos.lib ##########################################
// This library contains a set of demo functions based on examples located in the
// `/examples` folder. Its official prefix is `dm`.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/demos.lib>
//########################################################################################

/************************************************************************
************************************************************************
FAUST library file, GRAME section

Except where noted otherwise, Copyright (C) 2003-2017 by GRAME,
Centre National de Creation Musicale.
----------------------------------------------------------------------
GRAME LICENSE

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

ma = library("maths.lib");
ba = library("basics.lib");
de = library("delays.lib");
si = library("signals.lib");
an = library("analyzers.lib");
fi = library("filters.lib");
os = library("oscillators.lib");
no = library("noises.lib");
ef = library("misceffects.lib");
co = library("compressors.lib");
ve = library("vaeffects.lib");
pf = library("phaflangers.lib");
re = library("reverbs.lib");
en = library("envelopes.lib");

declare name "Faust Demos Library";
declare version "0.1";

//########################################################################################
/************************************************************************
FAUST library file, jos section

Except where noted otherwise, The Faust functions below in this
section are Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>
([jos](http://ccrma.stanford.edu/~jos/)), and released under the
(MIT-style) [STK-4.3](#stk-4.3-license) license.

MarkDown comments in this section are Copyright 2016-2019 by Romain
Michon and Julius O. Smith III, and are released under the
[CCA4I](https://creativecommons.org/licenses/by/4.0/) license (TODO: if/when Romain agrees!)

************************************************************************/

//====================================Analyzers===========================================
//========================================================================================

//----------------------`(dm.)mth_octave_spectral_level_demo`----------------------
// Demonstrate mth_octave_spectral_level in a standalone GUI.
//
// #### Usage
// ```
// _ : mth_octave_spectral_level_demo(BandsPerOctave) : _
// _ : spectral_level_demo : _ // 2/3 octave
// ```
//------------------------------------------------------------
// Author: Julius Smith
// Coauthor: Yann Orlarey
// License: MIT
mth_octave_spectral_level_demo(BPO) =  an.mth_octave_spectral_level_default(M,ftop,N,tau,dB_offset)
with{
    M = BPO;
    ftop = 16000;
    Noct = 10; // number of octaves down from ftop
    // Lowest band-edge is at ftop*2^(-Noct+2) = 62.5 Hz when ftop=16 kHz:
    N = int(Noct*M); // without 'int()', segmentation fault observed for M=1.67
    ctl_group(x)  = hgroup("[1] SPECTRUM ANALYZER CONTROLS", x);
    tau = ctl_group(hslider("[0] Level Averaging Time [unit:ms] [scale:log]
        [tooltip: band-level averaging time in milliseconds]",
    100,1,10000,1)) * 0.001;
    dB_offset = ctl_group(hslider("[1] Level dB Offset [unit:dB]
    [tooltip: Level offset in decibels]",
    50,-50,100,1));
};

spectral_level_demo = mth_octave_spectral_level_demo(1.5); // 2/3 octave


//======================================Filters===========================================
//========================================================================================

//--------------------------`(dm.)parametric_eq_demo`------------------------------
// A parametric equalizer application.
//
// #### Usage:
//
// ```
// _ : parametric_eq_demo : _
// ```
//------------------------------------------------------------
// Author: Julius Smith
// License: MIT
parametric_eq_demo = fi.low_shelf(LL,FL) : fi.peak_eq(LP,FP,BP) : fi.high_shelf(LH,FH)
with{
    eq_group(x) = hgroup("[0] PARAMETRIC EQ SECTIONS [tooltip: See Faust's filters.lib
        for info and pointers]",x);
    ls_group(x) = eq_group(vgroup("[1] Low Shelf",x));

    LL = ls_group(hslider("[0] Low Boost|Cut [unit:dB] [style:knob]
        [tooltip: Amount of low-frequency boost or cut in decibels]",0,-40,40,0.1));
    FL = ls_group(hslider("[1] Transition Frequency [unit:Hz] [style:knob] [scale:log]
        [tooltip: Transition-frequency from boost (cut) to unity gain]",200,1,5000,1));

    pq_group(x) = eq_group(vgroup("[2] Peaking Equalizer[tooltip: Parametric Equalizer
        sections from filters.lib]",x));
    LP = pq_group(hslider("[0] Peak Boost|Cut [unit:dB] [style:knob][tooltip: Amount of
        local boost or cut in decibels]",0,-40,40,0.1));
    FP = pq_group(hslider("[1] Peak Frequency [unit:PK] [style:knob] [tooltip: Peak
        Frequency in Piano Key (PK) units (A440 = 49PK)]",49,1,100,1)) : si.smooth(0.999)
        : ba.pianokey2hz;
    Q = pq_group(hslider("[2] Peak Q [style:knob] [scale:log] [tooltip: Quality factor
        (Q) of the peak = center-frequency/bandwidth]",40,1,1000,0.1));

    BP = FP/Q;

    hs_group(x) = eq_group(vgroup("[3] High Shelf [tooltip: A high shelf provides a boost
        or cut above some frequency]",x));
    LH = hs_group(hslider("[0] High Boost|Cut [unit:dB] [style:knob] [tooltip: Amount of
        high-frequency boost or cut in decibels]",0,-40,40,.1));
    FH = hs_group(hslider("[1] Transition Frequency [unit:Hz] [style:knob] [scale:log]
    [tooltip: Transition-frequency from boost (cut) to unity gain]",8000,20,10000,1));
};


//-------------------`(dm.)spectral_tilt_demo`-----------------------
// A spectral tilt application.
//
// #### Usage
//
// ```
// _ : spectral_tilt_demo(N) : _ 
// ```
//
// Where:
//
// * `N`: filter order (integer)
//
// All other parameters interactive
//------------------------------------------------------------
// Author: Julius Smith
// License: MIT
spectral_tilt_demo(N) = fi.spectral_tilt(O,f0,bw,alpha)
with{
    O = N;
    alpha = hslider("[1] Slope of Spectral Tilt across Band",-1/2,-1,1,0.001);
    f0 = hslider("[2] Band Start Frequency [unit:Hz]",100,20,10000,1);
    bw = hslider("[3] Band Width [unit:Hz]",5000,100,10000,1);
};


//---------`(dm.)mth_octave_filterbank_demo` and `(dm.)filterbank_demo`-------------
// Graphic Equalizer: Each filter-bank output signal routes through a fader.
//
// #### Usage
//
// ```
// _ : mth_octave_filterbank_demo(M) : _
// _ : filterbank_demo : _
// ```
//
// Where:
//
// * `M`: number of bands per octave
//--------------------------------------------------------------
mth_octave_filterbank_demo(O) = bp1(bp,mthoctavefilterbankdemo)
with{
    M = O;
    bp1 = ba.bypass1;
    mofb_group(x) = vgroup("CONSTANT-Q FILTER BANK (Butterworth dyadic tree)
        [tooltip: See Faust's filters.lib for documentation and references]", x);
    bypass_group(x) = mofb_group(hgroup("[0]", x));
    slider_group(x)     = mofb_group(hgroup("[1]", x));

    N = 10*M; // total number of bands (highpass band, octave-bands, dc band)
    ftop = 10000;
    mthoctavefilterbankdemo = chan;
    chan = fi.mth_octave_filterbank_default(M,ftop,N) : sum(i,N,(*(ba.db2linear(fader(N-i)))));
    fader(i) = slider_group(vslider("Band%2i [unit:dB] [tooltip: Bandpass filter
        gain in dB]", -10, -70, 10, 0.1)) : si.smoo;
    bp = bypass_group(checkbox("[0] Bypass
        [tooltip: When this is checked, the filter-bank has no effect]"));
};

filterbank_demo = mth_octave_filterbank_demo(1); // octave-bands = default


//======================================Effects===========================================
//========================================================================================

//---------------------------`(dm.)cubicnl_demo`--------------------------
// Distortion demo application.
//
// #### Usage:
//
// ```
// _ : cubicnl_demo : _
// ```
//------------------------------------------------------------
// Author: Julius Smith
// License: MIT
cubicnl_demo = ba.bypass1(bp, ef.cubicnl_nodc(drive:si.smoo,offset:si.smoo))
with{
    cnl_group(x)  = vgroup("CUBIC NONLINEARITY cubicnl [tooltip: Reference:
        https://ccrma.stanford.edu/~jos/pasp/Cubic_Soft_Clipper.html]", x);
    bp = cnl_group(checkbox("[0] Bypass [tooltip: When this is checked, the
        nonlinearity has no effect]"));
    drive = cnl_group(hslider("[1] Drive [tooltip: Amount of distortion]",
        0, 0, 1, 0.01));
    offset = cnl_group(hslider("[2] Offset [tooltip: Brings in even harmonics]",
        0, 0, 1, 0.01));
};


//----------------------------`(dm.)gate_demo`-------------------------
// Gate demo application.
//
// #### Usage
//
// ```
// _,_ : gate_demo : _,_
// ```
//------------------------------------------------------------
// Author: Julius Smith
// License: MIT
gate_demo = ba.bypass2(gbp,gate_stereo_demo)
with{
    gate_group(x) = vgroup("GATE  [tooltip: Reference:
        http://en.wikipedia.org/wiki/Noise_gate]", x);
    meter_group(x) = gate_group(hgroup("[0]", x));
    knob_group(x) = gate_group(hgroup("[1]", x));

    gbp = meter_group(checkbox("[0] Bypass    [tooltip: When this is checked,
        the gate has no effect]"));

    gateview = ef.gate_gain_mono(gatethr,gateatt,gatehold,gaterel) : ba.linear2db :
    meter_group(hbargraph("[1] Gate Gain [unit:dB] [tooltip: Current gain of the
    gate in dB]", -50,+10)); // [style:led]

    gate_stereo_demo(x,y) = attach(x,gateview(abs(x)+abs(y))),y :
    ef.gate_stereo(gatethr,gateatt,gatehold,gaterel);

    gatethr = knob_group(hslider("[1] Threshold [unit:dB] [style:knob] [tooltip: When
        the signal level falls below the Threshold (expressed in dB), the signal is
        muted]", -30, -120, 0, 0.1));

    gateatt = knob_group(hslider("[2] Attack [unit:us] [style:knob] [scale:log]
    [tooltip: Time constant in MICROseconds (1/e smoothing time) for the gate
    gain to go (exponentially) from 0 (muted) to 1 (unmuted)]",
    10, 10, 10000, 1)) : *(0.000001) : max(1.0/float(ma.SR));

    gatehold = knob_group(hslider("[3] Hold [unit:ms] [style:knob] [scale:log]
    [tooltip: Time in ms to keep the gate open (no muting) after the signal
    level falls below the Threshold]", 200, 1, 1000, 1)) : *(0.001) :
    max(1.0/float(ma.SR));

    gaterel = knob_group(hslider("[4] Release [unit:ms] [style:knob] [scale:log]
    [tooltip: Time constant in ms (1/e smoothing time) for the gain to go
    (exponentially) from 1 (unmuted) to 0 (muted)]",
    100, 1, 1000, 1)) : *(0.001) : max(1.0/float(ma.SR));
};


//----------------------------`(dm.)compressor_demo`-------------------------
// Compressor demo application.
//
// #### Usage
//
// ```
// _,_ : compressor_demo : _,_
// ```
//------------------------------------------------------------
// Author: Julius Smith
// License: MIT
compressor_demo = ba.bypass2(cbp,compressor_stereo_demo)
with{
    comp_group(x) = vgroup("COMPRESSOR [tooltip: Reference:
        http://en.wikipedia.org/wiki/Dynamic_range_compression]", x);

    meter_group(x)    = comp_group(hgroup("[0]", x));
    knob_group(x)  = comp_group(hgroup("[1]", x));

    cbp = meter_group(checkbox("[0] Bypass    [tooltip: When this is checked, the compressor
        has no effect]"));
    gainview = co.compression_gain_mono(ratio,threshold,attack,release) : ba.linear2db :
    meter_group(hbargraph("[1] Compressor Gain [unit:dB] [tooltip: Current gain of
    the compressor in dB]",-50,+10));

    displaygain = _,_ <: _,_,(abs,abs:+) : _,_,gainview : _,attach;

    compressor_stereo_demo =
    displaygain(co.compressor_stereo(ratio,threshold,attack,release)) :
    *(makeupgain), *(makeupgain);

    ctl_group(x) = knob_group(hgroup("[3] Compression Control", x));

    ratio = ctl_group(hslider("[0] Ratio [style:knob]
    [tooltip: A compression Ratio of N means that for each N dB increase in input
    signal level above Threshold, the output level goes up 1 dB]",
    5, 1, 20, 0.1));

    threshold = ctl_group(hslider("[1] Threshold [unit:dB] [style:knob]
    [tooltip: When the signal level exceeds the Threshold (in dB), its level
    is compressed according to the Ratio]",
    -30, -100, 10, 0.1));

    env_group(x) = knob_group(hgroup("[4] Compression Response", x));

    attack = env_group(hslider("[1] Attack [unit:ms] [style:knob] [scale:log]
    [tooltip: Time constant in ms (1/e smoothing time) for the compression gain
    to approach (exponentially) a new lower target level (the compression
    `kicking in')]", 50, 1, 1000, 0.1)) : *(0.001) : max(1/ma.SR);

    release = env_group(hslider("[2] Release [unit:ms] [style: knob] [scale:log]
    [tooltip: Time constant in ms (1/e smoothing time) for the compression gain
    to approach (exponentially) a new higher target level (the compression
    'releasing')]", 500, 1, 1000, 0.1)) : *(0.001) : max(1/ma.SR);

    makeupgain = comp_group(hslider("[5] Makeup Gain [unit:dB]
    [tooltip: The compressed-signal output level is increased by this amount
    (in dB) to make up for the level lost due to compression]",
    40, -96, 96, 0.1)) : ba.db2linear;
};


//-------------------------`(dm.)moog_vcf_demo`---------------------------
// Illustrate and compare all three Moog VCF implementations above.
//
// #### Usage
//
// ```
// _ : moog_vcf_demo : _
// ```
//------------------------------------------------------------
// Author: Julius Smith
// License: MIT
moog_vcf_demo = ba.bypass1(bp,vcf)
with{
    mvcf_group(x) = hgroup("MOOG VCF (Voltage Controlled Filter) [tooltip: See Faust's
        vaeffects.lib for info and references]",x);
    cb_group(x) = mvcf_group(hgroup("[0]",x));

    bp = cb_group(checkbox("[0] Bypass  [tooltip: When this is checked, the Moog VCF
        has no effect]"));
    archsw = cb_group(checkbox("[1] Use Biquads [tooltip: Select moog_vcf_2b (two-biquad)
        implementation, instead of the default moog_vcf (analog style) implementation]"));
    bqsw = cb_group(checkbox("[2] Normalized Ladders [tooltip: If using biquads, make
        them normalized ladders (moog_vcf_2bn)]"));

    freq = mvcf_group(hslider("[1] Corner Frequency [unit:PK] [tooltip: The VCF resonates
        at the corner frequency (specified in PianoKey (PK) units, with A440 = 49 PK).
        The VCF response is flat below the corner frequency, and rolls off -24 dB per
        octave above.]",
        25, 1, 88, 0.01) : ba.pianokey2hz) : si.smoo;

    res = mvcf_group(hslider("[2] Corner Resonance [style:knob] [tooltip: Amount of
        resonance near VCF corner frequency (specified between 0 and 1)]", 0.9, 0, 1, 0.01));

    outgain = mvcf_group(hslider("[3] VCF Output Level [unit:dB] [style:knob] [tooltip:
        output level in decibels]", 5, -60, 20, 0.1)) : ba.db2linear : si.smoo;

    vcfbq = _ <: select2(bqsw, ve.moog_vcf_2b(res,freq), ve.moog_vcf_2bn(res,freq));
    vcfarch = _ <: select2(archsw, ve.moog_vcf(res^4,freq), vcfbq);
    vcf = vcfarch : *(outgain);
};


//-------------------------`(dm.)wah4_demo`---------------------------
// Wah pedal application.
//
// #### Usage
//
// ```
// _ : wah4_demo : _
// ```
//------------------------------------------------------------
// Author: Julius Smith
// License: MIT
wah4_demo = ba.bypass1(bp, ve.wah4(fr))
with{
    wah4_group(x) = hgroup("WAH4 [tooltip: Fourth-order wah effect made using moog_vcf]", x);
    bp = wah4_group(checkbox("[0] Bypass [tooltip: When this is checked, the wah pedal has
        no effect]"));
    fr = wah4_group(hslider("[1] Resonance Frequency [scale:log] [tooltip: wah resonance
        frequency in Hz]", 200,100,2000,1));
    // Avoid dc with the moog_vcf (amplitude too high when freq comes up from dc)
    // Also, avoid very high resonance frequencies (e.g., 5kHz or above).
};

//-------------------------`(dm.)crybaby_demo`---------------------------
// Crybaby effect application.
//
// #### Usage
//
// ```
// _ : crybaby_demo : _
// ```
//------------------------------------------------------------
// Author: Julius Smith
// License: MIT
crybaby_demo = ba.bypass1(bp, ve.crybaby(wah))
with{
    crybaby_group(x) = hgroup("CRYBABY [tooltip: Reference:
        https://ccrma.stanford.edu/~jos/pasp/vegf.html]", x);
    bp = crybaby_group(checkbox("[0] Bypass [tooltip: When this is checked, the wah
        pedal has no effect]"));
    wah = crybaby_group(hslider("[1] Wah parameter [tooltip: wah pedal angle between
        0 (rocked back) and 1 (rocked forward)]",0.8,0,1,0.01));
};

//-------------------------`(dm.)flanger_demo`---------------------------
// Flanger effect application.
//
// #### Usage
//
// ```
// _,_ : flanger_demo : _,_
// ```
//------------------------------------------------------------
// Author: Julius Smith
// License: MIT
flanger_demo = ba.bypass2(fbp,flanger_stereo_demo)
with{
    flanger_group(x) = vgroup("FLANGER
        [tooltip: Reference: https://ccrma.stanford.edu/~jos/pasp/Flanging.html]", x);
    meter_group(x) = flanger_group(hgroup("[0]", x));
    ctl_group(x)  = flanger_group(hgroup("[1]", x));
    del_group(x)  = flanger_group(hgroup("[2] Delay Controls", x));
    lvl_group(x)  = flanger_group(hgroup("[3]", x));

    fbp = meter_group(checkbox("[0] Bypass    [tooltip: When this is checked, the flanger
        has no effect]"));
    invert = meter_group(checkbox("[1] Invert Flange Sum"));

    // FIXME: This should be an amplitude-response display:
    flangeview = lfor(freq) + lfol(freq) : meter_group(hbargraph("[2] Flange LFO
        [style: led] [tooltip: Display sum of flange delays]", -1.5,+1.5));

    flanger_stereo_demo(x,y) = attach(x,flangeview),y :
        *(level),*(level) : pf.flanger_stereo(dmax,curdel1,curdel2,depth,fb,invert);

    lfol = os.oscrs;
    lfor = os.oscrc;

    dmax = 2048;
    dflange = 0.001 * ma.SR *
        del_group(hslider("[1] Flange Delay [unit:ms] [style:knob]", 10, 0, 20, 0.001));
    odflange = 0.001 * ma.SR *
    del_group(hslider("[2] Delay Offset [unit:ms] [style:knob]", 1, 0, 20, 0.001));
    freq   = ctl_group(hslider("[1] Speed [unit:Hz] [style:knob]", 0.5, 0, 10, 0.01));
    depth  = ctl_group(hslider("[2] Depth [style:knob]", 1, 0, 1, 0.001));
    fb     = ctl_group(hslider("[3] Feedback [style:knob]", 0, -0.999, 0.999, 0.001));
    level  = lvl_group(hslider("Flanger Output Level [unit:dB]", 0, -60, 10, 0.1)) :
        ba.db2linear;
    curdel1 = odflange+dflange*(1 + lfol(freq))/2;
    curdel2 = odflange+dflange*(1 + lfor(freq))/2;
};


//-------------------------`(dm.)phaser2_demo`---------------------------
// Phaser effect demo application.
//
// #### Usage
//
// ```
// _,_ : phaser2_demo : _,_
// ```
//------------------------------------------------------------
// Author: Julius Smith
// License: MIT
phaser2_demo = ba.bypass2(pbp,phaser2_stereo_demo)
with{
    phaser2_group(x) = vgroup("PHASER2 [tooltip: Reference:
        https://ccrma.stanford.edu/~jos/pasp/Flanging.html]", x);
    meter_group(x) = phaser2_group(hgroup("[0]", x));
    ctl_group(x)  = phaser2_group(hgroup("[1]", x));
    nch_group(x)  = phaser2_group(hgroup("[2]", x));
    lvl_group(x)  = phaser2_group(hgroup("[3]", x));

    pbp = meter_group(checkbox("[0] Bypass    [tooltip: When this is checked, the phaser
        has no effect]"));
    invert = meter_group(checkbox("[1] Invert Internal Phaser Sum"));
    vibr = meter_group(checkbox("[2] Vibrato Mode")); // In this mode you can hear any "Doppler"

    // FIXME: This should be an amplitude-response display:
    // flangeview = phaser2_amp_resp : meter_group(hspectrumview("[2] Phaser Amplitude Response", 0,1));
    // phaser2_stereo_demo(x,y) = attach(x,flangeview),y : ...

    phaser2_stereo_demo = *(level),*(level) :
        pf.phaser2_stereo(Notches,width,frqmin,fratio,frqmax,speed,mdepth,fb,invert);

    Notches = 4; // Compile-time parameter: 2 is typical for analog phaser stomp-boxes

    // FIXME: Add tooltips
    speed  = ctl_group(hslider("[1] Speed [unit:Hz] [style:knob]", 0.5, 0, 10, 0.001));
    depth  = ctl_group(hslider("[2] Notch Depth (Intensity) [style:knob]", 1, 0, 1, 0.001));
    fb     = ctl_group(hslider("[3] Feedback Gain [style:knob]", 0, -0.999, 0.999, 0.001));

    width  = nch_group(hslider("[1] Notch width [unit:Hz] [style:knob] [scale:log]",
        1000, 10, 5000, 1));
    frqmin = nch_group(hslider("[2] Min Notch1 Freq [unit:Hz] [style:knob] [scale:log]",
        100, 20, 5000, 1));
    frqmax = nch_group(hslider("[3] Max Notch1 Freq [unit:Hz] [style:knob] [scale:log]",
        800, 20, 10000, 1)) : max(frqmin);
    fratio = nch_group(hslider("[4] Notch Freq Ratio: NotchFreq(n+1)/NotchFreq(n) [style:knob]",
        1.5, 1.1, 4, 0.001));

    level  = lvl_group(hslider("Phaser Output Level [unit:dB]", 0, -60, 10, 0.1)) :
        ba.db2linear;

    mdepth = select2(vibr,depth,2); // Improve "ease of use"
};

//======================================Reverbs===========================================
//========================================================================================

//----------------------------`(dm.)freeverb_demo`-------------------------
// Freeverb demo application.
//
// #### Usage
//
// ```
// _,_ : freeverb_demo : _,_
// ```
//------------------------------------------------------------
// Author: Romain Michon
// License: LGPL
freeverb_demo = _,_ <: (*(g)*fixedgain,*(g)*fixedgain :
    re.stereo_freeverb(combfeed, allpassfeed, damping, spatSpread)),
    *(1-g), *(1-g) :> _,_
with{
    scaleroom   = 0.28;
    offsetroom  = 0.7;
    allpassfeed = 0.5;
    scaledamp   = 0.4;
    fixedgain   = 0.1;
    origSR = 44100;

    parameters(x) = hgroup("Freeverb",x);
    knobGroup(x) = parameters(vgroup("[0]",x));
    damping = knobGroup(vslider("[0] Damp [style: knob] [tooltip: Somehow control the
        density of the reverb.]",0.5, 0, 1, 0.025)*scaledamp*origSR/ma.SR);
    combfeed = knobGroup(vslider("[1] RoomSize [style: knob] [tooltip: The room size
        between 0 and 1 with 1 for the largest room.]", 0.5, 0, 1, 0.025)*scaleroom*
        origSR/ma.SR + offsetroom);
    spatSpread = knobGroup(vslider("[2] Stereo Spread [style: knob] [tooltip: Spatial
        spread between 0 and 1 with 1 for maximum spread.]",0.5,0,1,0.01)*46*ma.SR/origSR
        : int);
    g = parameters(vslider("[1] Wet [tooltip: The amount of reverb applied to the signal
        between 0 and 1 with 1 for the maximum amount of reverb.]", 0.3333, 0, 1, 0.025));
};

//---------------------`(dm.)stereo_reverb_tester`--------------------
// Handy test inputs for reverberator demos below.
//
// #### Usage
//
// ```
// _ : stereo_reverb_tester : _
// ```
//------------------------------------------------------------
// Author: Julius Smith
// License: MIT
stereo_reverb_tester(revin_group,x,y) = reverb_tester(_)
with {
    reverb_tester(revin_group,x,y) = inx,iny with {
        ck_group(x) = revin_group(vgroup("[1] Input Config",x));
        mutegain = 1 - ck_group(checkbox("[1] Mute Ext Inputs
        [tooltip: When this is checked, the stereo external audio inputs are
        disabled (good for hearing the impulse response or pink-noise response alone)]"));
        pinkin = ck_group(checkbox("[2] Pink Noise
        [tooltip: Pink Noise (or 1/f noise) is Constant-Q Noise (useful for adjusting
        the EQ sections)]"));

        imp_group(x) = revin_group(hgroup("[2] Impulse Selection",x));
        pulseL =  imp_group(button("[1] Left
        [tooltip: Send impulse into LEFT channel]")) : ba.impulsify;
        pulseC =  imp_group(button("[2] Center
        [tooltip: Send impulse into LEFT and RIGHT channels]")) : ba.impulsify;
        pulseR = imp_group(button("[3] Right
        [tooltip: Send impulse into RIGHT channel]")) : ba.impulsify;

        inx = x*mutegain + (pulseL+pulseC) + pn;
        iny = y*mutegain + (pulseR+pulseC) + pn;
        pn = 0.1*pinkin*no.pink_noise;
    };
};


//-------------------------`(dm.)fdnrev0_demo`---------------------------
// A reverb application using `fdnrev0`.
//
// #### Usage
//
// ```
// _,_ : fdnrev0_demo(N,NB,BBSO) : _,_
// ```
//
// Where:
//
// * `n`: Feedback Delay Network (FDN) order / number of delay lines used =
//    order of feedback matrix / 2, 4, 8, or 16 [extend primes array below for
//    32, 64, ...]
// * `nb`: Number of frequency bands / Number of (nearly) independent T60 controls
//    / Integer 3 or greater
// * `bbso` = Butterworth band-split order / order of lowpass/highpass bandsplit
//    used at each crossover freq / odd positive integer
//------------------------------------------------------------
// Author: Julius Smith
// License: MIT
fdnrev0_demo(N,NB,BBSO) = stereo_reverb_tester(revin_group)
      <: re.fdnrev0(MAXDELAY,delays,BBSO,freqs,durs,loopgainmax,nonl)
      :> *(gain),*(gain)
with{
    MAXDELAY = 8192; // sync w delays and prime_power_delays above
    defdurs = (8.4,6.5,5.0,3.8,2.7); // NB default durations (sec)
    deffreqs = (500,1000,2000,4000); // NB-1 default crossover frequencies (Hz)
    deflens = (56.3,63.0); // 2 default min and max path lengths

    fdn_group(x)  = vgroup("FEEDBACK DELAY NETWORK (FDN) REVERBERATOR, ORDER 16
    [tooltip: See Faust's reverbs.lib for documentation and references]", x);

    freq_group(x)  = fdn_group(vgroup("[1] Band Crossover Frequencies", x));
    t60_group(x)  = fdn_group(hgroup("[2] Band Decay Times (T60)", x));
    path_group(x)  = fdn_group(vgroup("[3] Room Dimensions", x));
    revin_group(x)    = fdn_group(hgroup("[4] Input Controls", x));
    nonl_group(x) = revin_group(vgroup("[4] Nonlinearity",x));
    quench_group(x) = revin_group(vgroup("[3] Reverb State",x));

    nonl = nonl_group(hslider("[style:knob] [tooltip: nonlinear mode coupling]",
        0, -0.999, 0.999, 0.001));
    loopgainmax = 1.0-0.5*quench_group(button("[1] Quench
        [tooltip: Hold down 'Quench' to clear the reverberator]"));

    pathmin = path_group(hslider("[1] min acoustic ray length [unit:m] [scale:log]
    [tooltip: This length (in meters) determines the shortest delay-line used in the FDN
    reverberator. Think of it as the shortest wall-to-wall separation in the room.]",
    46, 0.1, 63, 0.1));
    pathmax = path_group(hslider("[2] max acoustic ray length [unit:m] [scale:log]
        [tooltip: This length (in meters) determines the longest delay-line used in the
        FDN reverberator. Think of it as the largest wall-to-wall separation in the room.]",
    63, 0.1, 63, 0.1));

    durvals(i) = t60_group(vslider("[%i] %i [unit:s] [scale:log][tooltip: T60 is the 60dB
        decay-time in seconds. For concert halls, an overall reverberation time (T60) near
        1.9 seconds is typical [Beranek 2004]. Here we may set T60 independently in each
        frequency band.     In real rooms, higher frequency bands generally decay faster due
        to absorption and scattering.]",ba.take(i+1,defdurs), 0.1, 100, 0.1));
    durs = par(i,NB,durvals(NB-1-i));

    freqvals(i) = freq_group(hslider("[%i] Band %i upper edge in Hz [unit:Hz] [scale:log]
    [tooltip: Each delay-line signal is split into frequency-bands for separate
    decay-time control in each band]",ba.take(i+1,deffreqs), 100, 10000, 1));
    freqs = par(i,NB-1,freqvals(i));

    delays = de.prime_power_delays(N,pathmin,pathmax);

    gain = hslider("[3] Output Level (dB) [unit:dB][tooltip: Output scale factor]",
        -40, -70, 20, 0.1) : ba.db2linear;
    // (can cause infinite loop:) with { db2linear(x) = pow(10, x/20.0); };
};

//---------------------------`(dm.)zita_rev_fdn_demo`------------------------------
// Reverb demo application based on `zita_rev_fdn`.
//
// #### Usage
//
// ```
// si.bus(8) : zita_rev_fdn_demo : si.bus(8)
// ```
//------------------------------------------------------------
// Author: Julius Smith
// License: MIT
zita_rev_fdn_demo = re.zita_rev_fdn(f1,f2,t60dc,t60m,fsmax)
with{
    fsmax = 48000.0;
    fdn_group(x) = hgroup("Zita_Rev Internal FDN Reverb [tooltip: ~ Zita_Rev's internal
        8x8 Feedback Delay Network (FDN) & Schroeder allpass-comb reverberator.     See
        Faust's reverbs.lib for documentation and references]",x);
    t60dc = fdn_group(vslider("[1] Low RT60 [unit:s] [style:knob][style:knob]
    [tooltip: T60 = time (in seconds) to decay 60dB in low-frequency band]",
    3, 1, 8, 0.1));
    f1 = fdn_group(vslider("[2] LF X [unit:Hz] [style:knob] [scale:log]
    [tooltip: Crossover frequency (Hz) separating low and middle frequencies]",
    200, 50, 1000, 1));
    t60m = fdn_group(vslider("[3] Mid RT60 [unit:s] [style:knob] [scale:log]
    [tooltip: T60 = time (in seconds) to decay 60dB in middle band]",
    2, 1, 8, 0.1));
    f2 = fdn_group(vslider("[4] HF Damping [unit:Hz] [style:knob] [scale:log]
    [tooltip: Frequency (Hz) at which the high-frequency T60 is half the middle-band's T60]",
    6000, 1500, 0.49*fsmax, 1));
};

//---------------------------`(dm.)zita_light`------------------------------
// Light version of `dm.zita_rev1` with only 2 UI elements.
//
// #### Usage
//
// ```
// _,_ : zita_light : _,_
// ```
//------------------------------------------------------------
// Author: Julius Smith
// License: MIT
zita_light = hgroup("Zita Light",(_,_ <: re.zita_rev1_stereo(rdel,f1,f2,t60dc,t60m,fsmax),_,_ : 
    out_eq,_,_ : dry_wet : out_level))
with{
    fsmax = 48000.0;  // highest sampling rate that will be used
    rdel = 60;    
    f1 = 200;
    t60dc = 3;
    t60m = 2;
    f2 = 6000;
    out_eq = pareq_stereo(eq1f,eq1l,eq1q) : pareq_stereo(eq2f,eq2l,eq2q);
    pareq_stereo(eqf,eql,Q) = fi.peak_eq_rm(eql,eqf,tpbt), fi.peak_eq_rm(eql,eqf,tpbt)
    with {
        tpbt = wcT/sqrt(max(0,g)); // tan(PI*B/SR), B bw in Hz (Q^2 ~ g/4)
        wcT = 2*ma.PI*eqf/ma.SR;  // peak frequency in rad/sample
        g = ba.db2linear(eql); // peak gain
    };
    eq1f = 315;
    eq1l = 0;
    eq1q = 3;
    eq2f = 1500;
    eq2l = 0;
    eq2q = 3;
    dry_wet(x,y) = *(wet) + dry*x, *(wet) + dry*y 
    with {
        wet = 0.5*(drywet+1.0);
        dry = 1.0-wet;
    };
    drywet = vslider("[1] Dry/Wet Mix [style:knob] [tooltip: -1 = dry, 1 = wet]",
        0,-1.0,1.0,0.01) : si.smoo;
    gain = vslider("[2] Level [unit:dB] [style:knob] [tooltip: Output scale
        factor]", -6, -70, 40, 0.1) : ba.db2linear : si.smoo;
    out_level = *(gain),*(gain);
};

//----------------------------------`(dm.)zita_rev1`------------------------------
// Example GUI for `zita_rev1_stereo` (mostly following the Linux `zita-rev1` GUI).
//
// Only the dry/wet and output level parameters are "dezippered" here. If
// parameters are to be varied in real time, use `smooth(0.999)` or the like
// in the same way.
//
// #### Usage
//
// ```
// _,_ : zita_rev1 : _,_
// ```
//
// #### Reference
//
// <http://www.kokkinizita.net/linuxaudio/zita-rev1-doc/quickguide.html>
//------------------------------------------------------------
// Author: Julius Smith
// License: MIT
zita_rev1 = _,_ <: re.zita_rev1_stereo(rdel,f1,f2,t60dc,t60m,fsmax),_,_ : out_eq,_,_ :
    dry_wet : out_level
with{
    fsmax = 48000.0;  // highest sampling rate that will be used

    fdn_group(x) = hgroup(
    "[0] Zita_Rev1 [tooltip: ~ ZITA REV1 FEEDBACK DELAY NETWORK (FDN) & SCHROEDER
    ALLPASS-COMB REVERBERATOR (8x8). See Faust's reverbs.lib for documentation and
    references]", x);

    in_group(x) = fdn_group(hgroup("[1] Input", x));

    rdel = in_group(vslider("[1] In Delay [unit:ms] [style:knob] [tooltip: Delay in ms
        before reverberation begins]",60,20,100,1));

    freq_group(x) = fdn_group(hgroup("[2] Decay Times in Bands (see tooltips)", x));

    f1 = freq_group(vslider("[1] LF X [unit:Hz] [style:knob] [scale:log] [tooltip:
        Crossover frequency (Hz) separating low and middle frequencies]", 200, 50, 1000, 1));

    t60dc = freq_group(vslider("[2] Low RT60 [unit:s] [style:knob] [scale:log]
    [style:knob] [tooltip: T60 = time (in seconds) to decay 60dB in low-frequency band]",
    3, 1, 8, 0.1));

    t60m = freq_group(vslider("[3] Mid RT60 [unit:s] [style:knob] [scale:log] [tooltip:
        T60 = time (in seconds) to decay 60dB in middle band]",2, 1, 8, 0.1));

    f2 = freq_group(vslider("[4] HF Damping [unit:Hz] [style:knob] [scale:log]
    [tooltip: Frequency (Hz) at which the high-frequency T60 is half the middle-band's T60]",
    6000, 1500, 0.49*fsmax, 1));

    out_eq = pareq_stereo(eq1f,eq1l,eq1q) : pareq_stereo(eq2f,eq2l,eq2q);
    // Zolzer style peaking eq (not used in zita-rev1) (filters.lib):
    // pareq_stereo(eqf,eql,Q) = peak_eq(eql,eqf,eqf/Q), peak_eq(eql,eqf,eqf/Q);
    // Regalia-Mitra peaking eq with "Q" hard-wired near sqrt(g)/2 (filters.lib):
    pareq_stereo(eqf,eql,Q) = fi.peak_eq_rm(eql,eqf,tpbt), fi.peak_eq_rm(eql,eqf,tpbt)
    with {
        tpbt = wcT/sqrt(max(0,g)); // tan(PI*B/SR), B bw in Hz (Q^2 ~ g/4)
        wcT = 2*ma.PI*eqf/ma.SR;  // peak frequency in rad/sample
        g = ba.db2linear(eql); // peak gain
    };

    eq1_group(x) = fdn_group(hgroup("[3] RM Peaking Equalizer 1", x));

    eq1f = eq1_group(vslider("[1] Eq1 Freq [unit:Hz] [style:knob] [scale:log] [tooltip:
        Center-frequency of second-order Regalia-Mitra peaking equalizer section 1]",
    315, 40, 2500, 1));

    eq1l = eq1_group(vslider("[2] Eq1 Level [unit:dB] [style:knob] [tooltip: Peak level
        in dB of second-order Regalia-Mitra peaking equalizer section 1]", 0, -15, 15, 0.1));

    eq1q = eq1_group(vslider("[3] Eq1 Q [style:knob] [tooltip: Q = centerFrequency/bandwidth
        of second-order peaking equalizer section 1]", 3, 0.1, 10, 0.1));

    eq2_group(x) = fdn_group(hgroup("[4] RM Peaking Equalizer 2", x));

    eq2f = eq2_group(vslider("[1] Eq2 Freq [unit:Hz] [style:knob] [scale:log] [tooltip:
        Center-frequency of second-order Regalia-Mitra peaking equalizer section 2]",
    1500, 160, 10000, 1));

    eq2l = eq2_group(vslider("[2] Eq2 Level [unit:dB] [style:knob] [tooltip: Peak level
        in dB of second-order Regalia-Mitra peaking equalizer section 2]", 0, -15, 15, 0.1));

    eq2q = eq2_group(vslider("[3] Eq2 Q [style:knob] [tooltip: Q = centerFrequency/bandwidth
        of second-order peaking equalizer section 2]", 3, 0.1, 10, 0.1));

    out_group(x) = fdn_group(hgroup("[5] Output", x));

    dry_wet(x,y) = *(wet) + dry*x, *(wet) + dry*y with {
        wet = 0.5*(drywet+1.0);
        dry = 1.0-wet;
    };

    drywet = out_group(vslider("[1] Dry/Wet Mix [style:knob] [tooltip: -1 = dry, 1 = wet]",
    0, -1.0, 1.0, 0.01)) : si.smoo;

    out_level = *(gain),*(gain);

    gain = out_group(vslider("[2] Level [unit:dB] [style:knob] [tooltip: Output scale
        factor]", -20, -70, 40, 0.1)) : ba.db2linear : si.smoo;
};

//----------------------------------`(dm.)dattorro_rev_demo`------------------------------
// Example GUI for `dattorro_rev` with all parameters exposed. With additional
// dry/wet and output gain control.
//
// #### Usage
//
// ```
// _,_ : dattorro_rev_demo : _,_
// ```
//
//------------------------------------------------------------
// Author: Jakob Zerbian
// License: MIT-style STK-4.3 license

declare dattorro_rev_demo author "Jakob Zerbian";
declare dattorro_rev_demo license "MIT-style STK-4.3 license";

dattorro_rev_demo = _,_ <: re.dattorro_rev(pre_delay, bw, i_diff1, i_diff2, decay, d_diff1, d_diff2, damping),_,_:
    dry_wet : out_level
with {
    rev_group(x) = hgroup("[0] Dattorro Reverb",x);

    in_group(x) = rev_group(hgroup("[0] Input",x));
    pre_delay = 0;
    bw = in_group(vslider("[1] Prefilter [style:knob] [tooltip: lowpass-like filter, 0 = no signal, 1 = no filtering]",0.7,0.0,1.0,0.001) : si.smoo);
    i_diff1 = in_group(vslider("[2] Diffusion 1 [style:knob] [tooltip: diffusion factor, influences reverb color and density]",0.625,0.0,1.0,0.001) : si.smoo);
    i_diff2 = in_group(vslider("[3] Diffusion 2 [style:knob] [tooltip: diffusion factor, influences reverb color and density]",0.625,0.0,1.0,0.001) : si.smoo);

    fdb_group(x) = rev_group(hgroup("[1] Feedback",x));
    d_diff1 = fdb_group(vslider("[1] Diffusion 1 [style:knob] [tooltip: diffusion factor, influences reverb color and density]",0.625,0.0,1.0,0.001) : si.smoo);
    d_diff2 = fdb_group(vslider("[2] Diffusion 2 [style:knob] [tooltip: diffusion factor, influences reverb color and density]",0.625,0.0,1.0,0.001) : si.smoo);
    decay = fdb_group(vslider("[3] Decay Rate [style:knob] [tooltip: decay length, 1 = infinite]",0.7,0.0,1.0,0.001) : si.smoo);
    damping = fdb_group(vslider("[4] Damping [style:knob] [tooltip: dampening in feedback network]",0.625,0.0,1.0,0.001) : si.smoo);

    out_group(x) = rev_group(hgroup("[2] Output",x));
    dry_wet(x,y) = *(dry) + wet*x, *(dry) + wet*y 
    with {
        wet = 0.5*(drywet+1.0);
        dry = 1.0-wet;
    };
    drywet = out_group(vslider("[1] Dry/Wet Mix [style:knob] [tooltip: -1 = dry, 1 = wet]",0,-1.0,1.0,0.01) : si.smoo);
    gain = out_group(vslider("[2] Level [unit:dB] [style:knob] [tooltip: Output Gain]", -6, -70, 40, 0.1) : ba.db2linear : si.smoo);
    out_level = *(gain),*(gain);
};

//----------------------------------`(dm.)jprev_demo`------------------------------
// Example GUI for `jprev` with all parameters exposed. 
//
// #### Usage
//
// ```
// _,_ : jprev_demo : _,_
// ```
//
//------------------------------------------------------------
// Author: Till Bovermann
// License: GPL2+

declare jprev_demo author "Till Bovermann";
declare jprev_demo license "GPL2+";

jprev_demo = re.jpverb(t60, damp, size, early_diff, mod_depth, mod_freq, low, mid, high, low_cutoff, high_cutoff)
with {
    rev_group(x) = vgroup("[0] JPrev",x);
    
    mix_group(x) = rev_group(hgroup("[0] Mix",x));
    early_diff = mix_group(hslider("[1]earlyDiff [style:knob]", 0.707, 0, 0.990, 0.001));
    size = mix_group(hslider("[2]size [style:knob]", 1, 0.5, 3, 0.01));
    t60 = mix_group(hslider("[3]t60 [style:knob]", 1, 0.1, 60, 0.1));
    damp = mix_group(hslider("[4]damp [style:knob]", 0, 0, 0.999, 0.0001));
    
    eq_group(x) = rev_group(hgroup("[1] EQ",x));
    low = eq_group(hslider("[07]lowX [style:knob]", 1, 0, 1, 0.01));
    mid = eq_group(hslider("[08]midX [style:knob]", 1, 0, 1, 0.01));
    high = eq_group(hslider("[09]highX [style:knob]", 1, 0, 1, 0.01));
    low_cutoff = eq_group(hslider("[10]lowBand [style:knob]", 500, 100, 6000, 0.1));
    high_cutoff = eq_group(hslider("[11]highBand [style:knob]", 2000, 1000, 10000, 0.1));
    
    mod_group(x) = rev_group(hgroup("[2] Mod",x));
    mod_depth = mod_group(hslider("[1]mDepth [style:knob]", 0.1, 0, 1, 0.001));
    mod_freq = mod_group(hslider("[2]mFreq [style:knob]", 2, 0, 10, 0.010));  
};


//----------------------------------`(dm.)greyhole_demo`------------------------------
// Example GUI for `greyhole` with all parameters exposed. 
//
// #### Usage
//
// ```
// _,_ : greyhole_demo : _,_
// ```
//
//------------------------------------------------------------
// Author: Till Bovermann
// License: GPL2+

declare greyhole_demo author "Till Bovermann";
declare greyhole_demo license "GPL2+";

greyhole_demo = re.greyhole(dt, damp, size, early_diff, feedback, mod_depth, mod_freq)
with {

    rev_group(x) = vgroup("[0] Greyhole",x);
    
    mix_group(x) = rev_group(hgroup("[0] Mix",x));
    dt = mix_group(hslider("[01]delayTime [style:knob]", 0.2, 0.001, 1.45, 0.0001));
    damp = mix_group(hslider("[02]damping [style:knob]", 0, 0, 0.99, 0.001));
    size = mix_group(hslider("[03]size [style:knob]", 1, 0.5, 3, 0.0001));
    early_diff = mix_group(hslider("[04]diffusion [style:knob]", 0.5, 0, 0.99, 0.0001));
    feedback = mix_group(hslider("[05]feedback [style:knob]", 0.9, 0, 1, 0.01));
    
    mod_group(x) = rev_group(hgroup("[1] Mod",x));
    mod_depth = mod_group(hslider("[06]modDepth [style:knob]", 0.1, 0, 1, 0.001));
    mod_freq = mod_group(hslider("[07]modFreq [style:knob]", 2, 0, 10, 0.01));
};

//====================================Generators==========================================
//========================================================================================

//--------------------------`(dm.)sawtooth_demo`---------------------------
// An application demonstrating the different sawtooth oscillators of Faust.
//
// #### Usage
//
// ```
// sawtooth_demo : _
// ```
//------------------------------------------------------------
// Author: Julius Smith
// License: MIT
sawtooth_demo = signal
with{
    osc_group(x) = vgroup("[0] SAWTOOTH OSCILLATOR [tooltip: See Faust's oscillators.lib
        for documentation and references]",x);
    knob_group(x)  = osc_group(hgroup("[1]", x));
    ampdb  = knob_group(vslider("[1] Amplitude [unit:dB] [style:knob] [tooltip: Sawtooth
        waveform amplitude]",-20,-120,10,0.1));
    amp = ampdb : ba.db2linear : si.smoo;
    freq = knob_group(vslider("[2] Frequency [unit:PK] [style:knob] [tooltip: Sawtooth
        frequency as a Piano Key (PK) number (A440 = key 49)]",49,1,88,0.01) : ba.pianokey2hz);
    detune1 = 1 + 0.01 * knob_group(
    vslider("[3] Detuning 1 [unit:%%] [style:knob] [tooltip: Percentage frequency-shift
    up or down for second oscillator]",-0.1,-10,10,0.01));
    detune2 = 1 + 0.01 * knob_group(vslider("[4] Detuning 2 [unit:%%] [style:knob] [tooltip:
        Percentage frequency-shift up or down for third detuned oscillator]",+0.1,-10,10,0.01));
    portamento = knob_group(vslider("[5] Portamento [unit:sec] [style:knob] [scale:log]
    [tooltip: Portamento (frequency-glide) time-constant in seconds]",0.1,0.001,10,0.001));
    sfreq = freq : si.smooth(ba.tau2pole(portamento));
    saworder = knob_group(nentry("[6] Saw Order [tooltip: Order of sawtootn aliasing
        suppression]",2,1,os.MAX_SAW_ORDER,1));
    sawchoice = _ <: par(i,os.MAX_SAW_ORDER,os.sawN(i+1)) :
        ba.selectn(int(os.MAX_SAW_ORDER), int(saworder-1)); // when max is pwr of 2
    tone = (amp/3) * (sawchoice(sfreq) + sawchoice(sfreq*detune1) + sawchoice(sfreq*detune2));
    signal = amp * select2(ei, select2(ss, tone, white_or_pink_noise), _);
    white_or_pink_noise = select2(wp,no.noise,no.pink_noise);
    checkbox_group(x) = knob_group(vgroup("[7] Alternate Signals",x));
    ss = checkbox_group(checkbox("[0] Noise (White or Pink - uses only Amplitude control on
        the left)"));
    wp = checkbox_group(checkbox("[1] Pink instead of White Noise (also called 1/f Noise)
        [tooltip: Pink Noise (or 1/f noise) is Constant-Q Noise, meaning that it has the
        same total power in every octave]"));
    ei = checkbox_group(checkbox("[2] External Signal Input (overrides Sawtooth/Noise
        selection above)"));
};


//----------------------`(dm.)virtual_analog_oscillator_demo`----------------------
// Virtual analog oscillator demo application.
//
// #### Usage
//
// ```
// virtual_analog_oscillator_demo : _
// ```
//------------------------------------------------------------
// Author: Julius Smith
// License: MIT
virtual_analog_oscillator_demo = signal
with{
    osc_group(x) = vgroup("[0] VIRTUAL ANALOG OSCILLATORS
        [tooltip: See Faust's oscillators.lib for documentation and references]",x);

    // Signals
    sawchoice = _ <:
    // When MAX_SAW_ORDER is a power of 2:
    par(i,os.MAX_SAW_ORDER,os.sawN(i+1)) : ba.selectn(int(os.MAX_SAW_ORDER), int(saworder-1));
    // When MAX_SAW_ORDER is NOT a power of 2:
    // (par(i,MAX_SAW_ORDER,sawN(i+1)), par(j,MAX_SAW_ORDER_NEXTPOW2-MAX_SAW_ORDER,_))
    //   : selectn(MAX_SAW_ORDER_NEXTPOW2, saworder-1);
    saw = (amp/3) *
        (sawchoice(sfreq) + sawchoice(sfreq*detune1) + sawchoice(sfreq*detune2));
    sq = (amp/3) *
    (os.square(sfreq) + os.square(sfreq*detune1) + os.square(sfreq*detune2));
    tri = (amp/3) *
    (os.triangle(sfreq) + os.triangle(sfreq*detune1) + os.triangle(sfreq*detune2));
    pt = (amp/3) * (os.pulsetrain(sfreq,ptd)
            + os.pulsetrain(sfreq*detune1,ptd)
            + os.pulsetrain(sfreq*detune2,ptd));
    ptN = (amp/3) * (os.pulsetrainN(N,sfreq,ptd)
            + os.pulsetrainN(N,sfreq*detune1,ptd)
            + os.pulsetrainN(N,sfreq*detune2,ptd)) with { N=3; };
    pn = amp * no.pink_noise;

    signal = ssaw*saw + ssq*sq + stri*tri
           + spt*((ssptN*ptN)+(1-ssptN)*pt)
           + spn*pn + sei*_;

    // Signal controls:
    signal_group(x) = osc_group(hgroup("[0] Signal Levels",x));
    ssaw = signal_group(vslider("[0] Sawtooth [style:vslider]",1,0,1,0.01));

    pt_group(x) = signal_group(vgroup("[1] Pulse Train",x));
    ssptN = pt_group(checkbox("[0] Order 3
        [tooltip: When checked, use 3rd-order aliasing suppression (up from 2)
    See if you can hear a difference with the freq high and swept]"));
    spt = pt_group(vslider("[1] [style:vslider]",0,0,1,0.01));
    ptd = pt_group(vslider("[2] Duty Cycle [style:knob]",0.5,0,1,0.01))
    : si.smooth(0.99);

    ssq = signal_group(vslider("[2] Square [style:vslider]",0,0,1,0.01));
    stri = signal_group(vslider("[3] Triangle [style:vslider]",0,0,1,0.01));
    spn = signal_group(vslider(
        "[4] Pink Noise [style:vslider][tooltip: Pink Noise (or 1/f noise) is
        Constant-Q Noise, meaning that it has the same total power in every octave
        (uses only amplitude controls)]",0,0,1,0.01));
    sei = signal_group(vslider("[5] Ext Input [style:vslider]",0,0,1,0.01));

    // Signal Parameters
    knob_group(x) = osc_group(hgroup("[1] Signal Parameters", x));
    af_group(x) = knob_group(vgroup("[0]", x));
    ampdb = af_group(hslider("[1] Mix Amplitude [unit:dB] [style:hslider]
        [tooltip: Sawtooth waveform amplitude]",-20,-120,10,0.1));
    amp = ampdb : ba.db2linear : si.smoo;
    freq = af_group(hslider("[2] Frequency [unit:PK] [style:hslider] [tooltip: Sawtooth
        frequency as a Piano Key (PK) number (A440 = key 49)]",49,1,88,0.01) : ba.pianokey2hz);

    detune1 = 1 - 0.01 * knob_group(
        vslider("[3] Detuning 1 [unit:%%] [style:knob]
    [tooltip: Percentage frequency-shift up or down for second oscillator]",
    -0.1,-10,10,0.01));
    detune2 = 1 + 0.01 * knob_group(
    vslider("[4] Detuning 2 [unit:%%] [style:knob]
    [tooltip: Percentage frequency-shift up or down for third detuned oscillator]",
    +0.1,-10,10,0.01));
    portamento = knob_group(
    vslider("[5] Portamento [unit:sec] [style:knob] [scale:log]
    [tooltip: Portamento (frequency-glide) time-constant in seconds]",
    0.1,0.001,10,0.001));
    saworder = knob_group(nentry("[6] Saw Order [tooltip: Order of sawtooth aliasing
    suppression]",2,1,os.MAX_SAW_ORDER,1));
    sfreq = freq : si.smooth(ba.tau2pole(portamento));
};


//--------------------------`(dm.)oscrs_demo` ---------------------------
// Simple application demoing filter based oscillators.
//
// #### Usage
//
// ```
// oscrs_demo : _
// ```
//-------------------------------------------------------------------
// Author: Julius Smith
// License: MIT
oscrs_demo = signal
with{
    osc_group(x) = vgroup("[0] SINE WAVE OSCILLATOR oscrs [tooltip: Sine oscillator based
        on 2D vector rotation]",x);
    ampdb  = osc_group(hslider("[1] Amplitude [unit:dB] [tooltip: Sawtooth waveform
        amplitude]",-20,-120,10,0.1));
    amp = ampdb : ba.db2linear : si.smoo;
    freq = osc_group(
        hslider("[2] Frequency [unit:PK]
    [tooltip: Sine wave frequency as a Piano Key (PK) number (A440 = 49 PK)]",
    49,1,88,0.01) : ba.pianokey2hz);
    portamento = osc_group(
    hslider("[3] Portamento [unit:sec] [scale:log]
    [tooltip: Portamento (frequency-glide) time-constant in seconds]",
    0.1,0.001,10,0.001));
    sfreq = freq : si.smooth(ba.tau2pole(portamento));
    signal = amp * os.oscrs(sfreq);
};

oscr_demo = oscrs_demo; // synonym


//--------------------------`(dm.)velvet_noise_demo`---------------------------
// Listen to velvet_noise!
//
// #### Usage
//
// ```
// velvet_noise_demo : _
// ```
//-------------------------------------------------------------------
// Author: Julius Smith
// License: MIT
velvet_noise_demo = vn
with{
    amp = hslider("Amp [unit:dB]",-10,-70,10,0.1) : ba.db2linear;
    f0 = 10.0, hslider("Freq [unit:log10(Hz)]",3,0,4,0.001) : pow;
    vn = no.velvet_noise(amp,f0);
};


//--------------------------`(dm.)latch_demo`---------------------------
// Illustrate latch operation.
//
// #### Usage
//
// ```
// echo 'import("stdfaust.lib");' > latch_demo.dsp
// echo 'process = dm.latch_demo;' >> latch_demo.dsp
// faust2octave latch_demo.dsp
// Octave:1> plot(faustout);
// ```
//-------------------------------------------------------------------
// Author: Julius Smith
// License: MIT
latch_demo = x, c, ba.latch(c,x) // plot(faustout) after faust2octave
with{
    f = float(ma.SR)/1000.0;
    x = os.oscr(f);
    c = 0.5 * os.oscrs(5*f); // sample 5 times per period
};


//--------------------------`(dm.)envelopes_demo`---------------------------
// Illustrate various envelopes overlaid, including their gate * 1.1.
//
// #### Usage
//
// ```
// echo 'import("stdfaust.lib");' > envelopes_demo.dsp
// echo 'process = dm.envelopes_demo;' >> envelopes_demo.dsp
// faust2octave envelopes_demo.dsp
// Octave:1> plot(faustout);
// ```
//-------------------------------------------------------------------
// Author: Julius Smith
// License: MIT
envelopes_demo = gate <: _*1.1,envSE,envAR,envARFE,envARE,envASR,envADSR,envADSRE
with{
    gate = (1-(1@500)) + 0.5*(1@750-(1@1700)); // retrigger at 1/2 amp
    envSE    = en.smoothEnvelope(attSec/6.91); // uses time-constant not t60
    envAR    = en.ar(attSec,relT60);
    envARFE  = en.arfe(attSec,relT60,0.25);
    envARE   = en.are(attSec,relT60);
    envASR   = en.asr(attSec,susLvl,relT60);
    envADSR  = en.adsr(attSec,decT60,susLvl,relT60);
    envADSRE = en.adsre(attSec,decT60,susLvl,relT60);
    attSec=0.002; //  2 ms attack time
    decT60=0.010; // 10 ms decay-to-sustain time
    susLvl=0.80;  // Sustain level = 0.8
    relT60=0.010; // 10 ms release (decay-to-zero) time
};

//-------------------`(dm.)fft_spectral_level_demo`------------------
// Make a real-time spectrum analyzer using FFT from analyzers.lib.
//
// #### Usage
//
// ```
// echo 'import("stdfaust.lib");' > fft_spectral_level_demo.dsp
// echo 'process = dm.fft_spectral_level_demo;' >> fft_spectral_level_demo.dsp
// Mac:
//   faust2caqt fft_spectral_level_demo.dsp
//   open fft_spectral_level_demo.app
// Linux GTK:
//   faust2jack fft_spectral_level_demo.dsp
//   ./fft_spectral_level_demo
// Linux QT:
//   faust2jaqt fft_spectral_level_demo.dsp
//   ./fft_spectral_level_demo
// ```
//-------------------------------------------------------------------
// Author: Julius Smith
// License: MIT
fft_spectral_level_demo(N) =  an.rfft_spectral_level(N,tau,dB_offset)
with{
    ctl_group(x)  = hgroup("[1] FFT SPECTRUM ANALYZER CONTROLS", x);
    tau = ctl_group(hslider("[0] Level Averaging Time [unit:ms] [scale:log]
        [tooltip: band-level averaging time in milliseconds]",
        100,1,10000,1)) * 0.001;
    dB_offset = ctl_group(hslider("[1] Level dB Offset [unit:dB]
        [tooltip: Level offset in decibels]",
        50,-50,100,1));
};

//-----------------`(dm.)reverse_echo_demo(nChans)`----------------
// Multichannel echo effect with reverse delays.
//
// #### Usage
//
// ```
// echo 'import("stdfaust.lib");' > reverse_echo_demo.dsp
// echo 'nChans = 3; // Any integer > 1 should work here' >> reverse_echo_demo.dsp
// echo 'process = dm.reverse_echo_demo(nChans);' >> reverse_echo_demo.dsp
// Mac:
//   faust2caqt reverse_echo_demo.dsp
//   open reverse_echo_demo.app
// Linux GTK:
//   faust2jack reverse_echo_demo.dsp
//   ./reverse_echo_demo
// Linux QT:
//   faust2jaqt reverse_echo_demo.dsp
//   ./reverse_echo_demo
// Etc.
// ```
//-------------------------------------------------------------------
// Author: Julius Smith
// License: MIT
reverse_echo_demo(nChans) =  ef.reverseEchoN(nChans,delMax) : ef.uniformPanToStereo(nChans) 
with {
    delMax = 2^int(nentry("Log2(Delay)",15,5,16,1)); // delay line length
};

//------------------------`(dm.)pospass_demo`------------------------
// Use Positive-Pass Filter pospass() to frequency-shift a sine tone.
// First, a real sinusoid is converted to its analytic-signal form
// using pospass() to filter out its negative frequency component.
// Next, it is multiplied by a modulating complex sinusoid at the
// shifting frequency to create the frequency-shifted result.
// The real and imaginary parts are output to channels 1 & 2.
// For a more interesting frequency-shifting example, check the
// "Use Mic" checkbox to replace the input sinusoid by mic input.
// Note that frequency shifting is not the same as frequency scaling.
// A frequency-shifted harmonic signal is usually not harmonic.
// Very small frequency shifts give interesting chirp effects when
// there is feedback around the frequency shifter.
//
// #### Usage
//
// ```
// echo 'import("stdfaust.lib");' > pospass_demo.dsp
// echo 'process = dm.pospass_demo;' >> pospass_demo.dsp
// Mac:
//   faust2caqt pospass_demo.dsp
//   open pospass_demo.app
// Linux GTK:
//   faust2jack pospass_demo.dsp
//   ./pospass_demo
// Linux QT:
//   faust2jaqt pospass_demo.dsp
//   ./pospass_demo
// Etc.
// ```
//-------------------------------------------------------------------
// Author: Julius Smith
// License: MIT
pospass_demo(x) = analytic_signal, modulator : si.cmul with {
  N = 6; // pospass filter order
  fc = ma.SR/(2*N); // guard-band for filter roll-off
  octavesShift = hslider("Frequency Shift in octaves away from SR/16",
         -2,-7,3,0.001) : si.smooth(0.999);
  in_select = checkbox("Use Mic");
  sine_tone = os.oscrs(f0);
  f0 = ma.SR/16.0;   // original frequency to be shifted
  fn = f0 * 2.0^octavesShift; // modulated frequency
  df = fn - f0; // frequency-shift as a difference
  input = select2(in_select, sine_tone, x);
  analytic_signal = input : fi.pospass6e(fc); // filter out neg freqs
  //analytic_signal = os.oscrs(f0) : fi.pospass(N,fc); // Butterworth case
  modulator = os.oscrq(df) : si.cconj; // complex modulation sinusoid
  // modulator(n) = exp(sqrt(-1) * 2 * ma.PI * df * n / ma.SR) // if complex ok
};

// end jos section
/************************************************************************
************************************************************************
FAUST library file, GRAME section

Except where noted otherwise, Copyright (C) 2003-2017 by GRAME,
Centre National de Creation Musicale.
----------------------------------------------------------------------
GRAME LICENSE

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

// TODO: Add GRAME functions here

//########################################################################################
/************************************************************************
FAUST library file, further contributions section

All contributions below should indicate both the contributor and terms
of license.  If no such indication is found, "git blame" will say who
last edited each line, and that person can be emailed to inquire about
license disposition, if their license choice is not already indicated
elsewhere among the libraries.    It is expected that all software will be
released under LGPL, STK-4.3, MIT, BSD, or a similar FOSS license.
************************************************************************/

//-------------------------------`(dm.)exciter`-------------------------------
// Psychoacoustic harmonic exciter, with GUI.
//
// #### Usage
//
// ```
// _ : exciter : _
// ```
//
// #### References
//
// * <https://secure.aes.org/forum/pubs/ebriefs/?elib=16939>
// * <https://www.researchgate.net/publication/258333577_Modeling_the_Harmonic_Exciter>
//-------------------------------------------------------------------------------------
// Authors: PPriyanka Shekar and Julius O. Smith III
// License: STK-4.3
// Markdown: Romain Michon
//-------------------------------------------------------------------------------------
exciter = _ <: (fi.highpass(2, fc) : compressor : pregain : harmonicCreator :
    postgain), _ : balance
with{
    // TODO: rewrite to use the standard compressor from compressors.lib
    compressor = ba.bypass1(cbp,compressorMono)
    with{
        comp_group(x) = vgroup("COMPRESSOR  [tooltip: Reference:
            http://en.wikipedia.org/wiki/Dynamic_range_compression]", x);

    meter_group(x) = comp_group(hgroup("[0]", x));
    knob_group(x) = comp_group(hgroup("[1]", x));

    cbp = meter_group(checkbox("[0] Bypass  [tooltip: When this is checked,
        the compressor has no effect]"));

    gainview = co.compression_gain_mono(ratio,threshold,attack,release) : ba.linear2db
        : meter_group(hbargraph("[1] Compressor Gain [unit:dB] [tooltip: Current gain
        of the compressor in dB]",-50,+10));

    displaygain = _ <: _,abs : _,gainview : attach;

    compressorMono = displaygain(co.compressor_mono(ratio,threshold,attack,release));

    ctl_group(x) = knob_group(hgroup("[3] Compression Control", x));

    ratio = ctl_group(hslider("[0] Ratio [style:knob]  [tooltip: A compression Ratio
    of N means that for each N dB increase in input signal level above Threshold, the
    output level goes up 1 dB]", 5, 1, 20, 0.1));

    threshold = ctl_group(hslider("[1] Threshold [unit:dB] [style:knob] [tooltip:
    When the signal level exceeds the Threshold (in dB), its level is compressed
    according to the Ratio]", -30, -100, 10, 0.1));

    env_group(x) = knob_group(hgroup("[4] Compression Response", x));

    attack = env_group(hslider("[1] Attack [unit:ms] [style:knob]  [tooltip:
    Time constant in ms (1/e smoothing time) for the compression gain to approach
    (exponentially) a new lower target level (the compression `kicking in')]",
    50, 0, 500, 0.1)) : *(0.001) : max(1/ma.SR);

    release = env_group(hslider("[2] Release [unit:ms] [style: knob]  [tooltip:
    Time constant in ms (1/e smoothing time) for the compression gain to approach
    (exponentially) a new higher target level (the compression 'releasing')]",
    500, 0, 1000, 0.1)) : *(0.001) : max(1/ma.SR);
    };

    //Exciter GUI controls
    ex_group(x) = hgroup("EXCITER  [tooltip: Reference: Patent US4150253 A]", x);

    //Highpass - selectable cutoff frequency
    fc = ex_group(hslider("[0] Cutoff Frequency [unit:Hz] [style:knob] [scale:log]
        [tooltip: Cutoff frequency for highpassed components to be excited]",
    5000, 1000, 10000, 100));

    //Pre-distortion gain - selectable percentage of harmonics
    ph = ex_group(hslider("[1] Harmonics [unit:percent] [style:knob] [tooltip:
        Percentage of harmonics generated]", 20, ma.EPSILON, 200, 1)) / 100;
    pregain = * (ph);

    // TODO: same thing: why doesn't this use cubicnl?
    //Asymmetric cubic soft clipper
    harmonicCreator(x) = x <: cubDist1, cubDist2, cubDist3 :> _;
    cubDist1(x) = (x < 0) * x;
    cubDist2(x) = (x >= 0) * (x <= 1) * (x - x ^ 3 / 3);
    cubDist3(x) = (x > 1) * 2/3;

    //Post-distortion gain - undoes effect of pre-gain
    postgain = * (1/ph);

    //Balance - selectable dry/wet mix
    ml = ex_group(hslider("[2] Mix [style:knob] [tooltip: Dry/Wet mix of original signal
        to excited signal]", 0.5, 0, 1, 0.01));
    balance = (_ * ml), (_ * (1.0 - ml)) :> _;
};


//----------------------------`(dm.)vocoder_demo`-------------------------
// Use example of the vocoder function where an impulse train is used
// as excitation.
//
// #### Usage
//
// ```
// _ : vocoder_demo : _
// ```
//------------------------------------------------------------
// Author: Romain Michon
// License: LGPL
vocoder_demo = hgroup("My Vocoder",_,os.lf_imptrain(freq)*gain :
    ve.vocoder(bands,att,rel,BWRatio) <: _,_)
with{
    bands = 32;
    vocoderGroup(x) = vgroup("Vocoder",x);
    att = vocoderGroup(hslider("[0] Attack [style:knob] [tooltip: Attack time in seconds]",
        5,0.1,100,0.1)*0.001);
    rel = vocoderGroup(hslider("[1] Release [style:knob] [tooltip: Release time in seconds]",
        5,0.1,100,0.1)*0.001);
    BWRatio = vocoderGroup(hslider("[2] BW [style:knob] [tooltip: Coefficient to adjust the
        bandwidth of each band]",0.5,0.1,2,0.001));
    excitGroup(x) = vgroup("Excitation",x);
    freq = excitGroup(hslider("[0] Freq [style:knob]",330,50,2000,0.1));
    gain = excitGroup(vslider("[1] Gain",0.5,0,1,0.01) : si.smoo);
};

// end further contributions section
//#################################### reverbs.lib ########################################
// A library of reverb effects. Its official prefix is `re`.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/reverbs.lib>
//########################################################################################

ma = library("maths.lib");
ba = library("basics.lib");
de = library("delays.lib");
ro = library("routes.lib");
si = library("signals.lib");
fi = library("filters.lib");
os = library("oscillators.lib");

declare name "Faust Reverb Library";
declare version "0.2";

//########################################################################################
/************************************************************************
FAUST library file, jos section

Except where noted otherwise, The Faust functions below in this
section are Copyright (C) 2003-2017 by Julius O. Smith III <jos@ccrma.stanford.edu>
([jos](http://ccrma.stanford.edu/~jos/)), and released under the
(MIT-style) [STK-4.3](#stk-4.3-license) license.

All MarkDown comments in this section are Copyright 2016-2017 by Romain
Michon and Julius O. Smith III, and are released under the
[CCA4I](https://creativecommons.org/licenses/by/4.0/) license (TODO: if/when Romain agrees!)

************************************************************************/

//=============================Schroeder Reverberators======================================
//==========================================================================================

//------------------------------`(re.)jcrev`------------------------------
// This artificial reverberator take a mono signal and output stereo
// (`satrev`) and quad (`jcrev`). They were implemented by John Chowning
// in the MUS10 computer-music language (descended from Music V by Max
// Mathews).  They are Schroeder Reverberators, well tuned for their size.
// Nowadays, the more expensive freeverb is more commonly used (see the
// Faust examples directory).
//
// `jcrev` reverb below was made from a listing of "RV", dated April 14, 1972,
// which was recovered from an old SAIL DART backup tape.
// John Chowning thinks this might be the one that became the
// well known and often copied JCREV.
//
// `jcrev` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : jcrev : _,_,_,_
// ```
//------------------------------------------------------------
jcrev = *(0.06) : allpass_chain <: comb_bank : mix_mtx with {
  rev1N = fi.rev1;
  rev12(len,g) = rev1N(2048,len,g);
  rev14(len,g) = rev1N(4096,len,g);
  allpass_chain =
    fi.rev2(512,347,0.7) :
    fi.rev2(128,113,0.7) :
    fi.rev2(64, 37,0.7);
  comb_bank =
    rev12(1601,.802),
    rev12(1867,.773),
    rev14(2053,.753),
    rev14(2251,.733);
    mix_mtx = _,_,_,_ <: psum, -psum, asum, -asum : _,_,_,_ with {
    psum = _,_,_,_ :> _;
    asum = *(-1),_,*(-1),_ :> _;
  };
};


//------------------------------`(re.)satrev`------------------------------
// This artificial reverberator take a mono signal and output stereo
// (`satrev`) and quad (`jcrev`).  They were implemented by John Chowning
// in the MUS10 computer-music language (descended from Music V by Max
// Mathews).  They are Schroeder Reverberators, well tuned for their size.
// Nowadays, the more expensive freeverb is more commonly used (see the
// Faust examples directory).
//
// `satrev` was made from a listing of "SATREV", dated May 15, 1971,
// which was recovered from an old SAIL DART backup tape.
// John Chowning thinks this might be the one used on his
// often-heard brass canon sound examples, one of which can be found at
// <https://ccrma.stanford.edu/~jos/wav/FM-BrassCanon2.wav>.
//
// #### Usage
//
// ```
// _ : satrev : _,_
// ```
//------------------------------------------------------------
satrev = *(0.2) <: comb_bank :> allpass_chain <: _,*(-1) with {
  rev1N = fi.rev1;
  rev11(len,g) = rev1N(1024,len,g);
  rev12(len,g) = rev1N(2048,len,g);
  comb_bank =
    rev11(778,.827),
    rev11(901,.805),
    rev11(1011,.783),
    rev12(1123,.764);
  rev2N = fi.rev2;
  allpass_chain =
    rev2N(128,125,0.7) :
    rev2N(64, 42,0.7) :
    rev2N(16, 12,0.7);
};

//======================Feedback Delay Network (FDN) Reverberators========================
//========================================================================================

//--------------------------------`(re.)fdnrev0`---------------------------------
// Pure Feedback Delay Network Reverberator (generalized for easy scaling).
// `fdnrev0` is a standard Faust function.
//
// #### Usage
//
// ```
// <1,2,4,...,N signals> <:
// fdnrev0(MAXDELAY,delays,BBSO,freqs,durs,loopgainmax,nonl) :>
// <1,2,4,...,N signals>
// ```
//
// Where:
//
// * `N`: 2, 4, 8, ...  (power of 2)
// * `MAXDELAY`: power of 2 at least as large as longest delay-line length
// * `delays`: N delay lines, N a power of 2, lengths perferably coprime
// * `BBSO`: odd positive integer = order of bandsplit desired at freqs
// * `freqs`: NB-1 crossover frequencies separating desired frequency bands
// * `durs`: NB decay times (t60) desired for the various bands
// * `loopgainmax`: scalar gain between 0 and 1 used to "squelch" the reverb
// * `nonl`: nonlinearity (0 to 0.999..., 0 being linear)
//
// #### Reference
//
// <https://ccrma.stanford.edu/~jos/pasp/FDN_Reverberation.html>
//------------------------------------------------------------
fdnrev0(MAXDELAY, delays, BBSO, freqs, durs, loopgainmax, nonl)
  = (si.bus(2*N) :> si.bus(N) : delaylines(N)) ~
    (delayfilters(N,freqs,durs) : feedbackmatrix(N))
with {
  N = ba.count(delays);
  NB = ba.count(durs);
//assert(count(freqs)+1==NB);
  delayval(i) = ba.take(i+1,delays);
  dlmax(i) = MAXDELAY; // must hardwire this from argument for now
//dlmax(i) = 2^max(1,nextpow2(delayval(i))) // try when slider min/max is known
//           with { nextpow2(x) = ceil(log(x)/log(2.0)); };
// -1 is for feedback delay:
  delaylines(N) = par(i,N,(de.delay(dlmax(i),(delayval(i)-1))));
  delayfilters(N,freqs,durs) = par(i,N,filter(i,freqs,durs));
  feedbackmatrix(N) = bhadamard(N);
  vbutterfly(n) = si.bus(n) <: (si.bus(n):>bus(n/2)) , ((si.bus(n/2),(si.bus(n/2):par(i,n/2,*(-1)))) :> si.bus(n/2));
  bhadamard(2) = si.bus(2) <: +,-;
  bhadamard(n) = si.bus(n) <: (si.bus(n):>si.bus(n/2)) , ((si.bus(n/2),(si.bus(n/2):par(i,n/2,*(-1)))) :> si.bus(n/2))
                 : (bhadamard(n/2) , bhadamard(n/2));

  // Experimental nonlinearities:
  // nonlinallpass = apnl(nonl,-nonl);
  // s = nonl*PI;
  // nonlinallpass(x) = allpassnn(3,(s*x,s*x*x,s*x*x*x)); // filters.lib
     nonlinallpass = _; // disabled by default (rather expensive)

  filter(i,freqs,durs) = fi.filterbank(BBSO,freqs) : par(j,NB,*(g(j,i)))
                         :> *(loopgainmax) / sqrt(N) : nonlinallpass
  with {
    dur(j) = ba.take(j+1,durs);
    n60(j) = dur(j)*ma.SR; // decay time in samples
    g(j,i) = exp(-3.0*log(10.0)*delayval(i)/n60(j));
        // ~ 1.0 - 6.91*delayval(i)/(SR*dur(j)); // valid for large dur(j)
  };
};


//-------------------------------`(re.)zita_rev_fdn`-------------------------------
// Internal 8x8 late-reverberation FDN used in the FOSS Linux reverb zita-rev1
// by Fons Adriaensen <fons@linuxaudio.org>.  This is an FDN reverb with
// allpass comb filters in each feedback delay in addition to the
// damping filters.
//
// #### Usage
//
// ```
// si.bus(8) : zita_rev_fdn(f1,f2,t60dc,t60m,fsmax) : si.bus(8)
// ```
//
// Where:
//
// * `f1`: crossover frequency (Hz) separating dc and midrange frequencies
// * `f2`: frequency (Hz) above f1 where T60 = t60m/2 (see below)
// * `t60dc`: desired decay time (t60) at frequency 0 (sec)
// * `t60m`: desired decay time (t60) at midrange frequencies (sec)
// * `fsmax`: maximum sampling rate to be used (Hz)
//
// #### Reference
//
// * <http://www.kokkinizita.net/linuxaudio/zita-rev1-doc/quickguide.html>
// * <https://ccrma.stanford.edu/~jos/pasp/Zita_Rev1.html>
//------------------------------------------------------------
zita_rev_fdn(f1,f2,t60dc,t60m,fsmax) =
  ((si.bus(2*N) :> allpass_combs(N) : feedbackmatrix(N)) ~
   (delayfilters(N,freqs,durs) : fbdelaylines(N)))
with {
  N = 8;

  // Delay-line lengths in seconds:
  apdelays = (0.020346, 0.024421, 0.031604, 0.027333, 0.022904,
              0.029291, 0.013458, 0.019123); // feedforward delays in seconds
  tdelays = (0.153129, 0.210389, 0.127837, 0.256891, 0.174713,
             0.192303, 0.125000, 0.219991); // total delays in seconds
  tdelay(i) = floor(0.5 + ma.SR*ba.take(i+1,tdelays)); // samples
  apdelay(i) = floor(0.5 + ma.SR*ba.take(i+1,apdelays));
  fbdelay(i) = tdelay(i) - apdelay(i);
  // NOTE: Since SR is not bounded at compile time, we can't use it to
  // allocate delay lines; hence, the fsmax parameter:
  tdelaymaxfs(i) = floor(0.5 + fsmax*ba.take(i+1,tdelays));
  apdelaymaxfs(i) = floor(0.5 + fsmax*ba.take(i+1,apdelays));
  fbdelaymaxfs(i) = tdelaymaxfs(i) - apdelaymaxfs(i);
  nextpow2(x) = ceil(log(x)/log(2.0));
  maxapdelay(i) = int(2.0^max(1.0,nextpow2(apdelaymaxfs(i))));
  maxfbdelay(i) = int(2.0^max(1.0,nextpow2(fbdelaymaxfs(i))));

  apcoeff(i) = select2(i&1,0.6,-0.6);  // allpass comb-filter coefficient
  allpass_combs(N) =
    par(i,N,(fi.allpass_comb(maxapdelay(i),apdelay(i),apcoeff(i)))); // filters.lib
  fbdelaylines(N) = par(i,N,(de.delay(maxfbdelay(i),(fbdelay(i)))));
  freqs = (f1,f2); durs = (t60dc,t60m);
  delayfilters(N,freqs,durs) = par(i,N,filter(i,freqs,durs));
  feedbackmatrix(N) = ro.hadamard(N);

  staynormal = 10.0^(-20); // let signals decay well below LSB, but not to zero

  special_lowpass(g,f) = si.smooth(p) with {
    // unity-dc-gain lowpass needs gain g at frequency f => quadratic formula:
    p = mbo2 - sqrt(max(0,mbo2*mbo2 - 1.0)); // other solution is unstable
    mbo2 = (1.0 - gs*c)/(1.0 - gs); // NOTE: must ensure |g|<1 (t60m finite)
    gs = g*g;
    c = cos(2.0*ma.PI*f/float(ma.SR));
  };

  filter(i,freqs,durs) = lowshelf_lowpass(i)/sqrt(float(N))+staynormal
  with {
    lowshelf_lowpass(i) = gM*low_shelf1_l(g0/gM,f(1)):special_lowpass(gM,f(2));
    low_shelf1_l(G0,fx,x) = x + (G0-1)*fi.lowpass(1,fx,x); // filters.lib
    g0 = g(0,i);
    gM = g(1,i);
    f(k) = ba.take(k,freqs);
    dur(j) = ba.take(j+1,durs);
    n60(j) = dur(j)*ma.SR; // decay time in samples
    g(j,i) = exp(-3.0*log(10.0)*tdelay(i)/n60(j));
  };
};

// Stereo input delay used by zita_rev1 in both stereo and ambisonics mode:
zita_in_delay(rdel) = zita_delay_mono(rdel), zita_delay_mono(rdel) with {
  zita_delay_mono(rdel) = de.delay(8192,ma.SR*rdel*0.001) * 0.3;
};

// Stereo input mapping used by zita_rev1 in both stereo and ambisonics mode:
zita_distrib2(N) = _,_ <: fanflip(N) with {
   fanflip(4) = _,_,*(-1),*(-1);
   fanflip(N) = fanflip(N/2),fanflip(N/2);
};


//----------------------------`(re.)zita_rev1_stereo`---------------------------
// Extend `zita_rev_fdn` to include `zita_rev1` input/output mapping in stereo mode.
// `zita_rev1_stereo` is a standard Faust function.
//
// #### Usage
//
// ```
// _,_ : zita_rev1_stereo(rdel,f1,f2,t60dc,t60m,fsmax) : _,_
// ```
//
// Where:
//
// `rdel`  = delay (in ms) before reverberation begins (e.g., 0 to ~100 ms)
// (remaining args and refs as for `zita_rev_fdn` above)
//------------------------------------------------------------
zita_rev1_stereo(rdel,f1,f2,t60dc,t60m,fsmax) =
   zita_in_delay(rdel)
 : zita_distrib2(N)
 : zita_rev_fdn(f1,f2,t60dc,t60m,fsmax)
 : output2(N)
with {
 N = 8;
 output2(N) = outmix(N) : *(t1),*(t1);
 t1 = 0.37; // zita-rev1 linearly ramps from 0 to t1 over one buffer
 outmix(4) = !,ro.butterfly(2),!; // probably the result of some experimenting!
 outmix(N) = outmix(N/2),par(i,N/2,!);
};


//-----------------------------`(re.)zita_rev1_ambi`---------------------------
// Extend zita_rev_fdn to include zita_rev1 input/output mapping in
// "ambisonics mode", as provided in the Linux C++ version.
//
// #### Usage
//
// ```
// _,_ : zita_rev1_ambi(rgxyz,rdel,f1,f2,t60dc,t60m,fsmax) : _,_,_,_
// ```
//
// Where:
//
// `rgxyz` = relative gain of lanes 1,4,2 to lane 0 in output (e.g., -9 to 9)
//   (remaining args and references as for zita_rev1_stereo above)
//------------------------------------------------------------
zita_rev1_ambi(rgxyz,rdel,f1,f2,t60dc,t60m,fsmax) =
   zita_in_delay(rdel)
 : zita_distrib2(N)
 : zita_rev_fdn(f1,f2,t60dc,t60m,fsmax)
 : output4(N) // ambisonics mode
with {
  N = 8;
  output4(N) = select4 : *(t0),*(t1),*(t1),*(t1);
  select4 = _,_,_,!,_,!,!,! : _,_,cross with { cross(x,y) = y,x; };
  t0 = 1.0/sqrt(2.0);
  t1 = t0 * 10.0^(0.05 * rgxyz);
};

// end jos section
/************************************************************************
************************************************************************
FAUST library file, GRAME section

Except where noted otherwise, Copyright (C) 2003-2017 by GRAME,
Centre National de Creation Musicale.
----------------------------------------------------------------------
GRAME LICENSE

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

//===============================Freeverb===================================
//==========================================================================

//----------------------------`(re.)mono_freeverb`-------------------------
// A simple Schroeder reverberator primarily developed by "Jezar at Dreampoint" that
// is extensively used in the free-software world. It uses four Schroeder allpasses in
// series and eight parallel Schroeder-Moorer filtered-feedback comb-filters for each
// audio channel, and is said to be especially well tuned.
//
// `mono_freeverb` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : mono_freeverb(fb1, fb2, damp, spread) : _
// ```
//
// Where:
//
// * `fb1`: coefficient of the lowpass comb filters (0-1)
// * `fb2`: coefficient of the allpass comb filters (0-1)
// * `damp`: damping of the lowpass comb filter (0-1)
// * `spread`: spatial spread in number of samples (for stereo)
//
// #### License
// While this version is licensed LGPL (with exception) along with other GRAME
// library functions, the file freeverb.dsp in the examples directory of older
// Faust distributions, such as faust-0.9.85, was released under the BSD license,
// which is less restrictive.
//------------------------------------------------------------
// TODO: author RM
mono_freeverb(fb1, fb2, damp, spread) = _ <: par(i,8,lbcf(combtuningL(i)+spread,fb1,damp))
	:> seq(i,4,fi.allpass_comb(1024, allpasstuningL(i)+spread, -fb2))
with {
 
    // Filters parameters
    combtuningL(0) = adaptSR(1116);
    combtuningL(1) = adaptSR(1188);
    combtuningL(2) = adaptSR(1277);
    combtuningL(3) = adaptSR(1356);
    combtuningL(4) = adaptSR(1422);
    combtuningL(5) = adaptSR(1491);
    combtuningL(6) = adaptSR(1557);
    combtuningL(7) = adaptSR(1617);

    allpasstuningL(0) = adaptSR(556);
    allpasstuningL(1) = adaptSR(441);
    allpasstuningL(2) = adaptSR(341);
    allpasstuningL(3) = adaptSR(225);
    
    // Lowpass Feedback Combfilter:
    // <https://ccrma.stanford.edu/~jos/pasp/Lowpass_Feedback_Comb_Filter.html>
    lbcf(dt, fb, damp) = (+:@(dt)) ~ (*(1-damp) : (+ ~ *(damp)) : *(fb));
     
    origSR = 44100;
    adaptSR(val) = val*ma.SR/origSR : int;

};


//----------------------------`(re.)stereo_freeverb`-------------------------
// A simple Schroeder reverberator primarily developed by "Jezar at Dreampoint" that
// is extensively used in the free-software world. It uses four Schroeder allpasses in
// series and eight parallel Schroeder-Moorer filtered-feedback comb-filters for each
// audio channel, and is said to be especially well tuned.
//
// #### Usage
//
// ```
// _,_ : stereo_freeverb(fb1, fb2, damp, spread) : _,_
// ```
//
// Where:
//
// * `fb1`: coefficient of the lowpass comb filters (0-1)
// * `fb2`: coefficient of the allpass comb filters (0-1)
// * `damp`: damping of the lowpass comb filter (0-1)
// * `spread`: spatial spread in number of samples (for stereo)
//------------------------------------------------------------
// TODO: author RM
stereo_freeverb(fb1, fb2, damp, spread) = + <: mono_freeverb(fb1, fb2, damp, 0), mono_freeverb(fb1, fb2, damp, spread);

//########################################################################################
/************************************************************************
FAUST library file, further contributions section

All contributions below should indicate both the contributor and terms
of license.  If no such indication is found, "git blame" will say who
last edited each line, and that person can be emailed to inquire about
license disposition, if their license choice is not already indicated
elsewhere among the libraries.  It is expected that all software will be
released under LGPL, STK-4.3, MIT, BSD, or a similar FOSS license.
************************************************************************/

//===============================Dattorro Reverb============================
//==========================================================================

//-------------------------------`(re.)dattorro_rev`-------------------------------
// Reverberator based on the Dattorro reverb topology. This implementation does
// not use modulated delay lengths (excursion).
//
// #### Usage
//
// ```
// _,_ : dattorro_rev(pre_delay, bw, i_diff1, i_diff2, decay, d_diff1, d_diff2, damping) : _,_
// ```
//
// Where:
//
// * `pre_delay`: pre-delay in samples (fixed at compile time)
// * `bw`: band-width filter (pre filtering); (0 - 1)
// * `i_diff1`: input diffusion factor 1; (0 - 1)
// * `i_diff2`: input diffusion factor 2;
// * `decay`: decay rate; (0 - 1); infinite decay = 1.0
// * `d_diff1`: decay diffusion factor 1; (0 - 1)
// * `d_diff2`: decay diffusion factor 2;
// * `damping`: high-frequency damping; no damping = 0.0
//
// #### Reference
//
// <https://ccrma.stanford.edu/~dattorro/EffectDesignPart1.pdf>
//------------------------------------------------------------

// Author: Jakob Zerbian
// License: MIT-style STK-4.3 license
declare dattorro_rev author "Jakob Zerbian";
declare dattorro_rev license "MIT-style STK-4.3 license";

dattorro_rev(pre_delay, bw, i_diff1, i_diff2, decay, d_diff1, d_diff2, damping) = 
    si.bus(2) : + : *(0.5) : predelay : bw_filter : diffusion_network <: ((si.bus(4) :> _,_) ~ (reverb_network : ro.cross(2)))
with {
    // allpass using delay with fixed size
    allpass_f(t, a) = (+ <: @(t),*(a)) ~ *(-a) : mem,_ : +;

    // input pre-delay and diffusion
    predelay = @(pre_delay);
    bw_filter = *(bw) : +~(mem : *(1-bw));
    diffusion_network = allpass_f(142, i_diff1) : allpass_f(107, i_diff1) : allpass_f(379, i_diff2) : allpass_f(277, i_diff2);

    // reverb loop
    reverb_network = par(i, 2, block(i)) with {
        d = (672, 908, 4453, 4217, 1800, 2656, 3720, 3163);
        block(i) = allpass_f(ba.take(i+1, d),-d_diff1) : @(ba.take(i+3, d)) : damp : 
            allpass_f(ba.take(i+5, d), d_diff2) : @(ba.take(i+5, d)) : *(decay)
        with {
            damp = *(1-damping) : +~*(damping) : *(decay);
        };
    };
};


//-------------------------------`(re.)dattorro_rev_default`-------------------------------
// Reverberator based on the Dattorro reverb topology with reverb parameters from the
// original paper.
// This implementation does not use modulated delay lengths (excursion) and
// uses zero length pre-delay.
//
// #### Usage
//
// ```
// _,_ : dattorro_rev_default : _,_
// ```
//
// #### Reference
//
// <https://ccrma.stanford.edu/~dattorro/EffectDesignPart1.pdf>
//------------------------------------------------------------

// Author: Jakob Zerbian
// License: MIT-style STK-4.3 license
declare dattorro_rev_default author "Jakob Zerbian";
declare dattorro_rev_default license "MIT-style STK-4.3 license";

dattorro_rev_default = dattorro_rev(0, 0.9995, 0.75, 0.625, 0.5, 0.7, 0.5, 0.0005);

//===============================JPverb and Greyhole Reverbs============================
//======================================================================================

jp_gh_rev = environment {

    diffuser_aux(angle, g, scale1, scale2, size, block) = si.bus(2) <: ((si.bus(2):par(i,2,*(c_norm))
        : ((si.bus(4) :> si.bus(2)
            : block
            : rotator(angle)
            : (de.fdelay1a(8192, prime_delays(size*scale1):smooth_init(0.9999,prime_delays(size*scale1)) -1),
               de.fdelay1a(8192, prime_delays(size*scale2):smooth_init(0.9999,prime_delays(size*scale2)) -1)))
        ~ par(i,2,*(-s_norm))) : par(i,2,mem:*(c_norm)))
        ,
        par(i,2,*(s_norm)))
        :> si.bus(2)
        with {
            rotator(angle) = si.bus(2) <: (*(c),*(-s),*(s),*(c)) :(+,+) : si.bus(2)
            with {
                c = cos(angle);
                s = sin(angle);
            };
            c_norm = cos(g);
            s_norm = sin(g);
        };

    diffuser(angle, g, scale1, scale2, size) = diffuser_aux(angle,g,scale1,scale2,size,si.bus(2));

    // Nested version
    diffuser_nested(1, angle, g, scale, size) = diffuser_aux(angle,g,scale,scale+10,size,si.bus(2));
    diffuser_nested(N, angle, g, scale, size) = diffuser_aux(angle,g,scale,scale+10,size,diffuser_nested(N-1,angle,g,scale+13,size));

    prime_delays(x) = (waveform {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973, 10007, 10009, 10037, 10039, 10061, 10067, 10069, 10079, 10091, 10093, 10099, 10103, 10111, 10133, 10139, 10141, 10151, 10159, 10163, 10169, 10177, 10181, 10193, 10211, 10223, 10243, 10247, 10253, 10259, 10267, 10271, 10273, 10289, 10301, 10303, 10313, 10321, 10331, 10333, 10337, 10343, 10357, 10369, 10391, 10399, 10427, 10429, 10433, 10453, 10457, 10459, 10463, 10477, 10487, 10499, 10501, 10513, 10529, 10531, 10559, 10567, 10589, 10597, 10601, 10607, 10613, 10627, 10631, 10639, 10651, 10657, 10663, 10667}, int(x)) : rdtable;

    smooth_init(s,default) = *(1.0 - s) : + ~ (+(default*init(1)):*(s)) with { init(value) = value - value'; };

    jpverb(t60, damp, size, early_diff, mod_depth, mod_freq, low, mid, high, low_cutoff, high_cutoff)
        = ((si.bus(4) :> (de.fdelay4(512, depth + depth*os.oscrs(mod_freq) + 5),de.fdelay4(512, depth + depth*os.oscrc(mod_freq) + 5))
            : par(i,2,si.smooth(damp))
            : diffuser(ma.PI/4,early_diff,55,240,size)
            : diffuser(ma.PI/4,early_diff,215,85,size)
            : diffuser(ma.PI/4,early_diff,115,190,size)
            : diffuser(ma.PI/4,early_diff,175,145,size)
        )~(seq(i,5,diffuser(ma.PI/4,0.707,10+30*i,110+30*i,size))
            : par(i,2,de.fdelay4(512, depth + (-1^i)*depth*os.oscrc(mod_freq)+5)
            : de.fdelay1a(8192,(prime_delays(size*(54+150*i))
            : smooth_init(0.995,prime_delays(size*(54+150*i)))) -1))
            : seq(i,5,diffuser(ma.PI/4,0.707,125+30*i,25+30*i,size))
            : par(i,2,de.fdelay4(8192, depth + (-1^i)*depth*os.oscrs(mod_freq)+5)
            : de.fdelay1a(8192,(prime_delays(size*(134-100*i))
            : smooth_init(0.995,prime_delays(size*(134-100*i)))) -1))
            : par(i,2,fi.filterbank(5,(low_cutoff,high_cutoff)):(_*(high),_*(mid),_*(low)) :> _)
            : par(i,2,*(fb))))
        with {
            depth = 50*mod_depth;
            calib = 1.7; // Calibration constant given by t60 in seconds when fb = 0.5
            total_length = calib*0.1*(size*5/4 -1/4);
            fb = 10^(-3/((t60)/(total_length)));
        };

    greyhole(dt, damp, size, early_diff, feedback, mod_depth, mod_freq)
        = (si.bus(4) :> seq(i,3,diffuser_nested(4,ma.PI/2,(-1^i)*diff,10+19*i,size))
            : par(i,2,si.smooth(damp_interp)))
        ~((de.fdelay4(512, 10 + depth + depth*os.oscrc(freq)),de.fdelay4(512, 10 + depth + depth*os.oscrs(freq)))
            : (de.sdelay(65536,44100/2,floor(dt_constrained)),de.sdelay(65536,44100/2,floor(dt_constrained)))
            : par(i,2,*(fb)))
        with {
            fb = feedback:linear_interp;
            depth = ((ma.SR/44100)*50*mod_depth):linear_interp;
            freq = mod_freq:linear_interp;
            diff = early_diff:linear_interp;
            dt_constrained = min(65533,ma.SR*dt);
            damp_interp = damp:linear_interp;
            linear_interp(x) = (x+x')/2;
        };

};

//-------------------------------`(re.)jpverb`-------------------------------
// An algorithmic reverb (stereo in/out), inspired by the lush chorused sound 
// of certain vintage Lexicon and Alesis reverberation units. 
// Designed to sound great with synthetic sound sources, rather than sound like a realistic space.
//
// #### Usage
//
// ```
// _,_ : jpverb(t60, damp, size, early_diff, mod_depth, mod_freq, low, mid, high, low_cutoff, high_cutoff) : _,_
// ```
//
// Where:
//
// * `t60`: approximate reverberation time in seconds (`[0.1..60]` sec) (T60 - the time for the reverb to decay by 60db when damp == 0 ). Does not effect early reflections
// * `damp`: controls damping of high-frequencies as the reverb decays. `0` is no damping, `1` is very strong damping. Values should be between (`[0..1]`)
// * `size`: scales size of delay-lines within the reverberator, producing the impression of a larger or smaller space. Values below `1` can sound metallic. Values should be between `[0.5..5]
// * `early_diff`: controls shape of early reflections. Values of `0.707` or more produce smooth exponential decay. Lower values produce a slower build-up of echoes. Values should be between (`[0..1]`)
// * `mod_depth`: depth (`[0..1]`) of delay-line modulation. Use in combination with `mod_freq` to set amount of chorusing within the structure
// * `modFreq`: frequency (`[0..10]` Hz) of delay-line modulation. Use in combination with modDepth to set amount of chorusing within the structure
// * `low`: multiplier (`[0..1]`) for the reverberation time within the low band
// * `mid`: multiplier (`[0..1]`) for the reverberation time within the mid band
// * `high`: multiplier (`[0..1]`) for the reverberation time within the high band
// * `lowcut`: frequency (100..6000 Hz) at which the crossover between the low and mid bands of the reverb occurs
// * `highcut`: frequency (1000..10000 Hz) at which the crossover between the mid and high bands of the reverb occurs
//
// #### Reference
//
// <https://doc.sccode.org/Overviews/DEIND.html>
//------------------------------------------------------------

// Author: Julian Parker, bug fixes and minor interface changes by Till Bovermann
// License: GPL2+
declare jpverb author "Julian Parker, bug fixes and minor interface changes by Till Bovermann";
declare jpverb license "GPL2+";

jpverb(t60, damp, size, early_diff, 
		mod_depth, mod_freq, 
		low, mid, high, 
		low_cutoff, high_cutoff)
    = jp_gh_rev.jpverb(t60, damp, size, early_diff, mod_depth, mod_freq, low, mid, high, low_cutoff, high_cutoff);


//-------------------------------`(re.)greyhole`-------------------------------
// A complex echo-like effect (stereo in/out), inspired by the classic Eventide effect of a similar name. 
// The effect consists of a diffuser (like a mini-reverb, structurally similar to the one used in `jpverb`)
// connected in a feedback system with a long, modulated delay-line. 
// Excels at producing spacey washes of sound.
//
// #### Usage
//
// ```
// _,_ : greyhole(dt, damp, size, early_diff, feedback, mod_depth, mod_freq) : _,_
// ```
//
// Where:
//
// * `dt`: approximate reverberation time in seconds (`[0.1..60 sec]`)
// * `damp`: controls damping of high-frequencies as the reverb decays. `0` is no damping, `1` is very strong damping. Values should be between (`[0..1]`)
// * `size`: scales size of delay-lines within the diffusion unit, producing the impression of a larger or smaller space. Values below `1` can sound metallic. Values should be between (`[0.5..5]`)
// * `size`: control of relative "room size" roughly between (`[0.5..3]`)
// * `early_diff`: controls pattern of echoes produced by the diffuser. At very low values, the diffuser acts like a delay-line whose length is controlled by the 'size' parameter. Medium values produce a slow build-up of echoes, giving the sound a reversed-like quality. Values of `0.707` or greater than produce smooth exponentially decaying echoes. Values should be in the range (`[0..1]`)
// * `feedback`: amount of feedback through the system. Sets the number of repeating echoes. A setting of `1.0` produces infinite sustain. Values should be in the range (`[0..1]`)
// * `mod_depth`: depth (`[0..1]`) of delay-line modulation. Use in combination with mod_freq to produce chorus and pitch-variations in the echoes
// * `mod_freq`: frequency (`[0..10]` Hz) of delay-line modulation. Use in combination with mod_depth to produce chorus and pitch-variations in the echoes
//
// #### Reference
//
// <https://doc.sccode.org/Overviews/DEIND.html>
//------------------------------------------------------------

// Author: Julian Parker, bug fixes and minor interface changes by Till Bovermann
// License: GPL2+
declare greyhole author "Julian Parker, bug fixes and minor interface changes by Till Bovermann";
declare greyhole license "GPL2+";

greyhole(dt, damp, size, early_diff, feedback, mod_depth, mod_freq) 
	= jp_gh_rev.greyhole(dt, damp, size, early_diff, feedback, mod_depth, mod_freq);

// end further further contributions section
//##################################### physmodels.lib ###################################
// Faust physical modeling library. Its official prefix is `pm`.
//
// This library provides an environment to facilitate physical modeling of musical
// instruments. It contains dozens of functions implementing low and high level
// elements going from a simple waveguide to fully operational models with
// built-in UI, etc.
//
// It is organized as follows:
//
// * [Global Variables](#global-variables): useful pre-defined variables for
// physical modeling (e.g., speed of sound, etc.).
// * [Conversion Tools](#conversion-tools-1): conversion functions specific
// to physical modeling (e.g., length to frequency, etc.).
// * [Bidirectional Utilities](#bidirectional-utilities): functions to create
// bidirectional block diagrams for physical modeling.
// * [Basic Elements](#basic-elements-1): waveguides, specific types of filters, etc.
// * [String Instruments](#string-instruments): various types of strings
// (e.g., steel, nylon, etc.), bridges, guitars, etc.
// * [Bowed String Instruments](#bowed-string-instruments): parts and models
// specific to bowed string instruments (e.g., bows, bridges, violins, etc.).
// * [Wind Instrument](#wind-instruments): parts and models specific to wind
// string instruments (e.g., reeds, mouthpieces, flutes, clarinets, etc.).
// * [Exciters](#exciters): pluck generators, "blowers", etc.
// * [Modal Percussions](#modal-percussions): percussion instruments based on
// modal models.
// * [Vocal Synthesis](#vocal-synthesis): functions for various vocal synthesis
// techniques (e.g., fof, source/filter, etc.) and vocal synthesizers.
// * [Misc Functions](#misc-functions): any other functions that don't fit in
// the previous category (e.g., nonlinear filters, etc.).
//
// This library is part of the Faust Physical Modeling ToolKit.
// More information on how to use this library can be found on this page:
// <https://ccrma.stanford.edu/~rmichon/pmFaust>. Tutorials on how to make
// physical models of musical instruments using Faust can be found
// [here](https://ccrma.stanford.edu/~rmichon/faustTutorials/#making-physical-models-of-musical-instruments-with-faust) as well.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/physmodels.lib>
//########################################################################################
// Authors: Romain Michon, Pierre-Amaury Grumiaux, and Yann Orlarey

import("stdfaust.lib");

declare name "Faust Physical Models Library";
declare version "0.1";

/*
TODO:
	- It'd be cool to have a version of the block diagram generator that automatically flips
	things based on the use of chains, etc.
	- When setting pole of filters by hand (e.g. smooth, should adjust pole in function of SR)
	- Probably need a single resonator function / see how to integrate that with "mode"
	- Need a non-linear function and see how this can be integrated with modal synthesis
	- See how bowed modal models could be integrated to this
	- Currently still missing keyboard instruments
	- Currently still missing vocal synth: easy to fix (create a formant filter function)
	- Real polyphonic instruments should be designated with some kind of prefix (e.g.,
	full)
*/

//=============================Global Variables===========================================
// Useful pre-defined variables for physical modeling.
//========================================================================================

//--------------`(pm.)speedOfSound`----------
// Speed of sound in meters per second (340m/s).
//--------------------------------------
speedOfSound = 340;

//--------------`(pm.)maxLength`----------
// The default maximum length (3) in meters of strings and tubes used in this
// library. This variable should be overriden to allow longer strings or tubes.
//--------------------------------------
maxLength = 3;

//================================Conversion Tools=======================================
// Useful conversion tools for physical modeling.
//========================================================================================

//--------------`(pm.)f2l`----------
// Frequency to length in meters.
//
// #### Usage
//
// ```
// f2l(freq) : distanceInMeters
// ```
//
// Where:
//
// * `freq`: the frequency
//-------------------------------
f2l(freq) = speedOfSound/freq;

//--------------`(pm.)l2f`----------
// Length in meters to frequency.
//
// #### Usage
//
// ```
// l2f(length) : freq
// ```
//
// Where:
//
// * `length`: length/distance in meters
//-------------------------------
l2f(length) = speedOfSound/length;

//--------------`(pm.)l2s`----------
// Length in meters to number of samples.
//
// #### Usage
//
// ```
// l2s(l) : numberOfSamples
// ```
//
// Where:
//
// * `l`: length in meters
//-------------------------------
l2s(l) = l*ma.SR/speedOfSound;

//=============================Bidirectional Utilities====================================
// Set of fundamental functions to create bi-directional block diagrams in Faust.
// These elements are used as the basis of this library to connect high level
// elements (e.g., mouthpieces, strings, bridge, instrument body, etc.). Each
// block has 3 inputs and 3 outputs. The first input/output carry left going
// waves, the second input/output carry right going waves, and the third
// input/output is used to carry any potential output signal to the end of the
// algorithm.
//========================================================================================

//--------------`(pm.)basicBlock`----------
// Empty bidirectional block to be used with [`chain`](#chain): 3 signals ins
// and 3 signals out.
//
// #### Usage
//
// ```
// chain(basicBlock : basicBlock : etc.)
// ```
//-------------------------------
basicBlock = _,_,_;

//-------`(pm.)chain`----------
// Creates a chain of bidirectional blocks.
// Blocks must have 3 inputs and outputs. The first input/output carry left
// going waves, the second input/output carry right going waves, and the third
// input/output is used to carry any potential output signal to the end of the
// algorithm. The implied one sample delay created by the `~` operator is
// generalized to the left and right going waves. Thus, `n` blocks in `chain()`
// will add an `n` samples delay to both left and right going waves.
//
// #### Usage
//
// ```
// leftGoingWaves,rightGoingWaves,mixedOutput : chain( A : B ) : leftGoingWaves,rightGoingWaves,mixedOutput
// with{
// 		A = _,_,_;
//		B = _,_,_;
// };
// ```
//-----------------------------
chain(A:As) = ((ro.crossnn(1),_',_ : _,A : ro.crossnn(1),_,_ : _,chain(As) : ro.crossnn(1),_,_)) ~ _ : !,_,_,_;
chain(A) = A;

//-------`(pm.)inLeftWave`--------------
// Adds a signal to left going waves anywhere in a [`chain`](#chain) of blocks.
//
// #### Usage
//
// ```
// model(x) = chain(A : inLeftWave(x) : B)
// ```
//
// Where `A` and `B` are bidirectional blocks and `x` is the signal added to left
// going waves in that chain.
//--------------------------------
inLeftWave(x) = +(x),_,_;

//-------`(pm.)inRightWave`--------------
// Adds a signal to right going waves anywhere in a [`chain`](#chain) of blocks.
//
// #### Usage
//
// ```
// model(x) = chain(A : inRightWave(x) : B)
// ```
//
// Where `A` and `B` are bidirectional blocks and `x` is the signal added to right
// going waves in that chain.
//--------------------------------
inRightWave(x) = _,+(x),_;

//-------`(pm.)in`--------------
// Adds a signal to left and right going waves anywhere in a [`chain`](#chain)
// of blocks.
//
// #### Usage
//
// ```
// model(x) = chain(A : in(x) : B)
// ```
//
// Where `A` and `B` are bidirectional blocks and `x` is the signal added to
// left and right going waves in that chain.
//--------------------------------
in(x) = +(x),+(x),_;

//-------`(pm.)outLeftWave`--------------
// Sends the signal of left going waves to the output channel of the [`chain`](#chain).
//
// #### Usage
//
// ```
// chain(A : outLeftWave : B)
// ```
//
// Where `A` and `B` are bidirectional blocks.
//--------------------------------
outLeftWave(x,y,s) = x,y,x+s;

//-------`(pm.)outRightWave`--------------
// Sends the signal of right going waves to the output channel of the [`chain`](#chain).
//
// #### Usage
//
// ```
// chain(A : outRightWave : B)
// ```
//
// Where `A` and `B` are bidirectional blocks.
//--------------------------------
outRightWave(x,y,s) = x,y,y+s;

//-------`(pm.)out`--------------
// Sends the signal of right and left going waves to the output channel of the
// [`chain`](#chain).
//
// #### Usage
//
// ```
// chain(A : out : B)
// ```
//
// Where `A` and `B` are bidirectional blocks.
//--------------------------------
out(x,y,s) = x,y,x+y+s;

//-------`(pm.)terminations`--------------
// Creates terminations on both sides of a [`chain`](#chain) without closing
// the inputs and outputs of the bidirectional signals chain. As for
// [`chain`](#chain), this function adds a 1 sample delay to the bidirectional
// signal, both ways. Of course, this function can be nested within a
// [`chain`](#chain).
//
// #### Usage
//
// ```
// terminations(a,b,c)
// with{
//		a = *(-1); // left termination
//		b = chain(D : E : F); // bidirectional chain of blocks (D, E, F, etc.)
//		c = *(-1); // right termination
// };
// ```
//----------------------------------------
terminations(a,b,c) = (_,ro.crossnn(1),_,_ : +,+,_ : b) ~ (a,c : ro.crossnn(1));

//-------`(pm.)lTermination`----------
// Creates a termination on the left side of a [`chain`](#chain) without
// closing the inputs and outputs of the bidirectional signals chain. This
// function adds a 1 sample delay near the termination and can be nested
// within another [`chain`](#chain).
//
// #### Usage
//
// ```
// lTerminations(a,b)
// with{
//		a = *(-1); // left termination
//		b = chain(D : E : F); // bidirectional chain of blocks (D, E, F, etc.)
// };
// ```
//----------------------------------------
lTermination(a,b) = (ro.crossnn(1),_,_ : _,+,_ : b) ~ a;

//-------`(pm.)rTermination`----------
// Creates a termination on the right side of a [`chain`](#chain) without
// closing the inputs and outputs of the bidirectional signals chain. This
// function adds a 1 sample delay near the termination and can be nested
// within another [`chain`](#chain).
//
// #### Usage
//
// ```
// rTerminations(b,c)
// with{
//		b = chain(D : E : F); // bidirectional chain of blocks (D, E, F, etc.)
//		c = *(-1); // right termination
// };
// ```
//----------------------------------------
rTermination(b,c) = (_,_,_,_ : +,_,_ : b) ~ (!,c);

//-------`(pm.)closeIns`----------
// Closes the inputs of a bidirectional chain in all directions.
//
// #### Usage
//
// ```
// closeIns : chain(...) : _,_,_
// ```
//----------------------------------------
closeIns = 0,0,0;

//-------`(pm.)closeOuts`----------
// Closes the outputs of a bidirectional chain in all directions except for the
// main signal output (3d output).
//
// #### Usage
//
// ```
// _,_,_ : chain(...) : _
// ```
//----------------------------------------
closeOuts = !,!,_;

//-------`(pm.)endChain`----------
// Closes the inputs and outputs of a bidirectional chain in all directions
// except for the main signal output (3d output).
//
// #### Usage
//
// ```
// endChain(chain(...)) : _
// ```
//----------------------------------------
endChain(b) = closeIns : b : closeOuts;


//==================================Basic Elements========================================
// Basic elements for physical modeling (e.g., waveguides, specific filters,
// etc.).
//========================================================================================

//-------`(pm.)waveguideN`----------
// A series of waveguide functions based on various types of delays (see
// [`fdelay[n]`](#fdelayn)).
//
// #### List of functions
//
// * `waveguideUd`: unit delay waveguide
// * `waveguideFd`: fractional delay waveguide
// * `waveguideFd2`: second order fractional delay waveguide
// * `waveguideFd4`: fourth order fractional delay waveguide
//
// #### Usage
//
// ```
// chain(A : waveguideUd(nMax,n) : B)
// ```
//
// Where:
//
// * `nMax`: the maximum length of the delays in the waveguide
// * `n`: the length of the delay lines in samples.
//----------------------------------
waveguideUd(nMax,n) = par(i,2,de.delay(nMax,n)),_;
waveguideFd(nMax,n) = par(i,2,de.fdelay(nMax,n)),_;
waveguideFd2(nMax,n) = par(i,2,de.fdelay2(nMax,n)),_;
waveguideFd4(nMax,n) = par(i,2,de.fdelay4(nMax,n)),_;


//-------`(pm.)waveguide`----------
// Standard `pm.lib` waveguide (based on [`waveguideFd4`](#waveguiden)).
//
// #### Usage
//
// ```
// chain(A : waveguide(nMax,n) : B)
// ```
//
// Where:
//
// * `nMax`: the maximum length of the delays in the waveguide
// * `n`: the length of the delay lines in samples.
//----------------------------------
waveguide(nMax,n) = waveguideFd4(nMax,n);


//-------`(pm.)bridgeFilter`----------
// Generic two zeros bridge FIR filter (as implemented in the
// [STK](https://ccrma.stanford.edu/software/stk/)) that can be used to
// implement the reflectance violin, guitar, etc. bridges.
//
// #### Usage
//
// ```
// _ : bridge(brightness,absorption) : _
// ```
//
// Where:
//
// * `brightness`: controls the damping of high frequencies (0-1)
// * `absorption`: controls the absorption of the brige and thus the t60 of
// the string plugged to it (0-1) (1 = 20 seconds)
//----------------------------------
// TODO: perhaps, the coefs of this filter should be adapted in function of SR
bridgeFilter(brightness,absorption,x) = rho * (h0 * x' + h1*(x+x''))
with{
    freq = 320;
    t60 = (1-absorption)*20;
    h0 = (1.0 + brightness)/2;
    h1 = (1.0 - brightness)/4;
    rho = pow(0.001,1.0/(freq*t60));
};


//-------`(pm.)modeFilter`----------
// Resonant bandpass filter that can be used to implement a single resonance
// (mode).
//
// #### Usage
//
// ```
// _ : modeFilter(freq,t60,gain) : _
// ```
//
// Where:
//
// * `freq`: mode frequency
// * `t60`: mode resonance duration (in seconds)
// * `gain`: mode gain (0-1)
//----------------------------------
modeFilter(freq,t60,gain) = fi.tf2(b0,b1,b2,a1,a2)*gain
with{
    b0 = 1;
    b1 = 0;
    b2 = -1;
    w = 2*ma.PI*freq/ma.SR;
    r = pow(0.001,1/float(t60*ma.SR));
    a1 = -2*r*cos(w);
    a2 = r^2;
};


//================================String Instruments======================================
// Low and high level string instruments parts. Most of the elements in
// this section can be used in a bidirectional chain.
//========================================================================================

//-------`(pm.)stringSegment`----------
// A string segment without terminations (just a simple waveguide).
//
// #### Usage
//
// ```
// chain(A : stringSegment(maxLength,length) : B)
// ```
//
// Where:
//
// * `maxLength`: the maximum length of the string in meters (should be static)
// * `length`: the length of the string in meters
//----------------------------------
stringSegment(maxLength,length) = waveguide(nMax,n)
with{
    nMax = maxLength : l2s;
    n = length : l2s/2;
};


//-------`(pm.)openString`----------
// A bidirectional block implementing a basic "generic" string with a
// selectable excitation position. Lowpass filters are built-in and
// allow to simulate the effect of dispersion on the sound and thus
// to change the "stiffness" of the string.
//
// #### Usage
//
// ```
// chain(... : openString(length,stiffness,pluckPosition,excitation) : ...)
// ```
//
// Where:
//
// * `length`: the length of the string in meters
// * `stiffness`: the stiffness of the string (0-1) (1 for max stiffness)
// * `pluckPosition`: excitation position (0-1) (1 is bottom)
// * `excitation`: the excitation signal
//----------------------------------
openString(length,stiffness,pluckPosition,excitation) = chain(stringSegment(maxStringLength,ntbd) : in(excitation) : dispersionFilters : stringSegment(maxStringLength,btbd))
with{
    dispersionFilters = par(i,2,si.smooth(stiffness)),_; // one pole filters
    maxStringLength = maxLength;
    ntbd = length*pluckPosition; // length of the upper portion of the string
    btbd = length*(1-pluckPosition); // length of the lower portion of the string
};


//-------`(pm.)nylonString`----------
// A bidirectional block implementing a basic nylon string with selectable
// excitation position. This element is based on [`openString`](#openstring)
// and has a fix stiffness corresponding to that of a nylon string.
//
// #### Usage
//
// ```
// chain(... : nylonString(length,pluckPosition,excitation) : ...)
// ```
//
// Where:
//
// * `length`: the length of the string in meters
// * `pluckPosition`: excitation position (0-1) (1 is bottom)
// * `excitation`: the excitation signal
//----------------------------------
nylonString(length,pluckPosition,excitation) =
openString(length,stiffness,pluckPosition,excitation)
with{
    stiffness = 0.4; // empirically set but it sounds good ;)
};


//-------`(pm.)steelString`----------
// A bidirectional block implementing a basic steel string with selectable
// excitation position. This element is based on [`openString`](#openstring)
// and has a fix stiffness corresponding to that of a steel string.
//
// #### Usage
//
// ```
// chain(... : steelString(length,pluckPosition,excitation) : ...)
// ```
//
// Where:
//
// * `length`: the length of the string in meters
// * `pluckPosition`: excitation position (0-1) (1 is bottom)
// * `excitation`: the excitation signal
//----------------------------------
steelString(length,pluckPosition,excitation) =
openString(length,stiffness,pluckPosition,excitation)
with{
    stiffness = 0.05; // empirically set but it sounds good ;)
    // in fact, we could almost get rid of the filters in that case,
    // but I think it's good to keep them for consistency
};


//-------`(pm.)openStringPick`----------
// A bidirectional block implementing a "generic" string with selectable
// excitation position. It also has a built-in pickup whose position is the
// same as the excitation position. Thus, moving the excitation position
// will also move the pickup.
//
// #### Usage
//
// ```
// chain(... : openStringPick(length,stiffness,pluckPosition,excitation) : ...)
// ```
//
// Where:
//
// * `length`: the length of the string in meters
// * `stiffness`: the stiffness of the string (0-1) (1 for max stiffness)
// * `pluckPosition`: excitation position (0-1) (1 is bottom)
// * `excitation`: the excitation signal
//----------------------------------
openStringPick(length,stiffness,pluckPosition,excitation) = strChain
with{
    dispersionFilters = par(i,2,si.smooth(stiffness)),_;
    maxStringLength = maxLength;
    nti = length*pluckPosition; // length of the upper portion of the string
    itb = length*(1-pluckPosition); // length of the lower portion of the string
    strChain = chain(stringSegment(maxStringLength,nti) : in(excitation) : out :
        dispersionFilters : stringSegment(maxStringLength,itb));
};


//-------`(pm.)openStringPickUp`----------
// A bidirectional block implementing a "generic" string with selectable
// excitation position and stiffness. It also has a built-in pickup whose
// position can be independenly selected. The only constraint is that the
// pickup has to be placed after the excitation position.
//
// #### Usage
//
// ```
// chain(... : openStringPickUp(length,stiffness,pluckPosition,excitation) : ...)
// ```
//
// Where:
//
// * `length`: the length of the string in meters
// * `stiffness`: the stiffness of the string (0-1) (1 for max stiffness)
// * `pluckPosition`: pluck position between the top of the string and the
// pickup (0-1) (1 for same as pickup position)
// * `pickupPosition`: position of the pickup on the string (0-1) (1 is bottom)
// * `excitation`: the excitation signal
//----------------------------------
openStringPickUp(length,stiffness,pluckPosition,pickupPosition,excitation) = strChain
with{
    dispersionFilters = par(i,2,si.smooth(stiffness)),_;
    maxStringLength = maxLength;
    nti = length*pluckPosition; // top to excitation length
    nto = nti*pickupPosition; // nuts to pickup length
    oti = nti*(1-pickupPosition); // pickup to excitation length
    itb = length*(1-pluckPosition); // pickup to bottom length
    strChain = chain(stringSegment(maxStringLength,nto) : out :
    stringSegment(maxStringLength,oti) : in(excitation) : dispersionFilters :
    stringSegment(maxStringLength,itb));
};


//-------`(pm.)openStringPickDown`----------
// A bidirectional block implementing a "generic" string with selectable
// excitation position and stiffness. It also has a built-in pickup whose
// position can be independenly selected. The only constraint is that the
// pickup has to be placed before the excitation position.
//
// #### Usage
//
// ```
// chain(... : openStringPickDown(length,stiffness,pluckPosition,excitation) : ...)
// ```
//
// Where:
//
// * `length`: the length of the string in meters
// * `stiffness`: the stiffness of the string (0-1) (1 for max stiffness)
// * `pluckPosition`: pluck position on the string (0-1) (1 is bottom)
// * `pickupPosition`: position of the pickup between the top of the string
// and the excitation position (0-1) (1 is excitation position)
// * `excitation`: the excitation signal
//----------------------------------
openStringPickDown(length,stiffness,pluckPosition,pickupPosition,excitation) =
strChain
with{
    dispersionFilters = par(i,2,si.smooth(stiffness)),_;
    maxStringLength = maxLength;
    nto = length*pickupPosition; // top to pickup length
    nti = nto*pluckPosition; // top to excitation length
    ito = nto*(1-pluckPosition); // excitation to pickup length
    otb = length*(1-pickupPosition); // pickup to bottom length
    strChain = chain(stringSegment(maxStringLength,nti) : in(excitation) :
    stringSegment(maxStringLength,ito) : out : dispersionFilters :
    stringSegment(maxStringLength,otb));
};


// TODO: eventually, we'd want to implement a generic function here that
// automatically switches the position of elements in the algorithm
// depending on the position of the pick. Even though this is currently
// possible, it will pose optimization issues (we'd want the new mute
// feature of Faust to be generalized in order to do that)

//-------`(pm.)ksReflexionFilter`----------
// The "typical" one-zero Karplus-strong feedforward reflexion filter. This
// filter will be typically used in a termination (see below).
//
// #### Usage
//
// ```
// terminations(_,chain(...),ksReflexionFilter)
// ```
//----------------------------------
ksReflexionFilter = _ <: (_+_')/2;


//-------`(pm.)rStringRigidTermination`----------
// Bidirectional block implementing a right rigid string termination (no damping,
// just phase inversion).
//
// #### Usage
//
// ```
// chain(rStringRigidTermination : stringSegment : ...)
// ```
//----------------------------------
rStringRigidTermination = rTermination(basicBlock,*(-1));


//-------`(pm.)lStringRigidTermination`----------
// Bidirectional block implementing a left rigid string termination (no damping,
// just phase inversion).
//
// #### Usage
//
// ```
// chain(... : stringSegment : lStringRigidTermination)
// ```
//----------------------------------
lStringRigidTermination = lTermination(*(-1),basicBlock);


//-------`(pm.)elecGuitarBridge`----------
// Bidirectional block implementing a simple electric guitar bridge. This
// block is based on [`bridgeFilter`](#bridgeFilter). The bridge doesn't
// implement transmittance since it is not meant to be connected to a
// body (unlike acoustic guitar). It also partially sets the resonance
// duration of the string with the nuts used on the other side.
//
// #### Usage
//
// ```
// chain(... : stringSegment : elecGuitarBridge)
// ```
//----------------------------------
elecGuitarBridge = rTermination(basicBlock,-bridgeFilter(0.8,0.6));


//-------`(pm.)elecGuitarNuts`----------
// Bidirectional block implementing a simple electric guitar nuts. This
// block is based on [`bridgeFilter`](#bridgeFilter) and does essentially
// the same thing as [`elecGuitarBridge`](#elecguitarbridge), but on the
// other side of the chain. It also partially sets the resonance duration of
// the string with the bridge used on the other side.
//
// #### Usage
//
// ```
// chain(elecGuitarNuts : stringSegment : ...)
// ```
//----------------------------------
elecGuitarNuts = lTermination(-bridgeFilter(0.8,0.6),basicBlock);


//-------`(pm.)guitarBridge`----------
// Bidirectional block implementing a simple acoustic guitar bridge. This
// bridge damps more hight frequencies than
// [`elecGuitarBridge`](#elecguitarbridge) and implements a transmittance
// filter. It also partially sets the resonance duration of the string with
// the nuts used on the other side.
//
// #### Usage
//
// ```
// chain(... : stringSegment : guitarBridge)
// ```
//----------------------------------
guitarBridge = rTermination(basicBlock,reflectance) : _,transmittance,_
with{
    reflectance = -bridgeFilter(0.4,0.5);
    transmittance = _; // TODO
};


//-------`(pm.)guitarNuts`----------
// Bidirectional block implementing a simple acoustic guitar nuts. This
// nuts damps more hight frequencies than
// [`elecGuitarNuts`](#elecguitarnuts) and implements a transmittance
// filter. It also partially sets the resonance duration of the string with
// the bridge used on the other side.
//
// #### Usage
//
// ```
// chain(guitarNuts : stringSegment : ...)
// ```
//----------------------------------
guitarNuts = lTermination(-bridgeFilter(0.4,0.5),basicBlock);


//-------`(pm.)idealString`----------
// An "ideal" string with rigid terminations and where the plucking position
// and the pick-up position are the same. Since terminations are rigid, this
// string will ring forever.
//
// #### Usage
//
// ```
// 1-1' : idealString(length,reflexion,xPosition,excitation)
// ```
//
// With:
// * `length`: the length of the string in meters
// * `pluckPosition`: the plucking position (0.001-0.999)
// * `excitation`: the input signal for the excitation.
//----------------------------------------------------------
idealString(length,pluckPosition,excitation) = wg
with{
    maxStringLength = maxLength;
    lengthTuning = 0.08; // tuned "by hand"
    tunedLength = length-lengthTuning;
    nUp = tunedLength*pluckPosition; // upper string segment length
    nDown = tunedLength*(1-pluckPosition); // lower string segment length
    wg = chain(lStringRigidTermination : stringSegment(maxStringLength,nUp) :
    in(excitation) : out : stringSegment(maxStringLength,nDown) :
    rStringRigidTermination); // waveguide chain
};


//-------`(pm.)ks`----------
// A Karplus-Strong string (in that case, the string is implemented as a
// one dimension waveguide).
//
// #### Usage
//
// ```
// ks(length,damping,excitation) : _
// ```
//
// Where:
//
// * `length`: the length of the string in meters
// * `damping`: string damping (0-1)
// * `excitation`: excitation signal
//----------------------------------
ks(length,damping,excitation) = endChain(ksChain)
with{
    maxStringLength = maxLength;
    lengthTuning = 0.05; // tuned "by hand"
    tunedLength = length-lengthTuning;
    refCoef = (1-damping)*0.2+0.8;
    refFilter = ksReflexionFilter*refCoef;
    ksChain = terminations(_,chain(in(excitation) :
    stringSegment(maxStringLength,tunedLength) : out),refFilter);
};


//-------`(pm.)ks_ui_MIDI`----------
// Ready-to-use, MIDI-enabled Karplus-Strong string with buil-in UI.
//
// #### Usage
//
// ```
// ks_ui_MIDI : _
// ```
//----------------------------------
ks_ui_MIDI = gate : impulseExcitation*gain : ks( (freq : f2l), damping )
with{
    f = hslider("v:karplus/h:[0]params/[0]freq[style:knob]",440,50,1000,0.01);
    bend = ba.semi2ratio(hslider("v:karplus/h:[0]params/[1]bend[style:knob][hidden:1][midi:pitchwheel]"
    ,0,-2,2,0.01)) : si.polySmooth(gate,0.999,1);
    gain = hslider("v:karplus/h:[0]params/[2]gain[style:knob]",0.8,0,1,0.01);
    s = hslider("v:karplus/h:[0]params/[3]sustain[hidden:1][midi:ctrl 64][style:knob]"
    ,0,0,1,1);
    damping = hslider("v:karplus/h:[0]params/[1]damping[midi:ctrl 1][style:knob]"
    ,0.01,0,1,0.01) : si.smoo;
    t = button("v:karplus/[1]gate");

    gate = t+s : min(1);
    freq = f*bend;
};


//-------`(pm.)elecGuitarModel`----------
// A simple electric guitar model (without audio effects, of course) with
// selectable pluck position.
// This model implements a single string. Additional strings should be created
// by making a polyphonic applications out of this function. Pitch is changed by
// changing the length of the string and not through a finger model.
//
// #### Usage
//
// ```
// elecGuitarModel(length,pluckPosition,mute,excitation) : _
// ```
//
// Where:
//
// * `length`: the length of the string in meters
// * `pluckPosition`: pluck position (0-1) (1 is on the bridge)
// * `mute`: mute coefficient (1 for no mute and 0 for instant mute)
// * `excitation`: excitation signal
//----------------------------------
elecGuitarModel(length,pluckPosition,mute,excitation) = endChain(egChain)
with{
    maxStringLength = maxLength;
    lengthTuning = 0.11; // tuned "by hand"
    stringL = length-lengthTuning;
    muteBlock = *(mute),*(mute),_;
    egChain = chain(
        elecGuitarNuts :
        openStringPick(stringL,0.05,pluckPosition,excitation) :
        muteBlock :
        elecGuitarBridge);
};


//-------`(pm.)elecGuitar`----------
// A simple electric guitar model with steel strings (based on
// [`elecGuitarModel`](#elecguitarmodel)) implementing an excitation
// model.
// This model implements a single string. Additional strings should be created
// by making a polyphonic applications out of this function.
//
// #### Usage
//
// ```
// elecGuitar(length,pluckPosition,trigger) : _
// ```
//
// Where:
//
// * `length`: the length of the string in meters
// * `pluckPosition`: pluck position (0-1) (1 is on the bridge)
// * `mute`: mute coefficient (1 for no mute and 0 for instant mute)
// * `gain`: gain of the pluck (0-1)
// * `trigger`: trigger signal (1 for on, 0 for off)
//----------------------------------
elecGuitar(stringLength,pluckPosition,mute,gain,trigger) =
pluckString(stringLength,1,1,1,gain,trigger) :
elecGuitarModel(stringLength,pluckPosition,mute);


//-------`(pm.)elecGuitar_ui_MIDI`----------
// Ready-to-use MIDI-enabled electric guitar physical model with built-in UI.
//
// #### Usage
//
// ```
// elecGuitar_ui_MIDI : _
// ```
//----------------------------------
elecGuitar_ui_MIDI = elecGuitar(stringLength,pluckPosition,1,gain,gate)*outGain
with{
    f = hslider("v:elecGuitar/h:[0]midi/[0]freq[style:knob]",440,50,1000,0.01);
    bend = ba.semi2ratio(hslider("v:elecGuitar/h:[0]midi/[1]bend[hidden:1][midi:pitchwheel][style:knob]"
    ,0,-2,2,0.01)) : si.polySmooth(gate,0.999,1);
    gain = hslider("v:elecGuitar/h:[0]midi/[2]gain[style:knob]",0.8,0,1,0.01);
    s = hslider("v:elecGuitar/h:[0]midi/[3]sustain[hidden:1]
    [midi:ctrl 64][style:knob]",0,0,1,1);
    pluckPosition = hslider("v:elecGuitar/[1]pluckPosition[midi:ctrl 1]",0.8,0,1,0.01) : si.smoo;
    outGain = hslider("v:elecGuitar/[2]outGain",0.5,0,1,0.01);
    t = button("v:elecGuitar/[3]gate");
    gate = t+s : min(1);
    freq = f*bend;
    stringLength = freq : f2l;
};


//-------`(pm.)guitarBody`----------
// WARNING: not implemented yet!
// Bidirectional block implementing a simple acoustic guitar body.
//
// #### Usage
//
// ```
// chain(... : guitarBody)
// ```
//----------------------------------
// TODO: not implemented yet
guitarBody = reflectance,transmittance,_
with{
    transmittance = _;
    reflectance = _;
};


//-------`(pm.)guitarModel`----------
// A simple acoustic guitar model with steel strings and selectable excitation
// position. This model implements a single string. Additional strings should be created
// by making a polyphonic applications out of this function. Pitch is changed by
// changing the length of the string and not through a finger model.
// WARNING: this function doesn't currently implement a body (just strings and
// bridge).
//
// #### Usage
//
// ```
// guitarModel(length,pluckPosition,excitation) : _
// ```
//
// Where:
//
// * `length`: the length of the string in meters
// * `pluckPosition`: pluck position (0-1) (1 is on the bridge)
// * `excitation`: excitation signal
//----------------------------------
guitarModel(length,pluckPosition,excitation) = endChain(egChain)
with{
    maxStringLength = maxLength;
    lengthTuning = 0.1; // tuned "by hand"
    stringL = length-lengthTuning;
    egChain = chain(guitarNuts : steelString(stringL,pluckPosition,excitation) :
    guitarBridge : guitarBody : out);
};


//-------`(pm.)guitar`----------
// A simple acoustic guitar model with steel strings (based on
// [`guitarModel`](#guitarmodel)) implementing an excitation model.
// This model implements a single string. Additional strings should be created
// by making a polyphonic applications out of this function.
//
// #### Usage
//
// ```
// guitar(length,pluckPosition,trigger) : _
// ```
//
// Where:
//
// * `length`: the length of the string in meters
// * `pluckPosition`: pluck position (0-1) (1 is on the bridge)
// * `gain`: gain of the excitation
// * `trigger`: trigger signal (1 for on, 0 for off)
//----------------------------------
guitar(stringLength,pluckPosition,gain,trigger) =
pluckString(stringLength,1,1.5,1,gain,trigger) : guitarModel(stringLength, pluckPosition);


//-------`(pm.)guitar_ui_MIDI`----------
// Ready-to-use MIDI-enabled steel strings acoustic guitar physical model with
// built-in UI.
//
// #### Usage
//
// ```
// guitar_ui_MIDI : _
// ```
//----------------------------------
guitar_ui_MIDI = guitar(stringLength,pluckPosition,gain,gate)*outGain
with{
    f = hslider("v:guitar/h:[0]midi/[0]freq[style:knob]",440,50,1000,0.01);
    bend = ba.semi2ratio(hslider("v:guitar/h:[0]midi/[1]bend[hidden:1][midi:pitchwheel]
    [style:knob]",0,-2,2,0.01)) : si.polySmooth(gate,0.999,1);
    gain = hslider("v:guitar/h:[0]midi/[2]gain[style:knob]",0.8,0,1,0.01);
    s = hslider("v:guitar/h:[0]midi/[3]sustain[hidden:1][midi:ctrl 64]
    [style:knob]",0,0,1,1);
    pluckPosition = hslider("v:guitar/pluckPosition[midi:ctrl 1]"
    ,0.8,0,1,0.01) : si.smoo;
    outGain = hslider("v:guitar/outGain",0.5,0,1,0.01);
    t = button("v:guitar/[4]gate");
    gate = t+s : min(1);
    freq = f*bend;
    stringLength = freq : f2l;
};


//-------`(pm.)nylonGuitarModel`----------
// A simple acoustic guitar model with nylon strings and selectable excitation
// position. This model implements a single string. Additional strings should be created
// by making a polyphonic applications out of this function. Pitch is changed by
// changing the length of the string and not through a finger model.
// WARNING: this function doesn't currently implement a body (just strings and
// bridge).
//
// #### Usage
//
// ```
// nylonGuitarModel(length,pluckPosition,excitation) : _
// ```
//
// Where:
//
// * `length`: the length of the string in meters
// * `pluckPosition`: pluck position (0-1) (1 is on the bridge)
// * `excitation`: excitation signal
//----------------------------------
nylonGuitarModel(length,pluckPosition,excitation) = endChain(egChain)
with{
    maxStringLength = maxLength; // meters
    lengthTuning = 0.11;
    stringL = length-lengthTuning;
    egChain = chain(guitarNuts : nylonString(stringL,pluckPosition,excitation) :
    guitarBridge : guitarBody : out);
};


//-------`(pm.)nylonGuitar`----------
// A simple acoustic guitar model with nylon strings (based on
// [`nylonGuitarModel`](#nylonguitarmodel)) implementing an excitation model.
// This model implements a single string. Additional strings should be created
// by making a polyphonic applications out of this function.
//
// #### Usage
//
// ```
// nylonGuitar(length,pluckPosition,trigger) : _
// ```
//
// Where:
//
// * `length`: the length of the string in meters
// * `pluckPosition`: pluck position (0-1) (1 is on the bridge)
// * `gain`: gain of the excitation (0-1)
// * `trigger`: trigger signal (1 for on, 0 for off)
//----------------------------------
nylonGuitar(stringLength,pluckPosition,gain,trigger) =
pluckString(stringLength,1,1.5,1,gain,trigger) : nylonGuitarModel(stringLength, pluckPosition);


//-------`(pm.)nylonGuitar_ui_MIDI`----------
// Ready-to-use MIDI-enabled nylon strings acoustic guitar physical model with
// built-in UI.
//
// #### Usage
//
// ```
// nylonGuitar_ui_MIDI : _
// ```
//----------------------------------
nylonGuitar_ui_MIDI = nylonGuitar(stringLength,pluckPosition,gain,gate)*outGain
with{
    f = hslider("v:nylonGuitar/h:[0]midi/[0]freq[style:knob]",440,50,1000,0.01);
    bend = ba.semi2ratio(hslider("v:nylonGuitar/h:[0]midi/[1]bend[hidden:1][midi:pitchwheel]
    [style:knob]",0,-2,2,0.01)) : si.polySmooth(gate,0.999,1);
    gain = hslider("v:nylonGuitar/h:[0]midi/[2]gain[style:knob]",0.8,0,1,0.01);
    s = hslider("v:nylonGuitar/h:[0]midi/[3]sustain[hidden:1][midi:ctrl 64]
    [style:knob]",0,0,1,1);
    pluckPosition = hslider("v:nylonGuitar/pluckPosition[midi:ctrl 1]"
    ,0.8,0,1,0.01) : si.smoo;
    outGain = hslider("v:nylonGuitar/outGain",0.5,0,1,0.01);
    t = button("v:nylonGuitar/[4]gate");
    gate = t+s : min(1);
    freq = f*bend;
    stringLength = freq : f2l;
};


//-------`(pm.)modeInterpRes`----------
// Modular string instrument resonator based on IR measurements made on 3D 
// printed models. The 2D space allowing for the control of the shape and the
// scale of the model is enabled by interpolating between modes parameters.
// More information about this technique/project can be found here: 
// <https://ccrma.stanford.edu/~rmichon/3dPrintingModeling/>.
//
// #### Usage
//
// ```
// _ : modeInterpRes(nModes,x,y) : _
// ```
//
// Where:
//
// * `nModes`: number of modeled modes (40 max)
// * `x`: shape of the resonator (0: square, 1: square with rounded corners, 2: round)
// * `y`: scale of the resonator (0: small, 1: medium, 2: large)
//----------------------------------
modeInterpRes(nModes,x,y) = _ <: par(i,min(40,nModes),modeFilter(modeFreq(i),modeT60(i),modeGain(i))) :> /(nModes)
with{
	// modes parameters
	roundBigCenterFreq(i) = ba.take(i+1,(286.134404,476.384455,602.872587,831.823345,862.773611,1024.985313,1209.932428,1515.548598,1777.819591,2001.806241,2674.135433,3154.282144,3329.555657,3431.385589,3673.656995,4228.801853,4389.842060,4552.745406,4766.151594,4854.354993,4970.516137,5064.203325,5200.399916,5347.650831,5459.807495,5630.144253,5870.258034,6121.961406,6244.522341,6677.052569,7233.100711,7520.031251,7677.902736,7805.138717,9918.905945,10418.988301,11296.101954,11432.719867,13422.238365,13679.232778));
	roundBigCenterGain(i) = ba.take(i+1,(1.000000,0.609711,0.222375,0.025505,0.026108,0.026840,0.605767,0.368186,0.093526,0.016656,0.159600,0.013836,0.044000,0.023103,0.107971,0.013696,0.043615,0.039848,0.041903,0.043671,0.055018,0.041730,0.062832,0.030464,0.028049,0.012880,0.047154,0.084707,0.050532,0.032735,0.031938,0.023554,0.017534,0.017268,0.026202,0.013725,0.015611,0.021294,0.011486,0.011875));
	roundBigCenterT60(i) = ba.take(i+1,(0.283544,0.076723,0.287423,0.058391,0.075172,0.120794,0.131540,0.081173,0.088549,0.034991,0.060237,0.014153,0.074709,0.068893,0.033354,0.032013,0.019088,0.020992,0.026703,0.018040,0.015815,0.016671,0.028732,0.017929,0.021520,0.024622,0.022706,0.023138,0.027323,0.020556,0.024577,0.023669,0.024714,0.024420,0.017733,0.017881,0.018715,0.017737,0.015660,0.016464));
	roundMidCenterFreq(i) = ba.take(i+1,(380.910663,615.862831,933.855656,1128.769825,1231.353452,1404.948092,1764.641239,2095.586536,2451.220548,2566.435588,2781.467120,2946.757398,3522.047891,3748.375254,3892.352583,4340.896246,4454.851770,4629.302932,4806.417393,5024.545475,5604.684752,5671.112515,6533.147087,6751.949816,6862.781990,6951.226279,7180.863112,7901.631311,8074.662174,8979.395914,10075.249374,10521.350963,11964.859921,14227.213322,15501.455250,15587.852956,16290.138756,16418.172746,16663.266694,17991.614994));
	roundMidCenterGain(i) = ba.take(i+1,(1.000000,0.437495,0.110598,0.025858,0.010841,0.022400,0.245241,0.187990,0.029650,0.058174,0.007035,0.013188,0.009767,0.059284,0.160848,0.007463,0.016816,0.008689,0.031644,0.045608,0.019773,0.018546,0.013495,0.018482,0.020130,0.015417,0.031109,0.007624,0.008526,0.032539,0.009846,0.007605,0.019866,0.007583,0.008991,0.009194,0.010128,0.008557,0.009333,0.007494));
	roundMidCenterT60(i) = ba.take(i+1,(0.193654,0.076056,0.197517,0.019475,0.043087,0.063829,0.074308,0.059791,0.082616,0.081949,0.042855,0.036140,0.068564,0.041711,0.043799,0.025988,0.057494,0.028353,0.018586,0.018651,0.025380,0.021250,0.019217,0.016326,0.019469,0.020754,0.019487,0.019590,0.011348,0.015969,0.015674,0.016305,0.026772,0.010597,0.009926,0.007595,0.008676,0.008274,0.011471,0.012424));
	roundSmallCenterFreq(i) = ba.take(i+1,(511.119501,860.897453,977.675690,1245.454667,1408.823199,1604.478891,1825.857776,1960.985105,2340.204377,2594.337460,2700.041698,3277.766643,3388.510632,3505.100505,4151.457765,4257.308449,4425.319123,4526.878869,4629.688075,4819.012204,5493.628166,6323.383769,6514.513248,6709.979636,6823.104590,7009.748398,7198.916858,9019.248381,9492.252653,9706.451249,9858.889433,10080.422278,10252.000811,10389.864946,12327.892342,12465.475093,13491.187794,15072.291233,15176.746743,20143.302052));
	roundSmallCenterGain(i) = ba.take(i+1,(1.000000,0.686570,0.362616,0.178685,0.113981,0.158727,0.024067,0.023659,0.085113,0.192224,0.174412,0.160279,0.042275,0.042204,0.027219,0.040505,0.064866,0.069074,0.029473,0.033054,0.055311,0.073694,0.071341,0.068366,0.026735,0.037359,0.026008,0.025958,0.025327,0.052859,0.082911,0.038156,0.046079,0.034839,0.022738,0.024480,0.158056,0.026848,0.028009,0.031387));
	roundSmallCenterT60(i) = ba.take(i+1,(0.200041,0.030199,0.050855,0.020135,0.020101,0.026910,0.043249,0.040814,0.058128,0.047490,0.051189,0.069063,0.047344,0.049448,0.024720,0.027275,0.028407,0.030171,0.026606,0.030289,0.040772,0.023856,0.020889,0.032859,0.027543,0.026427,0.032154,0.020576,0.032990,0.019344,0.019827,0.018571,0.017213,0.019002,0.020440,0.021329,0.023027,0.018833,0.018344,0.018811));
	semBigCenterFreq(i) = ba.take(i+1,(318.812824,545.646717,727.103717,813.406232,938.026296,1067.472803,1239.311077,1478.409235,1567.366603,1840.215865,2162.299536,2302.660906,2394.006715,2499.397129,2724.662564,2876.713036,3051.447083,3219.116214,3378.667296,3507.736722,3687.907343,3827.904993,4039.858029,4208.742422,4385.651803,4574.818448,4744.136436,4866.893882,5090.532579,5200.283111,5448.339367,5751.719886,6040.059676,6500.665192,6780.883377,6878.732474,7127.463954,7701.025454,10337.623684,17411.019601));
	semBigCenterGain(i) = ba.take(i+1,(1.000000,0.386065,0.297923,0.235171,0.346593,0.219093,0.050655,0.310031,0.175387,0.180464,0.064716,0.070721,0.027399,0.076973,0.086367,0.024188,0.100553,0.028776,0.027974,0.040200,0.031680,0.021694,0.035362,0.031821,0.027726,0.037219,0.026308,0.016164,0.022938,0.046669,0.031128,0.027430,0.032404,0.018356,0.026887,0.041003,0.012779,0.028785,0.013346,0.017281));
	semBigCenterT60(i) = ba.take(i+1,(0.195061,0.269748,0.108389,0.132557,0.127125,0.113759,0.159514,0.058527,0.067333,0.071996,0.067001,0.054194,0.052818,0.050935,0.045373,0.051611,0.051410,0.061272,0.050844,0.029415,0.021966,0.023483,0.022866,0.023418,0.033572,0.026764,0.017334,0.021394,0.025984,0.026146,0.018801,0.018242,0.022440,0.020939,0.011937,0.011739,0.020314,0.013848,0.016504,0.085830));
	semMidCenterFreq(i) = ba.take(i+1,(316.511541,548.598445,682.927606,764.088220,1145.795222,1280.068992,1524.562996,1677.146625,2083.900770,2285.783756,2452.226740,2779.274140,3196.405966,3569.262928,3798.251779,4071.264178,4413.799330,4550.364404,4966.398087,5156.799448,5363.124121,5611.038360,5995.650074,6162.624225,6583.973014,7029.525719,7207.893991,7706.775019,7844.032020,10298.804956,10564.531850,11615.688447,12056.168362,12661.205157,12876.405687,13082.890228,13851.437211,14452.383106,15683.910228,16667.950883));
	semMidCenterGain(i) = ba.take(i+1,(0.999641,0.798181,0.200080,0.280473,0.042761,0.079955,0.286673,0.162652,1.000000,0.309945,0.097527,0.023964,0.124529,0.155314,0.075600,0.178980,0.089168,0.134962,0.120730,0.036885,0.024020,0.102628,0.085255,0.059439,0.023339,0.027443,0.141618,0.044053,0.024269,0.046682,0.034465,0.068930,0.070502,0.025912,0.076088,0.024972,0.038501,0.051135,0.027801,0.022469));
	semMidCenterT60(i) = ba.take(i+1,(0.210670,0.062329,0.097470,0.136802,0.077790,0.025877,0.054632,0.060485,0.061625,0.061352,0.060614,0.030867,0.039440,0.030054,0.037956,0.030948,0.046137,0.045345,0.025326,0.025515,0.022514,0.043142,0.018663,0.015057,0.052844,0.016478,0.025993,0.017880,0.014006,0.022971,0.017720,0.032173,0.015391,0.009217,0.028936,0.011895,0.012607,0.018141,0.018341,0.018180));
	semSmallCenterFreq(i) = ba.take(i+1,(440.578370,637.619026,828.182637,978.279267,1088.401911,1321.315700,1648.932125,1817.216790,1938.686740,2173.897496,2450.967026,2582.312643,2748.003128,2858.292897,2973.003533,3235.482621,3348.561906,3496.046199,3706.507771,3934.307821,4418.408376,5239.069796,5428.018005,5771.733971,6106.378549,6304.512786,6788.234913,6905.001294,7054.694449,7227.988097,7348.344488,8450.449049,9000.316477,10930.327581,11271.451255,11418.301881,13448.385700,13938.733921,14334.394664,17413.449273));
	semSmallCenterGain(i) = ba.take(i+1,(1.000000,0.297197,0.715097,0.178811,0.229363,0.183731,0.107685,0.120764,0.060436,0.503361,0.352264,0.056432,0.042926,0.090906,0.224894,0.128151,0.257120,0.076416,0.096971,0.078669,0.065573,0.057421,0.085378,0.085397,0.050578,0.046534,0.213480,0.090142,0.078632,0.089706,0.276299,0.061182,0.038941,0.045447,0.043447,0.051347,0.055647,0.071836,0.040813,0.066853));
	semSmallCenterT60(i) = ba.take(i+1,(0.136710,0.070656,0.049965,0.034104,0.023973,0.032990,0.049605,0.026798,0.024777,0.040671,0.039262,0.035240,0.019214,0.053001,0.045917,0.045864,0.048770,0.040981,0.020747,0.022565,0.031089,0.026788,0.013828,0.023917,0.022485,0.035319,0.017955,0.014831,0.018902,0.014661,0.032984,0.027729,0.025067,0.021211,0.016910,0.027488,0.013164,0.012325,0.019985,0.079428));
	squareBigCenterFreq(i) = ba.take(i+1,(222.231629,336.343611,555.041069,772.219662,911.261442,1096.774273,1203.102824,1404.011001,1540.420421,1628.944840,1994.925663,2197.106949,2533.354244,2672.470165,2821.185962,2967.436266,3342.189608,3479.723368,3631.705350,3806.882908,3910.078404,4173.779128,4292.901543,4519.288440,4631.053559,4855.405142,5079.828139,5182.392108,5328.291818,5636.817979,5983.629129,6104.013800,6184.547942,6602.614840,6718.247643,6835.844044,6882.254514,7220.774814,7283.263950,7407.672066));
	squareBigCenterGain(i) = ba.take(i+1,(0.581227,1.000000,0.167366,0.663184,0.127173,0.141424,0.232076,0.043454,0.168681,0.244908,0.193343,0.147543,0.062214,0.112585,0.383899,0.053139,0.104651,0.093521,0.029220,0.027646,0.020979,0.031887,0.052610,0.045000,0.023542,0.049426,0.029063,0.049062,0.015097,0.030925,0.032215,0.032146,0.050862,0.016861,0.019228,0.021428,0.021039,0.016988,0.017971,0.033065));
	squareBigCenterT60(i) = ba.take(i+1,(0.417113,0.247980,0.103791,0.131234,0.194764,0.130569,0.119615,0.103862,0.102785,0.079975,0.068871,0.120830,0.066401,0.064964,0.037272,0.057999,0.038435,0.036927,0.036970,0.069147,0.036096,0.049136,0.046268,0.029452,0.025066,0.020942,0.040527,0.027374,0.030986,0.019875,0.028632,0.032344,0.033709,0.024938,0.063833,0.032297,0.028473,0.025768,0.024877,0.026385));
	squareMidCenterFreq(i) = ba.take(i+1,(306.243391,426.381556,523.626577,637.813655,855.576390,992.200454,1098.863347,1226.922784,1545.950522,1704.776255,1839.163057,1983.832482,2190.814571,2445.409860,2672.907579,2782.642755,2983.850376,3268.313978,3458.038380,3590.850048,3783.143602,4123.002328,4250.310528,4408.442518,4531.916055,4865.211680,5248.660726,5387.011592,5780.593786,5880.954673,6095.291499,6432.605387,6596.403501,6820.917687,6907.055108,7030.829711,7337.883035,7602.739152,7926.836412,12248.346109));
	squareMidCenterGain(i) = ba.take(i+1,(1.000000,0.292592,0.554710,0.359595,0.041223,0.283249,0.182057,0.078666,0.898203,0.105021,0.037156,0.128493,0.302569,0.134081,0.090181,0.116704,0.041711,0.268207,0.079651,0.034128,0.296838,0.051959,0.124454,0.077586,0.084915,0.126202,0.019697,0.017643,0.077301,0.068367,0.023764,0.015924,0.022163,0.017954,0.029917,0.021449,0.019083,0.026076,0.017965,0.017018));
	squareMidCenterT60(i) = ba.take(i+1,(0.236061,0.179001,0.084440,0.165197,0.083836,0.055543,0.067029,0.054547,0.046195,0.055390,0.052760,0.079021,0.073765,0.059744,0.071780,0.050510,0.036326,0.036162,0.039268,0.031777,0.037990,0.072567,0.045824,0.026516,0.027684,0.034229,0.040867,0.037800,0.026894,0.023151,0.023381,0.021277,0.023057,0.020207,0.019672,0.016358,0.024757,0.017036,0.016600,0.010195));
	squareSmallCenterFreq(i) = ba.take(i+1,(375.008194,527.945584,775.002560,981.584262,1125.203834,1287.701398,1394.790058,1577.138666,1727.825366,1860.700270,1950.809059,2020.169063,2185.798879,2382.343983,2587.140759,2792.652735,2970.443881,3047.515682,3332.695227,3416.636119,3513.876416,3994.492272,4128.261485,4247.828681,4425.131019,4686.893838,4731.141754,5553.904972,5702.206389,6415.071752,6552.422900,6785.461423,6990.104471,7256.116515,7884.508530,8787.479467,10529.849261,10641.861836,12075.018006,17405.170359));
	squareSmallCenterGain(i) = ba.take(i+1,(0.991070,1.000000,0.515946,0.549911,0.115279,0.157813,0.463743,0.206985,0.131491,0.244054,0.160114,0.116274,0.161678,0.048839,0.071332,0.072482,0.097678,0.083415,0.057484,0.059259,0.034662,0.064479,0.061452,0.110522,0.045770,0.053318,0.051225,0.034998,0.051538,0.081127,0.039422,0.226011,0.053013,0.052620,0.041956,0.058147,0.061262,0.046118,0.038256,0.124151));
	squareSmallCenterT60(i) = ba.take(i+1,(0.102256,0.088069,0.026433,0.131998,0.050149,0.052897,0.066531,0.060621,0.045315,0.047413,0.058375,0.059098,0.029950,0.018537,0.024086,0.032984,0.036868,0.032205,0.023710,0.023430,0.015516,0.022773,0.025265,0.028872,0.019743,0.036565,0.032704,0.025234,0.028383,0.018356,0.018609,0.017534,0.018699,0.015762,0.022800,0.013151,0.012300,0.018114,0.013192,0.085670));
	
	// computing modes freq in function of x and y
	modeFreq(i) = zxd + (zxu-zxd)*select2(y<1,(y-1),y)
	with{
		zx0 = squareSmallCenterFreq(i) + (semSmallCenterFreq(i)-squareSmallCenterFreq(i))*x;
		zx1 = semSmallCenterFreq(i) + (roundSmallCenterFreq(i)-semSmallCenterFreq(i))*(x-1);
		zx2 = squareMidCenterFreq(i) + (semMidCenterFreq(i)-squareMidCenterFreq(i))*x;
		zx3 = semMidCenterFreq(i) + (roundMidCenterFreq(i)-semMidCenterFreq(i))*(x-1);
		zx4 = squareBigCenterFreq(i) + (semBigCenterFreq(i)-squareBigCenterFreq(i))*x;
		zx5 = semBigCenterFreq(i) + (roundBigCenterFreq(i)-semBigCenterFreq(i))*(x-1);
		zxd = select2(y<1,select2(x<1,zx3,zx2),select2(x<1,zx1,zx0));
		zxu = select2(y<1,select2(x<1,zx5,zx4),select2(x<1,zx3,zx2));
	};

	// computing modes gain in function of x and y
	modeGain(i) = zxd + (zxu-zxd)*select2(y<1,(y-1),y) 
	with{
		zx0 = squareSmallCenterGain(i) + (semSmallCenterGain(i)-squareSmallCenterGain(i))*x;
		zx1 = semSmallCenterGain(i) + (roundSmallCenterGain(i)-semSmallCenterGain(i))*(x-1);
		zx2 = squareMidCenterGain(i) + (semMidCenterGain(i)-squareMidCenterGain(i))*x;
		zx3 = semMidCenterGain(i) + (roundMidCenterGain(i)-semMidCenterGain(i))*(x-1);
		zx4 = squareBigCenterGain(i) + (semBigCenterGain(i)-squareBigCenterGain(i))*x;
		zx5 = semBigCenterGain(i) + (roundBigCenterGain(i)-semBigCenterGain(i))*(x-1);
		zxd = select2(y<1,select2(x<1,zx3,zx2),select2(x<1,zx1,zx0));
		zxu = select2(y<1,select2(x<1,zx5,zx4),select2(x<1,zx3,zx2));
	};

	// computing modes T60 in function of x and y
	modeT60(i) = zxd + (zxu-zxd)*select2(y<1,(y-1),y) //: min(0.1)
	with{
		zx0 = squareSmallCenterT60(i) + (semSmallCenterT60(i)-squareSmallCenterT60(i))*x;
		zx1 = semSmallCenterT60(i) + (roundSmallCenterT60(i)-semSmallCenterT60(i))*(x-1);
		zx2 = squareMidCenterT60(i) + (semMidCenterT60(i)-squareMidCenterT60(i))*x;
		zx3 = semMidCenterT60(i) + (roundMidCenterT60(i)-semMidCenterT60(i))*(x-1);
		zx4 = squareBigCenterT60(i) + (semBigCenterT60(i)-squareBigCenterT60(i))*x;
		zx5 = semBigCenterT60(i) + (roundBigCenterT60(i)-semBigCenterT60(i))*(x-1);
		zxd = select2(y<1,select2(x<1,zx3,zx2),select2(x<1,zx1,zx0));
		zxu = select2(y<1,select2(x<1,zx5,zx4),select2(x<1,zx3,zx2));
	};
};


//-------`(pm.)modularInterpBody`----------
// Bidirectional block implementing a modular string instrument resonator 
// (see [`modeInterpRes`](#pm.modeinterpres)).
//
// #### Usage
//
// ```
// chain(... : modularInterpBody(nModes,shape,scale) : ...)
// ```
//
// Where:
//
// * `nModes`: number of modeled modes (40 max)
// * `shape`: shape of the resonator (0: square, 1: square with rounded corners, 2: round)
// * `scale`: scale of the resonator (0: small, 1: medium, 2: large)
//----------------------------------
modularInterpBody(nModes,shape,scale) = _,modeInterpRes(nModes,shape,scale),_;


//-------`(pm.)modularInterpStringModel`----------
// String instrument model with a modular body (see 
// [`modeInterpRes`](#pm.modeinterpres) and 
// <https://ccrma.stanford.edu/~rmichon/3dPrintingModeling/>).
//
// #### Usage
//
// ```
// modularInterpStringModel(length,pluckPosition,shape,scale,bodyExcitation,stringExcitation) : _
// ```
//
// Where:
//
// * `stringLength`: the length of the string in meters
// * `pluckPosition`: pluck position (0-1) (1 is on the bridge)
// * `shape`: shape of the resonator (0: square, 1: square with rounded corners, 2: round)
// * `scale`: scale of the resonator (0: small, 1: medium, 2: large)
// * `bodyExcitation`: excitation signal for the body
// * `stringExcitation`: excitation signal for the string
//----------------------------------
modularInterpStringModel(stringLength,pluckPosition,shape,scale,bodyExcitation,stringExcitation) = endChain(egChain)*0.5
with{
    maxStringLength = maxLength;
    lengthTuning = 0.1; // tuned "by hand"
    stringL = stringLength-lengthTuning;
    nBodyModes = 40;
    egChain = chain(guitarNuts : steelString(stringL,pluckPosition,stringExcitation) :
    guitarBridge : inRightWave(bodyExcitation) : modularInterpBody(nBodyModes,shape,scale) : out);
};


//-------`(pm.)modularInterpInstr`----------
// String instrument with a modular body (see 
// [`modeInterpRes`](#pm.modeinterpres) and 
// <https://ccrma.stanford.edu/~rmichon/3dPrintingModeling/>).
//
// #### Usage
//
// ```
// modularInterpInstr(stringLength,pluckPosition,shape,scale,gain,tapBody,triggerString) : _
// ```
//
// Where:
//
// * `stringLength`: the length of the string in meters
// * `pluckPosition`: pluck position (0-1) (1 is on the bridge)
// * `shape`: shape of the resonator (0: square, 1: square with rounded corners, 2: round)
// * `scale`: scale of the resonator (0: small, 1: medium, 2: large)
// * `gain`: of the string excitation
// * `tapBody`: send an impulse in the body of the instrument where the string is connected (1 for on, 0 for off)
// * `triggerString`: trigger signal for the string (1 for on, 0 for off)
//----------------------------------
modularInterpInstr(stringLength,pluckPosition,shape,scale,gain,tapBody,triggerString) = 
(tapBody : ba.impulsify), pluckString(stringLength,1,1,1,gain,triggerString) : 
modularInterpStringModel(stringLength,pluckPosition,shape,scale);


//-------`(pm.)modularInterpInstr_ui_MIDI`----------
// Ready-to-use MIDI-enabled string instrument with a modular body (see 
// [`modeInterpRes`](#pm.modeinterpres) and 
// <https://ccrma.stanford.edu/~rmichon/3dPrintingModeling/>)
// with built-in UI.
//
// #### Usage
//
// ```
// modularInterpInstr_ui_MIDI : _
// ```
//----------------------------------
modularInterpInstr_ui_MIDI = modularInterpInstr(stringLength,pluckPosition,shape,scale,gain,tapBody,gate)*outGain
with{
    f = hslider("v:modularInterpInstr/h:[0]midi/[0]freq[style:knob]",440,50,1000,0.01);
    bend = ba.semi2ratio(hslider("v:modularInterpInstr/h:[0]midi/[1]bend[hidden:1][midi:pitchwheel]
    [style:knob]",0,-2,2,0.01)) : si.polySmooth(gate,0.999,1);
    gain = hslider("v:modularInterpInstr/h:[0]midi/[2]gain[style:knob]",0.8,0,1,0.01);
    s = hslider("v:modularInterpInstr/h:[0]midi/[3]sustain[hidden:1][midi:ctrl 64]
    [style:knob]",0,0,1,1);
    shape = hslider("v:modularInterpInstr/h:[1]body/[0]shape[style:knob]",0,0,1,0.01)*2;
    scale = hslider("v:modularInterpInstr/h:[1]body/[1]scale[style:knob]",0,0,1,0.011)*2;
    tapBody = button("v:modularInterpInstr/h:[1]body/[2]tapBody");
    pluckPosition = hslider("v:modularInterpInstr/[2]pluckPosition[midi:ctrl 1]"
    ,0.8,0,1,0.01) : si.smoo;
    outGain = hslider("v:modularInterpInstr/[3]outGain",0.5,0,1,0.01);
    t = button("v:modularInterpInstr/[4]gate");
    gate = t+s : min(1);
    freq = f*bend;
    stringLength = freq : f2l;
};


//=============================Bowed String Instruments===================================
// Low and high level basic string instruments parts. Most of the elements in
// this section can be used in a bidirectional chain.
//========================================================================================

//-------`(pm.)bowTable`----------
// Extremely basic bow table that can be used to implement a wide range of
// bow types for many different bowed string instruments (violin, cello, etc.).
//
// #### Usage
//
// ```
// excitation : bowTable(offeset,slope) : _
// ```
//
// Where:
//
// * `excitation`: an excitation signal
// * `offset`: table offset
// * `slope`: table slope
//----------------------------------
bowTable(offset,slope) = pow(abs(sample) + 0.75, -4) : min(1)
with{
	sample = +(offset)*slope;
};


//-------`(pm.)violinBowTable`----------
// Violin bow table based on [`bowTable`](#bowtable).
//
// #### Usage
//
// ```
// bowVelocity : violinBowTable(bowPressure) : _
// ```
//
// Where:
//
// * `bowVelocity`: velocity of the bow/excitation signal (0-1)
// * `bowPressure`: bow pressure on the string (0-1)
//----------------------------------
violinBowTable(bowPressure) = bowTable(0,tableSlope)
with{
	tableSlope = 5 - (4*bowPressure);
};


//-------`(pm.)bowInteraction`----------
// Bidirectional block implementing the interaction of a bow in a
// [`chain`](#chain).
//
// #### Usage
//
// ```
// chain(... : stringSegment : bowInteraction(bowTable) : stringSegment : ...)
// ```
//
// Where:
//
// * `bowTable`: the bow table
//----------------------------------
bowInteraction(b) = (_,_ <: b,_,_ :> _,_),_;


//-------`(pm.)violinBow`----------
// Bidirectional block implementing a violin bow and its interaction with
// a string.
//
// #### Usage
//
// ```
// chain(... : stringSegment : violinBow(bowPressure,bowVelocity) : stringSegment : ...)
// ```
//
// Where:
//
// * `bowVelocity`: velocity of the bow / excitation signal (0-1)
// * `bowPressure`: bow pressure on the string (0-1)
//----------------------------------
violinBow(bowPressure,bowVelocity) = bowInteraction(bowSystem)
with{
	bowSystem = + : bowVelocity-_ <: *(violinBowTable(bowPressure)) <: _,_;
};


//-------`(pm.)violinBowedString`----------
// Violin bowed string bidirectional block with controllable bow position.
// Terminations are not implemented in this model.
//
// #### Usage
//
// ```
// chain(nuts : violinBowedString(stringLength,bowPressure,bowVelocity,bowPosition) : bridge)
// ```
//
// Where:
//
// * `stringLength`: the length of the string in meters
// * `bowVelocity`: velocity of the bow / excitation signal (0-1)
// * `bowPressure`: bow pressure on the string (0-1)
// * `bowPosition`: the position of the bow on the string (0-1)
//----------------------------------
violinBowedString(stringLength,bowPressure,bowVelocity,bowPosition) =
    chain(
        stringSegment(maxStringLength,ntbd) :
        violinBow(bowPressure,bowVelocity) :
        stringSegment(maxStringLength,btbd)
    )
    with{
        maxStringLength = maxLength;
        ntbd = stringLength*bowPosition; // upper portion of the string length
        btbd = stringLength*(1-bowPosition); // lower portion of the string length
    };


//-------`(pm.)violinNuts`----------
// Bidirectional block implementing simple violin nuts. This function is
// based on [`bridgeFilter`](#bridgefilter).
//
// #### Usage
//
// ```
// chain(violinNuts : stringSegment : ...)
// ```
//----------------------------------
violinNuts = lTermination(-bridgeFilter(0.6,0.1),basicBlock);


//-------`(pm.)violinBridge`----------
// Bidirectional block implementing a simple violin bridge. This function is
// based on [`bridgeFilter`](#bridgefilter).
//
// #### Usage
//
// ```
// chain(... : stringSegment : violinBridge
// ```
//----------------------------------
// TODO:
// 	* reflectance is not implemented yet
violinBridge = rTermination(basicBlock,reflectance) : _,transmittance,_
with{
    reflectance = -bridgeFilter(0.2,0.9);
    transmittance = _;
};


//-------`(pm.)violinBody`----------
// Bidirectional block implementing a simple violin body (just a simple
// resonant lowpass filter).
//
// #### Usage
//
// ```
// chain(... : stringSegment : violinBridge : violinBody)
// ```
//----------------------------------
// TODO:
// 	* reflectance is not implemented yet
violinBody = reflectance,transmittance,_
with{
    transmittance = fi.resonbp(500,2,1);
    reflectance = _;
};


//-------`(pm.)violinModel`----------
// Ready-to-use simple violin physical model. This model implements a single
// string. Additional strings should be created
// by making a polyphonic applications out of this function. Pitch is changed
// by changing the length of the string (and not through a finger model).
//
// #### Usage
//
// ```
// violinModel(stringLength,bowPressure,bowVelocity,bridgeReflexion,
// bridgeAbsorption,bowPosition) : _
// ```
//
// Where:
//
// * `stringLength`: the length of the string in meters
// * `bowVelocity`: velocity of the bow / excitation signal (0-1)
// * `bowPressure`: bow pressure on the string (0-1))
// * `bowPosition`: the position of the bow on the string (0-1)
//----------------------------------
violinModel(stringLength,bowPressure,bowVelocity,bowPosition) =
	endChain(modelChain)
with{
	stringTuning = 0.08;
	stringL = stringLength-stringTuning;
	modelChain = chain(
		violinNuts :
		violinBowedString(stringL,bowPressure,bowVelocity,bowPosition) :
		violinBridge :
		violinBody :
		out
	);
};


//-------`(pm.)violin_ui`----------
// Ready-to-use violin physical model with built-in UI.
//
// #### Usage
//
// ```
// violinModel_ui : _
// ```
//----------------------------------
violin_ui = violinModel(stringLength,bowPress,bowVel,bowPos)*outGain
with{
    stringLength = hslider("v:violin/v:[0]string/[0]length",0.75,0,2,0.01) : si.smoo;
    bowVel = hslider("v:violin/v:[1]bow/[0]velocity",0,0,1,0.01) : si.smoo;
    bowPress = hslider("v:violin/v:[1]bow/[1]pressure",0.5,0,1,0.01) : si.smoo;
    bowPos = hslider("v:violin/v:[1]bow/[2]position",0.7,0,1,0.01) : si.smoo;
    outGain = hslider("v:violin/outGain",0.5,0,1,0.01);
};


//-------`(pm.)violin_ui_MIDI`----------
// Ready-to-use MIDI-enabled violin physical model with built-in UI.
//
// #### Usage
//
// ```
// violin_ui_MIDI : _
// ```
//----------------------------------
violin_ui_MIDI = violinModel(stringLength,bowPress,bowVel,bowPos)*outGain
with{
    f = hslider("v:violin/h:[0]midi/[0]freq[style:knob]",440,50,1000,0.01);
    bend = ba.semi2ratio(hslider("v:violin/h:[0]midi/[1]bend[hidden:1][midi:pitchwheel]
    [style:knob]",0,-2,2,0.01)) : si.polySmooth(gate,0.999,1);
    gain = hslider("v:violin/h:[0]midi/[2]gain[style:knob]
    ",0.6,0,1,0.01);
    envAttack = hslider("v:violin/h:[0]midi/[3]envAttack[style:knob]
    ",1,0,30,0.01)*0.001;
    s = hslider("v:violin/h:[0]midi/[4]sustain[hidden:1][midi:ctrl 64]
    [style:knob]",0,0,1,1);
    bowPress = hslider("v:violin/h:[1]bow/[0]pressure[style:knob]
    [midi:ctrl 1]",0.5,0,1,0.01) : si.smoo;
    bowPos = hslider("v:violin/h:[1]bow/[1]position[style:knob]
    ",0.7,0,1,0.01) : si.smoo;
    vibratoFreq = hslider("v:violin/h:[2]otherParams/[0]vibratoFrequency
    [style:knob]",6,1,10,0.01);
    vibratoGain = hslider("v:violin/h:[2]otherParams/[1]vibratoGain
    [style:knob]",0.5,0,1,0.01)*0.01;
    outGain = hslider("v:violin/h:[2]otherParams/[2]outGain[style:knob]
    ",0.5,0,1,0.01);
    t = button("v:violin/[3]gate");

    gate = t+s : min(1);
    vibrato = 1+os.osc(vibratoFreq)*vibratoGain*envelope;
    freq = f*bend*vibrato;
    envelope = gate*gain : si.smooth(ba.tau2pole(envAttack));

    stringLength = freq : f2l;
    bowVel = envelope;
};


//=================================Wind Instruments=======================================
// Low and high level basic wind instruments parts. Most of the elements in
// this section can be used in a bidirectional chain.
//========================================================================================

//-------`(pm.)openTube`----------
// A tube segment without terminations (same as [`stringSegment`](#stringsegment)).
//
// #### Usage
//
// ```
// chain(A : openTube(maxLength,length) : B)
// ```
//
// Where:
//
// * `maxLength`: the maximum length of the tube in meters (should be static)
// * `length`: the length of the tube in meters
//----------------------------------
openTube = stringSegment;


//-------`(pm.)reedTable`----------
// Extremely basic reed table that can be used to implement a wide range of
// single reed types for many different instruments (saxophone, clarinet, etc.).
//
// #### Usage
//
// ```
// excitation : reedTable(offeset,slope) : _
// ```
//
// Where:
//
// * `excitation`: an excitation signal
// * `offset`: table offset
// * `slope`: table slope
//----------------------------------
reedTable(offset,slope) = reedTable : min(1) : max(-1)
with {
    reedTable = *(slope) + offset;
};


//-------`(pm.)fluteJetTable`----------
// Extremely basic flute jet table.
//
// #### Usage
//
// ```
// excitation : fluteJetTable : _
// ```
//
// Where:
//
// * `excitation`: an excitation signal
//----------------------------------
fluteJetTable = _ <: *(* : -(1)) : clipping
with{
    clipping = min(1) : max(-1);
};


//-------`(pm.)brassLipsTable`----------
// Simple brass lips/mouthpiece table. Since this implementation is very basic
// and that the lips and tube of the instrument are coupled to each other, the
// length of that tube must be provided here.
//
// #### Usage
//
// ```
// excitation : brassLipsTable(tubeLength,lipsTension) : _
// ```
//
// Where:
//
// * `excitation`: an excitation signal (can be DC)
// * `tubeLength`: length in meters of the tube connected to the mouthpiece
// * `lipsTension`: tension of the lips (0-1) (default: 0.5)
//----------------------------------
brassLipsTable(tubeLength,lipsTension) = *(0.03) : lipFilter <: * : clipping
with{
    clipping = min(1) : max(-1);
    freq = (tubeLength : l2f)*pow(4,(2*lipsTension)-1);
    filterR = 0.997;
    a1 = -2*filterR*cos(ma.PI*2*freq/ma.SR);
    lipFilter = fi.tf2(1,0,0,a1,pow(filterR,2)); // resonance with same freq as tube
};


//-------`(pm.)clarinetReed`----------
// Clarinet reed based on [`reedTable`](#reedtable) with controllable
// stiffness.
//
// #### Usage
//
// ```
// excitation : clarinetReed(stiffness) : _
// ```
//
// Where:
//
// * `excitation`: an excitation signal
// * `stiffness`: reed stiffness (0-1)
//----------------------------------
clarinetReed(stiffness) = reedTable(0.7,tableSlope)
with{
    tableSlope = -0.44 + 0.26*stiffness;
};


//-------`(pm.)clarinetMouthPiece`----------
// Bidirectional block implementing a clarinet mouthpiece as well as the various
// interactions happening with traveling waves. This element is ready to be
// plugged to a tube...
//
// #### Usage
//
// ```
// chain(clarinetMouthPiece(reedStiffness,pressure) : tube : etc.)
// ```
//
// Where:
//
// * `pressure`: the pressure of the air flow (DC) created by the virtual performer (0-1).
// This can also be any kind of signal that will directly injected in the mouthpiece
// (e.g., breath noise, etc.).
// * `reedStiffness`: reed stiffness (0-1)
//----------------------------------
clarinetMouthPiece(reedStiffness,pressure) = lTermination(reedInteraction,in(pressure))
with{
    reedInteraction = *(-1) <: *(clarinetReed(reedStiffness));
};


//-------`(pm.)brassLips`----------
// Bidirectional block implementing a brass mouthpiece as well as the various
// interactions happening with traveling waves. This element is ready to be
// plugged to a tube...
//
// #### Usage
//
// ```
// chain(brassLips(tubeLength,lipsTension,pressure) : tube : etc.)
// ```
//
// Where:
//
// * `tubeLength`: length in meters of the tube connected to the mouthpiece
// * `lipsTension`: tension of the lips (0-1) (default: 0.5)
// * `pressure`: the pressure of the air flow (DC) created by the virtual performer (0-1).
// This can also be any kind of signal that will directly injected in the mouthpiece
// (e.g., breath noise, etc.).
//----------------------------------
brassLips(tubeLength,lipsTension,pressure) = lTermination(mpInteraction,basicBlock)
with{
    absorption = *(0.85); // absorption coefficient
    p = pressure*0.3; // scaling pressure
    mpInteraction = absorption <:
    (p-_ : brassLipsTable(tubeLength,lipsTension) <: *(p),1-_),_ : _,* : + : fi.dcblocker;
};


//-------`(pm.)fluteEmbouchure`----------
// Bidirectional block implementing a flute embouchure as well as the various
// interactions happening with traveling waves. This element is ready to be
// plugged between tubes segments...
//
// #### Usage
//
// ```
// chain(... : tube : fluteEmbouchure(pressure) : tube : etc.)
// ```
//
// Where:
//
// * `pressure`: the pressure of the air flow (DC) created by the virtual
// performer (0-1).
// This can also be any kind of signal that will directly injected in the
// mouthpiece (e.g., breath noise, etc.).
//----------------------------------
fluteEmbouchure(pressure) =
(_ <: _,_),_,_ : _,*(0.5)+(pressure-_*0.5 : fluteJetTable),_;


//-------`(pm.)wBell`----------
// Generic wind instrument bell bidirectional block that should be placed at
// the end of a [`chain`](#chain).
//
// #### Usage
//
// ```
// chain(... : wBell(opening))
// ```
//
// Where:
//
// * `opening`: the "opening" of bell (0-1)
//----------------------------------
wBell(opening) = rTermination(basicBlock,si.smooth(opening));


//-------`(pm.)fluteHead`----------
// Simple flute head implementing waves reflexion.
//
// #### Usage
//
// ```
// chain(fluteHead : tube : ...)
// ```
//----------------------------------
fluteHead = lTermination(*(absorption),basicBlock)
with{
    absorption = 0.95; // same as for foot
};


//-------`(pm.)fluteFoot`----------
// Simple flute foot implementing waves reflexion and dispersion.
//
// #### Usage
//
// ```
// chain(... : tube : fluteFoot)
// ```
//----------------------------------
fluteFoot = rTermination(basicBlock,*(absorption) : dispersion)
with{
    dispersion = si.smooth(0.7); // just a simple lowpass
    absorption = 0.95;           // same as for head
};


//-------`(pm.)clarinetModel`----------
// A simple clarinet physical model without tone holes (pitch is changed by
// changing the length of the tube of the instrument).
//
// #### Usage
//
// ```
// clarinetModel(length,pressure,reedStiffness,bellOpening) : _
// ```
//
// Where:
//
// * `tubeLength`: the length of the tube in meters
// * `pressure`: the pressure of the air flow created by the virtual performer (0-1).
// This can also be any kind of signal that will directly injected in the mouthpiece
// (e.g., breath noise, etc.).
// * `reedStiffness`: reed stiffness (0-1)
// * `bellOpening`: the opening of bell (0-1)
//----------------------------------
clarinetModel(tubeLength,pressure,reedStiffness,bellOpening) = endChain(modelChain)
with{
	lengthTuning = 0.05; // empirical adjustment of the tuning of the tube
	maxTubeLength = maxLength;
	tunedLength = tubeLength/2-lengthTuning; // not really sure why we had to shift octave here
	modelChain =
		chain(
			clarinetMouthPiece(reedStiffness,pressure) :
			openTube(maxTubeLength,tunedLength) :
			wBell(bellOpening) : out
		);
};


//-------`(pm.)clarinetModel_ui`----------
// Same as [`clarinetModel`](#clarinetModel) but with a built-in UI. This function
// doesn't implement a virtual "blower", thus `pressure` remains an argument here.
//
// #### Usage
//
// ```
// clarinetModel_ui(pressure) : _
// ```
//
// Where:
//
// * `pressure`: the pressure of the air flow created by the virtual performer (0-1).
// This can also be any kind of signal that will be directly injected in the mouthpiece
// (e.g., breath noise, etc.).
//----------------------------------
clarinetModel_ui(pressure) = clarinetModel(tubeLength,pressure,reedStiffness,bellOpening)*outGain
with{
    tubeLength = hslider("v:clarinetModel/[0]tubeLength",0.8,0.01,3,0.01) : si.smoo;
    reedStiffness = hslider("v:clarinetModel/[1]reedStiffness",0.5,0,1,0.01);
    bellOpening = hslider("v:clarinetModel/[2]bellOpening",0.5,0,1,0.01);
    outGain = hslider("v:clarinetModel/[3]outGain",0.5,0,1,0.01);
};


//-------`(pm.)clarinet_ui`----------
// Ready-to-use clarinet physical model with built-in UI based on
// [`clarinetModel`](#clarinetmodel).
//
// #### Usage
//
// ```
// clarinet_ui : _
// ```
//----------------------------------
clarinet_ui = hgroup("clarinet",blower_ui : clarinetModel_ui);


//-------`(pm.)clarinet_ui_MIDI`----------
// Ready-to-use MIDI compliant clarinet physical model with built-in UI.
//
// #### Usage
//
// ```
// clarinet_ui_MIDI : _
// ```
//----------------------------------
clarinet_ui_MIDI =
clarinetModel(tubeLength,blow,reedStiffness,bellOpening)*outGain
with{
    f = hslider("v:clarinet/h:[0]midi/[0]freq[style:knob]",440,50,1000,0.01);
    bend = ba.semi2ratio(hslider("v:clarinet/h:[0]midi/[1]bend[hidden:1][midi:pitchwheel]
    [style:knob]",0,-2,2,0.01)) : si.polySmooth(gate,0.999,1);
    gain = hslider("v:clarinet/h:[0]midi/[2]gain[style:knob]
    ",0.6,0,1,0.01);
    envAttack = hslider("v:clarinet/h:[0]midi/[3]envAttack[style:knob]
    ",1,0,30,0.01)*0.001;
    s = hslider("v:clarinet/h:[0]midi/[4]sustain[hidden:1][midi:ctrl 64]
    [style:knob]",0,0,1,1);
    reedStiffness = hslider("v:clarinet/h:[1]otherParams/[0]reedStiffness
    [midi:ctrl 1][style:knob]",0.5,0,1,0.01);
    bellOpening = hslider("v:clarinet/h:[1]otherParams/[1]bellOpening
    [midi:ctrl 3][style:knob]",0.5,0,1,0.01);
    vibratoFreq = hslider("v:clarinet/h:[1]otherParams/[2]vibratoFreq
    [style:knob]",5,1,10,0.01);
    vibratoGain = hslider("v:clarinet/h:[1]otherParams/[3]vibratoGain
    [style:knob]",0.25,0,1,0.01)*0.01;
    outGain = hslider("v:clarinet/h:[1]otherParams/[4]outGain[style:knob]
    ",0.5,0,1,0.01);
    t = button("v:clarinet/[2]gate");

    gate = t+s : min(1);
    vibrato = 1+os.osc(vibratoFreq)*vibratoGain*envelope;
    freq = f*bend*vibrato;
    envelope = gate*gain : si.smooth(ba.tau2pole(envAttack));

    tubeLength = freq : f2l;
    pressure = envelope; // TODO: double vibrato here!!
    blow = blower(pressure,0.05,2000,vibratoFreq,vibratoGain);
};


//-------`(pm.)brassModel`----------
// A simple generic brass instrument physical model without pistons
// (pitch is changed by changing the length of the tube of the instrument).
// This model is kind of hard to control and might not sound very good if
// bad parameters are given to it...
//
// #### Usage
//
// ```
// brassModel(tubeLength,lipsTension,mute,pressure) : _
// ```
//
// Where:
//
// * `tubeLength`: the length of the tube in meters
// * `lipsTension`: tension of the lips (0-1) (default: 0.5)
// * `mute`: mute opening at the end of the instrument (0-1) (default: 0.5)
// * `pressure`: the pressure of the air flow created by the virtual performer (0-1).
// This can also be any kind of signal that will directly injected in the mouthpiece
// (e.g., breath noise, etc.).
//----------------------------------
brassModel(tubeLength,lipsTension,mute,pressure) = endChain(brassChain)
with{
    maxTubeLength = maxLength;
    lengthTuning = 0; // Not that important for that one because of lips tension
    tunedLength = tubeLength + lengthTuning;
    brassChain = chain(brassLips(tunedLength,lipsTension,pressure) : openTube(maxTubeLength,tunedLength) : wBell(mute) : out);
};


//-------`(pm.)brassModel_ui`----------
// Same as [`brassModel`](#brassModel) but with a built-in UI. This function
// doesn't implement a virtual "blower", thus `pressure` remains an argument here.
//
// #### Usage
//
// ```
// brassModel_ui(pressure) : _
// ```
//
// Where:
//
// * `pressure`: the pressure of the air flow created by the virtual performer (0-1).
// This can also be any kind of signal that will be directly injected in the mouthpiece
// (e.g., breath noise, etc.).
//----------------------------------
brassModel_ui(pressure) = brassModel(tubeLength,lipsTension,mute,pressure)
with{
    tubeLength = hslider("v:brassModel/[1]tubeLength",0.5,0.01,2.5,0.01) : si.smoo;
    lipsTension = hslider("v:brassModel/[2]lipsTension",0.5,0,1,0.01) : si.smoo;
    mute = hslider("v:brassModel/[3]mute",0.5,0,1,0.01) : si.smoo;
};


//-------`(pm.)brass_ui`----------
// Ready-to-use brass instrument physical model with built-in UI based on
// [`brassModel`](#brassmodel).
//
// #### Usage
//
// ```
// brass_ui : _
// ```
//----------------------------------
brass_ui = hgroup("brass",blower_ui : brassModel_ui);


//-------`(pm.)brass_ui_MIDI`----------
// Ready-to-use MIDI-controllable brass instrument physical model with built-in UI.
//
// #### Usage
//
// ```
// brass_ui_MIDI : _
// ```
//----------------------------------
brass_ui_MIDI = brassModel(tubeLength,lipsTension,mute,pressure)*outGain
with{
    f = hslider("v:brass/h:[0]midi/[0]freq[style:knob]",440,50,1000,0.01);
    bend = ba.semi2ratio(hslider("v:brass/h:[0]midi/[1]bend[hidden:1][midi:pitchwheel]
    [style:knob]",0,-2,2,0.01)) : si.polySmooth(gate,0.999,1);
    gain = hslider("v:brass/h:[0]midi/[2]gain[style:knob]
    ",0.5,0,1,0.01);
    envAttack = hslider("v:brass/h:[0]midi/[3]envAttack[style:knob]
    ",1,0,30,0.01)*0.001;
    s = hslider("v:brass/h:[0]midi/[4]sustain[hidden:1][midi:ctrl 64]
    [style:knob]",0,0,1,1);
    lipsTension = hslider("v:brass/h:[1]otherParams/[0]lipsTension[style:knob]
    [midi:ctrl 1]",0.5,0,1,0.01) : si.smoo;
    mute = hslider("v:brass/h:[1]otherParams/[1]mute[style:knob]
    ",0.5,0,1,0.01) : si.smoo;
    vibratoFreq = hslider("v:brass/h:[1]otherParams/[2]vibratoFreq[style:knob]
    ",5,1,10,0.01);
    vibratoGain = hslider("v:brass/h:[1]otherParams/[3]vibratoGain[style:knob]
    ",0.5,0,1,0.01)*0.04;
    outGain = hslider("v:brass/h:[1]otherParams/[4]outGain[style:knob]
    ",0.5,0,1,0.01);
    t = button("v:brass/[2]gate");

    gate = t+s : min(1);
    vibrato = 1+os.osc(vibratoFreq)*vibratoGain*envelope;
    freq = f*bend;
    envelope = gate*gain : si.smooth(ba.tau2pole(envAttack));

    tubeLength = freq : f2l;
    pressure = envelope*vibrato;
};


//-------`(pm.)fluteModel`----------
// A simple generic flute instrument physical model without tone holes
// (pitch is changed by changing the length of the tube of the instrument).
//
// #### Usage
//
// ```
// fluteModel(tubeLength,mouthPosition,pressure) : _
// ```
//
// Where:
//
// * `tubeLength`: the length of the tube in meters
// * `mouthPosition`: position of the mouth on the embouchure (0-1) (default: 0.5)
// * `pressure`: the pressure of the air flow created by the virtual performer (0-1).
// This can also be any kind of signal that will directly injected in the mouthpiece
// (e.g., breath noise, etc.).
//----------------------------------
// TODO: this model is out of tune and we're not really sure why
fluteModel(tubeLength,mouthPosition,pressure) = endChain(fluteChain) : fi.dcblocker
with{
    maxTubeLength = maxLength;
    tubeTuning = 0.27; // set "by hand"
    tLength = tubeLength+tubeTuning; // global tube length
    embouchurePos = 0.27 + (mouthPosition-0.5)*0.4; // position of the embouchure on the tube
    tted = tLength*embouchurePos; // head to embouchure distance
    eted = tLength*(1-embouchurePos); // embouchure to foot distance
    fluteChain = chain(fluteHead : openTube(maxTubeLength,tted) : fluteEmbouchure(pressure) : openTube(maxTubeLength,eted) : fluteFoot : out);
};


//-------`(pm.)fluteModel_ui`----------
// Same as [`fluteModel`](#fluteModel) but with a built-in UI. This function
// doesn't implement a virtual "blower", thus `pressure` remains an argument here.
//
// #### Usage
//
// ```
// fluteModel_ui(pressure) : _
// ```
//
// Where:
//
// * `pressure`: the pressure of the air flow created by the virtual performer (0-1).
// This can also be any kind of signal that will be directly injected in the mouthpiece
// (e.g., breath noise, etc.).
//----------------------------------
fluteModel_ui(pressure) =
fluteModel(tubeLength,mouthPosition,pressure)*outGain
with{
    tubeLength = hslider("v:fluteModel/[0]tubeLength",0.8,0.01,3,0.01) : si.smoo;
    mouthPosition = hslider("v:fluteModel/[1]mouthPosition",0.5,0,1,0.01) : si.smoo;
    outGain = hslider("v:fluteModel/[2]outGain",0.5,0,1,0.01);
};


//-------`(pm.)flute_ui`----------
// Ready-to-use flute physical model with built-in UI based on
// [`fluteModel`](#flutemodel).
//
// #### Usage
//
// ```
// flute_ui : _
// ```
//----------------------------------
flute_ui = hgroup("flute",blower_ui : fluteModel_ui);


//-------`(pm.)flute_ui_MIDI`----------
// Ready-to-use MIDI-controllable flute physical model with built-in UI.
//
// #### Usage
//
// ```
// flute_ui_MIDI : _
// ```
//----------------------------------
flute_ui_MIDI = fluteModel(tubeLength,mouthPosition,blow)*outGain
with{
    f = hslider("v:flute/h:[0]midi/[0]freq[style:knob]",440,50,1000,0.01);
    bend = ba.semi2ratio(hslider("v:flute/h:[0]midi/[1]bend[hidden:1][midi:pitchwheel]
    [style:knob]",0,-2,2,0.01)) : si.polySmooth(gate,0.999,1);
    gain = hslider("v:flute/h:[0]midi/[2]gain[style:knob]
    ",0.9,0,1,0.01);
    envAttack = hslider("v:flute/h:[0]midi/[3]envAttack[style:knob]
    ",1,0,30,0.01)*0.001;
    s = hslider("v:flute/h:[0]midi/[4]sustain[hidden:1][midi:ctrl 64]
    [style:knob]",0,0,1,1);
    mouthPosition = hslider("v:flute/h:[1]otherParams/[0]mouthPosition
    [style:knob][midi:ctrl 1]",0.5,0,1,0.01)
    : si.smoo;
    vibratoFreq = hslider("v:flute/h:[1]otherParams/[1]vibratoFreq[style:knob]
    ",5,1,10,0.01);
    vibratoGain = hslider("v:flute/h:[1]otherParams/[2]vibratoGain[style:knob]
    ",0.5,0,1,0.01)*0.04;
    outGain = hslider("v:flute/h:[1]otherParams/[3]outGain[style:knob]
    ",0.5,0,1,0.01);
    t = button("v:flute/[2]gate");

    gate = t+s : min(1);
    freq = f*bend;
    envelope = gate*gain : si.smooth(ba.tau2pole(envAttack));

    tubeLength = freq : f2l;
    pressure = envelope;
    blow = blower(pressure,0.05,2000,vibratoFreq,vibratoGain);
};


//=====================================Exciters===========================================
// Various kind of excitation signal generators.
//========================================================================================

//-------`(pm.)impulseExcitation`--------------
// Creates an impulse excitation of one sample.
//
// #### Usage
//
// ```
// gate = button('gate');
// impulseExcitation(gate) : chain;
// ```
//
// Where:
//
// * `gate`: a gate button
//--------------------------------------
impulseExcitation(trigger) = trigger : ba.impulsify;


//-------`(pm.)strikeModel`--------------
// Creates a filtered noise excitation.
//
// #### Usage
//
// ```
// gate = button('gate');
// strikeModel(LPcutoff,HPcutoff,sharpness,gain,gate) : chain;
// ```
//
// Where:
//
// * `HPcutoff`: highpass cutoff frequency
// * `LPcutoff`: lowpass cutoff frequency
// * `sharpness`: sharpness of the attack and release (0-1)
// * `gain`: gain of the excitation
// * `gate`: a gate button/trigger signal (0/1)
//--------------------------------------
strikeModel(HPcutoff,LPcutoff,sharpness,gain,trigger) =
no.noise : fi.highpass(2,HPcutoff) : fi.lowpass(2,LPcutoff) :
*(en.ar(att,rel,trigger))*gain
with{
    att = 0.002*sharpness;
    rel = att;
};


//-------`(pm.)strike`--------------
// Strikes generator with controllable excitation position.
//
// #### Usage
//
// ```
// gate = button('gate');
// strike(exPos,sharpness,gain,gate) : chain;
// ```
//
// Where:
//
// * `exPos`: excitation position wiht 0: for max low freqs and 1: for max high
// freqs. So, on membrane for example, 0 would be the middle and 1 the edge
// * `sharpness`: sharpness of the attack and release (0-1)
// * `gain`: gain of the excitation
// * `gate`: a gate button/trigger signal (0/1)
//--------------------------------------
strike(exPos,sharpness,gain,trigger) = strikeModel(HPcutoff,LPcutoff,sharpness,gain,trigger)
with{
	HPcutoff = 40+exPos*500;
	LPcutoff = 500+exPos*15000;
};


//-------`(pm.)pluckString`--------------
// Creates a plucking excitation signal.
//
// #### Usage
//
// ```
// trigger = button('gate');
// pluckString(stringLength,cutoff,maxFreq,sharpness,trigger)
// ```
//
// Where:
//
// * `stringLength`: length of the string to pluck
// * `cutoff`: cutoff ratio (1 for default)
// * `maxFreq`: max frequency ratio (1 for default)
// * `sharpness`: sharpness of the attack and release (1 for default)
// * `gain`: gain of the excitation (0-1)
// * `trigger`: trigger signal (1 for on, 0 for off)
//--------------------------------------
pluckString(stringLength,cutoff,maxFreq,sharpness,gain,trigger) =
no.noise : fi.lowpass(2,cutoffreq) : *(en.ar(att,rel,trigger))*gain
with{
    freq = stringLength : l2f;
    maxF = 2000*maxFreq;
    att = 0.002*sharpness*pow((1 - freq/maxF),2);
    rel = att;
    cutoffreq = freq*5*cutoff;
};


//-------`(pm.)blower`--------------
// A virtual blower creating a DC signal with some breath noise in it.
//
// #### Usage
//
// ```
// blower(pressure,breathGain,breathCutoff) : _
// ```
//
// Where:
//
// * `pressure`: pressure (0-1)
// * `breathGain`: breath noise gain (0-1) (recommended: 0.005)
// * `breathCutoff`: breath cuttoff frequency (Hz) (recommended: 2000)
//--------------------------------------
blower(pressure,breathGain,breathCutoff,vibratoFreq,vibratoGain) = pressure + vibrato + breathNoise
with{
    vibrato = os.osc(vibratoFreq)*vibratoGain;
    breathNoise = no.noise : fi.lowpass(2,breathCutoff) : *(pressure*breathGain);
};


//-------`(pm.)blower_ui`--------------
// Same as [`blower`](#blower) but with a built-in UI.
//
// #### Usage
//
// ```
// blower : somethingToBeBlown
// ```
//--------------------------------------
blower_ui = blower(pressure,breathGain,breathCutoff,vibratoFreq,vibratoGain)
with{
    pressure = hslider("v:blower/[0]pressure",0,0,1,0.01) : si.smoo;
    breathGain = hslider("v:blower/[1]breathGain",0.1,0,1,0.01)*0.05;
    breathCutoff = hslider("v:blower/[2]breathCutoff",2000,20,20000,0.1);
    vibratoFreq = hslider("v:blower/[3]vibratoFreq",5,0.1,10,0.1);
    vibratoGain = hslider("v:blower/[4]vibratoGain",0.25,0,1,0.01)*0.03;
};


//============================Modal Percussions===========================================
// High and low level functions for modal synthesis of percussion instruments.
//========================================================================================

//-------`(pm.)djembeModel`----------
// Dirt-simple djembe modal physical model. Mode parameters are empirically
// calculated and don't correspond to any measurements or 3D model. They
// kind of sound good though :).
//
// #### Usage
//
// ```
// excitation : djembeModel(freq)
// ```
//
// Where:
//
// * `excitation`: excitation signal
// * `freq`: fundamental frequency of the bar
//----------------------------------
djembeModel(freq) = _ <: par(i,nModes,modeFilter(modeFreqs(i),modeT60s(i),modeGains(i))) :> /(nModes)
with{
    nModes = 20;
    theta = 0; // angle
    modeFreqs(i) = freq + 200*i;
    modeT60s(i) = (nModes-i)*0.03;
    modeGains(i) = cos((i+1)*theta)/float(i+1)*(1/(i+1));
};


//-------`(pm.)djembe`----------
// Dirt-simple djembe modal physical model. Mode parameters are empirically
// calculated and don't correspond to any measurements or 3D model. They
// kind of sound good though :).
//
// This model also implements a virtual "exciter".
//
// #### Usage
//
// ```
// djembe(freq,strikePosition,strikeSharpness,gain,trigger)
// ```
//
// Where:
//
// * `freq`: fundamental frequency of the model
// * `strikePosition`: strike position (0 for the middle of the membrane and
// 1 for the edge)
// * `strikeSharpness`: sharpness of the strike (0-1, default: 0.5)
// * `gain`: gain of the strike
// * `trigger`: trigger signal (0: off, 1: on)
//----------------------------------
djembe(freq,strikePosition,strikeSharpness,gain,trigger) =
strike(strikePosition,strikeSharpness,gain,trigger) : djembeModel(freq);

//-------`(pm.)djembe_ui_MIDI`----------
// Simple MIDI controllable djembe physical model with built-in UI.
//
// #### Usage
//
// ```
// djembe_ui_MIDI : _
// ```
//----------------------------------
djembe_ui_MIDI =
djembe(freq,strikePosition,strikeSharpness,gain,gate)*outGain
with{
    freq = hslider("v:djembe/h:[0]midi/[0]freq[style:knob]",60,50,100,0.01);
    gain = hslider("v:djembe/h:[0]midi/[2]gain[style:knob]",1,0,1,0.01);
    strikePosition = hslider("v:djembe/h:[1]otherParams/[0]strikePosition
    [midi:ctrl 1][style:knob]",0.5,0,1,0.01);
    strikeSharpness = hslider("v:djembe/h:[1]otherParams/[1]strikeSharpness[style:knob]",0.5,0.01,5,0.01);
    outGain = hslider("v:djembe/h:[1]otherParams/[2]outGain
    [style:knob]",1,0,1,0.01);
    gate = button("v:djembe/[3]gate");
};


//-------`(pm.)marimbaBarModel`----------
// Generic marimba tone bar modal model.
//
// This model was generated using
// `mesh2faust` from a 3D CAD model of a marimba tone bar
// (`libraries/modalmodels/marimbaBar`). The corresponding CAD model is that
// of a C2 tone bar (original fundamental frequency: ~65Hz). While
// `marimbaBarModel` allows to translate the harmonic content of the generated
// sound by providing a frequency (`freq`), mode transposition has limits and
// the model will sound less and less like a marimba tone bar as it
// diverges from C2. To make an accurate model of a marimba, we'd want to have
// an independent model for each bar...
//
// This model contains 5 excitation positions going linearly from the center
// bottom to the center top of the bar. Obviously, a model with more excitation
// position could be regenerated using `mesh2faust`.
//
// #### Usage
//
// ```
// excitation : marimbaBarModel(freq,exPos,t60,t60DecayRatio,t60DecaySlope)
// ```
//
// Where:
//
// * `excitation`: excitation signal
// * `freq`: fundamental frequency of the bar
// * `exPos`: excitation position (0-4)
// * `t60`: T60 in seconds (recommended value: 0.1)
// * `t60DecayRatio`: T60 decay ratio (recommended value: 1)
// * `t60DecaySlope`: T60 decay slope (recommended value: 5)
//----------------------------------
marimbaBarModel(freq,exPos,t60,t60DecayRatio,t60DecaySlope) = _ <: par(i,nModes,modeFilter(modesFreqs(i),modesT60s(i),modesGains(int(exPos),i))) :> /(nModes)
with{
    nModes = 50;
    nExPos = 5;
    modesFreqRatios(n) = ba.take(n+1,(1,3.31356,3.83469,8.06313,9.44778,14.1169,18.384,21.0102,26.1775,28.9944,37.0728,37.8703,40.0634,47.6439,51.019,52.43,58.286,63.5486,65.3628,66.9587,74.5301,78.692,80.8375,89.978,92.9661,95.1914,97.4807,110.62,112.069,113.826,119.356,127.045,129.982,132.259,133.477,144.549,149.438,152.033,153.166,155.597,158.183,168.105,171.863,174.464,178.937,181.482,185.398,190.369,192.19,195.505));
    modesFreqs(i) = freq*modesFreqRatios(i);
    modesGains(p,n) = waveform{1,0.776725,0.625723,0.855223,0.760159,0.698373,0.768011,0.641127,0.244034,0.707754,0.634013,0.247527,0.660849,0.450396,0.567783,0.106361,0.716814,0.66392,0.291208,0.310599,0.801495,0.635292,0.307435,0.874124,0.497668,0.487088,0.459115,0.733455,0.541818,0.441318,0.31392,0.40309,0.685353,0.60314,0.400552,0.453511,0.634386,0.291547,0.131605,0.368507,0.839907,0.60216,0.288296,0.57967,0.0242493,0.262746,0.368588,0.890284,0.408963,0.556072,0.884427,0.83211,0.612015,0.757176,0.919477,1,0.827963,0.89241,0.0357408,0.480789,0.752872,0.0546301,0.235937,0.362938,0.444472,0.101751,0.703418,0.453136,0.316629,0.490394,0.982508,0.551622,0.602009,0.666957,0.77683,0.905662,0.0987197,0.402968,0.829452,0.307645,0.64048,0.983971,0.584205,0.650365,0.334447,0.58357,0.540191,0.672534,0.245712,0.687298,0.883058,0.79295,0.600619,0.572682,0.122612,0.388248,0.290658,0.380255,0.290967,0.567819,0.0737721,0.42099,0.0786578,0.393995,0.268983,0.260614,0.494086,0.238026,0.0987824,0.277879,0.440563,0.0770212,0.450591,0.128137,0.0368275,0.128699,0.329605,0.374512,0.36359,0.272594,0.379052,0.305241,0.0741129,0.345728,0.29935,0.221284,0.0261391,0.293202,0.361885,0.11433,0.239005,0.434156,0.329583,0.21946,0.284175,0.198555,0.431976,0.302985,1,0.146221,0.140701,0.264243,0.185997,0.426322,0.30478,0.34399,0.19543,0.386955,0.1876,0.172812,0.0434115,0.303761,0.069454,0.453943,0.832451,0.317817,0.940601,1,0.180658,0.737921,0.832297,0.402352,0.126786,0.594398,0.485455,0.32447,0.365102,0.777922,0.588272,0.401353,0.610735,0.158693,0.0746072,0.825099,0.925459,0.65377,0.260792,0.719384,0.559908,0.37259,0.360035,0.622939,0.210271,0.444595,0.311286,0.464309,0.557231,0.52408,0.0701056,0.320749,0.19446,0.727609,0.522062,0.394004,0.235035,0.395646,0.494796,0.517318,0.109752,0.692849,0.00632009,0.0207583,0.00306107,0.0637191,0.081661,0.03511,0.127814,0.202294,0.0764145,0.263127,0.400199,0.267278,0.633385,1,0.739902,0.413763,0.41811,0.612715,0.672374,0.339674,0.21172,0.459645,0.1025,0.32589,0.148154,0.265442,0.0974305,0.286438,0.275213,0.109111,0.575089,0.370283,0.29411,0.259826,0.0648719,0.583418,0.282663,0.182004,0.117421,0.417727,0.16965,0.24853,0.122819,0.185486,0.0433618,0.373849,0.252768,0.195103,0.0927835,0.166543},int(p*nModes+n) : rdtable : select2(modesFreqs(n)<(ma.SR/2-1),0);
    modesT60s(i) = t60*pow(1-(modesFreqRatios(i)/195.955)*t60DecayRatio,t60DecaySlope);
};


//-------`(pm.)marimbaResTube`----------
// Simple marimba resonance tube.
//
// #### Usage
//
// ```
// marimbaResTube(tubeLength,excitation)
// ```
//
// Where:
//
// * `tubeLength`: the length of the tube in meters
// * `excitation`: the excitation signal (audio in)
//----------------------------------
marimbaResTube(tubeLength,excitation) = endChain(tubeChain)
with{
	maxTubeLength = maxLength;
	lengthTuning = 0.04;
	tunedLength = tubeLength-lengthTuning;
	endTubeReflexion = si.smooth(0.95)*0.99;
	tubeChain =
		chain(
			in(excitation) :
			terminations(endTubeReflexion,
				openTube(maxTubeLength,tunedLength),
				endTubeReflexion) :
			out
		);
};


//-------`(pm.)marimbaModel`----------
// Simple marimba physical model implementing a single tone bar connected to
// tube. This model is scalable and can be adapted to any size of bar/tube
// (see [`marimbaBarModel`](#marimbabarmodel) to know more about the
// limitations of this type of system).
//
// #### Usage
//
// ```
// excitation : marimbaModel(freq,exPos) : _
// ```
//
// Where:
//
// * `freq`: the frequency of the bar/tube couple
// * `exPos`: excitation position (0-4)
//----------------------------------
marimbaModel(freq,exPos) =
marimbaBarModel(freq,exPos,maxT60,T60Decay,T60Slope) : marimbaResTube(resTubeLength)
with{
	resTubeLength = freq : f2l;
	maxT60 = 0.1;
	T60Decay = 1;
	T60Slope = 5;
};


//-------`(pm.)marimba`----------
// Simple marimba physical model implementing a single tone bar connected to
// tube. This model is scalable and can be adapted to any size of bar/tube
// (see [`marimbaBarModel`](#marimbabarmodel) to know more about the
// limitations of this type of system).
//
// This function also implement a virtual exciter to drive the model.
//
// #### Usage
//
// ```
// excitation : marimba(freq,strikePosition,strikeCutoff,strikeSharpness,gain,trigger) : _
// ```
//
// Where:
//
// * `excitation`: the excitation signal
// * `freq`: the frequency of the bar/tube couple
// * `strikePosition`: strike position (0-4)
// * `strikeCutoff`: cuttoff frequency of the strike genarator (recommended: ~7000Hz)
// * `strikeSharpness`: shaarpness of the strike (recommened: ~0.25)
// * `gain`: gain of the strike (0-1)
// * `trigger` signal (0: off, 1: on)
//----------------------------------
marimba(freq,strikePosition,strikeCutoff,strikeSharpness,gain,trigger) =
strikeModel(10,strikeCutoff,strikeSharpness,gain,trigger) :
marimbaModel(freq,strikePosition);


//-------`(pm.)marimba_ui_MIDI`----------
// Simple MIDI controllable marimba physical model with built-in UI
// implementing a single tone bar connected to
// tube. This model is scalable and can be adapted to any size of bar/tube
// (see [`marimbaBarModel`](#marimbabarmodel) to know more about the
// limitations of this type of system).
//
// #### Usage
//
// ```
// marimba_ui_MIDI : _
// ```
//----------------------------------
marimba_ui_MIDI =
marimba(freq,strikePosition,strikeCutoff,strikeSharpness,gain,gate)*outGain
with{
    freq = hslider("v:marimba/h:[0]midi/[0]freq[style:knob]",440,50,1000,0.01);
    gain = hslider("v:marimba/h:[0]midi/[2]gain[style:knob]",1,0,1,0.01);
    strikePosition = nentry("v:marimba/h:[1]otherParams/[0]strikePosition
    [midi:ctrl 1]",0,0,4,1);
    strikeCutoff = hslider("v:marimba/h:[1]otherParams/[1]strikeCutOff
    [midi:ctrl 1][style:knob]",6500,20,20000,1);
    strikeSharpness = hslider("v:marimba/h:[1]otherParams/[2]strikeSharpness
    [style:knob]",0.5,0.01,5,0.01);
    outGain = hslider("v:marimba/h:[1]otherParams/[2]outGain
    [style:knob]",0.8,0,1,0.01);
    gate = button("v:marimba/[3]gate");
};


//-------`(pm.)churchBellModel`----------
// Generic church bell modal model generated by `mesh2faust` from
// `libraries/modalmodels/churchBell`.
//
// Modeled after T. Rossing and R. Perrin, Vibrations of Bells, Applied
// Acoustics 2, 1987.
//
// Model height is 301 mm.
//
// This model contains 7 excitation positions going linearly from the
// bottom to the top of the bell. Obviously, a model with more excitation
// position could be regenerated using `mesh2faust`.
//
// #### Usage
//
// ```
// excitation : churchBellModel(nModes,exPos,t60,t60DecayRatio,t60DecaySlope)
// ```
//
// Where:
//
// * `excitation`: the excitation signal
// * `nModes`: number of synthesized modes (max: 50)
// * `exPos`: excitation position (0-6)
// * `t60`: T60 in seconds (recommended value: 0.1)
// * `t60DecayRatio`: T60 decay ratio (recommended value: 1)
// * `t60DecaySlope`: T60 decay slope (recommended value: 5)
//----------------------------------
churchBellModel(nModes,exPos,t60,t60DecayRatio,t60DecaySlope) = _ <: par(i,nModes,modeFilter(modesFreqs(i),modesT60s(i),modesGains(int(exPos),i))) :> /(nModes)
with{
    nExPos = 7;
    modesFreqs(n) = ba.take(n+1,(451.918,455,864.643,871.402,1072.47,1073.98,1292.23,1292.48,1504.6,1532.41,1646.2,1647,1677.83,1678.13,1866.63,1882.08,1985.2,1989.87,2114.93,2356.81,2444.32,2446.22,2528.77,2530.92,2668.86,2669.63,2738.06,2749.03,2750.53,2753.11,2827.19,2842.32,2992.56,2996.84,3172.61,3330.79,3390.33,3403.1,3516.43,3538.54,3582.79,3583.82,3730.04,3739.35,3758.66,3903.78,3942.59,3981.74,3983.25,4033.97));
    modesGains(p,n) = waveform{0.525285,0.814174,0.483261,0.296745,0.975056,0.472244,0.409501,0.425364,0.687559,0.288381,0.309285,0.123054,0.286333,0.576706,0.908322,0.626974,0.0801852,0.309835,0.45143,0.132845,0.470635,0.417008,0.265112,0.0752802,0.46347,0.47181,0.275324,0.547027,0.512519,0.394078,0.595404,0.941306,0.392501,0.381435,0.391232,0.118924,0.339495,0.101421,0.241755,0.0873255,0.378944,0.637705,0.171946,0.149859,0.23329,0.54181,1,0.115554,0.244172,0.574329,0.606171,0.938397,0.392555,0.277359,0.86857,0.432489,0.408856,0.407932,0.299815,0.256659,0.549572,0.406347,0.312331,0.627578,0.670167,0.524648,0.406926,0.637524,0.555837,1,0.818979,0.705347,0.678141,0.427382,0.674404,0.636105,0.643635,0.699136,0.836201,0.613085,0.319019,0.725259,0.545519,0.479861,0.49836,0.488654,0.861672,0.314287,0.671052,0.531905,0.421781,0.815066,0.772032,0.488722,0.0896674,0.291286,0.65873,0.635632,0.679357,0.459497,0.36024,0.582289,0.650605,0.49095,0.38191,0.157261,0.479624,0.477491,0.174435,0.013094,0.879113,0.608069,0.268877,0.604479,0.24513,0.170507,0.292888,0.545849,0.476646,0.922316,0.669192,0.578094,0.578797,0.311396,0.60121,0.549955,1,0.66573,0.980115,0.537848,0.0740531,0.252472,0.25575,0.223974,0.0865103,0.138209,0.198623,0.0453034,0.432453,0.292407,0.39441,0.857659,0.271668,0.201545,0.583994,0.0602378,0.190618,0.849505,0.975542,0.17314,0.206472,0.344793,0.761011,0.558125,0.117245,0.0338485,0.337597,0.336646,0.174253,0.23017,0.934873,0.593647,0.393225,0.683704,0.0566093,0.0405012,0.148972,0.338722,0.283419,0.394007,0.237475,0.269964,0.428313,0.177499,0.462585,0.443963,0.981793,0.408239,0.676527,0.402865,0.0163303,0.0515114,0.34139,0.311135,0.613276,0.805884,0.95329,0.406091,0.578705,0.386785,0.434103,0.77526,1,0.635909,0.782052,0.0137183,0.0387725,0.618964,0.857071,0.131522,0.184988,0.299495,0.789212,0.603114,0.0704989,0.0129339,0.252481,0.254121,0.189206,0.357713,0.950308,0.552573,0.466454,0.77736,0.0307886,0.0251943,0.378886,0.740187,0.247637,0.235201,0.493045,0.51785,0.883954,0.429473,0.409433,0.415266,0.940198,0.282334,0.43789,0.375385,0.0157366,0.0171763,0.485555,0.461015,0.858958,0.907991,0.935191,0.37551,1,0.585493,0.269981,0.423053,0.666067,0.43509,0.790252,0.00889586,0.0208844,0.449735,0.790808,0.159856,0.089599,0.161546,0.528168,0.380642,0.0206276,0.00726426,0.0315352,0.0315841,0.197649,0.475057,0.517232,0.360922,0.421204,0.63134,0.00952139,0.016105,0.499615,0.922958,0.214983,0.0655141,0.50397,0.514848,1,0.483619,0.254027,0.228372,0.436105,0.233125,0.152242,0.279513,0.00906739,0.0132332,0.451257,0.388566,0.737226,0.479378,0.233037,0.103767,0.845609,0.644127,0.261359,0.371457,0.527229,0.381373,0.334492,0.00833749,0.00861982,0.255919,0.254197,0.0872333,0.0461512,0.113018,0.345986,0.236344,0.01078,0.00816506,0.405181,0.38718,0.343681,0.816493,0.259082,0.211906,0.432455,0.696886,0.00576224,0.013131,0.455969,0.811609,0.426544,0.128489,0.215937,0.233934,0.72307,0.351623,0.394231,0.323766,0.168803,0.276932,0.264684,0.227703,0.00680935,0.0170703,0.603018,0.476461,0.585925,0.71696,1,0.576527,0.475524,0.447322,0.356902,0.597573,0.697246,0.505333,0.285421,0.0147193,0.0141618,0.136188,0.0336537,0.216437},int(p*nModes+n) : rdtable;
    modesT60s(i) = t60*pow(1-(modesFreqs(i)/4035.44)*t60DecayRatio,t60DecaySlope);
};


//-------`(pm.)churchBell`----------
// Generic church bell modal model.
//
// Modeled after T. Rossing and R. Perrin, Vibrations of Bells, Applied
// Acoustics 2, 1987.
//
// Model height is 301 mm.
//
// This model contains 7 excitation positions going linearly from the
// bottom to the top of the bell. Obviously, a model with more excitation
// position could be regenerated using `mesh2faust`.
//
// This function also implement a virtual exciter to drive the model.
//
// #### Usage
//
// ```
// excitation : churchBell(strikePosition,strikeCutoff,strikeSharpness,gain,trigger) : _
// ```
//
// Where:
//
// * `excitation`: the excitation signal
// * `strikePosition`: strike position (0-6)
// * `strikeCutoff`: cuttoff frequency of the strike genarator (recommended: ~7000Hz)
// * `strikeSharpness`: shaarpness of the strike (recommened: ~0.25)
// * `gain`: gain of the strike (0-1)
// * `trigger` signal (0: off, 1: on)
//----------------------------------
churchBell(strikePosition,strikeCutoff,strikeSharpness,gain,trigger) =
strikeModel(10,strikeCutoff,strikeSharpness,gain,trigger) :
churchBellModel(50,strikePosition,30,1,2.5);


//-------`(pm.)churchBell_ui`----------
// Church bell physical model based on [`churchBell`](#churchbell) with
// built-in UI.
//
// #### Usage
//
// ```
// churchBell_ui : _
// ```
//----------------------------------
churchBell_ui =
churchBell(strikePosition,strikeCutoff,strikeSharpness,gain,gate)
with{
  strikePosition = nentry("v:churchBell/[0]strikePosition",
	0,0,4,1);
	strikeCutoff = hslider("v:churchBell/[1]strikeCutOff",
	6500,20,20000,1);
	strikeSharpness = hslider("v:churchBell/[2]strikeSharpness",
	0.5,0.01,5,0.01);
	gain = hslider("v:churchBell/[3]gain",1,0,1,0.01);
	gate = button("v:churchBell/[4]gate");
};


//-------`(pm.)englishBellModel`----------
// English church bell modal model generated by `mesh2faust` from
// `libraries/modalmodels/englishBell`.
//
// Modeled after D. Bartocha and . Baron, Influence of Tin Bronze Melting and
// Pouring Parameters on Its Properties and Bell' Tone, Archives of Foundry
// Engineering, 2016.
//
// Model height is 1 m.
//
// This model contains 7 excitation positions going linearly from the
// bottom to the top of the bell. Obviously, a model with more excitation
// position could be regenerated using `mesh2faust`.
//
// #### Usage
//
// ```
// excitation : englishBellModel(nModes,exPos,t60,t60DecayRatio,t60DecaySlope)
// ```
//
// Where:
//
// * `excitation`: the excitation signal
// * `nModes`: number of synthesized modes (max: 50)
// * `exPos`: excitation position (0-6)
// * `t60`: T60 in seconds (recommended value: 0.1)
// * `t60DecayRatio`: T60 decay ratio (recommended value: 1)
// * `t60DecaySlope`: T60 decay slope (recommended value: 5)
//----------------------------------
englishBellModel(nModes,exPos,t60,t60DecayRatio,t60DecaySlope) = _ <: par(i,nModes,modeFilter(modesFreqs(i),modesT60s(i),modesGains(int(exPos),i))) :> /(nModes)
with{
    nExPos = 7;
    modesFreqs(n) = ba.take(n+1,(259.429,261.855,493.331,494.472,603.048,604.742,724.566,724.777,786.985,931.893,932.846,943.429,946.533,947.109,952.782,1024.24,1034.86,1211.59,1212.21,1236.28,1340.21,1341.15,1452.63,1453.38,1453.77,1457.45,1459.23,1460.7,1482.81,1483.04,1519.55,1547.27,1565.95,1576.95,1697.47,1826.61,1892.56,1896.09,1899.86,1908.29,2003.95,2005.07,2005.89,2005.99,2067.42,2082.42,2086.81,2120.56,2129.79,2133.23));
    modesGains(p,n) = waveform{0.694274,0.471698,0.17239,0.585446,0.397986,0.919579,0.531947,0.100205,0.639469,0.672209,0.144345,0.416595,0.124108,0.380591,0.256578,0.646031,0.8522,0.0224376,0.382762,0.143925,0.368691,0.430556,0.32318,0.142956,0.274521,0.713824,0.442794,0.352473,0.247756,0.415152,1,0.401869,0.197981,0.27951,0.210249,0.36974,0.369227,0.155769,0.272368,0.335712,0.31645,0.714103,0.285781,0.22006,0.827704,0.206342,0.180177,0.311478,0.197607,0.575475,0.473311,0.587232,0.50288,0.337308,0.304514,0.429039,0.351522,0.341373,0.175081,0.561748,0.439172,0.323164,0.540518,0.536523,0.0743865,0.213417,0.358012,0.474494,0.310274,0.839413,0.241372,0.202343,0.480634,0.995685,0.37374,0.133998,0.520674,0.207514,1,0.101239,0.279536,0.185985,0.436293,0.62411,0.334519,0.283585,0.179317,0.353847,0.449545,0.574128,0.135172,0.538275,0.476424,0.832903,0.164198,0.188562,0.135978,0.390128,0.131045,0.312065,0.142139,0.0255901,0.266947,0.371607,0.0168435,0.0249468,0.508917,0.35441,0.283348,0.628155,0.292478,0.35835,0.342569,0.441237,0.886699,0.0174698,0.00641843,0.55532,0.880129,0.0306909,0.290081,0.248816,0.981736,0.324624,0.213676,0.432885,0.0981559,0.444149,0.395554,0.525069,0.0771308,0.0488804,0.591321,0.108044,0.443802,0.740318,0.599438,0.293093,1,0.141662,0.910031,0.226126,0.299702,0.341472,0.0568061,0.222494,0.918718,0.199478,0.21662,0.107759,0.692324,0.556336,0.281718,0.430832,0.341656,0.608095,0.342129,0.311312,0.229953,0.695087,0.0761489,0.349818,0.361706,0.577611,0.147797,0.327376,0.465715,0.342902,0.521381,0.836828,0.241112,0.284394,0.539316,0.143408,0.51702,1,0.236336,0.480333,0.676744,0.807582,0.468621,0.236953,0.411604,0.579251,0.425098,0.37599,0.461176,0.27653,0.462368,0.613004,0.666849,0.954715,0.161507,0.170433,0.290461,0.117303,0.365133,0.233794,0.194568,0.338874,0.523381,0.39835,0.447839,0.652891,0.15708,0.340354,0.44217,0.338764,0.184397,0.771607,0.160502,0.324487,0.477499,0.831519,0.0168764,0.154264,0.201865,0.237786,0.390066,0.880164,0.284234,0.162837,0.437557,0.227846,0.39934,1,0.158107,0.396903,0.513029,0.676457,0.204282,0.0895575,0.55541,0.732486,0.125062,0.171229,0.081646,0.0541394,0.39616,0.454288,0.466863,0.928842,0.155393,0.26285,0.113453,0.133163,0.302021,0.612616,0.228392,0.195617,0.287236,0.198762,0.499884,0.809139,0.00929925,0.0840299,0.286446,0.182112,0.186044,0.754138,0.279556,0.266948,0.494291,1,0.321284,0.0230981,0.0375537,0.262531,0.602204,0.489925,0.633077,0.407409,0.422256,0.0910641,0.357935,0.550179,0.106192,0.132366,0.376231,0.351151,0.0420302,0.0372183,0.696335,0.840821,0.855235,0.249248,0.860011,0.340481,0.28558,0.363039,0.324122,0.515699,0.228131,0.172592,0.0188723,0.168243,0.995105,0.741759,0.107093,0.070349,0.136636,0.0780455,0.315748,0.502201,0.0190422,0.033914,0.225724,0.160236,0.184101,0.564203,0.247317,0.284225,0.327153,0.651443,0.593471,0.0163899,0.0141048,0.52113,1,0.105109,0.530936,0.363724,0.924809,0.25041,0.69288,0.414122,0.0793658,0.347813,0.441731,0.476428,0.0808834,0.0581638,0.557239,0.556515,0.746084,0.582228,0.177231,0.158425,0.850903,0.755271,0.673614,0.31706,0.0515386,0.201898,0.0577938,0.232031,0.734988,0.141594,0.267062,0.145807},int(p*nModes+n) : rdtable;
    modesT60s(i) = t60*pow(1-(modesFreqs(i)/2137.04)*t60DecayRatio,t60DecaySlope);
};


//-------`(pm.)englishBell`----------
// English church bell modal model.
//
// Modeled after D. Bartocha and . Baron, Influence of Tin Bronze Melting and
// Pouring Parameters on Its Properties and Bell' Tone, Archives of Foundry
// Engineering, 2016.
//
// Model height is 1 m.
//
// This model contains 7 excitation positions going linearly from the
// bottom to the top of the bell. Obviously, a model with more excitation
// position could be regenerated using `mesh2faust`.
//
// This function also implement a virtual exciter to drive the model.
//
// #### Usage
//
// ```
// excitation : englishBell(strikePosition,strikeCutoff,strikeSharpness,gain,trigger) : _
// ```
//
// Where:
//
// * `excitation`: the excitation signal
// * `strikePosition`: strike position (0-6)
// * `strikeCutoff`: cuttoff frequency of the strike genarator (recommended: ~7000Hz)
// * `strikeSharpness`: shaarpness of the strike (recommened: ~0.25)
// * `gain`: gain of the strike (0-1)
// * `trigger` signal (0: off, 1: on)
//----------------------------------
englishBell(strikePosition,strikeCutoff,strikeSharpness,gain,trigger) =
strikeModel(10,strikeCutoff,strikeSharpness,gain,trigger) :
englishBellModel(50,strikePosition,30,1,3);


//-------`(pm.)englishBell_ui`----------
// English church bell physical model based on [`englishBell`](#englishbell) with
// built-in UI.
//
// #### Usage
//
// ```
// englishBell_ui : _
// ```
//----------------------------------
englishBell_ui =
englishBell(strikePosition,strikeCutoff,strikeSharpness,gain,gate)
with{
    strikePosition = nentry("v:englishBell/[0]strikePosition",0,0,4,1);
    strikeCutoff = hslider("v:englishBell/[1]strikeCutOff",6500,20,20000,1);
    strikeSharpness = hslider("v:englishBell/[2]strikeSharpness",0.5,0.01,5,0.01);
    gain = hslider("v:englishBell/[3]gain",1,0,1,0.01);
    gate = button("v:englishBell/[4]gate");
};


//-------`(pm.)frenchBellModel`----------
// French church bell modal model generated by `mesh2faust` from
// `libraries/modalmodels/frenchBell`.
//
// Modeled after D. Bartocha and . Baron, Influence of Tin Bronze Melting and
// Pouring Parameters on Its Properties and Bell' Tone, Archives of Foundry
// Engineering, 2016.
//
// Model height is 1 m.
//
// This model contains 7 excitation positions going linearly from the
// bottom to the top of the bell. Obviously, a model with more excitation
// position could be regenerated using `mesh2faust`.
//
// #### Usage
//
// ```
// excitation : frenchBellModel(nModes,exPos,t60,t60DecayRatio,t60DecaySlope)
// ```
//
// Where:
//
// * `excitation`: the excitation signal
// * `nModes`: number of synthesized modes (max: 50)
// * `exPos`: excitation position (0-6)
// * `t60`: T60 in seconds (recommended value: 0.1)
// * `t60DecayRatio`: T60 decay ratio (recommended value: 1)
// * `t60DecaySlope`: T60 decay slope (recommended value: 5)
//----------------------------------
frenchBellModel(nModes,exPos,t60,t60DecayRatio,t60DecaySlope) = _ <: par(i,nModes,modeFilter(modesFreqs(i),modesT60s(i),modesGains(int(exPos),i))) :> /(nModes)
with{
    nExPos = 7;
    modesFreqs(n) = ba.take(n+1,(439.077,440.305,606.452,611.776,709.617,709.877,856.966,899.051,1064.37,1064.75,1073.03,1074.43,1076.58,1145.42,1148.9,1197.09,1199.91,1387.7,1400.16,1402.37,1512.06,1513.06,1592.47,1593.35,1663.45,1666.47,1691.32,1693.77,1804.83,1808.84,1820.07,1847.14,1910.73,1927.7,2035.07,2038.73,2054.66,2055.67,2078.69,2091.76,2115.78,2127.01,2209.86,2214.05,2296.15,2298.08,2298.97,2307.62,2404.44,2408.99));
    modesGains(p,n) = waveform{0.97289,0.542393,0.495832,0.897966,0.552367,0.557895,0.614213,0.353694,0.436039,0.441024,0.674913,0.566754,0.755008,0.69903,0.164398,0.91004,0.628373,0.201718,0.429517,0.503715,0.871174,0.106886,0.761173,0.673602,0.291937,0.58859,0.31528,0.413081,0.274464,0.494062,0.696121,0.61201,0.382757,0.995113,0.228806,0.198449,0.595847,0.306263,0.252397,0.0883567,0.236086,1,0.245278,0.379388,0.198824,0.548892,0.492764,0.420871,0.794637,0.605634,1,0.604159,0.399841,0.799347,0.507187,0.50981,0.477383,0.310226,0.426976,0.437623,0.735712,0.630728,0.625785,0.651168,0.277738,0.850858,0.578079,0.645354,0.3837,0.370598,0.782542,0.181325,0.614391,0.740684,0.342441,0.586186,0.286909,0.405197,0.259215,0.566983,0.748219,0.655898,0.36826,0.940814,0.336157,0.413702,0.561557,0.402176,0.117698,0.329369,0.254571,0.870706,0.260981,0.274122,0.206247,0.6453,0.400758,0.363622,0.636834,0.584566,0.975603,0.616937,0.295401,0.650447,0.464221,0.465057,0.312467,0.238358,0.383695,0.399674,0.753912,0.662012,0.504268,0.599248,0.378665,0.725363,0.493214,1,0.332836,0.265889,0.674073,0.320401,0.440018,0.769782,0.316419,0.529968,0.380509,0.578676,0.249013,0.591384,0.761717,0.687057,0.324437,0.818864,0.505369,0.672485,0.461783,0.426198,0.0678875,0.435329,0.347955,0.708394,0.293322,0.328986,0.258254,0.893512,0.320131,0.433554,0.459302,0.542213,0.817241,0.51623,0.205302,0.467354,0.388683,0.388216,0.171262,0.150865,0.29172,0.311414,0.658876,0.570647,0.383619,0.502455,0.364114,0.532313,0.352989,1,0.261984,0.219591,0.544031,0.337199,0.279173,0.668303,0.208439,0.39923,0.418674,0.648618,0.234133,0.504729,0.645347,0.572851,0.232828,0.614292,0.485272,0.666264,0.31657,0.320355,0.191421,0.340131,0.342069,0.538371,0.281131,0.393115,0.251394,0.890725,0.310644,0.5037,0.29909,0.442478,0.733128,0.455217,0.199322,0.315699,0.375856,0.37649,0.029145,0.0200283,0.279578,0.3168,0.655957,0.546843,0.349666,0.470249,0.353765,0.286794,0.180185,1,0.210831,0.280133,0.535853,0.376488,0.15367,0.634745,0.0510449,0.485575,0.593111,0.917884,0.380477,0.422925,0.599373,0.311421,0.135654,0.359954,0.295748,0.474439,0.353339,0.116743,0.454313,0.112858,0.35931,0.483897,0.301608,0.577342,0.262663,0.794986,0.54958,0.808086,0.152511,0.439591,0.535941,0.308018,0.419837,0.579191,0.250428,0.25212,0.10286,0.288332,0.599679,0.665108,0.636285,0.495234,0.251613,0.208527,0.0939072,0.458415,0.318952,0.23535,0.215189,0.313412,0.0472787,0.0386893,0.0863359,0.222346,0.361511,0.997037,0.238509,0.38214,1,0.203554,0.472087,0.509015,0.206371,0.441013,0.794008,0.971623,0.796384,0.55043,0.68778,0.554298,0.0436545,0.0595577,0.214685,0.58147,0.27732,0.368466,0.121382,0.152739,0.0782244,0.190497,0.316269,0.180456,0.405196,0.518716,0.159365,0.165808,0.194372,0.614764,0.553415,0.644794,0.44178,0.44149,0.221588,1,0.579371,0.606339,0.529167,0.0214475,0.417046,0.663152,0.894841,0.475752,0.168289,0.46859,0.304604,0.666369,0.308337,0.295091,0.768945,0.350911,0.49068,0.516584,0.400117,0.820687,0.545486,0.709357,0.509759,0.472006,0.152455,0.981265,0.459134,0.698666,0.247154,0.623253,0.255508,0.830815,0.088709,0.126082,0.0770623,0.263328},int(p*nModes+n) : rdtable;
    modesT60s(i) = t60*pow(1-(modesFreqs(i)/2555.3)*t60DecayRatio,t60DecaySlope);
};


//-------`(pm.)frenchBell`----------
// French church bell modal model.
//
// Modeled after D. Bartocha and . Baron, Influence of Tin Bronze Melting and
// Pouring Parameters on Its Properties and Bell' Tone, Archives of Foundry
// Engineering, 2016.
//
// Model height is 1 m.
//
// This model contains 7 excitation positions going linearly from the
// bottom to the top of the bell. Obviously, a model with more excitation
// position could be regenerated using `mesh2faust`.
//
// This function also implement a virtual exciter to drive the model.
//
// #### Usage
//
// ```
// excitation : frenchBell(strikePosition,strikeCutoff,strikeSharpness,gain,trigger) : _
// ```
//
// Where:
//
// * `excitation`: the excitation signal
// * `strikePosition`: strike position (0-6)
// * `strikeCutoff`: cuttoff frequency of the strike genarator (recommended: ~7000Hz)
// * `strikeSharpness`: shaarpness of the strike (recommened: ~0.25)
// * `gain`: gain of the strike (0-1)
// * `trigger` signal (0: off, 1: on)
//----------------------------------
frenchBell(strikePosition,strikeCutoff,strikeSharpness,gain,trigger) =
strikeModel(10,strikeCutoff,strikeSharpness,gain,trigger) :
frenchBellModel(50,strikePosition,30,1,3);


//-------`(pm.)frenchBell_ui`----------
// French church bell physical model based on [`frenchBell`](#frenchbell) with
// built-in UI.
//
// #### Usage
//
// ```
// frenchBell_ui : _
// ```
//----------------------------------
frenchBell_ui =
frenchBell(strikePosition,strikeCutoff,strikeSharpness,gain,gate)
with{
    strikePosition = nentry("v:frenchBell/[0]strikePosition",0,0,4,1);
    strikeCutoff = hslider("v:frenchBell/[1]strikeCutOff",6500,20,20000,1);
    strikeSharpness = hslider("v:frenchBell/[2]strikeSharpness",0.5,0.01,5,0.01);
    gain = hslider("v:frenchBell/[3]gain",1,0,1,0.01);
    gate = button("v:frenchBell/[4]gate");
};


//-------`(pm.)germanBellModel`----------
// German church bell modal model generated by `mesh2faust` from
// `libraries/modalmodels/germanBell`.
//
// Modeled after D. Bartocha and . Baron, Influence of Tin Bronze Melting and
// Pouring Parameters on Its Properties and Bell' Tone, Archives of Foundry
// Engineering, 2016.
//
// Model height is 1 m.
//
// This model contains 7 excitation positions going linearly from the
// bottom to the top of the bell. Obviously, a model with more excitation
// position could be regenerated using `mesh2faust`.
//
// #### Usage
//
// ```
// excitation : germanBellModel(nModes,exPos,t60,t60DecayRatio,t60DecaySlope)
// ```
//
// Where:
//
// * `excitation`: the excitation signal
// * `nModes`: number of synthesized modes (max: 50)
// * `exPos`: excitation position (0-6)
// * `t60`: T60 in seconds (recommended value: 0.1)
// * `t60DecayRatio`: T60 decay ratio (recommended value: 1)
// * `t60DecaySlope`: T60 decay slope (recommended value: 5)
//----------------------------------
germanBellModel(nModes,exPos,t60,t60DecayRatio,t60DecaySlope) = _ <: par(i,nModes,modeFilter(modesFreqs(i),modesT60s(i),modesGains(int(exPos),i))) :> /(nModes)
with{
    nExPos = 7;
    modesFreqs(n) = ba.take(n+1,(238.909,240.235,406.25,408.214,561.105,562.923,749.632,749.88,781.389,800.68,801.547,884.486,942.52,942.715,958.571,960.581,1016.87,1018.29,1022.29,1206.2,1206.87,1213.93,1222.77,1231.68,1345.65,1355.18,1356.55,1357.3,1389.29,1391.11,1420.17,1424.05,1424.31,1426.54,1582.3,1631.07,1638.15,1720.28,1726.7,1803.79,1827.08,1829.44,1922.87,1926.94,1940.96,1944.47,1948.2,1969.86,1992.24,2011.85));
    modesGains(p,n) = waveform{0.761411,0.797803,0.586057,0.225039,0.926354,0.813875,0.529871,0.158915,0.662516,0.30841,0.0454785,0.556082,0.784713,0.213035,0.956227,0.795165,0.313508,0.158531,0.301586,0.16832,0.281267,0.154237,0.217235,0.247239,0.522688,0.170303,0.320614,0.154857,0.414941,0.788364,0.713299,0.381592,0.707011,1,0.0106946,0.359763,0.0746156,0.431124,0.118053,0.52729,0.255303,0.646855,0.201145,0.919908,0.359389,0.253494,0.865695,0.0829263,0.222589,0.0415736,0.735774,0.769678,0.381416,0.197543,0.682389,0.614766,0.249525,0.289883,0.300319,0.443691,0.275272,0.370218,0.74879,0.161247,0.634353,0.498498,0.221988,0.350637,0.436817,0.436463,0.52508,0.842646,0.195324,0.224755,0.545681,0.353778,0.269044,0.327814,0.448952,0.852305,0.380503,1,0.458063,0.565058,0.354635,0.659529,0.449485,0.802014,0.283446,0.521563,0.374639,0.652112,0.181042,0.468394,0.430116,0.157207,0.414995,0.292737,0.487785,0.47768,0.481445,0.556988,0.561132,0.378265,0.291462,0.32325,0.482602,0.328248,0.196792,0.712254,0.389806,0.307751,0.792876,0.199098,0.288838,0.146811,0.0178444,0.394017,0.588212,0.489226,0.701486,0.940303,0.213191,0.0778845,0.474463,0.609972,0.16338,0.408376,0.330864,0.88999,0.0798101,1,0.167172,0.208727,0.227549,0.825903,0.531897,0.580946,0.215339,0.247319,0.268148,0.504088,0.160955,0.170316,0.230769,0.151191,0.0825031,0.141328,0.288079,0.499676,0.420355,0.487764,0.75371,0.492248,0.181364,0.20594,0.52497,0.325641,0.236827,0.931842,0.472981,0.312162,0.901032,0.270478,0.167112,0.0709698,0.166004,0.290745,0.425893,0.403633,0.581772,0.855694,0.0325587,0.0568359,0.241923,0.79931,0.181962,0.530283,0.41561,1,0.0291501,0.831155,0.119755,0.102188,0.132037,0.76603,0.442221,0.1749,0.142175,0.0140794,0.4375,0.85186,0.196836,0.0907522,0.551673,0.256528,0.0424377,0.490363,0.108178,0.503276,0.226584,0.312758,0.824079,0.48412,0.0347338,0.0619428,0.255097,0.145273,0.190359,0.995297,0.50342,0.217575,0.793975,0.357179,0.0409728,0.0187931,0.414458,0.15844,0.346233,0.0771673,0.175111,0.380567,0.497409,0.316164,0.488669,1,0.420657,0.442333,0.24706,0.796407,0.0104146,0.227079,0.10684,0.0289873,0.76757,0.0643122,0.0423098,0.715522,0.472117,0.392577,0.660433,0.803575,0.188653,0.0191653,0.873212,0.448719,0.0147128,0.618967,0.30718,0.345899,0.131394,0.193225,0.715283,0.40562,0.040637,0.0503336,0.0544331,0.0452023,0.152302,0.894549,0.443343,0.172071,0.647667,0.328993,0.0416014,0.0229488,0.551071,0.423544,0.862362,0.363526,0.769929,0.123452,0.710702,0.394895,0.556638,1,0.450925,0.422849,0.092187,0.413892,0.00995372,0.321146,0.160624,0.0300681,0.915385,0.4755,0.506951,0.387549,0.275591,0.468281,0.184776,0.186837,0.188195,0.0202785,0.697136,0.408862,0.0116935,0.349823,0.202301,0.461379,0.0559023,0.0582571,0.260608,0.181875,0.0271739,0.0249578,0.685089,0.470384,0.283194,0.33105,0.138349,0.338068,0.481992,0.178242,0.0155942,0.0110435,0.783771,0.442707,0.616478,0.381542,0.510892,0.045985,0.303119,0.0731909,0.547715,0.348941,0.149981,0.302158,0.284482,0.398177,0.00413049,0.180739,0.062839,0.0133459,0.347088,0.57637,0.240764,0.978481,0.452755,0.529742,0.340471,0.662282,0.444305,0.0429901,1,0.36194,0.0183372,0.626893,0.55285,0.384936},int(p*nModes+n) : rdtable;
    modesT60s(i) = t60*pow(1-(modesFreqs(i)/2016.94)*t60DecayRatio,t60DecaySlope);
};


//-------`(pm.)germanBell`----------
// German church bell modal model.
//
// Modeled after D. Bartocha and . Baron, Influence of Tin Bronze Melting and
// Pouring Parameters on Its Properties and Bell' Tone, Archives of Foundry
// Engineering, 2016.
//
// Model height is 1 m.
//
// This model contains 7 excitation positions going linearly from the
// bottom to the top of the bell. Obviously, a model with more excitation
// position could be regenerated using `mesh2faust`.
//
// This function also implement a virtual exciter to drive the model.
//
// #### Usage
//
// ```
// excitation : germanBell(strikePosition,strikeCutoff,strikeSharpness,gain,trigger) : _
// ```
//
// Where:
//
// * `excitation`: the excitation signal
// * `strikePosition`: strike position (0-6)
// * `strikeCutoff`: cuttoff frequency of the strike genarator (recommended: ~7000Hz)
// * `strikeSharpness`: shaarpness of the strike (recommened: ~0.25)
// * `gain`: gain of the strike (0-1)
// * `trigger` signal (0: off, 1: on)
//----------------------------------
germanBell(strikePosition,strikeCutoff,strikeSharpness,gain,trigger) =
strikeModel(10,strikeCutoff,strikeSharpness,gain,trigger) :
germanBellModel(50,strikePosition,30,1,2.5);


//-------`(pm.)germanBell_ui`----------
// German church bell physical model based on [`germanBell`](#germanbell) with
// built-in UI.
//
// #### Usage
//
// ```
// germanBell_ui : _
// ```
//----------------------------------
germanBell_ui =
germanBell(strikePosition,strikeCutoff,strikeSharpness,gain,gate)
with{
    strikePosition = nentry("v:germanBell/[0]strikePosition",0,0,4,1);
    strikeCutoff = hslider("v:germanBell/[1]strikeCutOff",6500,20,20000,1);
    strikeSharpness = hslider("v:germanBell/[2]strikeSharpness",0.5,0.01,5,0.01);
    gain = hslider("v:germanBell/[3]gain",1,0,1,0.01);
    gate = button("v:germanBell/[4]gate");
};


//-------`(pm.)russianBellModel`----------
// Russian church bell modal model generated by `mesh2faust` from
// `libraries/modalmodels/russianBell`.
//
// Modeled after D. Bartocha and . Baron, Influence of Tin Bronze Melting and
// Pouring Parameters on Its Properties and Bell' Tone, Archives of Foundry
// Engineering, 2016.
//
// Model height is 2 m.
//
// This model contains 7 excitation positions going linearly from the
// bottom to the top of the bell. Obviously, a model with more excitation
// position could be regenerated using `mesh2faust`.
//
// #### Usage
//
// ```
// excitation : russianBellModel(nModes,exPos,t60,t60DecayRatio,t60DecaySlope)
// ```
//
// Where:
//
// * `excitation`: the excitation signal
// * `nModes`: number of synthesized modes (max: 50)
// * `exPos`: excitation position (0-6)
// * `t60`: T60 in seconds (recommended value: 0.1)
// * `t60DecayRatio`: T60 decay ratio (recommended value: 1)
// * `t60DecaySlope`: T60 decay slope (recommended value: 5)
//----------------------------------
russianBellModel(nModes,exPos,t60,t60DecayRatio,t60DecaySlope) = _ <: par(i,nModes,modeFilter(modesFreqs(i),modesT60s(i),modesGains(int(exPos),i))) :> /(nModes)
with{
    nExPos = 7;
    modesFreqs(n) = ba.take(n+1,(136.491,136.992,258.958,260.419,316.489,318.411,393.852,393.949,454.677,467.493,503.594,503.637,530.46,531.046,541.16,546.158,578.335,579.863,660.026,708.34,716.915,717.23,775.839,776.066,783.356,783.464,788.826,789.463,800.348,806.758,876.788,880.414,887.297,888.222,916.815,919.711,937.686,984.606,1057.2,1058.45,1065.48,1082.27,1083.93,1086.55,1086.77,1108.2,1116.17,1149,1150.54,1199.54));
    modesGains(p,n) = waveform{0.925507,0.59752,0.0965671,0.45412,0.989773,0.593498,0.512541,0.124241,0.705411,0.292396,0.673399,0.302181,0.026234,0.286249,0.556267,1,0.250426,0.107711,0.427299,0.336295,0.616257,0.21442,0.0845294,0.231363,0.522724,0.559114,0.34847,0.854197,0.835576,0.735036,0.288494,0.117122,0.409686,0.363575,0.484943,0.170862,0.420531,0.164793,0.233847,0.861232,0.214037,0.283462,0.173153,0.876122,0.607809,0.294745,0.143142,0.332009,0.491878,0.626104,0.962027,0.584298,0.213653,0.420452,0.812329,0.545172,0.380744,0.331536,0.386801,0.248909,0.688756,0.313904,0.377894,0.595846,0.412274,0.739626,0.541148,0.393005,0.656637,0.847672,0.930653,0.288289,0.404938,0.657989,0.763949,0.574085,0.282241,1,0.429131,0.572049,0.734868,0.577477,0.520789,0.355593,0.890067,0.272391,0.448223,0.423969,0.392237,0.856091,0.0583794,0.784967,0.359527,0.576567,0.201513,0.642013,0.419308,0.340667,0.42319,0.860812,0.69402,0.423568,0.376987,0.568453,0.502302,0.280716,0.464041,0.395601,0.19985,0.0950398,0.64279,0.228326,0.484911,0.842353,0.161404,0.403432,0.655549,0.409098,0.699392,0.87605,1,0.185606,0.414255,0.695205,0.732612,0.478298,0.24947,0.927739,0.213135,0.227382,0.976352,0.642745,0.376311,0.260674,0.811034,0.264631,0.239979,0.261897,0.191642,0.78167,0.390679,0.382437,0.206714,0.22472,0.0676332,0.502611,0.301455,0.241029,0.224505,0.721193,0.436348,0.254062,0.480496,0.772371,0.210681,0.103415,0.485338,0.378334,0.228484,0.114877,0.68676,0.296942,0.50742,0.99747,0.0377103,0.132212,0.319547,0.192032,0.520574,0.585844,0.419362,0.0847317,0.134544,0.194762,0.616689,0.39736,0.298809,0.914746,0.0513371,0.0543569,0.989159,0.602892,0.145582,0.102149,0.129022,0.116485,0.279988,0.39427,0.290139,1,0.708655,0.780555,0.387526,0.0395217,0.00964067,0.24368,0.0740625,0.619315,0.447395,0.292497,0.295458,0.163748,0.521375,0.864533,0.0773408,0.0334231,0.345121,0.27886,0.223876,0.307756,0.763106,0.424707,0.487201,0.968962,0.00911747,0.0324653,0.334275,0.166787,0.312498,0.264262,0.35488,0.37559,0.261094,0.565006,0.474935,0.31352,0.251249,0.735352,0.0189072,0.0153634,0.786225,0.503299,0.369038,0.250765,0.673019,0.387573,0.742025,0.749056,0.261714,0.751868,0.771816,1,0.459484,0.0124402,0.0105394,0.964109,0.457052,0.532316,0.407128,0.697241,0.1522,0.0895893,0.406175,0.65104,0.0233951,0.010107,0.0722347,0.066634,0.195489,0.41674,0.654451,0.382782,0.305396,0.631501,0.00162802,0.0140906,0.762915,0.410245,0.189436,0.0604462,0.624941,0.439781,0.516273,0.896678,0.273298,0.202868,0.0996022,0.257657,0.0174508,0.0157859,0.429433,0.202184,0.443111,0.343811,0.447562,0.268694,0.753551,0.529426,0.0772973,0.097696,0.446414,0.261678,0.169035,0.0116219,0.0207399,1,0.488856,0.413029,0.252661,0.148369,0.0919644,0.0330634,0.268764,0.441849,0.0139873,0.0108584,0.657799,0.488248,0.375433,0.958179,0.761492,0.40949,0.151709,0.314931,0.0036118,0.013307,1,0.605343,0.550506,0.363516,0.255278,0.137537,0.448881,0.867615,0.483247,0.308622,0.348444,0.534835,0.0157716,0.0128965,0.147608,0.0762611,0.762224,0.511585,0.985863,0.540227,0.691691,0.905296,0.397521,0.69794,0.423289,0.924613,0.491559,0.00567911,0.0106002,0.647916,0.324182,0.579449,0.451936,0.877897},int(p*nModes+n) : rdtable;
    modesT60s(i) = t60*pow(1-(modesFreqs(i)/1201.01)*t60DecayRatio,t60DecaySlope);
};


//-------`(pm.)russianBell`----------
// Russian church bell modal model.
//
// Modeled after D. Bartocha and . Baron, Influence of Tin Bronze Melting and
// Pouring Parameters on Its Properties and Bell' Tone, Archives of Foundry
// Engineering, 2016.
//
// Model height is 2 m.
//
// This model contains 7 excitation positions going linearly from the
// bottom to the top of the bell. Obviously, a model with more excitation
// position could be regenerated using `mesh2faust`.
//
// This function also implement a virtual exciter to drive the model.
//
// #### Usage
//
// ```
// excitation : russianBell(strikePosition,strikeCutoff,strikeSharpness,gain,trigger) : _
// ```
//
// Where:
//
// * `excitation`: the excitation signal
// * `strikePosition`: strike position (0-6)
// * `strikeCutoff`: cuttoff frequency of the strike genarator (recommended: ~7000Hz)
// * `strikeSharpness`: shaarpness of the strike (recommened: ~0.25)
// * `gain`: gain of the strike (0-1)
// * `trigger` signal (0: off, 1: on)
//----------------------------------
russianBell(strikePosition,strikeCutoff,strikeSharpness,gain,trigger) =
strikeModel(10,strikeCutoff,strikeSharpness,gain,trigger) :
russianBellModel(50,strikePosition,30,1,3);


//-------`(pm.)russianBell_ui`----------
// Russian church bell physical model based on [`russianBell`](#russianbell) with
// built-in UI.
//
// #### Usage
//
// ```
// russianBell_ui : _
// ```
//----------------------------------
russianBell_ui =
russianBell(strikePosition,strikeCutoff,strikeSharpness,gain,gate)
with{
    strikePosition = nentry("v:russianBell/[0]strikePosition",0,0,4,1);
    strikeCutoff = hslider("v:russianBell/[1]strikeCutOff",6500,20,20000,1);
    strikeSharpness = hslider("v:russianBell/[2]strikeSharpness",0.5,0.01,5,0.01);
    gain = hslider("v:russianBell/[3]gain",1,0,1,0.01);
    gate = button("v:russianBell/[4]gate");
};

//-------`(pm.)standardBellModel`----------
// Standard church bell modal model generated by `mesh2faust` from
// `libraries/modalmodels/standardBell`.
//
// Modeled after T. Rossing and R. Perrin, Vibrations of Bells, Applied
// Acoustics 2, 1987.
//
// Model height is 1.8 m.
//
// This model contains 7 excitation positions going linearly from the
// bottom to the top of the bell. Obviously, a model with more excitation
// position could be regenerated using `mesh2faust`.
//
// #### Usage
//
// ```
// excitation : standardBellModel(nModes,exPos,t60,t60DecayRatio,t60DecaySlope)
// ```
//
// Where:
//
// * `excitation`: the excitation signal
// * `nModes`: number of synthesized modes (max: 50)
// * `exPos`: excitation position (0-6)
// * `t60`: T60 in seconds (recommended value: 0.1)
// * `t60DecayRatio`: T60 decay ratio (recommended value: 1)
// * `t60DecaySlope`: T60 decay slope (recommended value: 5)
//----------------------------------
standardBellModel(nModes,exPos,t60,t60DecayRatio,t60DecaySlope) = _ <: par(i,nModes,modeFilter(modesFreqs(i),modesT60s(i),modesGains(int(exPos),i))) :> /(nModes)
with{
    nExPos = 7;
    modesFreqs(n) = ba.take(n+1,(490.25,493.646,924.838,927.779,1181.21,1186.94,1348.84,1349.5,1560.33,1635.97,1706.73,1712.89,1745.05,1745.25,2005.51,2025.47,2053.88,2142.37,2151.4,2408.16,2534.11,2536.42,2623.3,2628.4,2711.57,2712.46,2823.23,2827.22,2863.42,2874.19,2923,2925.69,3032.52,3042.15,3208.57,3392.52,3485.92,3493.65,3539.8,3550.56,3678.71,3719.04,3722.59,3786.28,3789.38,3993.59,3998.43,4123.41,4164.83,4187.98));
    modesGains(p,n) = waveform{0.691911,0.622333,0.548651,0.463306,0.826946,0.749513,0.2242,0.642678,0.760442,0.326054,0.276463,0.359344,0.18258,0.686765,0.457159,0.839015,0.845338,0.372377,0.306417,0.147381,0.359707,0.653537,0.27553,0.401233,0.435417,0.251481,0.190062,0.773372,0.315014,0.228812,0.521512,0.411542,0.720762,1,0.286502,0.338938,0.119995,0.432289,0.409677,0.156272,0.298871,0.250786,0.640776,0.209431,0.17001,0.390014,0.301698,0.799413,0.980581,0.385,0.82544,0.818894,0.349616,0.235396,0.783164,0.821914,0.28411,0.430286,0.507671,0.326254,0.260488,0.273364,0.20518,0.714852,0.47995,0.803637,0.683943,0.355371,0.406924,0.656257,0.423025,0.413515,0.38636,0.384787,0.389448,0.813367,0.234988,1,0.311268,0.350245,0.403856,0.646143,0.500485,0.833553,0.431768,0.467064,0.298979,0.487413,0.514907,0.369383,0.106197,0.494224,0.816079,0.535807,0.379873,0.380201,0.606306,0.516117,0.748449,0.556948,0.587066,0.584423,0.394866,0.341121,0.433458,0.455987,0.361237,0.42939,0.122969,0.133175,0.505176,0.513985,0.0554619,0.604942,0.372074,0.381126,0.314354,0.499636,0.518711,0.923792,0.259544,0.576517,0.553915,0.585444,0.245369,1,0.117757,0.977318,0.652862,0.509314,0.14855,0.506402,0.180059,0.356005,0.38681,0.279354,0.205792,0.551055,0.689107,0.445724,0.306857,0.324747,0.603621,0.394466,0.288613,0.264697,0.60612,0.20274,0.267271,0.925656,0.439228,0.425884,0.626633,0.547204,0.230022,0.225654,0.392697,0.493474,0.149857,0.0604048,0.693889,0.740271,0.175485,0.704998,0.329732,0.153026,0.125744,0.286995,0.278878,0.812372,0.0562174,0.241479,0.294525,0.358834,0.171047,0.847604,0.17228,0.97521,0.892073,0.613987,0.0659213,0.301583,0.0610847,0.125438,0.145151,0.180086,0.124231,0.260161,0.337573,0.203743,0.655798,0.425893,0.902347,0.500686,0.311173,0.215561,0.349591,0.0854218,0.0805062,1,0.338652,0.295396,0.698314,0.664972,0.118983,0.0881905,0.31158,0.391136,0.151915,0.239504,0.685742,0.884332,0.288516,0.768688,0.274851,0.0490311,0.0357865,0.293303,0.249461,0.493771,0.340984,0.467623,0.216631,0.255235,0.0988695,0.46198,0.147247,0.640196,1,0.551938,0.0453732,0.189907,0.0197542,0.0309217,0.769837,0.360418,0.384041,0.867434,0.398948,0.171848,0.748652,0.301957,0.860611,0.958674,0.54903,0.272753,0.372753,0.0180728,0.0292353,0.8502,0.224583,0.214805,0.670319,0.586433,0.0435142,0.0388574,0.144811,0.157061,0.155569,0.418334,0.673656,0.749573,0.337354,0.747254,0.255997,0.0239656,0.0310719,0.721087,0.700616,0.199051,0.511844,0.849485,0.700682,0.778658,0.171289,0.261973,0.129228,0.328597,0.781821,0.583813,0.0806713,0.416876,0.0118202,0.00868563,1,0.461884,0.186882,0.641364,0.994705,0.501902,0.566449,0.0678845,0.139737,0.462582,0.318656,0.233947,0.495941,0.0314028,0.0146478,0.70432,0.124953,0.132549,0.457126,0.378636,0.0169362,0.0195494,0.204155,0.294401,0.271367,0.730857,0.459322,0.433078,0.325171,0.734536,0.416205,0.012873,0.0388489,0.821567,0.863683,0.0920531,0.393972,0.539544,0.832052,0.842732,0.241144,0.479558,0.283092,0.477845,0.385473,0.436587,0.144308,0.642395,0.0215791,0.00779029,0.563714,0.838279,0.410004,0.829086,1,0.630598,0.0233729,0.496217,0.711042,0.914266,0.695042,0.331894,0.898442,0.028568,0.0174966,0.482846},int(p*nModes+n) : rdtable;
	modesT60s(i) = t60*pow(1-(modesFreqs(i)/4191.95)*t60DecayRatio,t60DecaySlope);
};


//-------`(pm.)standardBell`----------
// Standard church bell modal model.
//
// Modeled after T. Rossing and R. Perrin, Vibrations of Bells, Applied
// Acoustics 2, 1987.
//
// Model height is 1.8 m.
//
// This model contains 7 excitation positions going linearly from the
// bottom to the top of the bell. Obviously, a model with more excitation
// position could be regenerated using `mesh2faust`.
//
// This function also implement a virtual exciter to drive the model.
//
// #### Usage
//
// ```
// excitation : standardBell(strikePosition,strikeCutoff,strikeSharpness,gain,trigger) : _
// ```
//
// Where:
//
// * `excitation`: the excitation signal
// * `strikePosition`: strike position (0-6)
// * `strikeCutoff`: cuttoff frequency of the strike genarator (recommended: ~7000Hz)
// * `strikeSharpness`: shaarpness of the strike (recommened: ~0.25)
// * `gain`: gain of the strike (0-1)
// * `trigger` signal (0: off, 1: on)
//----------------------------------
standardBell(strikePosition,strikeCutoff,strikeSharpness,gain,trigger) =
strikeModel(10,strikeCutoff,strikeSharpness,gain,trigger) :
standardBellModel(50,strikePosition,30,1,2.5);


//-------`(pm.)standardBell_ui`----------
// Standard church bell physical model based on [`standardBell`](#standardbell) with
// built-in UI.
//
// #### Usage
//
// ```
// standardBell_ui : _
// ```
//----------------------------------
standardBell_ui =
standardBell(strikePosition,strikeCutoff,strikeSharpness,gain,gate)
with{
	strikePosition = nentry("v:standardBell/[0]strikePosition",0,0,4,1);
	strikeCutoff = hslider("v:standardBell/[1]strikeCutOff",6500,20,20000,1);
	strikeSharpness = hslider("v:standardBell/[2]strikeSharpness",0.5,0.01,5,0.01);
	gain = hslider("v:standardBell/[3]gain",1,0,1,0.01);
	gate = button("v:standardBell/[4]gate");
};


//==============================Vocal Synthesis===========================================
// Vocal synthesizer functions (source/filter, fof, etc.).
//========================================================================================

//-------`(pm.)formantValues`----------
// Formant data values.
//
// The formant data used here come from the CSOUND manual
// <http://www.csounds.com/manual/html/>.
//
// #### Usage
//
// ```
// ba.take(j+1,formantValues.f(i)) : _
// ba.take(j+1,formantValues.g(i)) : _
// ba.take(j+1,formantValues.bw(i)) : _
// ```
//
// Where:
//
// * `i`: formant number
// * `j`: (voiceType*nFormants)+vowel
// * `voiceType`: the voice type (0: alto, 1: bass, 2: countertenor, 3:
// soprano, 4: tenor)
// * `vowel`: the vowel (0: a, 1: e, 2: i, 3: o, 4: u)
//--------------------------------------
formantValues = environment {
	f(0) = (800,400,350,450,325,600,400,250,400,350,660,440,270,430,370,800,
		350,270,450,325,650,400,290,400,350); // formant 0 freqs
	f(1) = (1150,1600,1700,800,700,1040,1620,1750,750,600,1120,1800,1850,820,630,
		1150,2000,2140,800,700,1080,1700,1870,800,600); // formant 1 freqs
	f(2) = (2800,2700,2700,2830,2530,2250,2400,2600,2400,2400,2750,2700,2900,2700,2750,
		2900,2800,2950,2830,2700,2650,2600,2800,2600,2700); // formant 2 freqs
	f(3) = (3500,3300,3700,3500,3500,2450,2800,3050,2600,2675,3000,3000,3350,3000,3000,
		3900,3600,3900,3800,3800,2900,3200,3250,2800,2900); // formant 3 freqs
	f(4) = (4950,4950,4950,4950,4950,2750,3100,3340,2900,2950,3350,3300,3590,3300,3400,
		4950,4950,4950,4950,4950,3250,3580,3540,3000,3300); // formant 4 freqs
	g(0) = (1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1); // formant 0 gains
	g(1) = (0.630957,0.063096,0.100000,0.354813,0.251189,0.446684,0.251189,0.031623,
		0.281838,0.100000,0.501187,0.199526,0.063096,0.316228,0.100000,
		0.501187,0.100000,0.251189,0.281838,0.158489,0.501187,0.199526,0.177828,
		0.316228,0.100000); // formant 1 gains
	g(2) = (0.100000,0.031623,0.031623,0.158489,0.031623,0.354813,0.354813,0.158489,
		0.089125,0.025119,0.070795,0.125893,0.063096,0.050119,0.070795,
		0.025119,0.177828,0.050119,0.079433,0.017783,0.446684,0.251189,0.125893,
		0.251189,0.141254); // formant 2 gains
	g(3) = (0.015849,0.017783,0.015849,0.039811,0.010000,0.354813,0.251189,0.079433,
		0.100000,0.039811,0.063096,0.100000,0.015849,0.079433,0.031623,
		0.100000,0.010000,0.050119,0.079433,0.010000,0.398107,0.199526,0.100000,
		0.251189,0.199526); // formant 3 gains
	g(4) = (0.001000,0.001000,0.001000,0.001778,0.000631,0.100000,0.125893,0.039811,
		0.010000,0.015849,0.012589,0.100000,0.015849,0.019953,0.019953,
		0.003162,0.001585,0.006310,0.003162,0.001000,0.079433,0.100000,0.031623,
		0.050119,0.050119); // formant 4 gains
	bw(0) = (80,60,50,70,50,60,40,60,40,40,80,70,40,40,40,80,60,60,40,50,
    50,70,40,70,40); // formant 0 bandwidths
	bw(1) = (90,80,100,80,60,70,80,90,80,80,90,80,90,80,60,90,100,90,80,60,
		90,80,90,80,60); // formant 1 bandwidths
	bw(2) = (120,120,120,100,170,110,100,100,100,100,120,100,100,100,100,
		120,120,100,100,170,120,100,100,100,100); // formant 2 bandwidths
	bw(3) = (130,150,150,130,180,120,120,120,120,120,130,120,120,120,120,
		130,150,120,120,180,130,120,120,130,120); // formant 3 bandwidths
	bw(4) = (140,200,200,135,200,130,120,120,120,120,140,120,120,120,120,
		140,200,120,120,200,140,120,120,135,120); // formant 4 bandwidths
};


// array of values used to multiply BWs by to get attack Bws for FOF version.
// min/max values per vowel (AEIOU) and per gender (M/F). Index by:
// gender*5 + vowel;
// values were chosen based on informal listening tests
bwMultMins = (1.0, 1.25, 1.25, 1.0, 1.5, 2.0, 3.0, 3.0, 2.0, 2.0);
bwMultMaxes = (10.0, 2.5, 2.5, 10.0, 4.0, 15.0, 12.0, 12.0, 12.0, 12.0);


// minimum/maximum frequency values per gender (M/F) used in the calculation
// of the attack Bws from the release Bws in the FOF version
// values are based on arbitrary maximum/minimum singing values
// in Hz for male/female voices
minGenderFreq = (82.41,174.61);
maxGenderFreq = (523.25,1046.5);


//--------------`(pm.)voiceGender`-----------------
// Calculate the gender for the provided `voiceType` value. (0: male, 1: female)
//
// #### Usage
//
// ```
// voiceGender(voiceType) : _
// ```
//
// Where:
//
// * `voiceType`: the voice type (0: alto, 1: bass, 2: countertenor,
// 		  3: soprano, 4: tenor)
//---------------------------------------------
// Author: Mike Olsen
voiceGender(voiceType) = ba.if(voiceType == 0,1,ba.if(voiceType == 3,1,0));


//-----------`(pm.)skirtWidthMultiplier`------------
// Calculates value to multiply bandwidth to obtain `skirtwidth`
// for a Fof filter.
//
// #### Usage
//
// ```
// skirtWidthMultiplier(vowel,freq,gender) : _
// ```
//
// Where:
//
// * `vowel`: the vowel (0: a, 1: e, 2: i, 3: o, 4: u)
// * `freq`: the fundamental frequency of the excitation signal
// * `gender`: gender of the voice used in the fof filter (0: male, 1: female)
//---------------------------------------------
// Author: Mike Olsen
skirtWidthMultiplier(vowel,freq,gender) = (multMax-multMin)*skirtParam+multMin
with {
	nVowels = 5;
	index = gender*nVowels + vowel;
	multMin = bwMultMins : ba.selectn(10,index);
	multMax = bwMultMaxes : ba.selectn(10,index);
	freqMin = minGenderFreq : ba.selectn(2,gender);
	freqMax = maxGenderFreq : ba.selectn(2,gender);
	skirtParam = ba.if(freq <= freqMin,0.0,ba.if(freq >= freqMax,1.0,
	 		    (1.0/(freqMax-freqMin))*(freq-freqMin)));
};


//--------------`(pm.)autobendFreq`-----------------
// Autobends the center frequencies of formants 1 and 2 based on
// the fundamental frequency of the excitation signal and leaves
// all other formant frequencies unchanged. Ported from `chant-lib`.
// Reference: <https://ccrma.stanford.edu/~rmichon/chantLib/>.
//
// #### Usage
//
// ```
// _ : autobendFreq(n,freq,voiceType) : _
// ```
//
// Where:
//
// * `n`: formant index
// * `freq`: the fundamental frequency of the excitation signal
// * `voiceType`: the voice type (0: alto, 1: bass, 2: countertenor,
//		  3: soprano, 4: tenor)
// * input is the center frequency of the corresponding formant
//---------------------------------------------
// Author: Mike Olsen
autobendFreq(n,freq,voiceType) = autobend(n)
with {
	autobend(0) = _ <: ba.if(_ <= freq,freq,_);
	autobend(1) = _ <: ba.if(voiceType != 2,
                _ <: ba.if((_ >= 1300)&(freq >= 200),
                _ -(freq-200)*(_-1300)/1050,
                ba.if(_ <= (30 + 2*freq),30 + 2*freq,_)), _);
	autobend(n) = _;
};


//--------------`(pm.)vocalEffort`-----------------
// Changes the gains of the formants based on the fundamental
// frequency of the excitation signal. Higher formants are
// reinforced for higher fundamental frequencies.
// Ported from `chant-lib`.
// Reference: <https://ccrma.stanford.edu/~rmichon/chantLib/>.
//
// #### Usage
//
// ```
// _ : vocalEffort(freq,gender) : _
// ```
//
// Where:
//
// * `freq`: the fundamental frequency of the excitation signal
// * `gender`: the gender of the voice type (0: male, 1: female)
// * input is the linear amplitude of the formant
//---------------------------------------------
// Author: Mike Olsen
vocalEffort(freq,gender) = _ <: ba.if(gender == 0,*(3+1.1*(400-freq)/300),*(0.8+1.05*(1000-freq)/1250));


//-------------------------`(pm.)fof`--------------------------
// Function to generate a single Formant-Wave-Function.
// Reference: <https://ccrma.stanford.edu/~mjolsen/pdfs/smc2016_MOlsenFOF.pdf>.
//
// #### Usage
//
// ```
// _ : fof(fc,bw,a,g) : _
// ```
//
// Where:
//
// * `fc`: formant center frequency,
// * `bw`: formant bandwidth (Hz),
// * `sw`: formant skirtwidth (Hz)
// * `g`: linear scale factor (g=1 gives 0dB amplitude response at fc)
// * input is an impulse signal to excite filter
//---------------------------------------------------------
// Author: Mike Olsen
fof(fc,bw,sw,g) = _ <: (_',_) : (f * s)
with {
	T = 1/ma.SR; 	      	// sample period
	pi = ma.PI;         	// pi
	u1 = exp(-sw*pi*T); 	// exponential controlling rise
	u2 = exp(-bw*pi*T); 	// exponential controlling decay
	a1 = -1*(u1+u2);    	// a1 filter coefficient
	a2 = u1*u2;         	// a2 filter coefficient
	G0 = 1/(1+a1+a2);   	// magnitude at DC
	b0 = g/G0;          	// filter gain
	s  = os.hs_oscsin(fc); 	// hardsyncing wavetable oscillator
	f  = fi.tf2(b0,0,0,a1,a2); // biquad filter
};


//-------------------------`(pm.)fofSH`-------------------------
// FOF with sample and hold used on `bw` and a parameter
// used in the filter-cycling FOF function `fofCycle`.
// Reference: <https://ccrma.stanford.edu/~mjolsen/pdfs/smc2016_MOlsenFOF.pdf>.
//
// #### Usage
//
// ```
// _ : fofSH(fc,bw,a,g) : _
// ```
//
// Where: all parameters same as for [`fof`](#fof)
//---------------------------------------------------------
// Author: Mike Olsen
fofSH(fc,bw,a,g) = _ <: (((_,bw):ba.sAndH),((_,a):ba.sAndH),_) : (fc,_,_,g,_') : fof;


//----------------------`(pm.)fofCycle`-------------------------
// FOF implementation where time-varying filter parameter noise is
// mitigated by using a cycle of `n` sample and hold FOF filters.
// Reference: <https://ccrma.stanford.edu/~mjolsen/pdfs/smc2016_MOlsenFOF.pdf>.
//
// #### Usage
//
// ```
// _ : fofCycle(fc,bw,a,g,n) : _
// ```
//
// Where:
//
// * `n`: the number of FOF filters to cycle through
// * all other parameters are same as for [`fof`](#fof)
//---------------------------------------------------------
// Author: Mike Olsen
fofCycle(fc,bw,a,g,n) = _ : ba.cycle(n) : par(i,n,fofSH(fc,bw,a,g)) :> _;


//----------------------`(pm.)fofSmooth`-------------------------
// FOF implementation where time-varying filter parameter
// noise is mitigated by lowpass filtering the filter
// parameters `bw` and `a` with [smooth](#smooth).
//
// #### Usage
//
// ```
// _ : fofSmooth(fc,bw,sw,g,tau) : _
// ```
//
// Where:
//
// * `tau`: the desired smoothing time constant in seconds
// * all other parameters are same as for [`fof`](#fof)
//---------------------------------------------------------
// Author: Mike Olsen
fofSmooth(fc,bw,sw,g,tau) = fof(fc,bw2,sw2,g)
with{
    sw2 = sw : si.smooth(ba.tau2pole(tau));
    bw2 = bw : si.smooth(ba.tau2pole(tau));
};


//-------`(pm.)formantFilterFofCycle`--------------
// Formant filter based on a single FOF filter.
// Formant parameters are linearly interpolated allowing to go smoothly from
// one vowel to another. A cycle of `n` fof filters with sample-and-hold is
// used so that the fof filter parameters can be varied in realtime.
// This technique is more robust but more computationally expensive than
// [`formantFilterFofSmooth`](#formantFilterFofSmooth).Voice type can be
// selected but must correspond to
// the frequency range of the provided source to be realistic.
//
// #### Usage
//
// ```
// _ : formantFilterFofCycle(voiceType,vowel,nFormants,i,freq) : _
// ```
//
// Where:
//
// * `voiceType`: the voice type (0: alto, 1: bass, 2: countertenor,
// 		  3: soprano, 4: tenor)
// * `vowel`: the vowel (0: a, 1: e, 2: i, 3: o, 4: u)
// * `nFormants`: number of formant regions in frequency domain, typically 5
// * `i`: formant number (i.e. 0 - 4) used to index formant data value arrays
// * `freq`: fundamental frequency of excitation signal. Used to calculate
//         rise time of envelope
//--------------------------------------
// Author: Mike Olsen
formantFilterFofCycle(voiceType,vowel,nFormants,i,freq) =
	fofCycle(formantFreq(i),formantBw(i),formantSw(i),formantGain(i),n)
with{
	n = 3; // number of fof filters to cycle between
	index = (voiceType*nFormants)+vowel; // index of formant values
	// formant center frequency using autobend correction
	formantFreq(i) = ba.listInterp(formantValues.f(i),index) : autobendFreq(i,freq,voiceType);
	// formant amplitude using vocal effort correction
	formantGain(i) = ba.listInterp(formantValues.g(i),index) : vocalEffort(freq,gender);
	formantBw(i) = ba.listInterp(formantValues.bw(i),index); // formant bandwidth
	// formant skirtwidth
	formantSw(i) = skirtWidthMultiplier(vowel,freq,gender)*formantBw(i);
	gender = voiceGender(voiceType); // gender of voice
};


//-------`(pm.)formantFilterFofSmooth`--------------
// Formant filter based on a single FOF filter.
// Formant parameters are linearly interpolated allowing to go smoothly from
// one vowel to another. Fof filter parameters are lowpass filtered
// to mitigate possible noise from varying them in realtime.
// Voice type can be selected but must correspond to
// the frequency range of the provided source to be realistic.
//
// #### Usage
//
// ```
// _ : formantFilterFofSmooth(voiceType,vowel,nFormants,i,freq) : _
// ```
//
// Where:
//
// * `voiceType`: the voice type (0: alto, 1: bass, 2: countertenor,
// 		  3: soprano, 4: tenor)
// * `vowel`: the vowel (0: a, 1: e, 2: i, 3: o, 4: u)
// * `nFormants`: number of formant regions in frequency domain, typically 5
// * `i`: formant number (i.e. 1 - 5) used to index formant data value arrays
// * `freq`: fundamental frequency of excitation signal. Used to calculate
//         rise time of envelope
//--------------------------------------
// Author: Mike Olsen
formantFilterFofSmooth(voiceType,vowel,nFormants,i,freq) =
	fofSmooth(formantFreq(i),formantBw(i),formantSw(i),formantGain(i),tau)
with{
	tau = 0.001;
	index = (voiceType*nFormants)+vowel; // index of formant values
	// formant center frequency using autobend correction
	formantFreq(i) = ba.listInterp(formantValues.f(i),index) : autobendFreq(i,freq,voiceType);
	// formant amplitude using vocal effort correction
	formantGain(i) = ba.listInterp(formantValues.g(i),index) : vocalEffort(freq,gender);
	formantBw(i) = ba.listInterp(formantValues.bw(i),index); // formant bandwidth
	// formant skirtwidth
	formantSw(i) = skirtWidthMultiplier(vowel,freq,gender)*formantBw(i);
	gender = voiceGender(voiceType); // gender of voice
};


//-------`(pm.)formantFilterBP`--------------
// Formant filter based on a single resonant bandpass filter.
// Formant parameters are linearly interpolated allowing to go smoothly from
// one vowel to another. Voice type can be selected but must correspond to
// the frequency range of the provided source to be realistic.
//
// #### Usage
//
// ```
// _ : formantFilterBP(voiceType,vowel,nFormants,i,freq) : _
// ```
//
// Where:
//
// * `voiceType`: the voice type (0: alto, 1: bass, 2: countertenor,
// 		  3: soprano, 4: tenor)
// * `vowel`: the vowel (0: a, 1: e, 2: i, 3: o, 4: u)
// * `nFormants`: number of formant regions in frequency domain, typically 5
// * `i`: formant index used to index formant data value arrays
// * `freq`: fundamental frequency of excitation signal.
//--------------------------------------
formantFilterBP(voiceType,vowel,nFormants,i,freq) =
	fi.resonbp(formantFreq(i),formantFreq(i)/formantBw(i),
		   formantGain(i))
with{
	index = (voiceType*nFormants)+vowel; // index of formant values
	// formant center frequency using autobend correction
	formantFreq(i) = ba.listInterp(formantValues.f(i),index) : autobendFreq(i,freq,voiceType);
	// formant amplitude using vocal effort correction
	formantGain(i) = ba.listInterp(formantValues.g(i),index) : vocalEffort(freq,gender);
	formantBw(i) = ba.listInterp(formantValues.bw(i),index); // formant bandwidth
	gender = voiceGender(voiceType); // gender of voice
};


//-------`(pm.)formantFilterbank`--------------
// Formant filterbank which can use different types of filterbank
// functions and different excitation signals. Formant parameters are
// linearly interpolated allowing to go smoothly from one vowel to another.
// Voice type can be selected but must correspond to the frequency range
// of the provided source to be realistic.
//
// #### Usage
//
// ```
// _ : formantFilterbank(voiceType,vowel,formantGen,freq) : _
// ```
//
// Where:
//
// * `voiceType`: the voice type (0: alto, 1: bass, 2: countertenor,
// 	 	  3: soprano, 4: tenor)
// * `vowel`: the vowel (0: a, 1: e, 2: i, 3: o, 4: u)
// * `formantGen`: the specific formant filterbank function
//                 (i.e. FormantFilterbankBP, FormantFilterbankFof,...)
// * `freq`: fundamental frequency of excitation signal. Needed for FOF
//         version to calculate rise time of envelope
//--------------------------------------
// Author: Mike Olsen
formantFilterbank(voiceType,vowel,formantGen,freq) =
	_ <: par(i,nFormants,formantGen(voiceType,vowel,nFormants,i,freq)) :> _
with{
	nFormants = 5;
};


//-----`(pm.)formantFilterbankFofCycle`-----
// Formant filterbank based on a bank of fof filters.
// Formant parameters are linearly interpolated allowing to go smoothly from
// one vowel to another. Voice type can be selected but must correspond to
// the frequency range of the provided source to be realistic.
//
// #### Usage
//
// ```
// _ : formantFilterbankFofCycle(voiceType,vowel,freq) : _
// ```
//
// Where:
//
// * `voiceType`: the voice type (0: alto, 1: bass, 2: countertenor,
// 		  3: soprano, 4: tenor)
// * `vowel`: the vowel (0: a, 1: e, 2: i, 3: o, 4: u)
// * `freq`: the fundamental frequency of the excitation signal. Needed to
//	     calculate the skirtwidth of the FOF envelopes and for the
//	     autobendFreq and vocalEffort functions
//-------------------------------------
// Author: Mike Olsen
formantFilterbankFofCycle(voiceType,vowel,freq) =
formantFilterbank(voiceType,vowel,formantFilterFofCycle,freq);


//-----`(pm.)formantFilterbankFofSmooth`----
// Formant filterbank based on a bank of fof filters.
// Formant parameters are linearly interpolated allowing to go smoothly from
// one vowel to another. Voice type can be selected but must correspond to
// the frequency range of the provided source to be realistic.
//
// #### Usage
//
// ```
// _ : formantFilterbankFofSmooth(voiceType,vowel,freq) : _
// ```
//
// Where:
//
// * `voiceType`: the voice type (0: alto, 1: bass, 2: countertenor,
// 		  3: soprano, 4: tenor)
// * `vowel`: the vowel (0: a, 1: e, 2: i, 3: o, 4: u)
// * `freq`: the fundamental frequency of the excitation signal. Needed to
//	     calculate the skirtwidth of the FOF envelopes and for the
//	     autobendFreq and vocalEffort functions
//-------------------------------------
// Author: Mike Olsen
formantFilterbankFofSmooth(voiceType,vowel,freq) =
formantFilterbank(voiceType,vowel,formantFilterFofSmooth,freq);


//-------`(pm.)formantFilterbankBP`--------------
// Formant filterbank based on a bank of resonant bandpass filters.
// Formant parameters are linearly interpolated allowing to go smoothly from
// one vowel to another. Voice type can be selected but must correspond to
// the frequency range of the provided source to be realistic.
//
// #### Usage
//
// ```
// _ : formantFilterbankBP(voiceType,vowel) : _
// ```
//
// Where:
//
// * `voiceType`: the voice type (0: alto, 1: bass, 2: countertenor,
// 		  3: soprano, 4: tenor)
// * `vowel`: the vowel (0: a, 1: e, 2: i, 3: o, 4: u)
// * `freq`: the fundamental frequency of the excitation signal. Needed
//	     for the autobendFreq and vocalEffort functions
//--------------------------------------
formantFilterbankBP(voiceType,vowel,freq) =
formantFilterbank(voiceType,vowel,formantFilterBP,freq);


//-------`(pm.)SFFormantModel`--------------
// Simple formant/vocal synthesizer based on a source/filter model. The `source`
// and `filterbank` must be specified by the user. `filterbank` must take the same
// input parameters as [`formantFilterbank`](#formantFilterbank) (`BP`/`FofCycle`
// /`FofSmooth`).
// Formant parameters are linearly interpolated allowing to go smoothly from
// one vowel to another. Voice type can be selected but must correspond to
// the frequency range of the synthesized voice to be realistic.
//
// #### Usage
//
// ```
// SFFormantModel(voiceType,vowel,exType,freq,gain,source,filterbank,isFof) : _
// ```
//
// Where:
//
// * `voiceType`: the voice type (0: alto, 1: bass, 2: countertenor,
// 		  3: soprano, 4: tenor)
// * `vowel`: the vowel (0: a, 1: e, 2: i, 3: o, 4: u
// * `exType`: voice vs. fricative sound ratio (0-1 where 1 is 100% fricative)
// * `freq`: the fundamental frequency of the source signal
// * `gain`: linear gain multiplier to multiply the source by
// * `isFof`: whether model is FOF based (0: no, 1: yes)
//--------------------------------------
// Author: Mike Olsen
SFFormantModel(voiceType,vowel,exType,freq,gain,source,filterbank,isFof) =
	excitation : resonance
with{
	breath = no.noise;
	excitation = ba.if(isFof,source,source*(1-exType) + breath*exType :
			*(gain));
	resonance = filterbank(voiceType,vowel,freq) <: ba.if(isFof,*(gain),_);
};


//-------`(pm.)SFFormantModelFofCycle`-------
// Simple formant/vocal synthesizer based on a source/filter model. The source
// is just a periodic impulse and the "filter" is a bank of FOF filters.
// Formant parameters are linearly interpolated allowing to go smoothly from
// one vowel to another. Voice type can be selected but must correspond to
// the frequency range of the synthesized voice to be realistic. This model
// does not work with noise in the source signal so exType has been removed
// and model does not depend on SFFormantModel function.
//
// #### Usage
//
// ```
// SFFormantModelFofCycle(voiceType,vowel,freq,gain) : _
// ```
//
// Where:
//
// * `voiceType`: the voice type (0: alto, 1: bass, 2: countertenor,
// 		  3: soprano, 4: tenor)
// * `vowel`: the vowel (0: a, 1: e, 2: i, 3: o, 4: u
// * `freq`: the fundamental frequency of the source signal
// * `gain`: linear gain multiplier to multiply the source by
//---------------------------------------
// Author: Mike Olsen
SFFormantModelFofCycle(voiceType,vowel,freq,gain) =
SFFormantModel(voiceType,vowel,0,freq,gain,os.lf_imptrain(freq),
formantFilterbankFofCycle,1);


//-------`(pm.)SFFormantModelFofSmooth`-------
// Simple formant/vocal synthesizer based on a source/filter model. The source
// is just a periodic impulse and the "filter" is a bank of FOF filters.
// Formant parameters are linearly interpolated allowing to go smoothly from
// one vowel to another. Voice type can be selected but must correspond to
// the frequency range of the synthesized voice to be realistic.
//
// #### Usage
//
// ```
// SFFormantModelFofSmooth(voiceType,vowel,freq,gain) : _
// ```
//
// Where:
//
// * `voiceType`: the voice type (0: alto, 1: bass, 2: countertenor,
// 		  3: soprano, 4: tenor)
// * `vowel`: the vowel (0: a, 1: e, 2: i, 3: o, 4: u
// * `freq`: the fundamental frequency of the source signal
// * `gain`: linear gain multiplier to multiply the source by
//---------------------------------------
// Author: Mike Olsen
SFFormantModelFofSmooth(voiceType,vowel,freq,gain) =
SFFormantModel(voiceType,vowel,0,freq,gain,os.lf_imptrain(freq),
formantFilterbankFofSmooth,1);


//-------`(pm.)SFFormantModelBP`--------------
// Simple formant/vocal synthesizer based on a source/filter model. The source
// is just a sawtooth wave and the "filter" is a bank of resonant bandpass filters.
// Formant parameters are linearly interpolated allowing to go smoothly from
// one vowel to another. Voice type can be selected but must correspond to
// the frequency range of the synthesized voice to be realistic.
//
// The formant data used here come from the CSOUND manual
// <http://www.csounds.com/manual/html/>.
//
// #### Usage
//
// ```
// SFFormantModelBP(voiceType,vowel,exType,freq,gain) : _
// ```
//
// Where:
//
// * `voiceType`: the voice type (0: alto, 1: bass, 2: countertenor,
// 		  3: soprano, 4: tenor)
// * `vowel`: the vowel (0: a, 1: e, 2: i, 3: o, 4: u
// * `exType`: voice vs. fricative sound ratio (0-1 where 1 is 100% fricative)
// * `freq`: the fundamental frequency of the source signal
// * `gain`: linear gain multiplier to multiply the source by
//---------------------------------------
SFFormantModelBP(voiceType,vowel,exType,freq,gain) =
SFFormantModel(voiceType,vowel,exType,freq,gain,os.sawtooth(freq),
formantFilterbankBP,0);


//-------`(pm.)SFFormantModelFofCycle_ui`----------
// Ready-to-use source-filter vocal synthesizer with built-in user interface.
//
// #### Usage
//
// ```
// SFFormantModelFofCycle_ui : _
// ```
//----------------------------------
// Author: Mike Olsen
SFFormantModelFofCycle_ui = SFFormantModelFofCycle(voiceType,vowel,freq2,gain*corrFactor)
with{
	freq1 = hslider("v:vocal/[0]freq",440,50,1000,0.01);
	gain = hslider("v:vocal/[1]gain",0.9,0,1,0.01);
	corrFactor = 75.0;
	voiceType = hslider("v:vocal/[2]voiceType",0,0,4,1);
	vowel = hslider("v:vocal/[3]vowel",0,0,4,0.01) : si.smoo;
	vibratoFreq = hslider("v:vocal/[5]vibratoFreq",6,1,10,0.01);
	vibratoGain = hslider("v:vocal/[6]vibratoGain",0.5,0,1,0.01)*0.1;
	freq2 = freq1*(os.osc(vibratoFreq)*vibratoGain+1);
};


//-------`(pm.)SFFormantModelFofSmooth_ui`----------
// Ready-to-use source-filter vocal synthesizer with built-in user interface.
//
// #### Usage
//
// ```
// SFFormantModelFofSmooth_ui : _
// ```
//----------------------------------
// Author: Mike Olsen
SFFormantModelFofSmooth_ui = SFFormantModelFofSmooth(voiceType,vowel,freq2,gain*corrFactor)
with{
	freq1 = hslider("v:vocal/[0]freq",440,50,1000,0.01);
	gain = hslider("v:vocal/[1]gain",0.9,0,1,0.01);
	corrFactor = 25.0;
	voiceType = hslider("v:vocal/[2]voiceType",0,0,4,1);
	vowel = hslider("v:vocal/[3]vowel",0,0,4,0.01) : si.smoo;
	vibratoFreq = hslider("v:vocal/[5]vibratoFreq",6,1,10,0.01);
	vibratoGain = hslider("v:vocal/[6]vibratoGain",0.5,0,1,0.01)*0.1;
	freq2 = freq1*(os.osc(vibratoFreq)*vibratoGain+1);
};


//-------`(pm.)SFFormantModelBP_ui`----------
// Ready-to-use source-filter vocal synthesizer with built-in user interface.
//
// #### Usage
//
// ```
// SFFormantModelBP_ui : _
// ```
//----------------------------------
SFFormantModelBP_ui = SFFormantModelBP(voiceType,vowel,fricative,freq2,gain)
with{
	freq1 = hslider("v:vocal/[0]freq",440,50,1000,0.01);
	gain = hslider("v:vocal/[1]gain",0.9,0,1,0.01);
	voiceType = hslider("v:vocal/[2]voiceType",0,0,4,1);
	vowel = hslider("v:vocal/[3]vowel",0,0,4,0.01) : si.smoo;
	fricative = hslider("v:vocal/[4]fricative",0,0,1,0.01) : si.smoo;
	vibratoFreq = hslider("v:vocal/[5]vibratoFreq",6,1,10,0.01);
	vibratoGain = hslider("v:vocal/[6]vibratoGain",0.5,0,1,0.01)*0.1;
	freq2 = freq1*(os.osc(vibratoFreq)*vibratoGain+1);
};


//-------`(pm.)SFFormantModelFofCycle_ui_MIDI`----------
// Ready-to-use MIDI-controllable source-filter vocal synthesizer.
//
// #### Usage
//
// ```
// SFFormantModelFofCycle_ui_MIDI : _
// ```
//----------------------------------
SFFormantModelFofCycle_ui_MIDI = SFFormantModelFofCycle(voiceType,vowel,freq2,envelope)*outGain
with{
	freq1 = hslider("v:vocal/h:[0]midi/[0]freq[style:knob]",440,50,1000,0.01);
	bend = ba.semi2ratio(hslider("v:vocal/h:[0]midi/[1]bend[hidden:1][midi:pitchwheel]
	[style:knob]",0,-2,2,0.01)) : si.polySmooth(gate,0.999,1);
	gain = hslider("v:vocal/h:[0]midi/[2]gain[style:knob]
	",0.9,0,1,0.01);
	corrFactor = 75.0;
	envAttack = hslider("v:vocal/h:[0]midi/[3]envAttack[style:knob]
	",10,0,30,0.01)*0.001;
	s = hslider("v:vocal/h:[0]midi/[4]sustain[hidden:1][midi:ctrl 64]
	[style:knob]",0,0,1,1);
	voiceType = hslider("v:vocal/h:[1]otherParams/[0]voiceType
	[style:knob]",0,0,4,1);
	vowel = hslider("v:vocal/h:[1]otherParams/[1]vowel
	[style:knob][midi:ctrl 1]",0,0,4,0.01) : si.smoo;
	vibratoFreq = hslider("v:vocal/h:[1]otherParams/[3]vibratoFreq[style:knob]
	",6,1,10,0.01);
	vibratoGain = hslider("v:vocal/h:[1]otherParams/[4]vibratoGain[style:knob]
	",0.5,0,1,0.01)*0.1;
	outGain = hslider("v:vocal/h:[1]otherParams/[5]outGain[style:knob]
	",0.5,0,1,0.01);
	t = button("v:vocal/[2]gate");

	gate = t+s : min(1);
	freq2 = freq1*bend*(os.osc(vibratoFreq)*vibratoGain+1);
	envelope = gate*gain*corrFactor : si.smooth(ba.tau2pole(envAttack));
};


//-------`(pm.)SFFormantModelFofSmooth_ui_MIDI`----------
// Ready-to-use MIDI-controllable source-filter vocal synthesizer.
//
// #### Usage
//
// ```
// SFFormantModelFofSmooth_ui_MIDI : _
// ```
//----------------------------------
SFFormantModelFofSmooth_ui_MIDI = SFFormantModelFofSmooth(voiceType,vowel,freq2,envelope)*outGain
with{
	freq1 = hslider("v:vocal/h:[0]midi/[0]freq[style:knob]",440,50,1000,0.01);
	bend = ba.semi2ratio(hslider("v:vocal/h:[0]midi/[1]bend[hidden:1][midi:pitchwheel]
	[style:knob]",0,-2,2,0.01)) : si.polySmooth(gate,0.999,1);
	gain = hslider("v:vocal/h:[0]midi/[2]gain[style:knob]
	",0.9,0,1,0.01);
	corrFactor = 25.0;
	envAttack = hslider("v:vocal/h:[0]midi/[3]envAttack[style:knob]
	",10,0,30,0.01)*0.001;
	s = hslider("v:vocal/h:[0]midi/[4]sustain[hidden:1][midi:ctrl 64]
	[style:knob]",0,0,1,1);
	voiceType = hslider("v:vocal/h:[1]otherParams/[0]voiceType
	[style:knob]",0,0,4,1);
	vowel = hslider("v:vocal/h:[1]otherParams/[1]vowel
	[style:knob][midi:ctrl 1]",0,0,4,0.01) : si.smoo;
	vibratoFreq = hslider("v:vocal/h:[1]otherParams/[3]vibratoFreq[style:knob]
	",6,1,10,0.01);
	vibratoGain = hslider("v:vocal/h:[1]otherParams/[4]vibratoGain[style:knob]
	",0.5,0,1,0.01)*0.1;
	outGain = hslider("v:vocal/h:[1]otherParams/[5]outGain[style:knob]
	",0.5,0,1,0.01);
	t = button("v:vocal/[2]gate");

	gate = t+s : min(1);
	freq2 = freq1*bend*(os.osc(vibratoFreq)*vibratoGain+1);
	envelope = gate*gain*corrFactor : si.smooth(ba.tau2pole(envAttack));
};


//-------`(pm.)SFFormantModelBP_ui_MIDI`----------
// Ready-to-use MIDI-controllable source-filter vocal synthesizer.
//
// #### Usage
//
// ```
// SFFormantModelBP_ui_MIDI : _
// ```
//----------------------------------
SFFormantModelBP_ui_MIDI = SFFormantModelBP(voiceType,vowel,fricative,freq2,envelope)*outGain
with{
	freq1 = hslider("v:vocal/h:[0]midi/[0]freq[style:knob]",440,50,1000,0.01);
	bend = ba.semi2ratio(hslider("v:vocal/h:[0]midi/[1]bend[hidden:1][midi:pitchwheel]
	[style:knob]",0,-2,2,0.01)) : si.polySmooth(gate,0.999,1);
	gain = hslider("v:vocal/h:[0]midi/[2]gain[style:knob]
	",0.9,0,1,0.01);
	envAttack = hslider("v:vocal/h:[0]midi/[3]envAttack[style:knob]
	",10,0,30,0.01)*0.001;
	s = hslider("v:vocal/h:[0]midi/[4]sustain[hidden:1][midi:ctrl 64]
	[style:knob]",0,0,1,1);
	voiceType = hslider("v:vocal/h:[1]otherParams/[0]voiceType
	[style:knob]",0,0,4,1);
	vowel = hslider("v:vocal/h:[1]otherParams/[1]vowel
	[style:knob][midi:ctrl 1]",0,0,4,0.01) : si.smoo;
	fricative = hslider("v:vocal/h:[1]otherParams/[2]fricative
	[style:knob]",0,0,1,0.01) : si.smoo;
	vibratoFreq = hslider("v:vocal/h:[1]otherParams/[3]vibratoFreq[style:knob]
	",6,1,10,0.01);
	vibratoGain = hslider("v:vocal/h:[1]otherParams/[4]vibratoGain[style:knob]
	",0.5,0,1,0.01)*0.1;
	outGain = hslider("v:vocal/h:[1]otherParams/[5]outGain[style:knob]
	",0.5,0,1,0.01);
	t = button("v:vocal/[2]gate");

 	gate = t+s : min(1);
	freq2 = freq1*bend*(os.osc(vibratoFreq)*vibratoGain+1);
	envelope = gate*gain : si.smooth(ba.tau2pole(envAttack));
};


//=============================== Misc Functions =========================================
// Various miscellaneous functions.
//========================================================================================

//-------`(pm.)allpassNL`--------------
// Bidirectional block adding nonlinearities in both directions in a chain.
// Nonlinearities are created by modulating the coefficients of a passive
// allpass filter by the signal it is processing.
//
// #### Usage
//
// ```
// chain(... : allpassNL(nonlinearity) : ...)
// ```
//
// Where:
//
// * `nonlinearity`: amount of nonlinearity to be added (0-1)
//--------------------------------------
allpassNL(nonlinearity) = par(i,2,nlf),_
with{
	nlf = _ <: fi.allpassn(2,par(i,2,*(nonlinearity)*ma.PI));
};


//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// UNCATEGORIZED FUNCTIONS (TODO)
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

//-------`(pm).modalModel`--------------
//
// Implement multiple resonance modes using resonant bandpass filters.
//
// #### Usage
//
// ```
// _ : modalModel(n, freqs, t60s, gains) : _
// ```
//
// Where:
//
// * `n`: number of given modes
// * `freqs` : list of filter center freqencies
// * `t60s` : list of mode resonance durations (in seconds)
// * `gains` : list of mode gains (0-1)
//
// For example, to generate a model with 2 modes (440 Hz and 660 Hz, a
// fifth) where the higher one decays faster and is attenuated:
//
// ```
// os.impulse : modalModel(2, (440, 660),
//                            (0.5, 0.25),
//                            (ba.db2linear(-1), ba.db2linear(-6)) : _
// ```
//
// Further reading: [Grumiaux et. al., 2017:
// Impulse-Response and CAD-Model-Based Physical Modeling in
// Faust](https://raw.githubusercontent.com/grame-cncm/faust/master-dev/tools/physicalModeling/ir2dsp/lacPaper2017.pdf)
//
//--------------------------------------
modalModel(n,modeFreqs,modeRes,modeGains) = _ <: par(i,n,modeFilter(freqs(i),res(i),gain(i))) :> _
with{
	freqs(i) = ba.take(i+1,modeFreqs);
	res(i) = ba.take(i+1,modeRes);
	gain(i) = ba.take(i+1,modeGains);
};
//################################### maths.lib ##########################################
//  Mathematic library for Faust. Its official prefix is `ma`.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/maths.lib>
//########################################################################################
// Some functions are implemented as Faust foreign functions of `math.h` functions
// that are not part of Faust's primitives. Defines also various constants and several
// utilities.
//########################################################################################

// ## History
// * 06/13/2016 [RM]	normalizing and integrating to new libraries
// * 07/08/2015	[YO]	documentation comments
// * 20/06/2014	[SL]	added FTZ function
// * 22/06/2013	[YO]	added float|double|quad variants of some foreign functions
// * 28/06/2005	[YO]	postfixed functions with 'f' to force float version instead of double
// * 28/06/2005	[YO]	removed 'modf' because it requires a pointer as argument

/************************************************************************
************************************************************************
FAUST library file
Copyright (C) 2003-2016 GRAME, Centre National de Creation Musicale
----------------------------------------------------------------------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

// This library contains platform specific constants 
pl = library("platform.lib");
ma = library("maths.lib"); // for compatible copy/paste out of this file

declare name "Faust Math Library";
declare version "2.5";
declare author "GRAME";
declare copyright "GRAME";
declare license "LGPL with exception";

//=============================Functions Reference========================================
//========================================================================================


//---------------------------------`(ma.)SR`---------------------------------------
// Current sampling rate. Constant during
// program execution.
//
// #### Usage
//
// ```
// SR : _
// ```
//-----------------------------------------------------------------------------
SR = pl.SR;

//---------------------------------`(ma.)T`---------------------------------------
// Current sampling period. Constant during
// program execution.
//
// #### Usage
//
// ```
// T : _
// ```
//-----------------------------------------------------------------------------
T = 1.0 / SR;

//---------------------------------`(ma.)BS`---------------------------------------
// Current block-size. Can change during the execution.
//
// #### Usage
//
// ```
// BS : _
// ```
//-----------------------------------------------------------------------------
BS = pl.BS;


//---------------------------------`(ma.)PI`---------------------------------------
// Constant PI in double precision.
//
// #### Usage
//
// ```
// PI : _
// ```
//-----------------------------------------------------------------------------
PI = 3.14159265358979323846;


//---------------------------------`(ma.)E`---------------------------------------
// Constant e in double precision.
//
// #### Usage
//
// ```
// E : _
// ```
//-----------------------------------------------------------------------------
E = 2.71828182845904523536;


//---------------------------------`(ma.)EPSILON`---------------------------------------
// Constant EPSILON in simple/double/quad precision.
//
// #### Usage
//
// ```
// EPSILON : _
// ```
//-----------------------------------------------------------------------------
singleprecision EPSILON = 1.192092896e-07;
doubleprecision EPSILON = 2.2204460492503131e-016;
quadprecision EPSILON = 2.2204460492503131e-016;
fixedpointprecision EPSILON = 2.2204460492503131e-016;


//---------------------------------`(ma.)MIN`---------------------------------------
// Constant MIN in simple/double/quad precision (minimal positive value).
//
// #### Usage
//
// ```
// MIN : _
// ```
//-----------------------------------------------------------------------------
singleprecision MIN = 1.175494351e-38;
doubleprecision MIN = 2.2250738585072014e-308;
quadprecision MIN = 2.2250738585072014e-308;
fixedpointprecision MIN = 2.2250738585072014e-308;


//---------------------------------`(ma.)MAX`------------------------------
// Constant MAX in simple/double/quad precision (maximal positive value).
//
// #### Usage
//
// ```
// MAX : _
// ```
//-----------------------------------------------------------------------------
singleprecision MAX = 3.402823466e+38;
doubleprecision MAX = 1.7976931348623158e+308;
quadprecision MAX = 1.7976931348623158e+308;
fixedpointprecision MAX = 1.7976931348623158e+308;

// Obsolete, kept for compatibility reasons
INFINITY = MAX; 

//---------------------------------`(ma.)FTZ`---------------------------------------
// Flush to zero: force samples under the "maximum subnormal number"
// to be zero. Usually not needed in C++ because the architecture
// file take care of this, but can be useful in JavaScript for instance.
//
// #### Usage
//
// ```
// _ : FTZ : _
// ```
//
// #### Reference
//
// <http://docs.oracle.com/cd/E19957-01/806-3568/ncg_math.html>
//-----------------------------------------------------------------------------
FTZ(x) = x * (abs(x) > MIN);


//---------------------------------`(ma.)copysign`---------------------------------------
// Changes the sign of x (first input) to that of y (second input).
//
// #### Usage
//
// ```
// _,_ : copysign : _
// ```
//-----------------------------------------------------------------------------
copysign = ffunction(float copysignf|copysign|copysignl (float, float), <math.h>,"");


//---------------------------------`(ma.)neg`---------------------------------------
// Invert the sign (-x) of a signal.
//
// #### Usage
//
// ```
// _ : neg : _
// ```
//-----------------------------------------------------------------------------
neg(x) = -x;


//-------`(ma.)sub(x,y)`------------------
// Subtract `x` and `y`.
//
// #### Usage
//
// ```
// _,_ : sub : _
// ```
//------------------------------
sub(x,y) = y-x;


//---------------------------------`(ma.)inv`---------------------------------------
// Compute the inverse (1/x) of the input signal.
//
// #### Usage
//
// ```
// _ : inv : _
// ```
//-----------------------------------------------------------------------------
inv(x) = 1/x;


//---------------------------------`(ma.)cbrt`--------------------------------------
// Computes the cube root of of the input signal.
//
// #### Usage
//
// ```
// _ : cbrt : _
// ```
//-----------------------------------------------------------------------------
cbrt = ffunction(float cbrtf|cbrt|cbrtl (float), <math.h>,"");


//---------------------------------`(ma.)hypot`-------------------------------------
// Computes the euclidian distance of the two input signals
// sqrt(x*x+y*y) without undue overflow or underflow.
//
// #### Usage
//
// ```
// _,_ : hypot : _
// ```
//-----------------------------------------------------------------------------
hypot = ffunction(float hypotf|hypot|hypotl (float, float), <math.h>,"");


//---------------------------------`(ma.)ldexp`-------------------------------------
// Takes two input signals: x and n, and multiplies x by 2 to the power n.
//
// #### Usage
//
// ```
// _,_ : ldexp : _
// ```
//-----------------------------------------------------------------------------
ldexp = ffunction(float ldexpf|ldexp|ldexpl (float, int), <math.h>,"");


//---------------------------------`(ma.)scalb`-------------------------------------
// Takes two input signals: x and n, and multiplies x by 2 to the power n.
//
// #### Usage
//
// ```
// _,_ : scalb : _
// ```
//-----------------------------------------------------------------------------
scalb = ffunction(float scalbnf|scalbn|scalbnl (float, int), <math.h>,"");


//---------------------------------`(ma.)log1p`----------------------------------
// Computes log(1 + x) without undue loss of accuracy when x is nearly zero.
//
// #### Usage
//
// ```
// _ : log1p : _
// ```
//-----------------------------------------------------------------------------
log1p = ffunction(float log1pf|log1p|log1pl (float), <math.h>,"");


//---------------------------------`(ma.)logb`---------------------------------------
// Return exponent of the input signal as a floating-point number.
//
// #### Usage
//
// ```
// _ : logb : _
// ```
//-----------------------------------------------------------------------------
logb = ffunction(float logbf|logb|logbl (float), <math.h>,"");


//---------------------------------`(ma.)ilogb`-------------------------------------
// Return exponent of the input signal as an integer number.
//
// #### Usage
//
// ```
// _ : ilogb : _
// ```
//-----------------------------------------------------------------------------
ilogb = ffunction(int ilogbf|ilogb|ilogbl (float), <math.h>,"");


//---------------------------------`(ma.)log2`-------------------------------------
// Returns the base 2 logarithm of x.
//
// #### Usage
//
// ```
// _ : log2 : _
// ```
//-----------------------------------------------------------------------------
log2(x) = log(x)/log(2.0);


//---------------------------------`(ma.)expm1`-------------------------------------
// Return exponent of the input signal minus 1 with better precision.
//
// #### Usage
//
// ```
// _ : expm1 : _
// ```
//-----------------------------------------------------------------------------
expm1 = ffunction(float expm1f|expm1|expm1l (float), <math.h>,"");


//---------------------------------`(ma.)acosh`-------------------------------------
// Computes the principle value of the inverse hyperbolic cosine
// of the input signal.
//
// #### Usage
//
// ```
// _ : acosh : _
// ```
//-----------------------------------------------------------------------------
acosh = ffunction(float acoshf|acosh|acoshl (float), <math.h>, "");


//--------------------------------`(ma.)asinh`-----------------------------------
// Computes the inverse hyperbolic sine of the input signal.
//
// #### Usage
//
// ```
// _ : asinh : _
// ```
//-----------------------------------------------------------------------------
asinh = ffunction(float asinhf|asinh|asinhl (float), <math.h>, "");


//--------------------------------`(ma.)atanh`-----------------------------------
// Computes the inverse hyperbolic tangent of the input signal.
//
// #### Usage
//
// ```
// _ : atanh : _
// ```
//-----------------------------------------------------------------------------
atanh = ffunction(float atanhf|atanh|atanhl (float), <math.h>, "");


//---------------------------------`(ma.)sinh`---------------------------------------
// Computes the hyperbolic sine of the input signal.
//
// #### Usage
//
// ```
// _ : sinh : _
// ```
//-----------------------------------------------------------------------------
sinh = ffunction(float sinhf|sinh|sinhl (float), <math.h>, "");


//---------------------------------`(ma.)cosh`--------------------------------------
// Computes the hyperbolic cosine of the input signal.
//
// #### Usage
//
// ```
// _ : cosh : _
// ```
//-----------------------------------------------------------------------------
cosh = ffunction(float coshf|cosh|coshl (float), <math.h>, "");


//---------------------------------`(ma.)tanh`--------------------------------------
// Computes the hyperbolic tangent of the input signal.
//
// #### Usage
//
// ```
// _ : tanh : _
// ```
//-----------------------------------------------------------------------------
tanh = ffunction(float tanhf|tanh|tanhl (float), <math.h>,"");


//---------------------------------`(ma.)erf`---------------------------------------
// Computes the error function of the input signal.
//
// #### Usage
//
// ```
// _ : erf : _
// ```
//-----------------------------------------------------------------------------
erf = ffunction(float erff|erf|erfl(float), <math.h>,"");


//---------------------------------`(ma.)erfc`---------------------------------------
// Computes the complementary error function of the input signal.
//
// #### Usage
//
// ```
// _ : erfc : _
// ```
//-----------------------------------------------------------------------------
erfc = ffunction(float erfcf|erfc|erfcl(float), <math.h>,"");


//---------------------------------`(ma.)gamma`-------------------------------------
// Computes the gamma function of the input signal.
//
// #### Usage
//
// ```
// _ : gamma : _
// ```
//-----------------------------------------------------------------------------
gamma = ffunction(float tgammaf|tgamma|tgammal(float), <math.h>,"");


//---------------------------------`(ma.)lgamma`------------------------------------
// Calculates the natural logorithm of the absolute value of
// the gamma function of the input signal.
//
// #### Usage
//
// ```
// _ : lgamma : _
// ```
//-----------------------------------------------------------------------------
lgamma = ffunction(float lgammaf|lgamma|lgammal(float), <math.h>,"");


//----------------------------------`(ma.)J0`---------------------------------------
// Computes the Bessel function of the first kind of order 0
// of the input signal.
//
// #### Usage
//
// ```
// _ : J0 : _
// ```
//-----------------------------------------------------------------------------
J0 = ffunction(float j0(float), <math.h>,"");


//----------------------------------`(ma.)J1`---------------------------------------
// Computes the Bessel function of the first kind of order 1
// of the input signal.
//
// #### Usage
//
// ```
// _ : J1 : _
// ```
//-----------------------------------------------------------------------------
J1 = ffunction(float j1(float), <math.h>,"");


//----------------------------------`(ma.)Jn`---------------------------------------
// Computes the Bessel function of the first kind of order n
// (first input signal) of the second input signal.
//
// #### Usage
//
// ```
// _,_ : Jn : _
// ```
//-----------------------------------------------------------------------------
Jn = ffunction(float jn(int, float), <math.h>,"");


//----------------------------------`(ma.)Y0`---------------------------------------
// Computes the linearly independent Bessel function of the second kind
// of order 0 of the input signal.
//
// #### Usage
//
// ```
// _ : Y0 : _
// ```
//-----------------------------------------------------------------------------
Y0 = ffunction(float y0(float), <math.h>,"");


//----------------------------------`(ma.)Y1`---------------------------------------
// Computes the linearly independent Bessel function of the second kind
// of order 1 of the input signal.
//
// #### Usage
//
// ```
// _ : Y0 : _
// ```
//-----------------------------------------------------------------------------
Y1 = ffunction(float y1(float), <math.h>,"");


//----------------------------------`(ma.)Yn`---------------------------------------
// Computes the linearly independent Bessel function of the second kind
// of order n (first input signal) of the second input signal.
//
// #### Usage
//
// ```
// _,_ : Yn : _
// ```
//-----------------------------------------------------------------------------
Yn = ffunction(float yn(int, float), <math.h>,"");


//----------------------------`(ma.)fabs`, `(ma.)fmax`, `(ma.)fmin`---------------------------
// Just for compatibility...
//
// ```
// fabs = abs
// fmax = max
// fmin = min
// ```
//-----------------------------------------------------------------------------
fabs = abs;
fmax = max;
fmin = min;

//-------------------------------`(ma.)np2`--------------------------------------
// Gives the next power of 2 of x.
//
// #### Usage
//
// ```
// np2(n) : _
// ```
//
// Where:
//
// * `n`: an integer
//-----------------------------------------------------------------------------
np2 = -(1) <: >>(1)|_ <: >>(2)|_ <: >>(4)|_ <: >>(8)|_ <: >>(16)|_ : +(1);


//-----------------------------`(ma.)frac`---------------------------------------
// Gives the fractional part of n.
//
// #### Usage
//
// ```
// frac(n) : _
// ```
//
// Where:
//
// * `n`: a decimal number
//------------------------------------------------------------------------------
frac(n) = n - floor(n);
decimal = frac;
// NOTE: decimal does the same thing as frac but using floor instead. JOS uses frac a lot
// in filters.lib so we decided to keep that one... decimal is declared though for
// backward compatibility.
// decimal(n) = n - floor(n);


//-------------------------------`(ma.)modulo`---------------------------------------
// Modulus operation.
//
// #### Usage
//
// ```
// modulo(x,N) : _
// ```
//
// Where:
//
// * `x`: the numerator
// * `N`: the denominator
//------------------------------------------------------------------------------
modulo(x,N) = (x % N + N) % N;


//---------------`(ma.)isnan`----------------
// Return non-zero if x is a NaN.
//
// #### Usage
//
// ```
// isnan(x)
// _ : isnan : _
// ```
//
// Where:
//
// * `x`: signal to analyse
//------------------------------------------
isnan = ffunction(int isnanf|isnan|isnanl (float),<math.h>,"");


//---------------`(ma.)isinf`----------------
// Return non-zero if x is a positive or negative infinity.
//
// #### Usage
//
// ```
// isinf(x)
// _ : isinf : _
// ```
//
// Where:
//
// * `x`: signal to analyse
//------------------------------------------
isinf = ffunction(int isinff|isinf|isinfl (float),<math.h>,"");

nextafter = ffunction(float nextafter(float, float),<math.h>,"");


//---------------------------`(ma.)chebychev`-------------------------------
// Chebychev transformation of order n.
//
// #### Usage
//
// ```
// _ : chebychev(n) : _
// ```
//
// Where:
//
// * `n`: the order of the polynomial
//
// #### Semantics
//
// ```
// T[0](x) = 1,
// T[1](x) = x,
// T[n](x) = 2x*T[n-1](x) - T[n-2](x)
// ```
//
// #### Reference
//
// <http://en.wikipedia.org/wiki/Chebyshev_polynomial>
//-------------------------------------------------------------------------
chebychev(0,x) = 1;
chebychev(1,x) = x;
chebychev(n,x) = 2*x*chebychev(n-1, x) - chebychev(n-2, x);


//------------------------`(ma.)chebychevpoly`-------------------------------
// Linear combination of the first Chebyshev polynomials.
//
// #### Usage
//
// ```
// _ : chebychevpoly((c0,c1,...,cn)) : _
// ```
//
// Where:
//
// * `cn`: the different Chebychevs polynomials such that:
// 	chebychevpoly((c0,c1,...,cn)) = Sum of chebychev(i)*ci
//
// #### Reference
//
// <http://www.csounds.com/manual/html/chebyshevpoly.html>
//-------------------------------------------------------------------------
chebychevpoly(lcoef) = _ <: L(0,lcoef) :> _
	with {
		L(n,(c,cs)) = chebychev(n)*c, L(n+1,cs);
		L(n,c)      = chebychev(n)*c;
	};


//------------------`(ma.)diffn`----------------------------
// Negated first-order difference.
//
// #### Usage
//
// ```
// _ : diffn : _
// ```
//--------------------------------------------------------
diffn(x) = x' - x; // negated first-order difference


//------------------`(ma.)signum`----------------------------
// The signum function signum(x) is defined as
// -1 for x<0, 0 for x==0, and 1 for x>0.
//
// #### Usage
//
// ```
// _ : signum : _
// ```
//--------------------------------------------------------
signum(x) = (x>0)-(x<0);


//------------------`(ma.)nextpow2`----------------------------
// The nextpow2(x) returns the lowest integer m such that
// 2^m >= x.
//
// #### Usage
//
// ```
// 2^nextpow2(n)
// ```
// Useful for allocating delay lines, e.g., 
// ```
// delay(2^nextpow2(maxDelayNeeded), currentDelay);
// ```
//--------------------------------------------------------
nextpow2(x) = ceil(log(x)/log(2.0));


//--------------------`(ma.)zc`------------------------------------------------
// Indicator function for zero-crossing: it returns 1 if a zero-crossing
// occurs, 0 otherwise.
//
// #### Usage
//
// ```
// _ : zc : _
// ```
//-----------------------------------------------------------------------------
zc(x) = x * x' < 0;

