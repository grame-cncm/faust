/************************************************************************
 ************************************************************************
  	FAUST library file
	Copyright (C) 2003-2012 GRAME, Centre National de Creation Musicale
    ---------------------------------------------------------------------
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as 
	published by the Free Software Foundation; either version 2.1 of the 
	License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
 	License along with the GNU C Library; if not, write to the Free
  	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
  	02111-1307 USA. 
  	
  	EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
  	larger FAUST program which directly or indirectly imports this library
  	file and still distribute the compiled code generated by the FAUST
  	compiler, or a modified version of this compiled code, under your own
  	copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
  	grants you the right to freely choose the license for the resulting
  	compiled code. In particular the resulting compiled code has no obligation
  	to be LGPL or GPL. For example you are free to choose a commercial or
  	closed source license or any other license if you decide so.

 ************************************************************************
 ************************************************************************/

declare name "Math Library";
declare author "GRAME";
declare copyright "GRAME";
declare version "1.0";
declare license "LGPL with exception"; 

//--------------------------------------------------------------------------------
// 						Mathematic library for Faust

// Implementation of the math.h file as Faust foreign functions
//
// History
// ----------
// 20/06/2014	[SL]	added FTZ function
// 22/06/2013	[YO]	added float|double|quad variants of some foreign functions
// 28/06/2005	[YO]	postfixed functions with 'f' to force float version
//						instead of double
//			  	[YO]	removed 'modf' because it requires a pointer as argument
//---------------------------------------------------------------------------------

// -- Utilities and constants

SR 	    = min(192000, max(1, fconstant(int fSamplingFreq, <math.h>)));
BS          = fvariable(int count, <math.h>);

PI          = 3.1415926535897932385;

// Flush to zero : force a float number under the "maximum subnormal number" to be zero
// see : http://docs.oracle.com/cd/E19957-01/806-3568/ncg_math.html
FTZ(x)      = x * (abs(x) > 1.17549435e-38);

// -- neg and inv functions

neg(x)      = -x;
inv(x)      = 1/x;

// -- Exponential Functions

cbrt 		= ffunction(float cbrtf|cbrt|cbrtl (float), <math.h>,"");
hypot 		= ffunction(float hypotf|hypot|hypotl (float, float), <math.h>,"");
ldexp 		= ffunction(float ldexpf|ldexp|ldexpl (float, int), <math.h>,"");
scalb 		= ffunction(float scalbnf|scalbn|scalbnl (float, int), <math.h>,"");
log1p 		= ffunction(float log1pf|log1p|log1pl (float), <math.h>,"");
logb 		= ffunction(float logbf|logb|logbl (float), <math.h>,"");
ilogb 		= ffunction(int ilogbf|ilogb|ilogbl (float), <math.h>,"");
expm1 		= ffunction(float expm1f|expm1|expm1l (float), <math.h>,"");

// -- Hyperbolic Functions

acosh		= ffunction(float acoshf|acosh|acoshl (float), <math.h>, "");
asinh		= ffunction(float asinhf|asinh|asinhl (float), <math.h>, "");
atanh		= ffunction(float atanhf|atanh|atanhl (float), <math.h>, "");

sinh		= ffunction(float sinhf|sinh|sinhl (float), <math.h>, "");
cosh		= ffunction(float coshf|cosh|coshl (float), <math.h>, "");
tanh		= ffunction(float tanhf|tanh|tanhl (float), <math.h>,"");

// -- Remainder Functions

// -- Nearest Integer Functions

// -- Special Functions

erf			= ffunction(float erff|erf|erfl(float), <math.h>,"");
erfc		= ffunction(float erfcf|erfc|erfcl(float), <math.h>,"");

gamma		= ffunction(float tgammaf|tgamma|tgammal(float), <math.h>,"");
lgamma		= ffunction(float lgammaf|lgamma|lgammal(float), <math.h>,"");

J0			= ffunction(float j0(float), <math.h>,"");
J1			= ffunction(float j1(float), <math.h>,"");
Jn			= ffunction(float jn(int, float), <math.h>,"");

Y0			= ffunction(float y0(float), <math.h>,"");
Y1			= ffunction(float y1(float), <math.h>,"");
Yn			= ffunction(float yn(int, float), <math.h>,"");


// -- Miscellaneous Functions

fabs = abs;
fmax = max;
fmin = min;

isnan 		= ffunction(int isnan (float),<math.h>,"");
nextafter	= ffunction(float nextafter(float, float),<math.h>,"");

// Pattern matching functions to count and access the elements of a list
// USAGE : 	count ((10,20,30,40)) 	-> 4  
//			take  (3,(10,20,30,40)) -> 30
// 

count ((xs, xxs)) = 1 + count(xxs);
count (xx) = 1;

take (1, (xs, xxs)) 	= xs;
take (1, xs) 			= xs;
take (nn, (xs, xxs)) 	= take (nn-1, xxs);

// Extract subsequence
// USAGE : subseq((10,20,30,40,50,60), 1, 3) -> (20,30,40)
//
subseq((head, tail), 0, 1)       = head;
subseq((head, tail), 0, end)     = head, subseq(tail, 0, end-1);
subseq((head, tail), start, end) = subseq(tail, start-1, end);
subseq(head, 0, end)             = head;


// linear interpolation between two signals 
interpolate(i) = *(1.0-i),*(i) : +; 

// if-then-else implemented with a select2. 
if(cond,thn,els) = select2(cond,els,thn);


//-----------------------------------------------------------------
// countdown(count,trig) 
// start counting down from count, count-1,...,0 when trig > 0
//-----------------------------------------------------------------
countdown(count, trig)	= \(c).(if(trig>0, count, max(0, c-1))) ~_;

//-----------------------------------------------------------------
// countup(count,trig) 
// start counting down from 0, 1, ... count-1, count when trig > 0
//-----------------------------------------------------------------
countup(count, trig)	= \(c).(if(trig>0, 0, min(count, c+1))) ~_;

/******************************************************************
 *  Hadamard matrix function
 *  Implementation contributed by Remy Muller
 *****************************************************************/

// bus(n) : n parallel cables
bus(2) = _,_; // avoids a lot of "bus(1)" labels in block diagrams
bus(n) = par(i, n, _);

// selector(i,n) : select ith cable among n
selector(i,n) = par(j, n, S(i, j))    with { S(i,i) = _; S(i,j) = !; };

// interleave(m,n) : interleave m*n cables : x(0), x(m), x(2m), ..., x(1),x(1+m), x(1+2m)...
//interleave(m,n) = bus(m*n) <: par(i, m, par(j, n, selector(i+j*m,m*n))); 

// interleave(row,col) : interleave row*col cables from column order to row order.
// input : x(0), x(1), x(2) ..., x(row*col-1)
// output: x(0+0*row), x(0+1*row), x(0+2*row), ..., x(1+0*row), x(1+1*row), x(1+2*row), ...
interleave(row,col) = bus(row*col) <: par(r, row, par(c, col, selector(r+c*row,row*col))); 

// butterfly(n) : addition then substraction of interleaved signals : 
butterfly(n) = bus(n) <: interleave(n/2,2), interleave(n/2,2) : par(i, n/2, +), par(i, n/2, -);

// hadamard(n) : hadamard matrix function of size n = 2^k
hadamard(2) = butterfly(2);
hadamard(n) = butterfly(n) : (hadamard(n/2) , hadamard(n/2));

// dot product for two vectors of size n
dot(n) = interleave(n,2) : par(i,n,*) :> _;

// cross n cables : (x1,x2,..,xn) -> (xn,..,x2,x1)
cross(n) = bus(n) <: par(i,n,selector(n-i-1,n));
