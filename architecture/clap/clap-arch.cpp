//dummy clap architecture file
//this file will translate faust's mydsp c++ class into the clap plugin interface
//it should include plugin lifecycle, audio block processing calls, parameter registration and ui integration using buildUserInterface () and CLAP API
//core of the plugin backend
<<includeIntrinsic>>
<<includeclass>> //this will be replaced by the code generated by the FAUST compiler
#include <clap/all.h> //core c header for clap
#include <clap/helpers/plugin.hh> //c++ wrapper around the core c interface
#include <clap/helpers/host-proxy.hh> //c++ wrapper for the host
#include <clap/helpers/param.hh> //not needed now tbh but eventually for parameter mgmt and whatnot

struct FaustCLAPPlugin : public clap::helpers::Plugin<clap::helpers::MisbehaviourHandler::Terminate, clap::helpers::CheckingLevel::Minimal> {
    mydsp fDSP; //instance of the faust generated dsp class

    clap::helpers::Param<float> fGainParam {
        0, CLAP_PARAM_IS_AUTOMATABLE, "gain", "", 0.0f, 10.0f, 0.1f, 1.0f

    };

    FaustCLAPPlugin(const clap_plugin_descriptor* desc, const clap_host* host)
        : Plugin(desc, host) {}

    bool init() noexcept override {
        fDSP.init(48000); //hardcoding thr SR for now...
        if(!add_param(&fGainParam)){
            log(CLAP_LOG_ERROR,"failed to register gain param");
            return false;
        }
        log(CLAP_LOG_DEBUG, "FaustCLAPPlugin initialised and gain param registered!");
        return true;
    }

    void buildUserInterface(UI* ui_interface){
    fDSP.buildUserInterface(ui_interface);
    }

    clap_process_status process(const clap_process* process) noexcept override {
    //if process or the audio in/outs are missing, bail out with an error
    if (!process || !process->audio_inputs || !process->audio_outputs) return CLAP_PROCESS_ERROR;

    //for the sake of simplicity i will assume mono in/out and faust using fVslider0
    //get pointers to the actual audio in and out buffers
    FAUSTFLOAT* input=reinterpret_cast<FAUSTFLOAT*>(process->audio_inputs[0].data32);
    FAUSTFLOAT* output=reinterpret_cast<FAUSTFLOAT*>(process->audio_outputs[0].data32);
    int frameCount=process->frames_count;

    //update the dsp gain value from the plugin parameter
    fDSP.fVslider0=fGainParam.value(); //host controlled gain
    //run the faust dsp on the input and produce output
    fDSP.compute(frameCount,&input,&output); //process audio?
    return CLAP_PROCESS_CONTINUE; //tell host to keep running the plugin

    }

};
