declare name "Faust Effect Library";
declare author "Julius O. Smith (jos at ccrma.stanford.edu)";
declare copyright "Julius O. Smith III";
declare version "1.1";
declare license "STK-4.3"; // Synthesis Tool Kit 4.3 (MIT style license)
declare reference "http://ccrma.stanford.edu/realsimple/faust_strings/";

import("filter.lib"); // dcblocker*, lowpass4, ...


//--------------- levelfilter, levelfilterN -----------------------
// Dynamic level lowpass filter:
// USAGE: levelfilter(L,freq), where
//  L    = desired level (in dB) at Nyquist limit (SR/2), e.g., -60
//  freq = corner frequency (-3dB point) usually set to fundamental freq
//
// Reference: 
// http://ccrma.stanford.edu/realsimple/faust_strings/Dynamic_Level_Lowpass_Filter.html
//
levelfilter(L,freq,x) = (L * L0 * x) + ((1.0-L) * lp2out(x))
with {
  L0 = pow(L,1/3);
  Lw = PI*freq/SR; // = w1 T / 2
  Lgain = Lw / (1.0 + Lw);
  Lpole2 = (1.0 - Lw) / (1.0 + Lw);
  lp2out = *(Lgain) : + ~ *(Lpole2);
};

levelfilterN(N,freq,L) = seq(i,N,levelfilter((L/N),freq));

//------------------------- speakerbp -------------------------------
// Dirt-simple speaker simulator (overall bandpass eq with observed
// roll-offs above and below the passband).
//
// Low-frequency speaker model = +12 dB/octave slope breaking to 
// flat near f1. Implemented using two dc blockers in series.
//
// High-frequency model = -24 dB/octave slope implemented using a 
// fourth-order Butterworth lowpass.
//
// Example based on measured Celestion G12 (12" speaker):
// speakerbp(130,5000);
//
// Requires filter.lib
//
speakerbp(f1,f2) = dcblockerat(f1) : dcblockerat(f1) : lowpass4(f2);


//--------------------- cubicnl(drive,offset) -----------------------
// Cubic nonlinearity distortion
// USAGE: cubicnl(drive,offset), where
//   drive  = distortion amount, between 0 and 1
//   offset = constant added before nonlinearity to give even harmonics
// Reference:
// http://ccrma.stanford.edu/~jos/pasp/Nonlinear_Distortion.html#18254
//
cubicnl(drive,offset) =
   +(offset) : *(pregain) : clip(-1,1) : cubic : *(postgain) : dcblocker
with {
    pregain = pow(10.0,2*drive);
    clip(lo,hi) = min(hi) : max(lo);
    cubic(x) = x - x*x*x/3;
    postgain = max(1.0,1.0/pregain); // unity gain when nearly linear
};


//------------------------- moogvcf(Q,fr) ---------------------------
// Moog "Voltage Controlled Filter" (VCF)
//
// USAGE: moogvcf(Q,fr), where
//   fr = corner-resonance frequency in Hz ( less than SR/6.3 or so )
//   Q  = corner-resonance quality factor Q
// Requires filter.lib.
// Reference "http://ccrma.stanford.edu/~jos/pasp/vegf.html";
// 
moogvcf(Q,fr) = (+ : pole(p) : pole(p) 
                   : pole(p) : pole(p) : *(scale(p))) ~ *(mk)
with {
     p = 1.0 - fr * 2.0 * PI / SR; // approx for fr << SR
     scale(p) = pow(1-p,4);
     mk = 0-Q;
};


//-------------------------- wah4(fr) -------------------------------
// Wah effect, 4th order
// USAGE: wah4(fr), where fr = resonance frequency in Hz
// Reference "http://ccrma.stanford.edu/~jos/pasp/vegf.html";
// 
wah4(fr) = moogvcf(3.8,fr); // Q fixed at ~ 3.8 (set to taste)


//------------------------ crybaby(wah) -----------------------------
// Digitized CryBaby wah pedal
// USAGE: crybaby(wah), where wah = "pedal angle" from 0 to 1.
// Requires filter.lib.
// Reference "http://ccrma.stanford.edu/~jos/pasp/vegf.html";
//
crybaby(wah) = *(gs(s)) : tf2(1,-1,0,a1s(s),a2s(s))
with {
  s = 0.999; // smoothing parameter (one-pole pole location)
  Q  = pow(2.0,(2.0*(1.0-wah)+1.0)); // Resonance "quality factor"
  fr = 450.0*pow(2.0,2.3*wah);       // Resonance tuning
  g  = 0.1*pow(4.0,wah);             // gain (optional)

  // Biquad fit using z = exp(s T) ~ 1 + sT for low frequencies:
  frn = fr/SR; // Normalized pole frequency (cycles per sample)
  R = 1 - PI*frn/Q; // pole radius
  theta = 2*PI*frn; // pole angle
  a1 = 0-2.0*R*cos(theta); // biquad coeff
  a2 = R*R;                // biquad coeff

  // dezippering of slider-driven signals:
  a1s(s) = a1 : smooth(s);
  a2s(s) = a2 : smooth(s);
  gs(s) =  g  : smooth(s);
};

